//@execute (0, 1, 2, 3)=4; (1, 1, 2, 3)=6; (2, 1, 2, 3)=4; (3, 1, 2, 4)=!UnimplementedException; (4, 12, 2, 1)=!UnimplementedException

// Test dispatch tables with multiple abstract methods
class A {
	var x: int;
	new(x) { }
	def f(i: int) -> int;
	def g(i: int) -> int { return x + i; }
}

class B extends A {
	var y: int;
	new(x: int, y) super(x) { }
	def f(i: int) -> int { return x + y + i; }
	def g(i: int) -> int;
}

def main(which: int, val1: int, val2: int, x: int) -> int {
	var a: A;
	var callf: bool;
	var callg: bool;
	match (which) {
		0 => { a = A.new(val1);		callf = false; callg = true;  }
		1 => { a = B.new(val1, val2);	callf = true;  callg = false; }
		2 => { a = A.new(val1);		callf = false; callg = true;  }
		3 => { a = B.new(val1, val2);	callf = true;  callg = true; }
		_ => { a = A.new(val1);		callf = true;  callg = true;  }
	}
	return if(callf, a.f(x), 0) +
	       if(callg, a.g(x), 0);
}
