// Copyright 2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = LibTests.register("TextReader", _, _);
def X = [
	T("init", test_init),
	T("readToken", test_readToken),
	T("readTokenAt", test_readTokenAt),
	T("advance", test_advance),
	T("skip", test_skip),
	T("opt1", test_opt1),
	T("optN", test_optN),
	T("req1", test_req1),
	T("reqN", test_reqN),
	T("at", test_at),
	T("range", test_range),
	T("posToLine", test_posToLine),
	T("posToColumn", test_posToColumn),
	T("peekRel", test_peekRel),
	T("star_rel", test_star_rel),
	T("plus_rel", test_plus_rel),
	T("verifyLineEnds", test_verifyLineEnds),
	T("skipWhitespace", test_skipWhitespace),
	T("skipSpacesAndTabs", test_skipSpacesAndTabs),
	T("skipToEndOfLine", test_skipToEndOfLine),
	T("skipToNextLine", test_skipToNextLine),
	T("skipNothing", test_skipNothing),
	T("error", test_error),
	T("error_positions", test_error_positions),
	T("nextTabStop", test_nextTabStop),
	T("renderCurrentLineWithCaret", test_renderCurrentLineWithCaret),
	T("lineStartOffset", test_lineStartOffset),
	T("lineEndOffset", test_lineEndOffset),
	T("extractLine", test_extractLine),
	T("extractLine2", test_extractLine2),
	()
];

def test_init(t: LibTest) {
	var data = "hello";
	var r = TextReader.new("test.txt", data);

	t.assert_string("test.txt", r.fileName);
	t.asserteq(0, r.pos);
	t.asserteq(5, r.limit);
	t.asserteq('h', r.char);
	t.asserteq(1, r.line);
	t.asserteq(1, r.column);
	t.assertz(true, r.ok);
	t.asserteq(int.max, r.error_line);
	t.asserteq(int.max, r.error_column);

	// Test empty data
	var empty = TextReader.new("empty.txt", "");
	t.asserteq(0, empty.pos);
	t.asserteq(0, empty.limit);
	t.asserteq('\x00', empty.char);
}

def test_readToken(t: LibTest) {
	var data = "hello world";
	var r = TextReader.new("test.txt", data);

	var token = r.readToken(5);
	t.assert_string("hello", token.image);
	t.asserteq(1, token.beginLine);
	t.asserteq(1, token.beginColumn);
	t.asserteq(6, r.pos); // advanced past 'hello' and space
	t.asserteq('w', r.char);

	var token2 = r.readToken(5);
	t.assert_string("world", token2.image);
	t.asserteq(1, token2.beginLine);
	t.asserteq(7, token2.beginColumn);
}

def test_readTokenAt(t: LibTest) {
	var data = "hello world";
	var r = TextReader.new("test.txt", data);
	r.advance(6); // move to "world"

	var token = r.readTokenAt(0, 5);
	t.assert_string("hello", token.image);
	t.asserteq(1, token.beginLine);
	t.asserteq(1, token.beginColumn);

	// Test with newlines
	var data2 = "line1\nline2\nline3";
	var r2 = TextReader.new("test.txt", data2);
	while (r2.pos < r2.limit) r2.skip1(); // advance to build lineEnds

	var token2 = r2.readTokenAt(0, 5);
	t.assert_string("line1", token2.image);
	t.asserteq(1, token2.beginLine);
	t.asserteq(1, token2.beginColumn);

	var token3 = r2.readTokenAt(6, 11);
	t.assert_string("line2", token3.image);
	t.asserteq(2, token3.beginLine);
	t.asserteq(1, token3.beginColumn);

	var token4 = r2.readTokenAt(12, 17);
	t.assert_string("line3", token4.image);
	t.asserteq(3, token4.beginLine);
	t.asserteq(1, token4.beginColumn);
}

def test_advance(t: LibTest) {
	var data = "abc  def";
	var r = TextReader.new("test.txt", data);

	t.asserteq('a', r.char);
	r.advance(1);
	t.asserteq('b', r.char); // whitespace skipped
	r.advance(1);
	t.asserteq('c', r.char);
	r.advance(1);
	t.asserteq('d', r.char); // spaces skipped

	// Test with tabs and newlines
	var data2 = "a\t\n\tb";
	var r2 = TextReader.new("test.txt", data2);
	t.asserteq('a', r2.char);
	t.asserteq(1, r2.line);
	t.asserteq(1, r2.column);

	r2.advance(1); // advance past 'a', skip tab, newline, tab
	t.asserteq('b', r2.char);
	t.asserteq(2, r2.line); // on second line
	t.asserteq(9, r2.column); // after tab
}

def test_skip(t: LibTest) {
	var data = "abc  def";
	var r = TextReader.new("test.txt", data);

	t.asserteq('a', r.char);
	r.skip(1);
	t.asserteq('b', r.char); // no whitespace skip
	r.skip(1);
	t.asserteq('c', r.char);
	r.skip(1);
	t.asserteq(' ', r.char); // stops on space
	r.skip(2);
	t.asserteq('d', r.char);

	// Test with tabs and newlines - skip does not skip whitespace
	var data2 = "a\t\nb";
	var r2 = TextReader.new("test.txt", data2);
	t.asserteq('a', r2.char);
	t.asserteq(1, r2.line);

	r2.skip(1); // skip just 'a'
	t.asserteq('\t', r2.char);
	t.asserteq(1, r2.line);
	t.asserteq(2, r2.column);

	r2.skip(1); // skip just tab
	t.asserteq('\n', r2.char);
	t.asserteq(1, r2.line);
	t.asserteq(9, r2.column); // tab advanced column

	r2.skip(1); // skip newline
	t.asserteq('b', r2.char);
	t.asserteq(2, r2.line);
	t.asserteq(1, r2.column); // new line resets column
}

def test_opt1(t: LibTest) {
	var data = "abc";
	var r = TextReader.new("test.txt", data);

	var pos = r.opt1('a');
	t.asserteq(0, pos);
	t.asserteq('b', r.char);

	pos = r.opt1('x'); // no match
	t.asserteq(-1, pos);
	t.asserteq('b', r.char); // unchanged

	pos = r.opt1('b');
	t.asserteq(1, pos);
	t.asserteq('c', r.char);
}

def test_optN(t: LibTest) {
	var data = "hello world";
	var r = TextReader.new("test.txt", data);

	var pos = r.optN("hello");
	t.asserteq(6, pos); // position after "hello " (with whitespace)
	t.asserteq('w', r.char);

	pos = r.optN("xyz"); // no match
	t.asserteq(-1, pos);
	t.asserteq('w', r.char); // unchanged

	pos = r.optN("world");
	t.asserteq(11, pos);
}

def test_req1(t: LibTest) {
	var data = "abc";
	var r = TextReader.new("test.txt", data);

	var pos = r.req1('a');
	t.asserteq(0, pos);
	t.asserteq('b', r.char);
	t.assertz(true, r.ok);

	pos = r.req1('x'); // no match - error
	t.asserteq(-1, pos);
	t.assertz(false, r.ok);
	t.asserteq(1, r.error_line);
}

def test_reqN(t: LibTest) {
	var data = "hello world";
	var r = TextReader.new("test.txt", data);

	var pos = r.reqN("hello");
	t.assertz(true, r.ok);
	t.asserteq('w', r.char);

	var r2 = TextReader.new("test.txt", data);
	r2.reqN("xyz"); // no match - error
	t.assertz(false, r2.ok);
}

def test_at(t: LibTest) {
	var data = "hello\nworld";
	var r = TextReader.new("test.txt", data);
	r.advance(6); // move to "world"

	r.at(0, 1, 1); // reset to beginning
	t.asserteq(0, r.pos);
	t.asserteq(1, r.line);
	t.asserteq(1, r.column);
	t.asserteq('h', r.char);

	r.at(6, 2, 1); // move to second line
	t.asserteq(6, r.pos);
	t.asserteq(2, r.line);
	t.asserteq(1, r.column);
	t.asserteq('w', r.char);

	r.at(100, 3, 1); // beyond limit
	t.asserteq(11, r.pos); // clamped to limit
	t.asserteq('\x00', r.char);
}

def test_range(t: LibTest) {
	var data = "hello";
	var r = TextReader.new("test.txt", data);
	r.at(2, 3, 5);

	var range = r.range();
	t.assert_string("test.txt", range.fileName);
	t.asserteq(3, range.beginLine);
	t.asserteq(5, range.beginColumn);
	t.asserteq(3, range.endLine);
	t.asserteq(5, range.endColumn);
}

def test_posToLine(t: LibTest) {
	var data = "line1\nline2\nline3";
	var r = TextReader.new("test.txt", data);

	// Manually advance to build lineEnds
	while (r.pos < r.limit) r.skip1();

	t.asserteq(1, r.posToLine(0));
	t.asserteq(1, r.posToLine(4));
	t.asserteq(2, r.posToLine(6));
	t.asserteq(2, r.posToLine(10));
	t.asserteq(3, r.posToLine(12));
}

def test_posToColumn(t: LibTest) {
	var data = "hello\tw\torld";
	var r = TextReader.new("test.txt", data);

	// Manually advance to build state
	while (r.pos < r.limit) r.skip1();

	t.asserteq(1, r.posToColumn(0)); // 'h'
	t.asserteq(2, r.posToColumn(1)); // 'e'
	t.asserteq(6, r.posToColumn(5)); // '\t'
	// tab advances to next multiple of 8 + 1
	t.asserteq(9, r.posToColumn(6)); // 'w' after tab
	t.asserteq(10, r.posToColumn(7));
	t.asserteq(17, r.posToColumn(8));
}

def test_peekRel(t: LibTest) {
	var data = "hello";
	var r = TextReader.new("test.txt", data);

	t.asserteq('h', r.peekRel(0));
	t.asserteq('e', r.peekRel(1));
	t.asserteq('o', r.peekRel(4));
	t.asserteq('\x00', r.peekRel(10)); // beyond limit

	r.skip(1);
	t.asserteq('e', r.peekRel(0));
	t.asserteq('l', r.peekRel(1));
}

def isVowel(ch: byte) -> bool {
	return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
}

def isDigit(ch: byte) -> bool {
	return ch >= '0' && ch <= '9';
}

def test_star_rel(t: LibTest) {
	var data = "aeiou123";
	var r = TextReader.new("test.txt", data);

	var pos = r.star_rel(0, isVowel);
	t.asserteq(5, pos); // matches all vowels

	pos = r.star_rel(5, isDigit);
	t.asserteq(8, pos); // matches all digits

	pos = r.star_rel(0, isDigit);
	t.asserteq(0, pos); // no match at start
}

def test_plus_rel(t: LibTest) {
	var data = "aeiou123xyz";
	var r = TextReader.new("test.txt", data);

	var pos = r.plus_rel(0, isVowel);
	t.asserteq(5, pos); // matches all vowels

	pos = r.plus_rel(5, isDigit);
	t.asserteq(8, pos); // matches all digits

	pos = r.plus_rel(0, isDigit);
	t.asserteq(-1, pos); // no match at start

	pos = r.plus_rel(8, isDigit);
	t.asserteq(-1, pos); // no digits at position 8
}

def test_verifyLineEnds(t: LibTest) {
	var data = "line1\nline2\nline3";
	var r = TextReader.new("test.txt", data);

	// Before advancing, lineEnds is empty
	t.assertz(true, r.verifyLineEnds());

	// Advance through first line
	while (r.char != '\n') r.skip1();
	r.skip1(); // skip the newline
	t.assertz(true, r.verifyLineEnds());

	// Advance through second line
	while (r.char != '\n') r.skip1();
	r.skip1();
	t.assertz(true, r.verifyLineEnds());
}

def test_skipWhitespace(t: LibTest) {
	var data = "a  \n\t  b";
	var r = TextReader.new("test.txt", data);

	t.asserteq('a', r.char);
	r.skip1();
	t.asserteq(' ', r.char);
	r.skipWhitespace();
	t.asserteq('b', r.char); // skipped spaces, newline, tab
}

def test_skipSpacesAndTabs(t: LibTest) {
	var data = "a  \t\nb";
	var r = TextReader.new("test.txt", data);
	r.skipWs = TextReader.skipSpacesAndTabs;

	t.asserteq('a', r.char);
	r.skip1();
	t.asserteq(' ', r.char);
	r.skipSpacesAndTabs();
	t.asserteq('\n', r.char); // stopped at newline
}

def test_skipToEndOfLine(t: LibTest) {
	var data = "hello world\nline2\nline3";
	var r = TextReader.new("test.txt", data);

	t.asserteq('h', r.char);
	r.skipToEndOfLine();
	t.asserteq('\n', r.char); // stopped at newline
	t.asserteq(1, r.line); // still on line 1
	t.asserteq(12, r.column); // at the newline position

	r.skip1(); // skip the newline
	t.asserteq('l', r.char);
	t.asserteq(2, r.line);

	r.skip(3); // skip "lin"
	t.asserteq('e', r.char);
	r.skipToEndOfLine();
	t.asserteq('\n', r.char); // stopped at second newline
	t.asserteq(2, r.line);

	// Test at end of file (no newline)
	r.skip1(); // skip to "line3"
	t.asserteq('l', r.char);
	r.skipToEndOfLine();
	t.asserteq('\x00', r.char); // at end of file
}

def test_skipToNextLine(t: LibTest) {
	var data = "hello world\nline2\nline3";
	var r = TextReader.new("test.txt", data);

	t.asserteq('h', r.char);
	r.skipToNextLine();
	t.asserteq('l', r.char); // at 'l' in "line2"
	t.asserteq(2, r.line); // on line 2
	t.asserteq(1, r.column); // at column 1

	r.skip(3); // skip "lin"
	t.asserteq('e', r.char);
	r.skipToNextLine();
	t.asserteq('l', r.char); // at 'l' in "line3"
	t.asserteq(3, r.line);
	t.asserteq(1, r.column);

	// Test at end of file
	r.skipToNextLine();
	t.asserteq('\x00', r.char); // at end of file
}

def test_skipNothing(t: LibTest) {
	var data = "a  b";
	var r = TextReader.new("test.txt", data);
	r.skipWs = TextReader.skipNothing;

	t.asserteq('a', r.char);
	r.advance1();
	t.asserteq(' ', r.char); // no skip
}

def test_error(t: LibTest) {
	var data = "hello";
	var r = TextReader.new("test.txt", data);

	t.assertz(true, r.ok);
	t.asserteq(int.max, r.error_line);

	r.fail("test error");
	t.assertz(false, r.ok);
	t.asserteq(1, r.error_line);
	t.asserteq(1, r.error_column);
	t.assert_string("test error", r.error_msg);

	// Second error should not override first (earlier position)
	r.advance(2);
	r.fail("second error");
	t.assert_string("test error", r.error_msg);

	// Test failRel
	var r2 = TextReader.new("test.txt", data);
	r2.failRel(3, "error at offset");
	t.assertz(false, r2.ok);
	t.asserteq(1, r2.error_line);
	t.asserteq(4, r2.error_column);
}

def test_nextTabStop(t: LibTest) {
	var r = TextReader.new("test.txt", "");

	t.asserteq(9, r.nextTabStop(1));
	t.asserteq(9, r.nextTabStop(2));
	t.asserteq(9, r.nextTabStop(8));
	t.asserteq(17, r.nextTabStop(9));
	t.asserteq(17, r.nextTabStop(16));
	t.asserteq(25, r.nextTabStop(17));
}

def test_renderCurrentLineWithCaret(t: LibTest) {
	var data = "hello\nworld\ntest";
	var r = TextReader.new("test.txt", data);

	// Test rendering second line
	var buf = StringBuilder.new();
	r.renderCurrentLineWithCaret(buf, 7); // 'w' in "world"
	var result = buf.toString();
	t.assertz(true, Strings.startsWith(result, "world"));
	t.assertz(true, result.length > 6); // includes newline and caret

	// Test rendering first line
	var buf2 = StringBuilder.new();
	r.renderCurrentLineWithCaret(buf2, 2); // 'l' in "hello"
	var result2 = buf2.toString();
	t.assertz(true, Strings.startsWith(result2, "hello"));

	// Test rendering third line
	var buf3 = StringBuilder.new();
	r.renderCurrentLineWithCaret(buf3, 13); // 'e' in "test"
	var result3 = buf3.toString();
	t.assertz(true, Strings.startsWith(result3, "test"));

	// Test rendering at position 0
	var buf4 = StringBuilder.new();
	r.renderCurrentLineWithCaret(buf4, 0); // 'h' at start
	var result4 = buf4.toString();
	t.assertz(true, Strings.startsWith(result4, "hello"));
}

def test_error_positions(t: LibTest) {
	// Test error at beginning
	var data = "hello\nworld\ntest";
	var r = TextReader.new("test.txt", data);
	r.fail("error at start");
	t.assertz(false, r.ok);
	t.asserteq(1, r.error_line);
	t.asserteq(1, r.error_column);

	// Test error after advancing
	var r2 = TextReader.new("test.txt", data);
	r2.skip(3); // move to 'l' in "hello"
	r2.fail("error in middle");
	t.assertz(false, r2.ok);
	t.asserteq(1, r2.error_line);
	t.asserteq(4, r2.error_column);

	// Test error on second line
	var r3 = TextReader.new("test.txt", data);
	while (r3.char != '\n') r3.skip1();
	r3.skip1(); // move to 'w' in "world"
	r3.skip(2); // move to 'r' in "world"
	r3.fail("error on line 2");
	t.assertz(false, r3.ok);
	t.asserteq(2, r3.error_line);
	t.asserteq(3, r3.error_column);

	// Test error using failRel with offset
	var r4 = TextReader.new("test.txt", data);
	r4.advance(5);
	r4.at(0, 1, 1);
	r4.failRel(6, "error with offset"); // offset to 'w' in "world"
	t.assertz(false, r4.ok);
	t.asserteq(2, r4.error_line);
	t.asserteq(1, r4.error_column);

	// Test that earlier errors are preserved
	var r5 = TextReader.new("test.txt", data);
	r5.fail("first error");
	var first_line = r5.error_line;
	var first_col = r5.error_column;
	var first_msg = r5.error_msg;

	r5.skip(5);
	r5.fail("second error");
	// First error should be preserved
	t.asserteq(first_line, r5.error_line);
	t.asserteq(first_col, r5.error_column);
	t.assert_string(first_msg, r5.error_msg);
}

def test_lineStartOffset(t: LibTest) {
	var data = "hello\nworld\ntest";
	var r = TextReader.new("test.txt", data);

	// Build lineEnds by advancing through the data
	while (r.pos < r.limit) r.skip1();

	// Line 1 starts at position 0
	t.asserteq(0, r.lineStartOffset(1));

	// Line 2 starts at position 6 (after "hello\n")
	t.asserteq(6, r.lineStartOffset(2));

	// Line 3 starts at position 12 (after "hello\nworld\n")
	t.asserteq(12, r.lineStartOffset(3));
}

def test_lineEndOffset(t: LibTest) {
	var data = "hello\nworld\ntest";
	var r = TextReader.new("test.txt", data);

	// Build lineEnds by advancing through the data
	while (r.pos < r.limit) r.skip1();

	// Line 1 ends at position 5 (the '\n' after "hello")
	t.asserteq(5, r.lineEndOffset(1));

	// Line 2 ends at position 11 (the '\n' after "world")
	t.asserteq(11, r.lineEndOffset(2));

	// Line 3 ends at position 16 (end of data, no newline)
	t.asserteq(16, r.lineEndOffset(3));

	// Test with data that has a newline at the end
	var data2 = "line1\nline2\n";
	var r2 = TextReader.new("test.txt", data2);
	while (r2.pos < r2.limit) r2.skip1();

	t.asserteq(5, r2.lineEndOffset(1));
	t.asserteq(11, r2.lineEndOffset(2));
}

def assert_line(t: LibTest, r: TextReader, str: string, x: int) {
	t.assert_string(str, r.extractLine(x));
}

def test_extractLine(t: LibTest) {
	var data = "hello\nworld\ntest";
	var r = TextReader.new("test.txt", data);
	def L = assert_line(t, r, _, _);

	// Build lineEnds by advancing through the data
	while (r.pos < r.limit) r.skip1();

	L("hello", 1);
	L("world", 2);
	L("test", 3);

	// Extract line 0 (should return null)
	var line0 = r.extractLine(0);
	t.asserteq(null, line0);
}

def test_extractLine2(t: LibTest) {
	var data = "hello\n\nworld";
	var r = TextReader.new("test.txt", data);
	def L = assert_line(t, r, _, _);

	while (r.pos < r.limit) r.skip1();

	L("hello", 1);
	L("", 2);
	L("world", 3);
}
