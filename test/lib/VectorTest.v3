// Copyright 2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = LibTests.register("Vector", _, _);
def X = [
	T("putMerge_empty_range", test_putMerge_empty_range),
	T("putMerge_empty_vector", test_putMerge_empty_vector),
	T("putMerge_no_overlap", test_putMerge_no_overlap),
	T("putMerge_interleaved", test_putMerge_interleaved),
	T("putMerge_duplicates", test_putMerge_duplicates),
	T("putMerge_all_duplicates", test_putMerge_all_duplicates),
	T("putMerge_range_all_smaller", test_putMerge_range_all_smaller),
	T("putMerge_range_all_larger", test_putMerge_range_all_larger),
	T("putMerge_prefix_optimization", test_putMerge_prefix_optimization),
	T("putMerge_prefix_with_dup", test_putMerge_prefix_with_dup),
	()
];

def intLt(a: int, b: int) -> bool { return a < b; }

def assertVec(t: LibTest, v: Vector<int>, expected: Array<int>) {
	if (v.length != expected.length) {
		return t.fail2("expected length %d, got %d", expected.length, v.length);
	}
	for (i < expected.length) {
		if (v[i] != expected[i]) {
			return t.fail3("expected [%d] == %d, got %d", i, expected[i], v[i]);
		}
	}
}

def test_putMerge_empty_range(t: LibTest) {
	var v = Vector<int>.new();
	v.puta([1, 3, 5]);
	var empty: Array<int> = [];
	v.putMerge(empty, intLt);
	assertVec(t, v, [1, 3, 5]);
}

def test_putMerge_empty_vector(t: LibTest) {
	var v = Vector<int>.new();
	v.putMerge([2, 4, 6], intLt);
	assertVec(t, v, [2, 4, 6]);
}

def test_putMerge_no_overlap(t: LibTest) {
	var v = Vector<int>.new();
	v.puta([1, 3, 5]);
	v.putMerge([2, 4, 6], intLt);
	assertVec(t, v, [1, 2, 3, 4, 5, 6]);
}

def test_putMerge_interleaved(t: LibTest) {
	var v = Vector<int>.new();
	v.puta([2, 4, 6]);
	v.putMerge([1, 3, 5, 7], intLt);
	assertVec(t, v, [1, 2, 3, 4, 5, 6, 7]);
}

def test_putMerge_duplicates(t: LibTest) {
	var v = Vector<int>.new();
	v.puta([1, 3, 5]);
	v.putMerge([2, 3, 4], intLt);
	assertVec(t, v, [1, 2, 3, 4, 5]);
}

def test_putMerge_all_duplicates(t: LibTest) {
	var v = Vector<int>.new();
	v.puta([1, 2, 3]);
	v.putMerge([1, 2, 3], intLt);
	assertVec(t, v, [1, 2, 3]);
}

def test_putMerge_range_all_smaller(t: LibTest) {
	var v = Vector<int>.new();
	v.puta([5, 6, 7]);
	v.putMerge([1, 2, 3], intLt);
	assertVec(t, v, [1, 2, 3, 5, 6, 7]);
}

def test_putMerge_range_all_larger(t: LibTest) {
	var v = Vector<int>.new();
	v.puta([1, 2, 3]);
	v.putMerge([5, 6, 7], intLt);
	assertVec(t, v, [1, 2, 3, 5, 6, 7]);
}

def test_putMerge_prefix_optimization(t: LibTest) {
	// Elements 1, 2, 3 are all < 5 (r[0]), so they stay in place
	var v = Vector<int>.new();
	v.puta([1, 2, 3, 7, 8, 9]);
	v.putMerge([5, 6, 10], intLt);
	assertVec(t, v, [1, 2, 3, 5, 6, 7, 8, 9, 10]);
}

def test_putMerge_prefix_with_dup(t: LibTest) {
	// Tests prefix optimization with duplicates in merge section
	var v = Vector<int>.new();
	v.puta([1, 2, 2, 2]);
	v.putMerge([2, 3, 4], intLt);
	assertVec(t, v, [1, 2, 2, 2, 3, 4]);
}
