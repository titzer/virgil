// Copyright 2023 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = LibTests.register("Math", _, _);
def X = [
	T("exp:simple", test_exp_simple),
	T("exp:nan", test_exp_nan),
	T("exp:infinities", test_exp_infinities),
	// TODO: tests for Math.log
	()
];

def assertOk<T>(t: LibTest, f: (StringBuilder, T) -> StringBuilder, val: T, expected: string) {
	var b = StringBuilder.new();
	f(b, val);
	t.assert_string(expected, b.extract());
}

// Assert that {e == g}.
def assertDoubleEq(t: LibTest, e: double, g: double) {
	if (e != g) t.fail(Strings.format2("expected double 0x%x, got 0x%x", u64.view(e), u64.view(g)));
}

// Assert that {g} is within one unit of least precision of {e}.
def assertDouble1ulp(t: LibTest, e: double, g: double) {
	if (e.sign == g.sign && e.exponent == g.exponent) {
		var e_frac = e.fraction;
		var g_frac = g.fraction;
		if (e_frac == g_frac) return;
		if (e_frac == (g_frac + 1)) return;
		if (e_frac == (g_frac - 1)) return;
	}
	t.fail(Strings.format2("expected double close to 0x%x, got 0x%x", u64.view(e), u64.view(g)));
}

def assertDoubleConst(d: double, bits: u64) -> double { // primarily checks Virgil parsing of double constants
	if (u64.view(d) != bits) System.error("DoubleConstantError", "compile-time double constant differed from expected bits");
	return d;
}

def CONSTANT_E = assertDoubleConst(2.718281828459045d, 0x4005BF0A8B145769);

def test_exp_simple(t: LibTest) {
	var assert = assertDouble1ulp(t, _, _);
	assert(CONSTANT_E, Math.exp(1));
	assert(CONSTANT_E * CONSTANT_E, Math.exp(2));
	// TODO: test square root, cube root, 1 / e, etc
}

def test_exp_nan(t: LibTest) {
	// TODO: test Math.exp(nan)
}

def test_exp_infinities(t: LibTest) {
	assertDoubleEq(t, double.infinity, Math.exp(double.infinity));
	assertDoubleEq(t, 0, Math.exp(0d - double.infinity));
}
