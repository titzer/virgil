//@execute (0, 0, 0, 0, 1)=!NullCheckException
//@execute (0, 0, 0, 0, 1)=77; (0, 0, 0, 1, 2)=80; (0, 0, 1, 0, 3)=82; (0, 0, 1, 1, 4)=85; (0, 1, 0, 0, 1)=76; (0, 1, 0, 1, 2)=79; (0, 1, 1, 0, 3)=81; (0, 1, 1, 1, 4)=84; (1, 0, 0, 0, 1)=78; (1, 0, 0, 1, 2)=81; (1, 0, 1, 0, 3)=83; (1, 0, 1, 1, 4)=86; (1, 1, 0, 0, 1)=77; (1, 1, 0, 1, 2)=80; (1, 1, 1, 0, 3)=82; (1, 1, 1, 1, 4)=85
//@heap-size=4000

// Complex / nested function type subsumption

class A {
	def m() -> int { return 11; }
}

class B extends A {
	def m() -> int { return 12; }
}

class C {
	def n() -> int { return 13; }
}

class D extends C {
	def n() -> int { return 13; }
}

type Arg3<T, U, V>(x: T, y: U, j: V) #unboxed;

class Cls {

	def fac1(x: A, y: C, j: int) -> int { return x.m() + y.n() + j; }
	def fac1t(arg: Arg3<A, C, int>) -> int { return fac1(arg.x, arg.y, arg.j); }
	def fac2(x: A, y: C, j: int) -> int { return x.m() + y.n() + j + 1; }
	def fac2t(arg: Arg3<A, C, int>) -> int { return fac2(arg.x, arg.y, arg.j); }

	def fbc1(x: B, y: C, j: int) -> int { return x.m() - y.n() - j; }
	def fbc1t(arg: Arg3<B, C, int>) -> int { return fbc1(arg.x, arg.y, arg.j); }
	def fbc2(x: B, y: C, j: int) -> int { return x.m() - y.n() - j + 1; }
	def fbc2t(arg: Arg3<B, C, int>) -> int { return fbc2(arg.x, arg.y, arg.j); }

	def fad1(x: A, y: D, j: int) -> int { return x.m() + y.n() + j - 1; }
	def fad1t(arg: Arg3<A, D, int>) -> int { return fad1(arg.x, arg.y, arg.j); }
	def fad2(x: A, y: D, j: int) -> int { return x.m() + y.n() + j - 2; }
	def fad2t(arg: Arg3<A, D, int>) -> int { return fad2(arg.x, arg.y, arg.j); }

	def fbd1(x: B, y: D, j: int) -> int { return x.m() + y.n() + j + 2; }
	def fbd1t(arg: Arg3<B, D, int>) -> int { return fbd1(arg.x, arg.y, arg.j); }
	def fbd2(x: B, y: D, j: int) -> int { return x.m() + y.n() + j + 3; }
	def fbd2t(arg: Arg3<B, D, int>) -> int { return fbd2(arg.x, arg.y, arg.j); }

	def add4(f1: Closure<Cls, Arg3<B, D, int>, int>,
		 f2: Closure<Cls, Arg3<B, D, int>, int>,
		 f3: Closure<Cls, Arg3<B, D, int>, int>,
		 f4: Closure<Cls, Arg3<B, D, int>, int>,
		 arg: Arg3<B, D, int>) -> int {
		return f1.func(f1.rcvr, arg) +
		       f2.func(f2.rcvr, arg) +
		       f3.func(f3.rcvr, arg) +
		       f4.func(f4.rcvr, arg);
	}
}

type Closure<R, T, U>(rcvr: R, func: (R, T)-> U) {
	def call(arg: T) -> U { return func(rcvr, arg); }
}


def fac1tobd(cls: Cls, arg: Arg3<B, D, int>) -> int { return cls.fac1t(Arg3<A,C,int>(arg.x, arg.y, arg.j)); }
def fac2tobd(cls: Cls, arg: Arg3<B, D, int>) -> int { return cls.fac2t(Arg3<A,C,int>(arg.x, arg.y, arg.j)); }

def fbc1tobd(cls: Cls, arg: Arg3<B, D, int>) -> int { return cls.fbc1t(Arg3<B,C,int>(arg.x, arg.y, arg.j)); }
def fbc2tobd(cls: Cls, arg: Arg3<B, D, int>) -> int { return cls.fbc2t(Arg3<B,C,int>(arg.x, arg.y, arg.j)); }

def fad1tobd(cls: Cls, arg: Arg3<B, D, int>) -> int { return cls.fad1t(Arg3<A,D,int>(arg.x, arg.y, arg.j)); }
def fad2tobd(cls: Cls, arg: Arg3<B, D, int>) -> int { return cls.fad2t(Arg3<A,D,int>(arg.x, arg.y, arg.j)); }

def ac_to_bd(f: Closure<Cls, Arg3<A, C, int>, int>) -> Closure<Cls, Arg3<B, D, int>, int> {
	if (f.func == Cls.fac1t)      return Closure<Cls, Arg3<B, D, int>, int>(f.rcvr, fac1tobd);
	else if (f.func == Cls.fac2t) return Closure<Cls, Arg3<B, D, int>, int>(f.rcvr, fac2tobd);
	else return Closure<Cls, Arg3<B, D, int>, int>(null, null);
}

def bc_to_bd(f: Closure<Cls, Arg3<B, C, int>, int>) -> Closure<Cls, Arg3<B, D, int>, int> {
	if (f.func == Cls.fbc1t)      return Closure<Cls, Arg3<B, D, int>, int>(f.rcvr, fbc1tobd);
	else if (f.func == Cls.fbc2t) return Closure<Cls, Arg3<B, D, int>, int>(f.rcvr, fbc2tobd);
	else return Closure<Cls, Arg3<B, D, int>, int>(null, null);
}

def ad_to_bd(f: Closure<Cls, Arg3<A, D, int>, int>) -> Closure<Cls, Arg3<B, D, int>, int> {
	if (f.func == Cls.fad1t)      return Closure<Cls, Arg3<B, D, int>, int>(f.rcvr, fad1tobd);
	else if (f.func == Cls.fad2t) return Closure<Cls, Arg3<B, D, int>, int>(f.rcvr, fad2tobd);
	else return Closure<Cls, Arg3<B, D, int>, int>(null, null);
}

def main(i1: int, i2: int, i3: int, i4: int, j: int) -> int {
	var cls = Cls.new();
	var arrAC: Array<Closure<Cls, Arg3<A, C, int>, int>> = [Closure(cls, Cls.fac1t), Closure(cls, Cls.fac2t)];
	var arrAD: Array<Closure<Cls, Arg3<A, D, int>, int>> = [Closure(cls, Cls.fad1t), Closure(cls, Cls.fad2t)];
	var arrBC: Array<Closure<Cls, Arg3<B, C, int>, int>> = [Closure(cls, Cls.fbc1t), Closure(cls, Cls.fbc2t)];
	var arrBD: Array<Closure<Cls, Arg3<B, D, int>, int>> = [Closure(cls, Cls.fbd1t), Closure(cls, Cls.fbd2t)];
	return cls.add4(ac_to_bd(arrAC[i1]),
			ad_to_bd(arrAD[i2]),
			bc_to_bd(arrBC[i3]),
			arrBD[i4],
			Arg3(B.new(), D.new(), j));
}
