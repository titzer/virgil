//@execute (0, 0, 0, 0, 1, 0)=77; (0, 0, 0, 1, 2, 0)=80; (0, 0, 1, 0, 3, 0)=82; (0, 0, 1, 1, 4, 0)=85; (0, 1, 0, 0, 1, 0)=76; (0, 1, 0, 1, 2, 0)=79; (0, 1, 1, 0, 3, 0)=81; (0, 1, 1, 1, 4, 0)=84; (1, 0, 0, 0, 1, 0)=78; (1, 0, 0, 1, 2, 0)=81; (1, 0, 1, 0, 3, 0)=83; (1, 0, 1, 1, 4, 0)=86; (1, 1, 0, 0, 1, 0)=77; (1, 1, 0, 1, 2, 0)=80; (1, 1, 1, 0, 3, 0)=82; (1, 1, 1, 1, 4, 0)=85
//@heap-size=4000

// Complex / nested function type subsumption

class A {
	def m() -> int { return 11; }
}

class B extends A {
	def m() -> int { return 12; }
}

class C {
	def n() -> int { return 13; }
}

class D extends C {
	def n() -> int { return 13; }
}

class Cls {

	def fac1(x: A, y: C, j: int) -> int { return x.m() + y.n() + j; }
	def fac2(x: A, y: C, j: int) -> int { return x.m() + y.n() + j + 1; }

	def fbc1(x: B, y: C, j: int) -> int { return x.m() - y.n() - j; }
	def fbc2(x: B, y: C, j: int) -> int { return x.m() - y.n() - j + 1; }

	def fad1(x: A, y: D, j: int) -> int { return x.m() + y.n() + j - 1; }
	def fad2(x: A, y: D, j: int) -> int { return x.m() + y.n() + j - 2; }

	def fbd1(x: B, y: D, j: int) -> int { return x.m() + y.n() + j + 2; }
	def fbd2(x: B, y: D, j: int) -> int { return x.m() + y.n() + j + 3; }

	def add4(f1: (Cls, B, D, int) -> int, f2: (Cls, B, D, int) -> int,
		 f3: (Cls, B, D, int) -> int, f4: (Cls, B, D, int) -> int,
		 b: B, d: D, j: int) -> int {
		return f1(this, b, d, j) + f2(this, b, d, j) + f3(this, b, d, j) + f4(this, b, d, j);
	}
}

class Cls2 extends Cls {
	def fac1(x: A, y: C, j: int) -> int { return x.m() + y.n() + j + 100; }
	def fac2(x: A, y: C, j: int) -> int { return x.m() + y.n() + j + 1 + 100; }

	def fbc1(x: B, y: C, j: int) -> int { return x.m() - y.n() - j + 100; }
	def fbc2(x: B, y: C, j: int) -> int { return x.m() - y.n() - j + 1 + 100; }

	def fad1(x: A, y: D, j: int) -> int { return x.m() + y.n() + j - 1 + 100; }
	def fad2(x: A, y: D, j: int) -> int { return x.m() + y.n() + j - 2 + 100; }

	def fbd1(x: B, y: D, j: int) -> int { return x.m() + y.n() + j + 2 + 100; }
	def fbd2(x: B, y: D, j: int) -> int { return x.m() + y.n() + j + 3 + 100; }

}

def ac2bd(cls: Cls, f: (Cls, A, C, int) -> int, b: B, d: D, j: int) -> int {
	return f(cls, b, d, j);
}

def bc2bd(cls: Cls, f: (Cls, B, C, int) -> int, b: B, d: D, j: int) -> int {
	return f(cls, b, d, j);
}

def ad2bd(cls: Cls, f: (Cls, A, D, int) -> int, b: B, d: D, j: int) -> int {
	return f(cls, b, d, j);
}

def main(i1: int, i2: int, i3: int, i4: int, j: int, k: int) -> int {
	var cls = if(k == 0, Cls.new(), Cls2.new());
	var arrAC: Array<(Cls, A, C, int) -> int> = [Cls.fac1, Cls.fac2];
	var arrAD: Array<(Cls, A, D, int) -> int> = [Cls.fad1, Cls.fad2];
	var arrBC: Array<(Cls, B, C, int) -> int> = [Cls.fbc1, Cls.fbc2];
	var arrBD: Array<(Cls, B, D, int) -> int> = [Cls.fbd1, Cls.fbd2];
	return cls.add4(ac2bd(_, arrAC[i1], _, _, _),
			ad2bd(_, arrAD[i2], _, _, _),
			bc2bd(_, arrBC[i3], _, _, _),
			arrBD[i4], B.new(), D.new(), j);
}
