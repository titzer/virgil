//@execute 0=0; 1=-15531774; -1=-15531773; 7=-42399985; 100=-622041895; 1000000=765350153; 2147483647=-1074396930; -2147483648=352780288
// Tests many different immediate values for arithmetic SHR (>>) on i64.
// Tests shift amounts from 0-63 to cover all valid shift amounts.
// Input is multiplied by 0x100000001L to create 64-bit values with upper bits set.
// Results are XORed together to produce checksum.

def SCALE: long = 0x100000001L;

// Low shift amounts (0-7)
def shr_0(a: long) -> long { return a >> 0; }
def shr_1(a: long) -> long { return a >> 1; }
def shr_2(a: long) -> long { return a >> 2; }
def shr_3(a: long) -> long { return a >> 3; }
def shr_4(a: long) -> long { return a >> 4; }
def shr_5(a: long) -> long { return a >> 5; }
def shr_6(a: long) -> long { return a >> 6; }
def shr_7(a: long) -> long { return a >> 7; }

// Byte boundary shifts
def shr_8(a: long) -> long { return a >> 8; }
def shr_16(a: long) -> long { return a >> 16; }
def shr_24(a: long) -> long { return a >> 24; }
def shr_32(a: long) -> long { return a >> 32; }
def shr_40(a: long) -> long { return a >> 40; }
def shr_48(a: long) -> long { return a >> 48; }
def shr_56(a: long) -> long { return a >> 56; }

// Other interesting shifts
def shr_12(a: long) -> long { return a >> 12; }
def shr_15(a: long) -> long { return a >> 15; }
def shr_31(a: long) -> long { return a >> 31; }
def shr_33(a: long) -> long { return a >> 33; }
def shr_63(a: long) -> long { return a >> 63; }

def main(a: int) -> int {
	var x = long.view(a) * SCALE;
	var r: long = 0;
	r ^= shr_0(x);
	r ^= shr_1(x);
	r ^= shr_2(x);
	r ^= shr_3(x);
	r ^= shr_4(x);
	r ^= shr_5(x);
	r ^= shr_6(x);
	r ^= shr_7(x);
	r ^= shr_8(x);
	r ^= shr_16(x);
	r ^= shr_24(x);
	r ^= shr_32(x);
	r ^= shr_40(x);
	r ^= shr_48(x);
	r ^= shr_56(x);
	r ^= shr_12(x);
	r ^= shr_15(x);
	r ^= shr_31(x);
	r ^= shr_33(x);
	r ^= shr_63(x);
	// Return low 32 bits
	return int.view(r);
}
