//@execute 0=0; 1=-67374; -1=65166; 7=-459042; 100=-6583288; 1000000=-1258160000; 2147483647=65166; -2147483648=0
// Tests many different immediate values for MUL on i64.
// Covers various multipliers that may be optimized differently on different architectures.
// Input is multiplied by 0x100000001L to create 64-bit values with upper bits set.
// Results are XORed together to produce checksum.

def SCALE: long = 0x100000001L;

// Small multipliers (often converted to shifts/adds)
def mul_0(a: long) -> long { return a * 0L; }
def mul_1(a: long) -> long { return a * 1L; }
def mul_2(a: long) -> long { return a * 2L; }
def mul_3(a: long) -> long { return a * 3L; }
def mul_4(a: long) -> long { return a * 4L; }
def mul_5(a: long) -> long { return a * 5L; }
def mul_7(a: long) -> long { return a * 7L; }
def mul_8(a: long) -> long { return a * 8L; }
def mul_9(a: long) -> long { return a * 9L; }
def mul_10(a: long) -> long { return a * 10L; }

// Powers of 2 (converted to shifts)
def mul_16(a: long) -> long { return a * 16L; }
def mul_32(a: long) -> long { return a * 32L; }
def mul_64(a: long) -> long { return a * 64L; }
def mul_256(a: long) -> long { return a * 256L; }
def mul_1024(a: long) -> long { return a * 1024L; }

// Powers of 2 minus 1 (often LEA patterns on x86)
def mul_15(a: long) -> long { return a * 15L; }
def mul_31(a: long) -> long { return a * 31L; }
def mul_63(a: long) -> long { return a * 63L; }
def mul_127(a: long) -> long { return a * 127L; }
def mul_255(a: long) -> long { return a * 255L; }

// Powers of 2 plus 1
def mul_17(a: long) -> long { return a * 17L; }
def mul_33(a: long) -> long { return a * 33L; }
def mul_65(a: long) -> long { return a * 65L; }
def mul_257(a: long) -> long { return a * 257L; }

// Larger values
def mul_100(a: long) -> long { return a * 100L; }
def mul_1000(a: long) -> long { return a * 1000L; }
def mul_65536(a: long) -> long { return a * 65536L; }

// Negative multipliers
def mul_neg1(a: long) -> long { return a * -1L; }
def mul_neg2(a: long) -> long { return a * -2L; }
def mul_neg3(a: long) -> long { return a * -3L; }

def main(a: int) -> int {
	var x = long.view(a) * SCALE;
	var r: long = 0;
	r ^= mul_0(x);
	r ^= mul_1(x);
	r ^= mul_2(x);
	r ^= mul_3(x);
	r ^= mul_4(x);
	r ^= mul_5(x);
	r ^= mul_7(x);
	r ^= mul_8(x);
	r ^= mul_9(x);
	r ^= mul_10(x);
	r ^= mul_16(x);
	r ^= mul_32(x);
	r ^= mul_64(x);
	r ^= mul_256(x);
	r ^= mul_1024(x);
	r ^= mul_15(x);
	r ^= mul_31(x);
	r ^= mul_63(x);
	r ^= mul_127(x);
	r ^= mul_255(x);
	r ^= mul_17(x);
	r ^= mul_33(x);
	r ^= mul_65(x);
	r ^= mul_257(x);
	r ^= mul_100(x);
	r ^= mul_1000(x);
	r ^= mul_65536(x);
	r ^= mul_neg1(x);
	r ^= mul_neg2(x);
	r ^= mul_neg3(x);
	// Return low 32 bits
	return int.view(r);
}
