//@execute 0=0; 1=1; -1=-1894906833; 7=7; 100=36; 1000000=917504; 2147483647=252576815; -2147483648=-2147483648
// Tests many different immediate values for AND on i64.
// Covers 8-bit, 12-bit, and 32-bit immediate ranges for various architectures.
// Input is multiplied by 0x100000001L to create 64-bit values with upper bits set.
// Results are XORed together to produce checksum.

def SCALE: long = 0x100000001L;

// 8-bit immediates
def and_0x1(a: long) -> long { return a & 0x1L; }
def and_0x7F(a: long) -> long { return a & 0x7FL; }
def and_0xFF(a: long) -> long { return a & 0xFFL; }

// 12-bit immediates (arm64 range)
def and_0x100(a: long) -> long { return a & 0x100L; }
def and_0x3FF(a: long) -> long { return a & 0x3FFL; }
def and_0xFFF(a: long) -> long { return a & 0xFFFL; }

// 16-bit immediates
def and_0x7FFF(a: long) -> long { return a & 0x7FFFL; }
def and_0xFFFF(a: long) -> long { return a & 0xFFFFL; }

// 32-bit immediates
def and_0x186A0(a: long) -> long { return a & 0x186A0L; }  // 100000
def and_0x7FFFFFFF(a: long) -> long { return a & 0x7FFFFFFFL; }
def and_0xFFFFFFFF(a: long) -> long { return a & 0xFFFFFFFFL; }

// Large 64-bit immediates
def and_0x100000000(a: long) -> long { return a & 0x100000000L; }
def and_0x100000001(a: long) -> long { return a & 0x100000001L; }
def and_0xFFFFFFFF00000000(a: long) -> long { return a & 0xFFFFFFFF00000000L; }
def and_0xFFFFFFFFFFFFFFFF(a: long) -> long { return a & 0xFFFFFFFFFFFFFFFFL; }

// Pattern masks (useful for arm64 logical immediates)
def and_0x5555555555555555(a: long) -> long { return a & 0x5555555555555555L; }
def and_0xAAAAAAAAAAAAAAAA(a: long) -> long { return a & 0xAAAAAAAAAAAAAAAAL; }
def and_0x0F0F0F0F0F0F0F0F(a: long) -> long { return a & 0x0F0F0F0F0F0F0F0FL; }

def main(a: int) -> int {
	var x = long.view(a) * SCALE;
	var r: long = 0;
	r ^= and_0x1(x);
	r ^= and_0x7F(x);
	r ^= and_0xFF(x);
	r ^= and_0x100(x);
	r ^= and_0x3FF(x);
	r ^= and_0xFFF(x);
	r ^= and_0x7FFF(x);
	r ^= and_0xFFFF(x);
	r ^= and_0x186A0(x);
	r ^= and_0x7FFFFFFF(x);
	r ^= and_0xFFFFFFFF(x);
	r ^= and_0x100000000(x);
	r ^= and_0x100000001(x);
	r ^= and_0xFFFFFFFF00000000(x);
	r ^= and_0xFFFFFFFFFFFFFFFF(x);
	r ^= and_0x5555555555555555(x);
	r ^= and_0xAAAAAAAAAAAAAAAA(x);
	r ^= and_0x0F0F0F0F0F0F0F0F(x);
	// Return low 32 bits
	return int.view(r);
}
