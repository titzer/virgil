//@execute 0=0; 1=1; -1=-1427046146; 7=5; 100=71; 1000000=686500; 2147483647=1433960575; -2147483648=-7765887
// Tests many different immediate values for logical SHR (>>) on u64.
// Tests shift amounts from 0-63 to cover all valid shift amounts.
// Input is zero-extended to u64 (not sign-extended).
// Results are XORed together to produce checksum.

// Low shift amounts (0-7)
def shr_0(a: u64) -> u64 { return a >> 0; }
def shr_1(a: u64) -> u64 { return a >> 1; }
def shr_2(a: u64) -> u64 { return a >> 2; }
def shr_3(a: u64) -> u64 { return a >> 3; }
def shr_4(a: u64) -> u64 { return a >> 4; }
def shr_5(a: u64) -> u64 { return a >> 5; }
def shr_6(a: u64) -> u64 { return a >> 6; }
def shr_7(a: u64) -> u64 { return a >> 7; }

// Byte boundary shifts
def shr_8(a: u64) -> u64 { return a >> 8; }
def shr_16(a: u64) -> u64 { return a >> 16; }
def shr_24(a: u64) -> u64 { return a >> 24; }
def shr_32(a: u64) -> u64 { return a >> 32; }
def shr_40(a: u64) -> u64 { return a >> 40; }
def shr_48(a: u64) -> u64 { return a >> 48; }
def shr_56(a: u64) -> u64 { return a >> 56; }

// Other interesting shifts
def shr_12(a: u64) -> u64 { return a >> 12; }
def shr_15(a: u64) -> u64 { return a >> 15; }
def shr_31(a: u64) -> u64 { return a >> 31; }
def shr_33(a: u64) -> u64 { return a >> 33; }
def shr_63(a: u64) -> u64 { return a >> 63; }

def main(a: int) -> int {
	var x = u64.view(u32.view(a));
	var r: u64 = 0;
	r ^= shr_0(x);
	r ^= shr_1(x);
	r ^= shr_2(x);
	r ^= shr_3(x);
	r ^= shr_4(x);
	r ^= shr_5(x);
	r ^= shr_6(x);
	r ^= shr_7(x);
	r ^= shr_8(x);
	r ^= shr_16(x);
	r ^= shr_24(x);
	r ^= shr_32(x);
	r ^= shr_40(x);
	r ^= shr_48(x);
	r ^= shr_56(x);
	r ^= shr_12(x);
	r ^= shr_15(x);
	r ^= shr_31(x);
	r ^= shr_33(x);
	r ^= shr_63(x);
	// Return low 32 bits
	return int.view(r);
}
