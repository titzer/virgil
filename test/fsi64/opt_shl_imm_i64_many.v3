//@execute 0=0; 1=-2130603521; -1=2130743125; 7=-2029718019; 100=1682966492; 1000000=1564295616; 2147483647=-16740523; -2147483648=-2147483648
// Tests many different immediate values for SHL on i64.
// Tests shift amounts from 0-63 to cover all valid shift amounts.
// Input is multiplied by 0x100000001L to create 64-bit values with upper bits set.
// Results are XORed together to produce checksum.

def SCALE: long = 0x100000001L;

// Low shift amounts (0-7)
def shl_0(a: long) -> long { return a << 0; }
def shl_1(a: long) -> long { return a << 1; }
def shl_2(a: long) -> long { return a << 2; }
def shl_3(a: long) -> long { return a << 3; }
def shl_4(a: long) -> long { return a << 4; }
def shl_5(a: long) -> long { return a << 5; }
def shl_6(a: long) -> long { return a << 6; }
def shl_7(a: long) -> long { return a << 7; }

// Byte boundary shifts
def shl_8(a: long) -> long { return a << 8; }
def shl_16(a: long) -> long { return a << 16; }
def shl_24(a: long) -> long { return a << 24; }
def shl_32(a: long) -> long { return a << 32; }
def shl_40(a: long) -> long { return a << 40; }
def shl_48(a: long) -> long { return a << 48; }
def shl_56(a: long) -> long { return a << 56; }

// Other interesting shifts
def shl_12(a: long) -> long { return a << 12; }
def shl_15(a: long) -> long { return a << 15; }
def shl_31(a: long) -> long { return a << 31; }
def shl_33(a: long) -> long { return a << 33; }
def shl_63(a: long) -> long { return a << 63; }

def main(a: int) -> int {
	var x = long.view(a) * SCALE;
	var r: long = 0;
	r ^= shl_0(x);
	r ^= shl_1(x);
	r ^= shl_2(x);
	r ^= shl_3(x);
	r ^= shl_4(x);
	r ^= shl_5(x);
	r ^= shl_6(x);
	r ^= shl_7(x);
	r ^= shl_8(x);
	r ^= shl_16(x);
	r ^= shl_24(x);
	r ^= shl_32(x);
	r ^= shl_40(x);
	r ^= shl_48(x);
	r ^= shl_56(x);
	r ^= shl_12(x);
	r ^= shl_15(x);
	r ^= shl_31(x);
	r ^= shl_33(x);
	r ^= shl_63(x);
	// Return low 32 bits
	return int.view(r);
}
