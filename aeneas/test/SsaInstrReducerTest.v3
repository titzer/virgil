def T = UnitTests.registerT("reduce:", _, SsaInstrReducerTester.new, _);
def X_ = void(
	T("EqualOps", testEqualOps),
	T("Int32Fold", testInt32Fold),
	T("Int64Fold", testInt64Fold),
	T("Int32Reduce", testInt32Reduce),
	T("AddThrow", testAddThrow),
	T("Int32DivModZero", testInt32DivModZero),
	T("Int32Facts", testInt32Facts),
	T("Int64Facts", testInt64Facts),
	T("IntCommute", testIntCommute),
	T("ShiftSafety", testShiftSafety),
	T("BoolOps", testBoolOps),
	T("TypeSubsume", testTypeSubsume),
	T("TypeCast", testTypeCast),
	T("TypeQuery", testTypeQuery),
	T("ArrayOps", testArrayOps),
	T("BoundsChecks", testBoundsChecks),
	T("NullChecks", testNullChecks),
	T("FlowSensitiveNullChecks", testFlowSensitiveNullChecks),
	T("LoadElimination", testLoadElimination),
	T("ClassOps", testClassOps),
	T("ComponentOps", testComponentOps),
	T("TupleOps", testTupleOps),
	T("ClosureOps", testClosureOps),
	T("VariantOps", testVariantOps),
	T("ConditionalThrow", testConditionalThrow),
	T("IntBounds", testIntBounds),
	T("If", testIf),
	T("Phis", testPhis),
	T("Switch", testSwitch),
	()
);

private class SsaInstrReducerTester(t: Tester) {
	def prog = Program.new();
	def graph = SsaGraph.new([SsaParam.new(0, Int.TYPE)], Int.TYPE);
	def context = SsaContext.new(null, prog);
	var optimize_loads: bool;	// activates load elimination
	var optimize_nullchecks: bool;	// activates null check elimination
	var optimize_inits: bool;	// activates init elimination
	var optimize_bounds: bool;	// activates bounds check elimination
	var last_block: SsaBlock;

	def opt1(block: SsaBlock, i: SsaInstr) -> SsaInstr {
		if (block == null) {
			last_block = block = SsaBlock.new();
			block.append(i);
		}
		var opt = newReducer(block, i);
		return opt.reduceInstr(i);
	}
	def optB(block: SsaBlock) {
		var opt = newReducer(block, null);
		opt.reduceBlock(block);
	}
	def assertIK(val: int, i: SsaInstr) {
		var j = opt1(null, i);
		if (!SsaConst.?(j)) failInstr(graph.intConst(val), j);
		t.assert_eq(val, Int.unbox(SsaConst.!(j).val));
	}
	def assertLK(val: long, i: SsaInstr) {
		var j = opt1(null, i);
		if (!SsaConst.?(j)) failInstr(graph.longConst(val), j);
		t.assert_eq(val, Long.unboxSU(SsaConst.!(j).val, val < 0));
	}
	def assertRK(vals: Array<Val>, i: SsaInstr) {
		var j = opt1(null, i);
		t.assert_eq(true, SsaConst.?(j));
		var v = SsaConst.!(j);
		t.assert_eq(true, Record.?(v.val));
		var r = Record.!(v.val);
		t.assert_eq(vals.length, r.values.length);
		for (k < vals.length) {
			t.assert_eq(true, Values.equal(vals[k], r.values[k]));
		}
	}
	def assertTK(vals: Array<Val>, i: SsaInstr) {
		var j = opt1(null, i);
		t.assert_eq(true, SsaConst.?(j));
		t.assert_eq(true, Values.equal(BoxVal.new(null, vals), SsaConst.!(j).val));
	}
	def assertBK(val: bool, i: SsaInstr) {
		t.assert_eq(val, SsaConst.!(opt1(null, i)).unbox<bool>());
	}
	def assertId(i: SsaInstr, j: SsaInstr) {
		j = opt1(null, j);
		if (i != j) failInstr(i, j);
	}
	def assertEq(i: SsaInstr, j: SsaInstr) {
		j = opt1(null, j);
		assertShape(i, j);
	}
	def assertNo(i: SsaInstr) {
		assertId(i, opt1(null, i));
	}
	def assertFact(facts: Fact.set, i: SsaInstr) {
		var j = opt1(null, i);
		if (!j.checkFact(facts)) t.fail("expected facts"); // XXX: unify with helper
	}
	def assertNotFact(facts: Fact.set, i: SsaInstr) {
		var j = opt1(null, i);
		if ((j.facts & facts) != Facts.NONE) t.fail("expected not to have facts");
	}
	def assertThrow(exception: string, i: SsaInstr) {
		var j = opt1(null, i);
		var e = last_block.end();
		if (!SsaThrow.?(e)) failInstr(SsaThrow.new(null, exception), j);
		t.assert_eq(exception, SsaThrow.!(e).exception);
	}
	def newBlock(instr: Array<SsaInstr>) -> SsaBlock {
		var block = SsaBlock.new();
		var prev: SsaLink = block;
		for (i in instr) {
			prev.next = i;
			i.prev = prev;
			prev = i;
		}
		prev.next = block;
		block.prev = prev;
		assertBlock(block, instr);
		return block;
	}
	def assertBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		for (i < expected.length) {
			var prev = if(i == 0, block, expected[i - 1]);
			var next = if(i == expected.length - 1, block, expected[i + 1]);
			var x = expected[i];
			if (x != prev.next) return failBlock(block, expected);
			if (prev != x.prev) return failBlock(block, expected);
			if (x != next.prev) return failBlock(block, expected);
			if (next != x.next) return failBlock(block, expected);
		}
	}
	def assertBlockEq(block: SsaBlock, expected: Array<SsaInstr>) {
		var link = block.next;
		for (i < expected.length) {
			if (!checkShape(link, expected[i])) return failBlock(block, expected);
			link = link.next;
		}
	}
	def addThrow(block: SsaBlock, i: SsaInstr, exception: string) -> SsaInstr {
		var opt = newReducer(block, i.prev);
		return opt.addThrow(null, exception);
	}
	def assertLink(i: SsaLink, j: SsaLink) {
		if (i != j) {
			var msg = if(j == null,
					Strings.format1("expected link @%d, got null", i.uid),
					Strings.format2("expected link @%d, got @%d", i.uid, j.uid));
			t.fail(msg);
		}
	}
	def failBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		printExpectedBlock(block, expected);
		Terminal.put("--- got ---\n");
		printBlock(block, expected.length * 2 + 1);
		t.fail("block");
	}
	def printExpectedBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		var p = SsaPrinter.new();
		p.buf.put1("expected: %d -> \n", block.uid);
		for (i < expected.length) {
			var prev = if(i == 0, block, expected[i - 1]);
			p.buf.put1("prev: %d ", prev.uid);
			p.printInstr(expected[i], true, true, true, false);
			p.buf.ln();
		}
		p.buf.put1("next: %d\n", block.uid);
		p.flush();
	}
	def printBlock(block: SsaBlock, max: int) {
		var p = SsaPrinter.new();
		p.buf.put1("chain: %d -> \n", block.uid);
		var i = block.next;
		for (count < max) {
			if (i == null) {
				p.buf.puts(" ");
				p.putnull();
				p.ln();
				break;
			}
			if (i == block) break;
			p.buf.put1("prev: %d ", if(i.prev == null, -1, i.prev.uid));
			p.printInstr(SsaInstr.!(i), true, true, true, false);
			i = i.next;
			p.buf.ln();
		}
		p.flush();
	}
	def printGraph() {
		var p = SsaPrinter.new();
		p.printGraph("test", StringBuilder.puts(_, "TestGraph"), graph, null);
		p.flush();
	}
	def newReducer(block: SsaBlock, link: SsaLink) -> SsaInstrReducer {
		var opt = SsaInstrReducer.new(context);
		opt.reset(graph, block, link);
		opt.optimize_loads = optimize_loads;
		opt.optimize_nullchecks = optimize_nullchecks;
		opt.optimize_inits = optimize_inits;
		opt.optimize_bounds = optimize_bounds;
		opt.remove_pure_ops = false; // TODO: test with removal of pure operations
		return opt;
	}
	def recordConst(rtype: Type, vals: Array<Val>) -> SsaConst {
		var r = prog.newRecord(rtype, vals.length);
		for (i < vals.length) r.values[i] = vals[i];
		return graph.valConst(rtype, r);
	}
	def tupleConst(rtype: Type, vals: Array<Val>) -> SsaConst {
		var r = BoxVal.new(null, vals);
		return graph.valConst(rtype, r);
	}
	def failInstr(i: SsaInstr, j: SsaInstr) {
		def prog = Program.new();
		var p = SsaPrinter.new();
		p.buf.puts("\nexpected: ");
		p.printInstr(i, true, true, true, false);
		p.buf.puts("\nresult:   ");
		p.printInstr(j, true, true, true, false);
		p.ln();
		p.flush();
		t.fail("instruction mismatch"); // TODO: report mismatch
	}
	def assertShape(i: SsaInstr, j: SsaInstr) {
		if (!checkShape(i, j)) return failInstr(i, j);
	}
}


def checkShape(i: SsaLink, j: SsaInstr) -> bool {
	if (i == j) return true;
	if (SsaConst.?(i) && SsaConst.?(j)) {
		var x = SsaConst.!(i), y = SsaConst.!(j);
		return Values.equal(x.val, y.val) && x.vtype == y.vtype;
	}
	if (SsaApplyOp.?(i) && SsaApplyOp.?(j)) {
		var x = SsaApplyOp.!(i), y = SsaApplyOp.!(j);
		if (!x.op.equals(y.op)) return false;
		if (x.inputs.length != y.inputs.length) return false;
		for (i < x.inputs.length) {
			var xx = x.inputs[i].dest, yy = y.inputs[i].dest;
			if (!checkShape(xx, yy)) return false;
		}
		return true;
	}
	return false;
}

def unop(op: Operator, x: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x]);
	i.setFact(Opcodes.facts(op.opcode));
	return i;
}

def binop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y]);
	i.setFact(Opcodes.facts(op.opcode));
	return i;
}

def triop(op: Operator, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y, z]);
	i.setFact(Opcodes.facts(op.opcode));
	return i;
}

def EQUAL(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return binop(V3Op.newEqual(t), x, y);
}

def NOT_EQUAL(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return unop(V3Op.opBoolNot, binop(V3Op.newEqual(t), x, y));
}

def INT32_ADD = binop(Int.TYPE.opAdd(), _, _);
def INT32_SUB = binop(Int.TYPE.opSub(), _, _);
def INT32_MUL = binop(Int.TYPE.opMul(), _, _);
def INT32_DIV = binop(Int.TYPE.opDiv(), _, _);
def INT32_MOD = binop(Int.TYPE.opMod(), _, _);
def INT32_AND = binop(Int.TYPE.opAnd(), _, _);
def INT32_OR  = binop(Int.TYPE.opOr(), _, _);
def INT32_XOR = binop(Int.TYPE.opXor(), _, _);
def INT32_SHL = binop(Int.TYPE.opShl(), _, _);
def INT32_SHR = binop(Int.TYPE.opShr(), _, _);
def INT32_SAR = binop(Int.TYPE.opSar(), _, _);
def INT32_LT  = binop(Int.TYPE.opLt(), _, _);
def INT32_LE  = binop(Int.TYPE.opLtEq(), _, _);

def INT64_ADD = binop(Long.TYPE.opAdd(), _, _);
def INT64_SUB = binop(Long.TYPE.opSub(), _, _);
def INT64_MUL = binop(Long.TYPE.opMul(), _, _);
def INT64_DIV = binop(Long.TYPE.opDiv(), _, _);
def INT64_MOD = binop(Long.TYPE.opMod(), _, _);
def INT64_AND = binop(Long.TYPE.opAnd(), _, _);
def INT64_OR  = binop(Long.TYPE.opOr(), _, _);
def INT64_XOR = binop(Long.TYPE.opXor(), _, _);
def INT64_SHL = binop(Long.TYPE.opShl(), _, _);
def INT64_SHR = binop(Long.TYPE.opShr(), _, _);
def INT64_SAR = binop(Long.TYPE.opSar(), _, _);
def INT64_LT  = binop(Long.TYPE.opLt(), _, _);
def INT64_LE  = binop(Long.TYPE.opLtEq(), _, _);

def BOOL_AND = binop(V3Op.opBoolAnd, _, _);
def BOOL_OR = binop(V3Op.opBoolOr, _, _);
def BOOL_NOT = unop(V3Op.opBoolNot, _);

def CONDITIONAL_THROW(exception: string, x: SsaInstr) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newConditionalThrow(exception), [x]);
}

def TYPECAST(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
	return unop(V3Op.newTypeCast(ft, tt), x);
}

def TYPEQUERY(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
	return unop(V3Op.newTypeQuery(ft, tt), x);
}

def TEST_CLASS_TYPE = V3.stringType;
def IMM_FIELD = makeIrField(TEST_CLASS_TYPE, Int.TYPE, Fact.F_VALUE);
def MUT_FIELD = makeIrField(TEST_CLASS_TYPE, Int.TYPE, Facts.NONE);
def CLASS_GET_FIELD = unop(V3Op.newClassGetField(MUT_FIELD), _);
def CLASS_SET_FIELD = binop(V3Op.newClassSetField(MUT_FIELD), _, _);


def CALL_CLOSURE(ftype: Type, x: Array<SsaInstr>) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newCallClosure(ftype), x);
}

def CALL_METHOD(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newCallMethod(m), x);
}

def CALL_CLASS_VIRTUAL(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newCallClassVirtual(m), x);
}

def CLASS_GET_METHOD(m: IrSpec, o: SsaInstr) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newClassGetMethod(m), [o]);
}

def CLASS_GET_VIRTUAL(m: IrSpec, o: SsaInstr) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newClassGetVirtual(m), [o]);
}

def CREATE_CLOSURE(m: IrSpec, ftype: Type, o: SsaInstr) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newCreateClosure(m, ftype), [o]);
}

def TUPLE_GET_ELEM(index: int, x: SsaInstr) -> SsaInstr {
	return unop(V3Op.newTupleGetElem(x.getType(), index), x);
}

def VARIANT_GET_TAG(t: Type, x: SsaInstr) -> SsaInstr {
	return unop(V3Op.newVariantGetTag(t), x);
}

def testEqualOps(T: SsaInstrReducerTester) {
	// test constant folding and strength reduction of equality
	def P = T.graph.params[0], Q = PARAM(Int.TYPE);
	def K = T.graph.intConst;
	def EQ = EQUAL(Int.TYPE, _, _);

	T.assertNo(   EQ(P, Q));
	T.assertNo(   EQ(Q, P));

	T.assertBK(true, EQ(P, P));
	T.assertBK(true, EQ(Q, Q));

	T.assertBK(true, EQ(K(11), K(11)));
	T.assertBK(false, EQ(K(-11), K(11)));

	// test mismatch zero/non-zero values
	if (false) { // TODO: optimization currently disabled
		def X = PARAM(Int.TYPE), Y = PARAM(Int.TYPE);
		X.facts |= Fact.V_NON_ZERO;
		Y.facts |= Fact.V_ZERO;

		T.assertBK(false, EQ(X, Y));
		T.assertBK(false, EQ(X, K(0)));
	}

	// TODO: test equality of references, tuples, arrays, etc
}

def PARAM(t: Type) -> SsaParam {
	return SsaParam.new(1, t);
}

def testInt32Fold(T: SsaInstrReducerTester) {
	// test constant folding
	def P = T.graph.params[0];
	def K = T.graph.intConst;

	T.assertIK(7,          INT32_ADD(K(3), K(4)));
	T.assertIK(6,          INT32_ADD(K(2), K(4)));

	T.assertIK(-1,         INT32_SUB(K(3), K(4)));
	T.assertIK(-398,       INT32_SUB(K(2), K(400)));

	T.assertIK(-35,        INT32_MUL(K(5), K(-7)));
	T.assertIK(-727379968, INT32_MUL(K(1000000), K(1000000)));

	T.assertIK(-3,         INT32_DIV(K(-34), K(11)));
	T.assertIK(18181,      INT32_DIV(K(1000000), K(55)));

	T.assertIK(3,          INT32_MOD(K(13), K(10)));
	T.assertIK(-7,         INT32_MOD(K(-107), K(100)));
	T.assertIK(5,          INT32_MOD(K(122), K(-117)));

	T.assertIK(15,         INT32_AND(K(15), K(31)));
	T.assertIK(2,          INT32_AND(K(6), K(10)));

	T.assertIK(31,         INT32_OR(K(3), K(28)));
	T.assertIK(-225,       INT32_OR(K(15), K(-240)));

	T.assertIK(12,         INT32_XOR(K(1333), K(1337)));
	T.assertIK(-8,         INT32_XOR(K(-9), K(15)));

	T.assertIK(896,        INT32_SHL(K(112), K(3)));
	T.assertIK(-3896,      INT32_SHL(K(-974), K(2)));

	T.assertIK(48,         INT32_SHR(K(192), K(2)));
	T.assertIK(536870787,  INT32_SHR(K(-999), K(3)));

	T.assertIK(49,         INT32_SAR(K(196), K(2)));
	T.assertIK(-125,       INT32_SAR(K(-999), K(3)));

	T.assertBK(true,       INT32_LT(K(55), K(56)));
	T.assertBK(false,      INT32_LT(K(-99), K(-100)));

	T.assertBK(true,       INT32_LE(K(155), K(155)));
	T.assertBK(false,      INT32_LE(K(-991), K(-1001)));
}

def testInt32Reduce(T: SsaInstrReducerTester) {
	// test strength reduction
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	var POS = PARAM(Int.TYPE);
	POS.facts |= Fact.V_NON_NEGATIVE;
	var NEG = PARAM(Int.TYPE);
	NEG.facts |= Fact.V_BELOW_ZERO;

	T.assertId(P,                   INT32_ADD(P, K(0)));
	T.assertId(P,                   INT32_ADD(K(0), P));

	T.assertId(P,                   INT32_SUB(P, K(0)));
	T.assertNo(                     INT32_SUB(K(0), P));

	T.assertIK(0,                   INT32_MUL(P, K(0)));
	T.assertId(P,                   INT32_MUL(P, K(1)));
	T.assertId(P,                   INT32_MUL(K(1), P));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(P, K(-1)));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(K(-1), P));
	T.assertEq(INT32_ADD(P, P),     INT32_MUL(K(2), P));
	T.assertEq(INT32_SHL(P, K(2)),  INT32_MUL(K(4), P));
	T.assertEq(INT32_SHL(P, K(3)),  INT32_MUL(K(8), P));
	T.assertEq(INT32_SHL(P, K(4)),  INT32_MUL(K(16), P));
	T.assertEq(INT32_SHL(P, K(5)),  INT32_MUL(K(32), P));
	T.assertEq(INT32_SHL(P, K(20)), INT32_MUL(K(1024 * 1024), P));
	T.assertEq(INT32_SHL(P, K(31)), INT32_MUL(K(1024 * 1024 * 1024 * 2), P));

	T.assertId(P,                    INT32_DIV(P, K(1)));
	T.assertEq(INT32_SUB(K(0), P),   INT32_DIV(P, K(-1)));
	T.assertNo(                      INT32_DIV(P, K(2)));
	T.assertEq(INT32_SHR(POS, K(1)), INT32_DIV(POS, K(2)));
	T.assertEq(INT32_SHR(POS, K(2)), INT32_DIV(POS, K(4)));
	T.assertEq(INT32_SHR(POS, K(3)), INT32_DIV(POS, K(8)));
	T.assertEq(INT32_SHR(POS, K(4)), INT32_DIV(POS, K(16)));
	T.assertEq(INT32_SHR(POS, K(5)), INT32_DIV(POS, K(32)));

	T.assertIK(0,                     INT32_MOD(P, K(1)));
	T.assertIK(0,                     INT32_MOD(P, K(-1)));
	T.assertNo(                       INT32_MOD(P, K(2)));
	T.assertEq(INT32_AND(POS, K(1)),  INT32_MOD(POS, K(2)));
	T.assertEq(INT32_AND(POS, K(3)),  INT32_MOD(POS, K(4)));
	T.assertEq(INT32_AND(POS, K(7)),  INT32_MOD(POS, K(8)));
	T.assertEq(INT32_AND(POS, K(15)), INT32_MOD(POS, K(16)));
	T.assertEq(INT32_AND(POS, K(31)), INT32_MOD(POS, K(32)));

	T.assertId(P,                     INT32_AND(P, K(-1)));
	T.assertIK(0,                     INT32_AND(P, K(0)));

	T.assertId(P,                     INT32_OR(P, K(0)));
	T.assertIK(-1,                    INT32_OR(P, K(-1)));

	T.assertIK(0,                     INT32_XOR(P, P));
	T.assertId(P,                     INT32_XOR(P, K(0)));

	T.assertIK(0,                     INT32_SHL(P, K(-1)));
	T.assertIK(0,                     INT32_SHL(P, K(32)));

	T.assertIK(0,                     INT32_SHR(P, K(-1)));
	T.assertIK(0,                     INT32_SHR(P, K(32)));

	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(-1)));
	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(32)));
	T.assertIK(0,                     INT32_SAR(POS, K(-1)));
	T.assertIK(-1,                    INT32_SAR(NEG, K(-1)));
}


def testInt64Fold(T: SsaInstrReducerTester) {
	// test constant folding
	def P = T.graph.params[0];
	def K = T.graph.longConst;

	T.assertLK(7,            INT64_ADD(K(3), K(4)));
	T.assertLK(6,            INT64_ADD(K(2), K(4)));
	T.assertLK(200000000003, INT64_ADD(K(100000000001), K(100000000002)));

	T.assertLK(-1,         INT64_SUB(K(3), K(4)));
	T.assertLK(-398,       INT64_SUB(K(2), K(400)));

	T.assertLK(-35,           INT64_MUL(K(5), K(-7)));
	T.assertLK(1000000000000, INT64_MUL(K(1000000), K(1000000)));

	T.assertLK(-3,         INT64_DIV(K(-34), K(11)));
	T.assertLK(18181,      INT64_DIV(K(1000000), K(55)));

	T.assertLK(3,          INT64_MOD(K(13), K(10)));
	T.assertLK(-7,         INT64_MOD(K(-107), K(100)));
	T.assertLK(5,          INT64_MOD(K(122), K(-117)));
	T.assertLK(0,          INT64_MOD(P, K(1)));
	T.assertLK(0,          INT64_MOD(P, K(-1)));

	T.assertLK(15,         INT64_AND(K(15), K(31)));
	T.assertLK(2,          INT64_AND(K(6), K(10)));

	T.assertLK(31,         INT64_OR(K(3), K(28)));
	T.assertLK(-225,       INT64_OR(K(15), K(-240)));

	T.assertLK(12,         INT64_XOR(K(1333), K(1337)));
	T.assertLK(-8,         INT64_XOR(K(-9), K(15)));

	T.assertLK(896,        INT64_SHL(K(112), K(3)));
	T.assertLK(-3896,      INT64_SHL(K(-974), K(2)));

	T.assertLK(48,                   INT64_SHR(K(192), K(2)));
	T.assertLK(0x1FFFFFFFFFFFFF83,   INT64_SHR(K(-999), K(3)));
	T.assertLK(0,                    INT64_SHR(K(10009), K(100)));

	T.assertLK(49,         INT64_SAR(K(196), K(2)));
	T.assertLK(-125,       INT64_SAR(K(-999), K(3)));
	T.assertLK(0,          INT64_SAR(K(10333309), K(64)));
	T.assertLK(-1,         INT64_SAR(K(-99910009), K(65)));

	T.assertBK(true,       INT64_LT(K(55), K(56)));
	T.assertBK(false,      INT64_LT(K(-99), K(-100)));

	T.assertBK(true,       INT64_LE(K(155), K(155)));
	T.assertBK(false,      INT64_LE(K(-991), K(-1001)));
}

def testAddThrow(T: SsaInstrReducerTester) {
	def P0 = T.graph.params[0];
	def P1 = T.graph.params[0];
	def I1 = INT32_ADD(P0, P1);
	def I2 = INT32_ADD(P0, P1);
	def I3 = INT32_ADD(P0, P1);

	for (i < 3) {
		var x = "MyException", array = [I1, I2, I3];
		def b = T.newBlock(array);
		var t = T.addThrow(b, array[i], x);
		var nop = T.graph.nop();
		T.t.assert_eq(nop, t);
		var e = b.end();
		T.t.assert_eq(true, SsaThrow.?(e));
		T.t.assert_eq(x, SsaThrow.!(e).exception);
		T.assertBlock(b, Arrays.append(e, Arrays.range(array, 0, i)));
	}
}

def testInt32DivModZero(T: SsaInstrReducerTester) {
	def K = T.graph.intConst;
	def P = T.graph.params[0];

	{
		def I = INT32_DIV(P, K(0));
		var block = T.newBlock([I]);
		var t = T.opt1(block, I);
		var e = block.end();
		T.t.assert_eq(true, SsaThrow.?(e));
		T.t.assert_eq(V3Exception.DivideByZero, SsaThrow.!(e).exception);
		T.assertBlock(block, [e]);
	}

	{
		def I = INT32_MOD(P, K(0));
		var block = T.newBlock([I]);
		var t = T.opt1(block, I);
		var e = block.end();
		T.t.assert_eq(true, SsaThrow.?(e));
		T.t.assert_eq(V3Exception.DivideByZero, SsaThrow.!(e).exception);
		T.assertBlock(block, [e]);
	}
}

def testInt32Facts(T: SsaInstrReducerTester) {
	// test propagation of integer range facts
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	var POS = PARAM(Int.TYPE);
	POS.facts |= Fact.V_NON_NEGATIVE;
	var POS2 = PARAM(Int.TYPE);
	POS2.facts |= Fact.V_NON_NEGATIVE;
	var NEG = PARAM(Int.TYPE);
	NEG.facts |= Fact.V_BELOW_ZERO;
	var NZ = PARAM(Int.TYPE);
	NZ.facts |= Fact.V_NON_ZERO;

	T.assertFact(Facts.O_SAFE_DIVIDE, INT32_DIV(P, K(11)));

	T.assertFact(Fact.V_NON_NEGATIVE, INT32_AND(P, K(33)));
	T.assertFact(Fact.V_NON_NEGATIVE, INT32_AND(P, POS));
	T.assertFact(Fact.V_NON_NEGATIVE, INT32_AND(POS, P));

	T.assertFact(Fact.V_BELOW_ZERO, INT32_OR(P, K(-3)));
	T.assertFact(Fact.V_BELOW_ZERO, INT32_OR(K(-2), P));
	T.assertFact(Fact.V_BELOW_ZERO, INT32_OR(P, NEG));
	T.assertFact(Fact.V_BELOW_ZERO, INT32_OR(NEG, P));

	T.assertFact(Fact.V_NON_ZERO, INT32_OR(P, K(1)));
	T.assertFact(Fact.V_NON_ZERO, INT32_OR(K(2), P));

	T.assertFact(Fact.V_NON_ZERO, INT32_OR(P, K(-5)));
	T.assertFact(Fact.V_NON_ZERO, INT32_OR(K(-6), P));

	T.assertFact(Fact.V_NON_NEGATIVE, INT32_XOR(POS, K(11)));
	T.assertFact(Fact.V_NON_NEGATIVE, INT32_XOR(POS, POS2));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHL(P, K(2)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHL(P, K(12)));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, K(11)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, K(14)));
	T.assertFact(Fact.V_NON_NEGATIVE,   INT32_SHR(P, K(2)));
	T.assertFact(Fact.V_NON_NEGATIVE,   INT32_SHR(P, NZ));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SAR(P, K(16)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SAR(P, K(31)));

	T.assertIK(0, INT32_SAR(POS, K(32)));
	T.assertIK(0, INT32_SAR(POS, K(-1)));
	T.assertIK(-1, INT32_SAR(NEG, K(32)));
	T.assertIK(-1, INT32_SAR(NEG, K(-1)));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SAR(P, K(-1)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SAR(P, K(40)));

	T.assertEq(INT32_SAR(P, K(31)),  INT32_SAR(P, K(-1)));
	T.assertEq(INT32_SAR(P, K(31)),  INT32_SAR(P, K(40)));
}

def testInt64Facts(T: SsaInstrReducerTester) {
	// test propagation of integer range facts
	def P = T.graph.params[0];
	def K = T.graph.longConst;
	var POS = PARAM(Long.TYPE);
	POS.facts |= Fact.V_NON_NEGATIVE;
	var POS2 = PARAM(Long.TYPE);
	POS2.facts |= Fact.V_NON_NEGATIVE;
	var NEG = PARAM(Long.TYPE);
	NEG.facts |= Fact.V_BELOW_ZERO;
	var NZ = PARAM(Long.TYPE);
	NZ.facts |= Fact.V_NON_ZERO;

	T.assertFact(Facts.O_SAFE_DIVIDE, INT64_DIV(P, K(11)));

	T.assertFact(Fact.V_NON_NEGATIVE, INT64_AND(P, K(Int.MAX_VALUE)));
	T.assertFact(Fact.V_NON_NEGATIVE, INT64_AND(P, POS));
	T.assertFact(Fact.V_NON_NEGATIVE, INT64_AND(POS, P));

	T.assertFact(Fact.V_BELOW_ZERO, INT64_OR(P, K(-3)));
	T.assertFact(Fact.V_BELOW_ZERO, INT64_OR(K(-2), P));
	T.assertFact(Fact.V_BELOW_ZERO, INT64_OR(P, NEG));
	T.assertFact(Fact.V_BELOW_ZERO, INT64_OR(NEG, P));

	T.assertFact(Fact.V_NON_NEGATIVE, INT64_XOR(POS, K(1110000)));
	T.assertFact(Fact.V_NON_NEGATIVE, INT64_XOR(POS, POS2));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHL(P, K(2)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHL(P, K(12)));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHR(P, K(11)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHR(P, K(14)));
	T.assertFact(Fact.V_NON_NEGATIVE,   INT64_SHR(P, K(2)));
	T.assertFact(Fact.V_NON_NEGATIVE,   INT64_SHR(P, NZ));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(16)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(31)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(63)));

	T.assertIK(0, INT64_SAR(POS, K(64)));
	T.assertIK(0, INT64_SAR(POS, K(-1)));
	T.assertIK(-1, INT64_SAR(NEG, K(64)));
	T.assertIK(-1, INT64_SAR(NEG, K(-1)));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(-1)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(40)));

	T.assertEq(INT64_SAR(P, T.graph.intConst(63)),  INT64_SAR(P, K(-1)));
	T.assertNo(                      INT64_SAR(P, K(40)));
	T.assertEq(INT64_SAR(P, T.graph.intConst(63)),  INT64_SAR(P, K(100)));
}

def testIntCommute(T: SsaInstrReducerTester) {
	// test putting constants on the right
	def P = T.graph.params[0];
	def K = T.graph.intConst(27);

	T.assertEq(INT32_ADD(P, K), INT32_ADD(K, P));
	T.assertEq(INT32_MUL(P, K), INT32_MUL(K, P));
	T.assertEq(INT32_AND(P, K), INT32_AND(K, P));
	T.assertEq(INT32_OR(P, K),  INT32_OR(K, P));
	T.assertEq(INT32_XOR(P, K), INT32_XOR(K, P));

	T.assertEq(INT64_ADD(P, K), INT64_ADD(K, P));
	T.assertEq(INT64_MUL(P, K), INT64_MUL(K, P));
	T.assertEq(INT64_AND(P, K), INT64_AND(K, P));
	T.assertEq(INT64_OR(P, K),  INT64_OR(K, P));
	T.assertEq(INT64_XOR(P, K), INT64_XOR(K, P));

	T.assertNo(               INT32_SUB(K, P));
	T.assertNo(               INT32_DIV(K, P));
	T.assertNo(               INT32_MOD(K, P));
	T.assertNo(               INT32_SHL(K, P));
	T.assertNo(               INT32_SHR(K, P));
	T.assertNo(               INT32_SAR(K, P));

	T.assertNo(               INT64_SUB(K, P));
	T.assertNo(               INT64_DIV(K, P));
	T.assertNo(               INT64_MOD(K, P));
	T.assertNo(               INT64_SHL(K, P));
	T.assertNo(               INT64_SHR(K, P));
	T.assertNo(               INT64_SAR(K, P));

	// Comparisons are not commuted.
	T.assertEq(INT64_LT(P, K), INT64_LT(P, K));
	T.assertEq(INT64_LE(P, K), INT64_LE(P, K));
	T.assertEq(INT64_LT(K, P), INT64_LT(K, P));
	T.assertEq(INT64_LE(K, P), INT64_LE(K, P));

	T.assertEq(INT32_LT(P, K), INT32_LT(P, K));
	T.assertEq(INT32_LE(P, K), INT32_LE(P, K));
	T.assertEq(INT32_LT(K, P), INT32_LT(K, P));
	T.assertEq(INT32_LE(K, P), INT32_LE(K, P));
}

def testShiftSafety(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SAR(P, K(3)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SAR(P, K(7)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SAR(P, K(31)));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(3)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(7)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SAR(P, K(31)));

	def u3_t = Int.getType(false, 3);
	def u4_t = Int.getType(false, 4);
	def u5_t = Int.getType(false, 5);
	def u6_t = Int.getType(false, 6);
	def u7_t = Int.getType(false, 7);

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHL(P, PARAM(u3_t)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHL(P, PARAM(u4_t)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHL(P, PARAM(u5_t)));
	T.assertNotFact(Fact.O_NO_SHIFT_CHECK, INT32_SHL(P, PARAM(u6_t)));
	T.assertNotFact(Fact.O_NO_SHIFT_CHECK, INT32_SHL(P, PARAM(u7_t)));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHL(P, PARAM(u3_t)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHL(P, PARAM(u4_t)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHL(P, PARAM(u5_t)));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHL(P, PARAM(u6_t)));
	T.assertNotFact(Fact.O_NO_SHIFT_CHECK, INT64_SHL(P, PARAM(u7_t)));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, INT32_AND(P, K(3))));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, INT32_AND(P, K(7))));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, INT32_AND(P, K(31))));
	T.assertNotFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, INT32_AND(P, K(32))));
	T.assertNotFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, INT32_AND(P, K(63))));

	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHR(P, INT32_AND(P, K(3))));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHR(P, INT32_AND(P, K(7))));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHR(P, INT32_AND(P, K(31))));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHR(P, INT32_AND(P, K(60))));
	T.assertFact(Fact.O_NO_SHIFT_CHECK, INT64_SHR(P, INT32_AND(P, K(63))));
	T.assertNotFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, INT32_AND(P, K(64))));
	T.assertNotFact(Fact.O_NO_SHIFT_CHECK, INT32_SHR(P, INT32_AND(P, K(65))));
}

def testBoolOps(T: SsaInstrReducerTester) {
	// folding and reduction of boolean operators
	def P = PARAM(Bool.TYPE);
	def TRUE = T.graph.trueConst(), FALSE = T.graph.falseConst();

	T.assertId(P, BOOL_AND(TRUE, P));
	T.assertId(P, BOOL_AND(P, TRUE));

	T.assertId(P, BOOL_OR(FALSE, P));
	T.assertId(P, BOOL_OR(P, FALSE));

	T.assertBK(false, BOOL_AND(FALSE, P));
	T.assertBK(false, BOOL_AND(P, FALSE));

	T.assertBK(true, BOOL_OR(TRUE, P));
	T.assertBK(true, BOOL_OR(P, TRUE));

	T.assertBK(true, BOOL_NOT(FALSE));
	T.assertBK(false, BOOL_NOT(TRUE));

	T.assertId(P, BOOL_NOT(BOOL_NOT(P)));
}


def testTypeSubsume(T: SsaInstrReducerTester) {
	// TODO
}

def testTypeCast(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	def LK = T.graph.valConst(Long.TYPE, _);

	// class types.
	def A = newClassType("A", null);
	def B = newClassType("B", A);
	def C = newClassType("C", A);
	def X = newClassType("X", null);

	// nop casts.
	for (t in [Byte.TYPE, Int.TYPE, Long.TYPE, Bool.TYPE, Void.TYPE, A, B, C]) {
		var param = SsaParam.new(1, t);
		T.assertEq(param, TYPECAST(t, t, param));
		T.assertEq(param, TYPECAST(t, t, param));
		T.assertEq(param, TYPECAST(t, t, param));
		T.assertEq(param, TYPECAST(t, t, param));
	}

	// class casts.
	T.assertNo(       TYPECAST(A, C, P));
	T.assertNo(       TYPECAST(A, B, P));
	T.assertEq(P,     TYPECAST(C, A, P));
	T.assertEq(P,     TYPECAST(B, A, P));

	for (pair in [(B, C), (C, B), (X, B), (B, X)]) {
		// null-only class casts.
		var cast = TYPECAST(pair.0, pair.1, P);
		T.assertEq(T.graph.nullConst(pair.1), cast);
		var block = T.newBlock([cast]);
		T.optB(block);
		var cmp = EQUAL(pair.0, P, T.graph.nullConst(pair.0));
		var not = BOOL_NOT(cmp);
		var check = CONDITIONAL_THROW(V3Exception.TypeCheck, not);
		T.assertBlockEq(block, [cmp, not, check]);
	}

	// int conversions.
	var ival = 0xabcd1623;
	var lval = 0xabcdeffedcba3344;
	for (signed in [false, true]) {
		for (width = 1; width < 33; width++) {
			var expected = ival << u5.!(32 - width);
			if (signed) expected = expected >> u5.!(32 - width);
			else expected = expected >>> u5.!(32 - width);
			var tt = Int.getType(signed, width);

			// constant folding for narrowing.
			var narrow = V3Op.newTypeCast(Int.TYPE, tt);
			// TODO: assert throw

			// constant folding for widening.
			var widen = V3Op.newTypeCast(tt, Int.TYPE);
			// TODO: assert widening

			// replace with int conversion.
			if (tt != Int.TYPE) {
				var narrowc = V3Op.newIntViewI(Int.TYPE, tt);
				// TODO: assert throw

				var widenc = V3Op.newIntViewI(tt, Int.TYPE);
				// TODO: assert widening
			}
		}

		for (width = 1; width < 65; width++) {
			var expected = lval << u6.!(64 - width);
			if (signed) expected = expected >> u6.!(64 - width);
			else expected = expected >>> u6.!(64 - width);
			var tt = Int.getType(signed, width);

			// constant folding for narrowing.
			var narrow = V3Op.newTypeCast(Long.TYPE, tt);
			// TODO: assert throw

			// constant folding for widening.
			var widen = V3Op.newTypeCast(tt, Long.TYPE);
			// TODO: assert widening
		}
	}

	// enum to set conversions.
	for (size: u5 = 3; size < 17; size++) {
		var et = SsaGraphBuildingHelper.newEnumType("farth", size);
		var ets = et.setType;
		for (i: u5 < size) {
			T.assertIK(1 << i, TYPECAST(et, ets, K(i)));
			var shl = Int.getType(false, size).opShl();
			T.assertEq(binop(shl, K(1), P), TYPECAST(et, ets, P));
		}
	}

	// invalid type casts.
	for (pair in [(Int.TYPE, Bool.TYPE), (Int.TYPE, V3.stringType), (A, Int.TYPE)]) {
		T.assertThrow(V3Exception.TypeCheck, TYPECAST(pair.0, pair.1, P));
		T.assertThrow(V3Exception.TypeCheck, TYPECAST(pair.1, pair.0, P));
	}

	// fact propagation.
	var NN = SsaParam.new(2, A);
	NN.facts = Fact.V_NON_ZERO;
	T.assertFact(Fact.O_NO_NULL_CHECK | Fact.V_NON_ZERO, TYPECAST(A, B, NN));
}

def assertTypeQueryFolds(T: SsaInstrReducerTester, result: bool, xt: Type, yt: Type) {
	T.assertEq(T.graph.boolConst(result), TYPEQUERY(xt, yt, SsaParam.new(1, xt)));
}

def testTypeQuery(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	def LK = T.graph.valConst(Long.TYPE, _);
	def BK = T.graph.boolConst;
	def YES = assertTypeQueryFolds(T, true, _, _);
	def NO = assertTypeQueryFolds(T, false, _, _);

	var simple = [Byte.TYPE, Int.TYPE, Long.TYPE, Bool.TYPE, Void.TYPE]; // TODO
	var ints = [Byte.TYPE, Int.TYPE, Long.TYPE];

	for (t in simple) YES(t, t);

	for (i < ints.length) {
		for (j < ints.length) {
			if (i <= j) YES(ints[i], ints[j]);
		}
		NO(ints[i], Bool.TYPE);
		NO(Bool.TYPE, ints[i]);
		NO(ints[i], Void.TYPE);
	}

	var A = newClassType("A", null);
	var B = newClassType("B", A);
	T.assertEq(NOT_EQUAL(A, P, T.graph.nullConst(A)), TYPEQUERY(A, A, P));
	T.assertEq(NOT_EQUAL(B, P, T.graph.nullConst(B)), TYPEQUERY(B, A, P));
	T.assertNo(                                       TYPEQUERY(A, B, P));

	var N = SsaParam.new(1, A);
	N.facts |= Fact.V_NON_ZERO;
	T.assertFact(Fact.O_NO_NULL_CHECK, TYPEQUERY(A, B, N));
}

def testArrayOps(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;

	def R = T.recordConst(V3.stringType, [
		Int.box(11),
		Int.box(12),
		Int.box(13),
		Int.box(14),
		Int.box(15)
	]);

	// test length check of ArrayAlloc
	T.assertFact(Fact.O_NO_NEGATIVE_CHECK, ARRAY_ALLOC(K(0)));
	T.assertFact(Fact.O_NO_NEGATIVE_CHECK, ARRAY_ALLOC(K(33)));

	// test fold of ArrayInit
	T.assertNo(ARRAY_INIT([K(0), P]));
	T.assertNo(ARRAY_INIT([P, K(0)]));
	T.assertNo(ARRAY_INIT([]));
	T.assertNo(ARRAY_INIT([K(11)]));
	T.assertNo(ARRAY_INIT([K(11), K(12)]));
	T.assertNo(ARRAY_INIT([K(11), K(12), K(-1333)]));

	// test fold of pure ArrayGetElem
	for (i < Record.!(R.val).values.length) {
		var G = ARRAY_GET_ELEM(R, K(i));
		T.assertNo(        G);
		G.facts |= Fact.O_PURE;
		T.assertIK(11 + i, G);
	}

	// ArrayGetLength
	T.assertId(P, ARRAY_GET_LENGTH(ARRAY_ALLOC(P)));
	T.assertIK(5, ARRAY_GET_LENGTH(R));
	T.assertIK(3, ARRAY_GET_LENGTH(ARRAY_INIT([K(1), K(2), K(3)])));
}

def ARRAY_ALLOC = unop(V3Op.newArrayAlloc(V3.stringType), _);
def ARRAY_GET_ELEM = binop(V3Op.newArrayGetElem(V3.stringType, Int.TYPE), _, _);
def ARRAY_SET_ELEM = triop(V3Op.newArrayGetElem(V3.stringType, Int.TYPE), _, _, _);
def ARRAY_GET_LENGTH = unop(V3Op.newArrayGetLength(V3.stringType), _);
def ARRAY_INIT(instrs: Array<SsaInstr>) -> SsaInstr {
	var op = V3Op.newArrayInit(V3.stringType, instrs.length);
	var i = SsaApplyOp.new(null, op, instrs);
	i.setFact(Opcodes.facts(op.opcode));
	return i;
}
def newTupleType(len: int) -> Type {
	var l: List<Type>;
	for (i < len) l = List.new(Int.TYPE, l);
	return Tuple.newType(l);
}
def TUPLE_CREATE(instrs: Array<SsaInstr>) -> SsaInstr {
	var op = V3Op.newTupleCreate(newTupleType(instrs.length));
	var i = SsaApplyOp.new(null, op, instrs);
	i.setFact(Opcodes.facts(op.opcode));
	return i;
}
def BOUNDS_CHECK = binop(V3Op.newBoundsCheck(V3.stringType), _, _);

def makeIrField(receiver: Type, fieldType: Type, facts: Fact.set) -> IrSpec {
	var field = IrField.new(receiver, fieldType);
	field.facts = facts;
	field.index = 0;
	return IrSpec.new(receiver, [receiver], field);
}

def makeIrMethod(receiver: Type, typeArgs: TypeArgs, paramTypes: Array<Type>, returnType: Type) -> IrSpec {
	var method = IrMethod.new(receiver, typeArgs, Function.siga(paramTypes, returnType));
	method.index = 0;
	return IrSpec.new(receiver, [receiver], method);
}

def testBoundsChecks(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	def size = 9;
	def Z = K(0);
	def R = T.graph.valConst(V3.stringType, T.prog.newRecord(V3.stringType, size));

	def A = ARRAY_ALLOC(K(size));

	T.optimize_bounds = true;

	// negative indices are always out of bounds
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(P, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(P, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(P, K(-1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(Int.MIN_VALUE), Z));

	// Constant record and constant index.
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size+1)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(Int.MAX_VALUE)));

	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(-2)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size+1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(Int.MAX_VALUE)));

	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(-1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size+1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(Int.MAX_VALUE), Z));

	// Constant record and constant index, in bounds.
	for (i < size) {
		T.assertFact(Fact.O_KILLED, BOUNDS_CHECK(R, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(R, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_SET_ELEM(R, K(i), Z));
	}

	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size), Z));

	for (i < size) {
		T.assertFact(Fact.O_KILLED, BOUNDS_CHECK(A, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(A, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_SET_ELEM(A, K(i), Z));
	}

	// Test bounds checks using range analysis from the types.
	for (log: byte = 1; log < 4; log++) {
		var size = 1 << log, ut = Int.getType(false, log);
		def r = T.prog.newRecord(V3.stringType, size);
		def R = T.graph.recordConst(r);
		def P = PARAM(ut);
		T.assertFact(Facts.O_SAFE_BOUNDS, BOUNDS_CHECK(R, P));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(R, P));
	}

	// Test bounds checks using range analysis from {x & mask}.
	for (log: byte = 1; log < 4; log++) {
		var size = 1 << log, mask = size - 1;
		def r = T.prog.newRecord(V3.stringType, size);
		def R = T.graph.recordConst(r);
		T.assertFact(Facts.O_SAFE_BOUNDS, BOUNDS_CHECK(R, INT32_AND(P, K(mask))));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(R, INT32_AND(K(mask), P)));
	}
}

def testNullChecks(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	def size = 9;
	def A = ARRAY_ALLOC(K(size));

	T.optimize_bounds = true;

	def instrs = [
		BOUNDS_CHECK(_, K(0)),
		ARRAY_GET_ELEM(_, K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		CLASS_GET_FIELD(_),
		CLASS_SET_FIELD(_, K(0))
	];

	def N = T.graph.nullConst(V3.stringType);
	def R = T.graph.valConst(V3.stringType, T.prog.newRecord(V3.stringType, size));
	def Z = PARAM(V3.stringType);
	Z.facts |= Fact.V_ZERO;
	def NZ = PARAM(V3.stringType);
	NZ.facts |= Fact.V_NON_ZERO;

	for (f in instrs) {
		// null always throws.
		T.assertThrow(V3Exception.NullCheck, f(N));
		// null always throws.
		T.assertThrow(V3Exception.NullCheck, f(Z));
		// no null check for non-zero
		T.assertFact(Fact.O_NO_NULL_CHECK, f(NZ));
		// no null check for non-zero
		T.assertFact(Fact.O_NO_NULL_CHECK, f(R));
		// no null check for non-zero
		T.assertFact(Fact.O_NO_NULL_CHECK, f(A));
	}
}

def testFlowSensitiveNullChecks(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	def R = T.prog.newRecord(V3.stringType, 4);

//	T.optimize_bounds = true; // TODO

	def instrs = [
		BOUNDS_CHECK(_, K(0)),
		ARRAY_GET_ELEM(_, K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		CLASS_GET_FIELD(_),
		CLASS_SET_FIELD(_, K(0))
	];

	for (on in [false, true]) {
		T.optimize_nullchecks = on;
		for (f in instrs) {
			var i = f(P), j = f(P);
			var block = T.newBlock([i, j]);
			T.optB(block);
			T.assertBlock(block, [i, j]);
			T.t.assert_eq(false, i.facts.O_NO_NULL_CHECK);
			T.t.assert_eq(on,    j.facts.O_NO_NULL_CHECK);
		}
	}
}

def testLoadElimination(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def P2 = PARAM(Int.TYPE);
	def K = T.graph.intConst;

	def getClass = unop(V3Op.newClassGetField(IMM_FIELD), _);
	def setClass = binop(V3Op.newClassSetField(IMM_FIELD), _, _);
	def initClass = binop(V3Op.newClassInitField(IMM_FIELD), _, _);
	def getComp = unop(V3Op.newComponentGetField(IMM_FIELD), _);
	def setComp = binop(V3Op.newComponentSetField(IMM_FIELD), _, _);

	for (on in [false, true]) {
		// load of the same field from the same object
		T.optimize_loads = on;
		var ia = [setClass, initClass, setComp, setComp];
		var ja = [getClass, getClass, getComp, ARRAY_GET_LENGTH];
		for (kind < 4) {
			var i = ja[kind](P);
			var j = ja[kind](P);
			var k = INT32_ADD(i, j);
			var block = T.newBlock([i, j, k]);
			var before = i.facts.O_NO_NULL_CHECK;
			T.optB(block);
			T.t.assert_eq(before, i.facts.O_NO_NULL_CHECK);
			if (on) {
				T.assertBlock(block, [i, k]);
				T.assertShape(INT32_ADD(i, i), k);
			} else {
				T.assertBlock(block, [i, j, k]);
			}
		}
		// load-store-forwarding
		T.optimize_loads = on;
		for (kind < 3) {
			var i = ia[kind](P, P2);
			var j = ja[kind](P);
			var k = INT32_ADD(j, K(2));
			var block = T.newBlock([i, j, k]);
			var before = i.facts.O_NO_NULL_CHECK;
			T.optB(block);
			T.t.assert_eq(before, i.facts.O_NO_NULL_CHECK);
			if (on) {
				T.assertBlock(block, [i, k]);
				T.assertShape(INT32_ADD(P2, K(2)), k);
			} else {
				T.assertBlock(block, [i, j, k]);
			}
		}
	}

	{
		// negative test; load P.f and P2.f
		T.optimize_loads = true;
		var i = getClass(P), j = getClass(P2), k = INT32_ADD(i, j);
		var block = T.newBlock([i, j, k]);
		T.optB(block);
		T.t.assert_eq(false, i.facts.O_NO_NULL_CHECK);
		T.assertBlock(block, [i, j, k]);
		T.assertShape(INT32_ADD(i, j), k);
	}
	{
		// immutable fields
		def R = T.recordConst(V3.stringType, [
			Int.box(11),
			Int.box(12),
			Int.box(13)
		]);
		for (i < 3) {
			def f = makeIrField(TEST_CLASS_TYPE, Int.TYPE, Fact.F_VALUE);
			f.member.index = i;
			T.assertIK(11 + i, unop(V3Op.newClassGetField(f), R));
		}
	}
}

def testClassOps(T: SsaInstrReducerTester) {
	// TODO
	def P = T.graph.params[0];
	def P2 = PARAM(Int.TYPE);
	def K = T.graph.intConst;

	def get = unop(V3Op.newClassGetField(IMM_FIELD), _);

}

def testComponentOps(T: SsaInstrReducerTester) {
	// TODO
	def P = T.graph.params[0];
	def K = T.graph.intConst;
	def lit = Literal.new(null, Int.box(55), Int.TYPE);
	def token = Token.new("<internal>", "f", 1, 1);

	for (islong in [false, true]) {
		def f = makeIrField(TEST_CLASS_TYPE, if(islong, Long.TYPE, Int.TYPE), Fact.F_VALUE);
		for (writability in [Writability.READ_ONLY, Writability.PRIVATE_WRITEABLE, Writability.WRITEABLE]) {
			f.asField().source = VstField.new(false, writability, token, null, lit, null);
			var instr = unop(V3Op.newComponentGetField(f), P);
			if (writability != Writability.READ_ONLY) {
				T.assertNo(    instr);
			} else if (islong) {
				T.assertLK(55, instr);
			} else {
				T.assertIK(55, instr);
			}
		}
	}
}

def testTupleOps(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.intConst;

	// test fold of TupleCreate
	T.assertNo(TUPLE_CREATE([K(0), P]));
	T.assertNo(TUPLE_CREATE([P, K(0)]));
	T.assertTK([], TUPLE_CREATE([]));
	T.assertTK([Int.box(11)], TUPLE_CREATE([K(11)]));
	T.assertTK([Int.box(11), Int.box(12)], TUPLE_CREATE([K(11), K(12)]));
	T.assertTK([Int.box(11), Int.box(12), Int.box(-1333)], TUPLE_CREATE([K(11), K(12), K(-1333)]));

	// test fold of TupleGetElem
	var tupleType = newTupleType(3);
	def P1 = PARAM(tupleType);
	T.assertNo(TUPLE_GET_ELEM(0, P1));
	T.assertNo(TUPLE_GET_ELEM(1, P1));
	T.assertNo(TUPLE_GET_ELEM(2, P1));
	def R = T.tupleConst(tupleType, [
		Int.box(33),
		Int.box(66),
		Int.box(99)
	]);
	T.assertIK(33, TUPLE_GET_ELEM(0, R));
	T.assertIK(66, TUPLE_GET_ELEM(1, R));
	T.assertIK(99, TUPLE_GET_ELEM(2, R));

	T.assertId(P,   TUPLE_GET_ELEM(0, TUPLE_CREATE([P, K(1), K(2)])));
	T.assertIK(109, TUPLE_GET_ELEM(1, TUPLE_CREATE([P, K(109), K(207)])));
	T.assertIK(313, TUPLE_GET_ELEM(2, TUPLE_CREATE([P, K(-99), K(313)])));
}
def newComponentType(name: string) -> Type {
	def token = Token.new("<internal>", name, 1, 1);
	def decl = VstComponent.new(false, false, null, token, null);
	def typecon = V3Component_TypeCon.new(decl, TypeCache.new());
	return typecon.create0();
}

def newClassType(name: string, superType: Type) -> ClassType {
	def token = Token.new("<internal>", name, 1, 1);
	var tref = if(superType != null, TypeUtil.typeRefOf(superType));
	def decl = VstClass.new(false, token, null, null, tref, null, null);
	def typecon = V3Class_TypeCon.new(decl, TypeCache.new());
	return ClassType.!(typecon.create0());
}

def testClosureOps(T: SsaInstrReducerTester) {
	def ftype = Function.newType(Int.TYPE, Int.TYPE);
	def K = T.graph.intConst;

	{  // component methods
		def compType = newComponentType("comp");
		def m2 = makeIrMethod(compType, null, [Int.TYPE], Int.TYPE);
		def M2 = T.graph.valConst(ftype, Closure.new(null, m2));
		def R = T.graph.nullReceiver();
		T.assertEq(CALL_METHOD(m2, [R, K(24)]), CALL_CLOSURE(ftype, [M2, K(24)]));
		T.assertEq(CALL_METHOD(m2, [R, K(25)]), CALL_CLOSURE(ftype, [CREATE_CLOSURE(m2, ftype, K(44)), K(25)]));
		T.assertEq(CALL_METHOD(m2, [R, K(26)]), CALL_CLOSURE(ftype, [CREATE_CLOSURE(m2, ftype, R), K(26)]));
	}

	{  // class methods
		def classType = newClassType("claz", null);
		def m2 = makeIrMethod(classType, null, [Int.TYPE], Int.TYPE);
		var receiver1 = T.prog.newRecord(classType, 0);
		var receiver2 = T.prog.newRecord(classType, 0);
		var R1 = T.graph.valConst(classType, receiver1);
		var R2 = T.graph.valConst(classType, receiver2);
		def M2 = T.graph.valConst(ftype, Closure.new(receiver1, m2));
		T.assertEq(CALL_METHOD(m2, [R1, K(24)]), CALL_CLOSURE(ftype, [M2, K(24)]));
		T.assertEq(CALL_METHOD(m2, [R2, K(25)]), CALL_CLOSURE(ftype, [CLASS_GET_METHOD(m2, R2), K(25)]));
		def P = SsaParam.new(1, classType);
		T.assertEq(CALL_CLASS_VIRTUAL(m2, [P, K(99)]), CALL_CLOSURE(ftype, [CLASS_GET_VIRTUAL(m2, P), K(99)]));
		T.assertEq(CALL_METHOD(m2, [K(29), K(26)]), CALL_CLOSURE(ftype, [CREATE_CLOSURE(m2, ftype, K(29)), K(26)]));
	}
}

def testVariantOps(T: SsaInstrReducerTester) {
	def V = SsaGraphBuildingHelper.newVariantType("V", 3);
	def P = SsaParam.new(0, V);
	def N = T.graph.nullConst(V);
	def ftype = Function.newType(Int.TYPE, Int.TYPE);
	def K = T.graph.intConst;

	T.assertNo( VARIANT_GET_TAG(V, P));
	T.assertIK(0, VARIANT_GET_TAG(V, N));

	{  // call method
		def m2 = makeIrMethod(V, null, [Int.TYPE], Int.TYPE);
		var receiver1 = T.prog.newRecord(V, 1);
		receiver1.values[0] = Int.box(11);
		var receiver2 = T.prog.newRecord(V, 1);
		receiver2.values[0] = Int.box(13);
		def M2 = T.graph.valConst(ftype, Closure.new(receiver1, m2));
		var R1 = T.graph.valConst(V, receiver1);
		var R2 = T.graph.valConst(V, receiver2);

		T.assertEq(CALL_METHOD(m2, [R1, K(24)]), CALL_CLOSURE(ftype, [M2, K(24)]));
		T.assertEq(CALL_METHOD(m2, [R2, K(25)]), CALL_CLOSURE(ftype, [CLASS_GET_METHOD(m2, R2), K(25)]));
		T.assertFact(Fact.O_NO_NULL_CHECK, CALL_METHOD(m2, [K(24)]));

		T.assertEq(CALL_CLASS_VIRTUAL(m2, [P, K(99)]), CALL_CLOSURE(ftype, [CLASS_GET_VIRTUAL(m2, P), K(99)]));
		T.assertEq(CALL_METHOD(m2, [R1, K(26)]), CALL_CLOSURE(ftype, [CREATE_CLOSURE(m2, ftype, R1), K(26)]));
		T.assertFact(Fact.O_NO_NULL_CHECK, CALL_CLASS_VIRTUAL(m2, [R2]));
	}
}

def testConditionalThrow(T: SsaInstrReducerTester) {
	def P = T.graph.params[0];
	def K = T.graph.boolConst;

	T.assertNo(CONDITIONAL_THROW(V3Exception.BoundsCheck, P));
	T.assertThrow(V3Exception.BoundsCheck, CONDITIONAL_THROW(V3Exception.BoundsCheck, K(true)));
	T.assertFact(Fact.O_KILLED,  CONDITIONAL_THROW(V3Exception.BoundsCheck, K(false)));
}

def INT_CONVERT(ft: IntType, tt: IntType, x: SsaInstr) -> SsaInstr {
	return unop(V3Op.newIntViewI(ft, tt), x);
}

def testIntBounds(T: SsaInstrReducerTester) {
	def K = T.graph.intConst;
	def P = T.graph.params[0];
	def X = SsaInstrReducer.new(T.context);
	def bound = X.posIntBound;

	def STYPE = Int.getType(true, _);
	def UTYPE = Int.getType(false, _);

	T.t.assert_eq(-1, bound(K(-1)));
	T.t.assert_eq(-2, bound(K(-2)));
	T.t.assert_eq(Int.MIN_VALUE, bound(K(Int.MIN_VALUE)));

	T.t.assert_eq(0, bound(K(0)));
	T.t.assert_eq(1, bound(K(1)));
	T.t.assert_eq(255, bound(K(255)));
	T.t.assert_eq(44444, bound(K(44444)));
	T.t.assert_eq(Int.MAX_VALUE, bound(K(Int.MAX_VALUE)));

	T.t.assert_eq(255, bound(PARAM(Byte.TYPE)));
	T.t.assert_eq(255, bound(INT_CONVERT(Byte.TYPE, Int.TYPE, PARAM(Byte.TYPE))));

	for (t in [	UTYPE(1),
			UTYPE(2),
			UTYPE(3),
			UTYPE(8),
			UTYPE(16),
			UTYPE(31)	]) {
		var max = Int.unbox(t.max);
		var Q = PARAM(t);
		T.t.assert_eq(max, X.posIntBoundFromType(Q));
		T.t.assert_eq(max, bound(Q));
		T.t.assert_eq(max, bound(INT_CONVERT(t, Int.TYPE, Q)));
	}

	for (t in [	STYPE(1),
			STYPE(5),
			STYPE(16),
			STYPE(31),
			UTYPE(33),
			STYPE(35)	]) {
		var P = PARAM(t);
		T.t.assert_eq(-1, X.posIntBoundFromType(P));
		T.t.assert_eq(-1, bound(P));
	}

	for (k in [1, 3, 5, 7, 255, 511, 65535, Int.MAX_VALUE]) {
		T.t.assert_eq(k, bound(INT32_AND(P, K(k))));
		T.t.assert_eq(k, bound(INT32_AND(K(k), P)));
	}

	def i5_t = STYPE(5), u5_t = UTYPE(5);
	def i6_t = STYPE(6), u6_t = UTYPE(6);

	// Test overflow cases for unsigned -> signed conversions.
	T.t.assert_eq(-1, bound(INT_CONVERT(u5_t, i5_t, PARAM(u5_t))));
	T.t.assert_eq(-1, bound(INT_CONVERT(u6_t, i5_t, PARAM(u6_t))));

	T.t.assert_eq(31, bound(INT_CONVERT(i5_t, u5_t, PARAM(i5_t))));
	T.t.assert_eq(63, bound(INT_CONVERT(i5_t, u6_t, PARAM(i5_t))));

	T.t.assert_eq(31, bound(INT_CONVERT(u5_t, i6_t, PARAM(u5_t))));
}

def testIf(T: SsaInstrReducerTester) {
	for (b in [true, false]) {
		def T = SsaInstrReducerTester.new(T.t);
		def K = T.graph.boolConst;
		def IK = T.graph.intConst;
		def P = T.graph.params[0];

		def d1 = Diamond.new(T.graph.startBlock, K(b));
		def phi = d1.phi(Int.TYPE, IK(1), IK(2));
		def add = INT32_ADD(phi, IK(3));
		def ret = SsaReturn.new([add]);
		d1.merge.append(add);
		d1.merge.append(ret);

		T.optB(d1.top);

		T.assertShape(INT32_ADD(if(b, IK(1), IK(2)), IK(3)), add);

		def ret2 = d1.top.end();
		if (!SsaReturn.?(ret2)) T.t.fail("expected return");
		var expected = if(b, 4, 5);
		T.assertShape(IK(expected), ret2.input0());  // add should be folded

		T.assertBlock(d1.top, [ret2]);
	}
}

def PHI(x: SsaInstr) -> SsaPhi {
	return SsaPhi.new(Int.TYPE, null, [x]);
}

def PHIN(x: Array<SsaInstr>) -> SsaPhi {
	return SsaPhi.new(Int.TYPE, null, x);
}

def testPhis(T: SsaInstrReducerTester) {
	def K = T.graph.intConst;
	def P = T.graph.params[0];

	T.assertId(P, PHI(P));
	T.assertId(P, PHIN([P, P]));
	T.assertId(P, PHIN([P, P, P]));
	T.assertNo(   PHIN([K(0), P, P]));
	T.assertNo(   PHIN([P, K(0), P]));
	T.assertNo(   PHIN([P, P, K(0)]));

	def N = SsaParam.new(1, Int.TYPE);
	P.facts = Fact.V_NON_NEGATIVE;
	N.facts = Fact.V_NON_NEGATIVE;
	T.assertFact(Fact.V_NON_NEGATIVE, PHIN([P, N]));
}

def testSwitch(T: SsaInstrReducerTester) {
	def size = 10;
	for (index = -2; index < size + 3; index++) {
		def T = SsaInstrReducerTester.new(T.t);
		def K = T.graph.intConst;
		def P = T.graph.params[0];

		def top = T.graph.startBlock;
		def sw = SsaSwitch.new(Int.TYPE, size - 2, K(index));
		top.append(sw);

		def blocks = Array<SsaBlock>.new(size);
		def merge = SsaBlock.new();
		def inputs = Array<SsaInstr>.new(size);
		for (i < size) {
			def b = SsaBlock.new();
			blocks[i] = b;
			sw.succs[i].connect(b);
			b.append(SsaGoto.new(merge));
			inputs[i] = K(i);
		}
		def phi = SsaPhi.new(Int.TYPE, merge, inputs);
		merge.prepend(phi);

		merge.append(SsaReturn.new([phi]));

//		var p = SsaPrinter.new();
//		p.buf.puts("Before:\n");
//		p.printBlock(top);
//		for (b in blocks) p.printBlock(b);
//		p.printBlock(merge);
//		p.flush();

		T.optB(top);
//		p.buf.puts("After:\n");
//		p.printBlock(top);
//		p.flush();

		def ret2 = top.end();
		if (!SsaReturn.?(ret2)) T.t.fail("expected return");
		var expected = if(index < 0 || index > sw.maxValue, size - 1, index);
		T.assertShape(K(expected), ret2.input0());

		T.assertBlock(top, [ret2]);
	}

}
