def TEST = UnitTest.new("MachStackifierTest", test);
def test() {
//	Aeneas.PRINT_STACKIFY.val = true;
//	Aeneas.PRINT_MACH.val = true;
	testAplusB();
	test3();
}

// Opcodes for instructions used in this test
def ARCH_OP = 1;
def ARCH_LOAD = 3;
def ARCH_STORE = 4;
def ARCH_POP = 5;
def ARCH_CONST = 6;

def prog = Program.new();
def global_context = SsaContext.new(null, prog);

class Generator extends ArchCodeGen {
	def p0 = SsaParam.new(0, Int.TYPE);
	def p1 = SsaParam.new(1, Int.TYPE);
	new() super(global_context, MachProgram.new(Program.new(), AddressSpaces.MEM32LE, AddressSpaces.MEM32LE, null), null, null) {
		var graph = SsaGraph.new([p0, p1], Int.TYPE);
		reset(graph, null, null);
		cursor = ArchInstr.new(ArchInstrs.ARCH_END, ArchInstrs.NO_OPERANDS);
		context.block = SsaBlock.new();
		context.block.mark = 0;
		context.graph = graph;
		for (p in [p0, p1]) getVreg(p);
	}
	def op1(d: VReg, a: VReg) {
		emit2(ARCH_OP, dfnv(d), usev(a));
	}
	def op2(d: VReg, a: VReg, b: VReg) {
		emit3(ARCH_OP, dfnv(d), usev(a), usev(b));
	}
	def op3(d: VReg, a: VReg, b: VReg, c: VReg) {
		dfnv(d); usev(a); usev(b); usev(c);
		emitN(ARCH_OP);
	}
	def finish() {
		advanceCursor();
		emit0(ArchInstrs.ARCH_END);
		advanceCursor();
	}
	def stackify() {
		var first = cursor, last = cursor;
		while (last.next != null) last = last.next;
		def s = MachStackifier.new(this);
		s.printInstr = printInstrV;
		s.stackify(0, first, last, false);
		while (first.prev != null) first = first.prev;
		cursor = first;
	}
	def run() {
		Interpreter.new().run(this);
	}
	def test() {
		finish();
		stackify();
		run();
	}
	def renderSpecific(indent: int, opcode: int, a: Array<Operand>) -> (int, bool) {
		var name = WasmOpNames.array[opcode];
		match (opcode) {
			ARCH_OP => out.puts("op ");
			ARCH_LOAD => out.puts("load ");
			ARCH_STORE => out.puts("store ");
			ARCH_POP => out.puts("pop ");
			ARCH_CONST => out.puts("const ");
			_ => return (indent, false);
		}
		out.putOperands(a);
		return (indent, true);
	}
	def genLoadLocal(v: VReg) {
		emit1(ARCH_LOAD, usev(v));
	}
	def genStoreLocal(v: VReg, pop: bool) {
		emit1(ARCH_STORE, dfnv(v));
	}
	def genPop(v: VReg) {
		emit0(ARCH_POP);
	}
	def genLoadConst(t: Type, val: Val) { }
}

class Interpreter {
	def stack = Vector<VReg>.new();
	def run(g: Generator) {
		stack.length = 0;
		var first = g.cursor, out = g.out, printInstr = g.printInstrV;
		if (out != null) {
			out.puts("running...");
			out.outln();
		}
		for (i = first; i != null; i = i.next) {
			if (out != null) {
				out.putc('|');
				for (j < stack.length) {
					out.putc('v').put1(stack[j].varNum);
				}
				out.puts("| ");
				printInstr(i);
			}
			var ops = ArchInstrs.NO_OPERANDS;
			match (int.!(i.opcode())) {
				ARCH_POP => pop(null);
				ARCH_LOAD => {
					var vreg = Operand.Use.!(i.operands[0]).vreg;
					stack.add(vreg);
					continue;
				}
				ARCH_STORE => {
					var vreg = Operand.Def.!(i.operands[0]).vreg;
					pop(vreg);
					continue;
				}
				_ => ops = i.operands;
			}
			for (j = ops.length - 1; j >= 0; j--) {
				match (ops[j]) {
					Def(ssa, vreg, constraint) => {
						stack.add(vreg);
					}
					Use(ssa, vreg, constraint) => {
						pop(vreg);
					}
					_ => ;
				}
				
			}
		}
	}
	def pop(expect: VReg) {
		if (stack.length == 0) return V3.fail("empty stack");
		var top = stack[stack.length-1];
		stack.length--;
		if (expect != null && top != expect) return V3.fail1("expected v%1", expect.varNum);
	}
}

def testAplusB() {
	def g = Generator.new();
	def p0 = g.getVreg(g.p0), p1 = g.getVreg(g.p1), x = g.newVreg(null), y = g.newVreg(null), z = g.newVreg(null);
	g.op2(x, p0, p1);
	g.op2(y, p0, x);
	g.op2(z, p0, x);
	g.test();
}

def test3() {
	def i1 = [0, 1];
	def i2 = [0, 2];
	def i3 = [0, 2, 3];

	for (i1a in i1) for (i1b in i1) 
	for (i2a in i2) for (i2b in i2) 
	for (i3a in i3) for (i3b in i3) {
		def g = Generator.new();
		var x: VReg, y: VReg, z: VReg;
		def inputs = [g.getVreg(g.p0), g.getVreg(g.p1), x = g.newVreg(null), y = g.newVreg(null), z = g.newVreg(null)];
		g.op2(x, inputs[i1a], inputs[i1b]);
		g.op2(y, inputs[i2a], inputs[i2b]);
		g.op2(z, inputs[i3a], inputs[i3b]);
		g.test();
	}
}
