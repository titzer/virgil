// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("packing:", _, VariantSolverTester.new, _);
def X = [
    T("simple", test_simple),
    T("unify", test_unify)
];
def VERBOSE = false;

def makeNormConfig(usedScalars: Scalar.set, getScalar: Type -> Scalar.set, getBitWidth: Type -> byte) -> NormalizerConfig {
    var nc = NormalizerConfig.new();
    nc.UsedScalars = usedScalars;
    if (getScalar != null) nc.GetScalar = getScalar;
    if (getBitWidth != null) nc.GetBitWidth = getBitWidth;
    return nc;
}

class VariantSolverTester(t: Tester) {
    var solver: VariantSolver;
	def useSolver(s: VariantSolver) { solver = s; }

	def assert_solvable(p: VariantProblem) -> VariantSolution {
		var s = trySolve(p);
		if (s == null) t.fail(Strings.format1("%q: expected solution, no solution found", p.render));
		else verifyValidity(p, s);
		return s;
	}
	def assert_solvable_with_size(p: VariantProblem, size: byte) -> VariantSolution {
		var s = assert_solvable(p);
		if (s == null) return s;
		if (s.size() > size) t.fail(Strings.format3("%q: expected solution with size <= %d, found solution %q", p.render, size, s.render));
		return s;
	}
	def assert_unsolvable(p: VariantProblem) {
		var s = trySolve(p);
		if (s != null) t.fail(Strings.format2("%q: expected no solution, found solution %q", p.render, s.render));
	}
	def assert_unsolvable_with_size(p: VariantProblem, size: byte) {
		var s = trySolve(p);
		if (s != null && s.size() <= size) t.fail(Strings.format3("%q: expected unsolvable with size <= %d, found solution %q", p.render, size, s.render));;
	}
	private def trySolve(problem: VariantProblem) -> VariantSolution {
		var solution = solver.solve(problem);
		if (VERBOSE) Terminal.put2("%q => %q\n", problem.render, printSolution(_, solution));
		return solution;
	}
	private def printSolution(sb: StringBuilder, solution: VariantSolution) -> StringBuilder {
		if (solution == null) return sb.puts("no solution found");
		else return solution.render(sb);
	}
	private def verifyValidity(p: VariantProblem, s: VariantSolution) {
		var normFields = p.normFields;
		for (cf = Maps.keyList(p.assignments); cf != null; cf = cf.tail) {
			if (s.assignments[cf.head] != p.assignments[cf.head]) t.fail(Strings.format1("%q: specified assignment not obeyed", p.render));
		}
		for (i < normFields.length) {
			for (j < normFields[i].length) {
				var cf = CaseField(i, j);
				if (!s.assignments.has(cf)) t.fail(Strings.format1("%q: missing assignment", p.render));
			}
		}
	}
}

def getScalar_noUnify(t: Type) -> Scalar.set {
	match (t) {
		x: IntType => return if(x.width <= 32, Scalar.B64, Scalar.B32);
		x: FloatType => return if(x.is64, Scalar.F64, Scalar.F32);
		x: BoolType => return Scalar.B32;
		_ => return Scalar.Ref;
	}
}
def test_simple(t: VariantSolverTester) {
    var nc = makeNormConfig(Scalar.B32, getScalar_noUnify, null), p: VariantProblem;
    t.useSolver(VariantSolver.new(nc));

    p = VariantProblem.new([], [], false);
    t.assert_solvable_with_size(p, 0);

    p = VariantProblem.new([[Int.TYPE]], null, false);
    t.assert_solvable_with_size(p, 1);

    p = VariantProblem.new([[Float.FLOAT32]], null, false);
    t.assert_solvable_with_size(p, 1);

    p = VariantProblem.new([[Int.TYPE], [Int.TYPE]], null, false);
    t.assert_unsolvable_with_size(p, 1);
    t.assert_solvable_with_size(p, 2);

    p = VariantProblem.new([[Int.TYPE], [Int.TYPE], [Int.TYPE]], null, false);
    t.assert_unsolvable_with_size(p, 1);
    t.assert_solvable_with_size(p, 2);

    p = VariantProblem.new([[Int.TYPE], [Float.FLOAT32]], null, false);
    t.assert_unsolvable_with_size(p, 2);
    t.assert_solvable_with_size(p, 3);
}

def getScalar_unify0(t: Type) -> Scalar.set {
	match (t) {
		x: IntType => return if(x.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64);
		x: FloatType => return if(x.is64, Scalar.F64 | Scalar.B32, Scalar.F32 | Scalar.B32);
		x: BoolType => return Scalar.B32 | Scalar.B64 | Scalar.F32 | Scalar.F64;
		_ => return Scalar.Ref;
	}
}
def test_unify(t: VariantSolverTester) {
	var nc = makeNormConfig(Scalar.B32 | Scalar.F32, getScalar_unify0, null), p: VariantProblem;
	t.useSolver(VariantSolver.new(nc));

	p = VariantProblem.new([[Int.TYPE], [Float.FLOAT32]], null, false);
	t.assert_unsolvable_with_size(p, 1);
    t.assert_solvable_with_size(p, 2);

    p = VariantProblem.new([[Int.TYPE], [Float.FLOAT64]], null, false);
    t.assert_unsolvable_with_size(p, 2);
    t.assert_solvable_with_size(p, 3);
}
