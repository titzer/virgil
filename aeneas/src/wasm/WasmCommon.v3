// Copyright 2016-2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Definitions used by both the Wasm and WasmGc back-ends

component WasmCommon {
	def WASM_MAGIC = 0x6d736100;
	def WASM_VERSION = 0x1;

	// See WasmSectionBuffer, below
	def patchSize(w: MachDataWriter, offset: int, size: int) {
		w.at(offset).overwrite_uleb32(size).atEnd();
	}

	def MINIMUM_DATA_START_ADDR = 8u32;
	def MAXIMUM_DATA_START_ADDR = 0x8000_0000u32;

	def SPACE = AddressSpace.new("mem", false, 32, 4, Alignment.new(65536), Alignment.new(4));
}
// Constants for the binary encoding of sections
enum WasmSection(code: byte) {
	UNKNOWN(0),	// code for unknown sections
	TYPE(1),	// Function signature declarations
	IMPORT(2),	// Import declarations
	FUNCTION(3),	// Function declarations
	TABLE(4),	// Indirect function table and other tables
	MEMORY(5),	// Memory attributes
	GLOBAL(6),	// Global declarations
	EXPORT(7),	// Exports
	START(8),	// Start function declaration
	ELEMENT(9),	// Elements section
	CODE(10),	// Function code
	DATA(11),	// Data segments
	NAME(12)	// Name section (encoded as a string)
}

// Constants for the binary encodings of import/export kinds
component WasmExternal {
	def FUNCTION: byte = 0;
	def TABLE: byte = 1;
	def MEMORY: byte = 2;
	def GLOBAL: byte = 3;
}
// A helper to emit properly-sized sections
class WasmSectionBuffer extends MachDataWriter {
	var sizepos = -1;
	var start = -1;
	new(pageAlign: Alignment, initialSize: int) super(pageAlign, 0, initialSize) {
	}
	def startSection(code: byte) {
		if (sizepos >= 0) return V3.fail("unterminated section");
		atEnd();
		putb(code);
		sizepos = skip_leb32();
		start = pos;
	}
	def endSection() {
		atEnd();
		if (sizepos < 0) return V3.fail("unstarted section");
		WasmCommon.patchSize(this, sizepos, pos - start);
		sizepos = -1;
		start = -1;
	}
	def str(str: string) -> this {
		// TODO: properly utf-8 encode Wasm strings (import/export,debug)
		put_sleb32(str.length);
		puta(str);
	}
	def importName(s: string) -> this {
		if (s.length > 0 && s[0] == '\"') s = Strings.parseLiteral(s, 0).1; // XXX: reparsing literal
		str(s);
	}
}
