// Copyright 2016-2025 Virgil authors.  All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// TODO(wasm): codegen system ops
// TODO(wasm): stacktrace reconstruction
// XXX(wasm): improve cfg optimizer
// XXX(wasm): default init of locals

component WasmGcComponent {
	new() {
		Aeneas.registerTarget(WasmGcTarget.new("wasm-gc-test", true));
		Aeneas.registerTarget(WasmGcTarget.new("wasm-gc", false));
	}

	def isDefaultValue(v: Val) -> bool {
		if (v == null) return true;
		match (v) {
			x: Float32Val => { return x.bits == 0; }
			x: Float64Val => { return x.bits == 0; }
			x: Box<int> => { return x.val == 0; }
			x: Box<long> => { return x.val == 0; }
			x: Box<bool> => { return x.val == false; }
			x: Box<byte> => { return x.val == 0; }
			// other cases: only if null, which is already handled
		}
		return false;
	}
}

// Records are (fictionally) placed in one region, numbered 0, 1, 2, ...
def RECORD_SPACE = AddressSpace.new("records", false, 32, 4, Alignment.new(1), Alignment.new(1));
def RECORD_REGION = Region.new("records", RECORD_SPACE);

// Functions are likewise placed in a fictional Region;
// WasmGc manages function numbers itself
def FUNCTIONS_SPACE = AddressSpace.new("functions", false, 32, 4, Alignment.new(1), Alignment.new(1));
def FUNCTIONS_REGION = Region.new("functions", FUNCTIONS_SPACE);	// the "main" table

// information about a dispatch table entry
type DispatchInfo {
	case Abstract(method: IrMethod) {
		// a method with no implementation
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put1("dispatch function abstract method %q", method.render);
		}
	}
	case Absolute(method: IrMethod, funcIndex: u32) {
		// a function known in advance
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put2("dispatch function %d method %q", funcIndex, method.render);
		}
	}
	case Relative(method: IrMethod, adapterIndex: u32) {
		// an adapter, relative to the dispatch adapter base
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put2("dispatch adapter %d method %q", adapterIndex, method.render);
		}
	}
	def render(buf: StringBuilder) -> StringBuilder;
}

type TableKind {
	case Indirect0;
	case Indirect(rootSig: Signature);
	case Dispatch(rootReceiver: Type, rootSig: Signature);
}

// Different kinds of Wasm functions we generate
enum FunctionInfoKind { AllocStub, EntryStub, HeapInit, Method, Indirect, Dispatch }

// For entries in data structures related to outputting functions and tables
class FunctionInfo {
	def kind: FunctionInfoKind;
	def rcvr: Type;
	def sig: Signature;
	def sigIndex: u32;
	def method: IrMethod;
	var funcIndex: int;  // may start -1 and be assigned later
	new(kind, rcvr, sig, sigIndex, method, funcIndex) { }
	def render (sb: StringBuilder) -> StringBuilder {
		var sidx = int.!(sigIndex) - 1;
		match (kind) {
			AllocStub => return sb.put3("Alloc Stub sig: %q  sigidx: %d  func #%d",
						    sig.funcType().render, sidx, funcIndex);
			EntryStub => return sb.put3("Entry Stub sig: %q  sigidx: %d  func #%d",
						    sig.funcType().render, sidx, funcIndex)
					      .put2("  rcvr: %q  main: %q",
						    rcvr.render, method.render);
			HeapInit => return sb.put3("Heap Init sig: %q  sigidx: %d  func #%d",
						   sig.funcType().render, sidx, funcIndex);
			Method => return sb.put3("Method sig: %q  sigidx: %d  func #%d",
						 sig.funcType().render, sidx, funcIndex)
					   .put2("  rcvr: %q  method: %q",
						 rcvr.render, method.render);
			Indirect => return sb.put3("Indirect sig: %q  sigidx: %d  func #%d",
						   sig.funcType().render, sidx, funcIndex)
					     .put2("  rcvr: %q  method: %q",
						   rcvr.render, method.render);
			Dispatch => return sb.put3("Dispatch sig: %q  sigidx: %d  func #%d",
						   sig.funcType().render, sidx, funcIndex)
					     .put2("  rcvr: %q  method: %q",
						   rcvr.render, method.render);
		}
	}
}

// Started from a copy of class WasmTarget
class WasmGcTarget extends Target {
	def test: bool;

	new(name: string, test) super(name) {
		typedMain = !test;
		requireMain = false;
	}

	def configureCompiler(compiler: Compiler) {
		WasmComponent.includeSection = WasmComponent.getSectionFlags(CLOptions.WASMGC_SECTIONS.get());
		WasmComponent.printSection = WasmComponent.getSectionFlags(CLOptions.PRINT_WASMGC.get());

		compiler.Reachability = true;
		compiler.NormConfig.setSignatureLimits(10000, if(CLOptions.WASM_MULTI_VALUE.val, 1000, 1));
		compiler.NormConfig.GetScalar = getScalar;

		// added for WASM-GC
		compiler.NormConfig.MixedArrays = false;
		compiler.NormConfig.ArrayLengthType = Int.getType(true, 32);
		compiler.NormConfig.ArrayIndexType = Int.getType(true, 32);
		compiler.NormConfig.RangeStartType = Int.getType(true, 32);	// 64-bit memories?
		compiler.NormConfig.WrapFuncTypeSubsume = true;
		compiler.NormConfig.AnyRefOverflow = false;
		compiler.NormConfig.ExplicitRefTypeCast = true;
		// compiler.unboxVariantsOpt = false;	// EBM: can't change it here
		// compiler.DisableBoundsChecks = true;	// leave since there can be residual checks
		// compiler.DisableNullChecks = true;	// EBM: look into this
		// compiler.DisableLengthChecks = true;	// EBM: look into this
	}
	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {
		match (t) {
			x: EnumType => return if(x.enumDecl.tagType.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R32, once packed refs
			x: EnumSetType => return if(x.repType.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R32, once packed refs
			x: BoolType => return Scalar.B32;
			x: IntType => return if(x.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64);
			x: FloatType => return if(x.is64, Scalar.F64 | Scalar.B64, Scalar.F32 | Scalar.B32);
			// EBM: concerned about too many things matching the default ...
			// EBM: e.g., what about VoidType?
			_ => return Scalar.Ref;
		}
	}
	def configureProgram(prog: Program) {
		def intNorm = IntNormalizers.I64LE;
		var mach = MachProgram.new(prog, FUNCTIONS_SPACE, RECORD_SPACE, intNorm);
		prog.tprog = mach;
		MachModule.install(prog, mach);
		mach.runtime = MachRuntime.new(mach);
		// EBM: Note that Pointer use is somewhat limited on WasmGc (these restrictions are
		// not all set up yet)
		// - atContents and atElement work only on off heap ranges (give bounds trap otherwise)
		// - atObject is prohibited
		// - atField works on on off heap Refs
		var cirt = CiRuntime_TypeCon.new(MachModule.PTR_32.create0(), prog.typeCache);
		prog.typeEnv.add(cirt);
	}
	def emit(compiler: Compiler, prog: Program) {
		var context = SsaContext.new(compiler, prog);
		var rt = getRuntime(prog);
		var e: ExecuteTestCase;
		if (test) {
			e = SpecParser.parseFile(prog.ERROR, prog.files[0], prog.inputs[0]);
			rt.heapSize = e.heapSize;
		}
		var w = emitWasmModule(context, rt);
		if (test) emitTestWrappers(context, rt, w, e);
		if (CLOptions.WASM_RUN_COMMAND.val != null) emitEngineScript(CLOptions.WASM_RUN_COMMAND.val, compiler, prog);
	}
	def emitWasmModule(context: SsaContext, rt: MachRuntime) -> DataWriter {
		def pageSize = CLOptions.WASM_PAGE_SIZE.get();
		if (!Ints.isPowerOf2(pageSize)) context.fail1("expected -wasm.page-size option to be a power of 2, got %d", pageSize);

		var dataStartAddrOption = CLOptions.DATA_START_ADDR.get();
		if (dataStartAddrOption > WasmCommon.MAXIMUM_DATA_START_ADDR) context.fail1("-data-start-addr too large for Wasm target, got 0x%x", dataStartAddrOption);
		def dataStartAddr = if(dataStartAddrOption < WasmCommon.MINIMUM_DATA_START_ADDR,
				       WasmCommon.MINIMUM_DATA_START_ADDR,
				       u32.view(dataStartAddrOption));

		def prog = context.prog;

		def wasm = WasmGcProgram.new(rt.mach, context, test);

		// Lower to machine level from V3 level
		def config = MachLoweringConfig.new();
		config.MachLoweringFactory = WasmGcLowering.new(wasm, this, _, _, _);
		config.ImplicitNullChecks = true;
		config.ExplicitDivChecks = true;
		config.Int32Arith = true;
		config.Int64Arith = true;
		config.IntCastFTraps = true;
		config.NativeCmpSwp = false;

		// EBM: MachProgram has some useful data structures and functions;
		// build populates things and gets components in the record queue;
		// it runs lowering, though WasmGcLowering handles some ops
		rt.mach.build(context.compiler, config);

		// (0) Populate type table
		//--------------------------------------------------------------------------------
		// This captures most types, though some may be seen only later when going through
		// IR instructions.

		// Go through all of the heap types
		// Note: importantly this processes the classes *first*, so they will be known
		// when going through other things
		if (WasmComponent.printSection.TYPE)
			prog.ERROR.addError(null, null, "Type Section", "========== Adding types from IR ==========");
		AddTypes.addIrTypes(prog.ir, wasm);
		if (WasmComponent.printSection.TYPE)
			prog.ERROR.addError(null, null, "Type Section", "========== Assigning type indices ==========");
		wasm.gcTypeTable.assignTypeIndices();
		// if printing out information, add source strings
		if (WasmComponent.printSection.TYPE) {
			for (i < prog.ir.classes.length) {
				var cls = prog.ir.classes[i];
				var ctype = cls.ctype;
				var name = wasm.getClassName(ctype);
				var wht = wasm.gcTypeTable.heapTypeMap[ctype];
				wht.source = StringBuilder.new().put1("class/type %s", name).extract();
			}
			for (i < prog.ir.methods.length) {
				var m = prog.ir.methods[i];
				var ms = m.source;
				if (ms == null) continue;
				var sig = wasm.getSig(m.receiver, m.sig);
				var wht = wasm.gcTypeTable.addSignature(sig);
				var name = wasm.getMethodName(m);
				wht.source = StringBuilder.new().put1("method %s", name).extract();
			}
		}

		def initialSize = 300;

		// pageAlign does not mean much for WasmGc
		def out = WasmSectionBuffer.new(Alignment.new(1), initialSize);

		// (1) Encode the WASM header
		//--------------------------------------------------------------------------------
		out.put_b32(WasmCommon.WASM_MAGIC);
		out.put_b32(WasmCommon.WASM_VERSION);

		var sizepos: int, start: int;

		// Add the allocation stub if the program might dynamically
		// allocate memory.
		def m = rt.mach;

		// Will get info about each function, in Wasm order
		def functionInfos = Vector<FunctionInfo>.new();

		// Add all the method signatures to the signatures vector and
		// sort the method array.
		// This will include the allocation and entry stubs (if any)
		// and all non-imported functions.
		def methods = wasm.addIrMethods(functionInfos);

		// The work of these MachProgram calls is done in this module
		// since WasmGc has rather different notions about data,
		// addresses, and so on.

		// Build globals and Record info for components
		// Maps Record's id to component and IrClass
		def recordInfo = HashMap<int,IrClass>.new(int.+(_,0), int.==);
		for (i < prog.ir.classes.length) {
			processForComponent(wasm, recordInfo, prog.ir.classes[i]);
		}

		// Build the initial heap
		layoutAllRecordsAndFuncs(wasm, m);
		def compRecords = Vector<Record>.new();  // Record objects for components needing init
		def compRecordSet = HashMap<Record,void>.new(Record.hash, Record.equals);
		def otherRecords = Vector<Record>.new();  // other Record objects
		if (m.recordQueue.length > 0) {
//			for (cr in prog.compRecords) {
//				if (cr != null) {
//				var sb = StringBuilder.new().put2("prog.compRecords element has type %q id %d", cr.rtype.render, cr.id);
//				prog.ERROR.addError(null, null, "====>", sb.extract());
//				}
//			}
			var needInit = false;
			for (i < m.recordQueue.length) {
				var r = m.recordQueue[i];
				var rt = r.rtype;
// EBM XXY go through fields looking for functions that need subsumption adapters


//				var sb = StringBuilder.new().put2("record queue element %d type %q", i, rt.render);
//				prog.ERROR.addError(null, null, "====>", sb.extract());
				if (recordInfo.has(r.id)) {
//					sb.puts("is a component Record");
					if (r.values == null) {
//						sb.puts(" but has no values");
					} else {
						for (v in r.values) {
							if (WasmGcComponent.isDefaultValue(v)) continue;
//							sb.puts(" has a non-default value");
							compRecords.put(r);
							needInit = true;
							break;
						}
					}
				} else {
//					sb.puts("is not a component Record");
					otherRecords.put(r);
					var globalNum = wasm.globalVarsForFields.length + wasm.globalVarsForRecords.length;
					wasm.globalVarForRecord[r] = globalNum;
					var addr = addrOfRecord(m, r);  // may not yet have an Addr
					addr.absolute = globalNum;
					wasm.globalVarsForRecords.put(r);
					needInit = true;
				}
//				prog.ERROR.addError(null, null, "======>", sb.extract());
			}
			if (needInit) {
				// set up to produce heap init function
				var findex = functionInfos.length;
				var sig = Signature.new(null, [], []);
				var sigIdx = wasm.addSig(Void.TYPE, sig);
				functionInfos.put(FunctionInfo.new(FunctionInfoKind.HeapInit, Void.TYPE, sig, sigIdx, null, findex));
				wasm.heapInitFuncIndex = findex;
				wasm.sigIndex_heapInit = int.!(sigIdx);
			}
		}

		m.methodMap.apply(processMethodMapEntry(wasm, _, _));

		// Generate WASM code into the code buffer. Lowering populates
		// the signatures and requests individual indirect adapters,
		// and indirect and dispatch tables, which must happen before
		// these can be emitted.
		def codebuf = MachDataWriter.new(Alignment.new(1), 0, initialSize);

		// Lowering has set up individual indirectly-referenced
		// functions.  These go into table 0.
		def needTable0 = (wasm.indirectAdapterRequests.length > 0) ||
				 (wasm.indirectTableRequests.length > 0) ||
				 wasm.anyCallFunctions;
		def table0Infos: Vector<FunctionInfo> = if(needTable0, Vector<FunctionInfo>.new(), null);
		def tableInfos = Vector<(TableKind, Vector<FunctionInfo>)>.new();
		if (needTable0) tableInfos.put((TableKind.Indirect0, table0Infos));
		def numIndividualIndirectAdapters = wasm.indirectAdapterRequests.length;
		for (i < numIndividualIndirectAdapters) {
			var meth = wasm.indirectAdapterRequests[i];
			var findex = functionInfos.length;
			wasm.indirectAdapterFor[meth] = findex;
			wasm.indirectAdapterIndexFor[meth] = i + 1;  // + 1 to skip the null entry
			wasm.indirectAdapterVector.put(meth);
			var sigIdx = wasm.addSig(AnyRef.TYPE, meth.sig);
			var fi = FunctionInfo.new(FunctionInfoKind.Indirect, AnyRef.TYPE, meth.sig, sigIdx, meth, findex);
			table0Infos.put(fi);
			functionInfos.put(fi);
			if (WasmComponent.printSection.FUNCTION ||
			    WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put1("Adding Adapter %q", fi.render);
				prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
		}
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put2("# of individual indirect adapters = %d, will %semit a table",
							  numIndividualIndirectAdapters, if(needTable0, "", "not "));
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		var nextTableNum = tableInfos.length;

		// Add all the indirect adapter methods from method tables.
		// This also adds their signatures.
//		def firstIndirectTable = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# of indirect tables = %d", wasm.indirectTableRequests.length);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		for (i < wasm.indirectTableRequests.length) {
			var mtable = wasm.indirectTableRequests[i];
			if (WasmComponent.printSection.FUNCTION ||
			    WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Indirect table %d for %q", nextTableNum, mtable.render);
				prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
			wasm.indirectTableBase[mtable] = table0Infos.length + 1;  // account for null entry
			var rootSig: Signature = null;
			for (m in mtable.table) {
				if (m == null) continue;
				if (rootSig == null) rootSig = m.sig;
				if (CLOptions.PRINT_RA.get()) {
					Terminal.buf.put3("Request indirect adapter for mtable for %q.%q{%d}", m.receiver.render, m.render, m.index).outln();
				}
				wasm.requestIndirectAdapter(m);
				var findex = functionInfos.length;
				wasm.indirectAdapterFor[m] = findex;
				var sigIdx = wasm.addSig(AnyRef.TYPE, m.sig);
				var fi = FunctionInfo.new(FunctionInfoKind.Indirect, AnyRef.TYPE, m.sig, sigIdx, m, findex);
				table0Infos.put(fi);
				wasm.indirectAdapterIndexFor[m] = table0Infos.length;
				wasm.indirectAdapterVector.put(m);
				functionInfos.put(fi);
				if (WasmComponent.printSection.FUNCTION ||
				    WasmComponent.printSection.TABLE ||
				    WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put1("Adding Adapter %q", fi.render);
					prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
				}
			}
//			tableInfos.put((TableKind.Indirect(rootSig), finfos));
		}

		// Add all the dispatch adapter methods from method tables.
		// This also add the signature of the root method, which is
		// the signature of all the other dispatch methods.
		def firstDispatchTable = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# of dispatch tables = %d", wasm.dispatchTableRequests.length);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		for (i < wasm.dispatchTableRequests.length) {
			// EBM build table entries and assign function numbers
			var mtable = wasm.dispatchTableRequests[i];
			if (WasmComponent.printSection.FUNCTION ||
			    WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Dispatch table %d for %q", nextTableNum, mtable.render);
				prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
			var tableNum = nextTableNum++;
			wasm.dispatchTableFor[mtable] = tableNum;

			var root = mtable.root;
			var sigIdx = wasm.addSig(root.receiver, root.sig);	// make sure signature is present
			var superIdx = root.machIndex;
			// superIdx *can* be -1 (e.g., for an ADT with an empty-body default for a method)
			var funcInfo: FunctionInfo = if(superIdx < 0, null, functionInfos[superIdx]);
			var dispIdx = superIdx;
			var entryNum = 0;
			var tableInfo = Vector<FunctionInfo>.new();
			// we need a function index to use for nay null entries
			var recentMethod: IrMethod;
			for (m in mtable.table) {
				if (m == null) continue;
				recentMethod = m;
				break;
			}
			for (m0 in mtable.table) {
				// m0 == null means there are no instances -
				// but we still need an entry for proper indexing
				var m = if(m0 == null, recentMethod, m0);
				recentMethod = m;
				var name = if(WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT,
					      wasm.getMethodName(m), null);
				var mFuncIdx = m.machIndex;
				if (mFuncIdx != superIdx) {
					// New dispatch adapter needed
					dispIdx = functionInfos.length;
					funcInfo = FunctionInfo.new(FunctionInfoKind.Dispatch, m.receiver, m.sig, sigIdx, m, dispIdx);
					functionInfos.put(funcInfo);
					// The dispatch adapter is its own Wasm function
					if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
						var sb = StringBuilder.new().put1("Adding Adapter %q", funcInfo.render);
						prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
					}
					superIdx = mFuncIdx;  // for next iteration
				}
				tableInfo.put(funcInfo);
				wasm.dispatchAdapterFor[m] = dispIdx;
				if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put2("Adding dispatch table entry for %s; func #%d", name, mFuncIdx)
								    .put2(" table %d entry %d", tableNum, entryNum);
					prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
				}
				entryNum++;
			}
			tableInfos.put((TableKind.Dispatch(root.receiver, root.sig), tableInfo));
		}
		def numTables = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# tables = %d", numTables);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}

		// Now that we have figured out the adapters, we can emit code
		var codegen: WasmGcCodeGen;
		if (WasmComponent.includeSection.CODE) {
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Building code buffer ==========");
			codegen = WasmGcCodeGen.new(context, wasm, rt, codebuf);
	                rt.recordCodeStart(codebuf.addr_end());
			for (i < functionInfos.length) {
				var fi = functionInfos[i];
				match (fi.kind) {
					AllocStub => {
						codegen.emitAllocationStub();
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
					EntryStub => {
						codegen.emitEntryStub(test);
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
					HeapInit => {
						codegen.emitHeapInit(wasm, compRecords, recordInfo, otherRecords);
						if (WasmComponent.printSection.CODE || WasmComponent.printSection.START) {
							var sb = StringBuilder.new().put2("Emitting %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code/Start Section", sb.extract());
						}
					}
					Method => {
						codegen.emitWasm(fi.method, fi.funcIndex);
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
					Indirect => {
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting Adapter %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
						codegen.emitIndirectAdapter(fi.method);
					}
					Dispatch => {
						codegen.emitDispatchAdapter(fi.method);
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting Adapter %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
				}
			}

	                rt.recordCodeEnd(codebuf.addr_end());
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Done building code buffer ==========");
		}

		// (2) Emit types
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.TYPE) {
			out.startSection(WasmSection.TYPE.code);
			out.put_uleb32(u32.!(wasm.gcTypeTable.typeGroups.length));
			wasm.gcTypeTable.emit(out);
			out.endSection();
		}

		// (3) Emit imports
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.IMPORT) {
			if (wasm.numImports > 0) {
				out.startSection(WasmSection.IMPORT.code);
				out.put_sleb32(wasm.numImports);
				if (WasmComponent.printSection.IMPORT) {
					var sb = StringBuilder.new().put1("========== Emitting %d imports ==========", wasm.numImports);
					prog.ERROR.addError(null, null, "Import Section", sb.extract());
				}
				for (i = 0; i < wasm.numImports; i++) {
					var m = methods[i];
					var compName = VstComponent.!(m.source.receiver).importName.image;
					var methName = m.source.importName.image;
					var sigidx = wasm.getSigIndex(m);
					out.importName(compName);
					out.importName(methName);
					out.putb(/*Function import*/0);
					out.put_uleb32(sigidx);
					if (WasmComponent.printSection.IMPORT) {
						var sb = StringBuilder.new().put3("Function sig #%d %s.%s", sigidx, compName, methName);
						prog.ERROR.addError(null, null, "Import Section", sb.extract());
					}
				}
				out.endSection();
				if (WasmComponent.printSection.IMPORT) {
					var sb = StringBuilder.new().put1("========== Done ==========", wasm.numImports);
					prog.ERROR.addError(null, null, "Import Section", sb.extract());
				}
			} else {
				if (WasmComponent.printSection.IMPORT)
					prog.ERROR.addError(null, null, "Import Section", "========== Not emitting (no imports) ==========");
			}
		}

		// (4) Emit function signature declarations
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.FUNCTION) {
			out.startSection(WasmSection.FUNCTION.code);

			var nfsigs = functionInfos.length;
			out.put_sleb32(nfsigs);
			if (WasmComponent.printSection.FUNCTION) {
				var sb = StringBuilder.new().put1("========== Emitting %d function signature indexes ==========", nfsigs);
				prog.ERROR.addError(null, null, "Function Section", sb.extract());
			}

			for (i < nfsigs) {
				var fi = functionInfos[i];
				out.put_sleb32(int.!(fi.sigIndex) - 1);
				if (WasmComponent.printSection.FUNCTION) {
					var sb = StringBuilder.new().put1("Function sig index for %q", fi.render);
					prog.ERROR.addError(null, null, "Function Section", sb.extract());
				}
			}

			out.endSection();
			if (WasmComponent.printSection.FUNCTION)
				prog.ERROR.addError(null, null, "Function Section", "========== Done ==========");
		}

		// (5) Emit tables
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.TABLE) {
			def ntables = tableInfos.length;
			if (WasmComponent.printSection.TABLE) {
				var sb = StringBuilder.new().put1("========== Emitting %d tables ==========", ntables);
				prog.ERROR.addError(null, null, "Table Section", sb.extract());
			}
			out.startSection(WasmSection.TABLE.code);
			out.putb(ntables);  // number of tables
			for (i < ntables) {
				var entry = tableInfos[i];
				var kind = entry.0; var tab = entry.1;
				match (kind) {
					Indirect0 => {
						var len = u32.!(tab.length + 1);  // + 1 for the null entry
						if (WasmComponent.printSection.TABLE) {
							var sb = StringBuilder.new().put2("Indirect function table 0 (#%d); num entries %d", i, len);
							prog.ERROR.addError(null, null, "Table Section", sb.extract());
						}

						out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
						out.putb(1);	// flags = contains maximum
						out.put_uleb32(len);  // initial table length
						out.put_uleb32(len);  // maximum table length
					}
					Indirect(rSig) => {
						var rootSig = if(rSig == null, Signature.new(null, [], []), rSig);
						var sigidx = wasm.addSig(AnyRef.TYPE, rootSig);
						var fsig = wasm.getSig(AnyRef.TYPE, rootSig);
						var wft = wasm.gcTypeTable.addSignature(fsig);
						var wvt = WasmValueType.RefNull(wft);

						var count = u32.!(tab.length);
						if (WasmComponent.printSection.TABLE) {
							var sb = StringBuilder.new().put2("Indirect table #%d; num entries %d", i, count)
										    .put2("  sig: %q  sigIdx: %d", rootSig.funcType().render, sigidx);
							prog.ERROR.addError(null, null, "Table Section", sb.extract());
						}
						if (count == 0) {
							// an empty table??
							out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
							out.putb(1);	// flags = contains maximum
							out.put_uleb32(0);  // initial table length
							out.put_uleb32(0);  // maximum table length
							continue;
						}
						wvt.put(out);
						out.putb(1);	// flags = contains maximum
						out.put_uleb32(count);
						out.put_uleb32(count);
					}
					Dispatch(rootRcvr, rootSig) => {
						var sigidx = wasm.addSig(rootRcvr, rootSig);
						var fsig = wasm.getSig(rootRcvr, rootSig);
						var wft = wasm.gcTypeTable.addSignature(fsig);
						var wvt = WasmValueType.RefNull(wft);
						var count = u32.!(tab.length);

						if (WasmComponent.printSection.TABLE) {
							var sb = StringBuilder.new().put2("Dispatch table #%d; num entries %d", i, count)
										    .put3("  rcvr: %q  sig: %q  sigIdx: %d", rootRcvr.render, rootSig.funcType().render, sigidx);
							prog.ERROR.addError(null, null, "Table Section", sb.extract());
						}
						if (count == 0) {
							out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
							out.putb(1);	// flags = contains maximum
							out.put_uleb32(0);  // initial table length
							out.put_uleb32(0);  // maximum table length
							continue;
						}
						wvt.put(out);
						out.putb(1);	// flags = contains maximum
						out.put_uleb32(u32.!(count));
						out.put_uleb32(u32.!(count));
					}
				}
			}
			out.endSection();
			if (WasmComponent.printSection.TABLE)
				prog.ERROR.addError(null, null, "Table Section", "========== Done ==========");
		} else {
			if (WasmComponent.printSection.TABLE)
				prog.ERROR.addError(null, null, "Table Section", "========== Not emitted (no tables) ==========");
		}
			
		// (6) Emit memory section
		//--------------------------------------------------------------------------------
		var hasMemorySection = false;
		if (WasmComponent.includeSection.MEMORY) {
			if ((m.allocates || wasm.usesMemory) && rt.heapSize == 0) {
				rt.heapSize = pageSize;  // min of one page to allocate into
			}
			var totalSize = rt.heapSize + rt.shadowStackSize;
			if (totalSize > 0) {
				hasMemorySection = true;
				if (WasmComponent.printSection.MEMORY)
					prog.ERROR.addError(null, null, "Memory Section", "========== Emitting ==========");
				out.startSection(WasmSection.MEMORY.code);
				out.putb(1);	// 1 memory
				// Compute the maximum accessible data address, and from that the pages needed
				var maxDataAddr = u32.!(totalSize);
				var pages = (maxDataAddr + pageSize - 1u) / pageSize;
				var flags = 1;
				if (pageSize != 65536) flags |= 1 << 3;		// custom page size
				out.putb(flags);				// flags = contains maximum
				out.put_uleb32(pages);				// initial memory size
				out.put_uleb32(pages);				// maximum memory size
				if (pageSize != 65536) {
					out.put_uleb32(u32.!(Ints.log(pageSize))); // page size log
				}
				if (WasmComponent.printSection.MEMORY) {
					var sb = StringBuilder.new().put2("Max address = %d (0x%x) bytes", maxDataAddr, maxDataAddr)
								    .put2(", %d (0x%x) pages", pages, pages)
								    .put2(", page size %d (0x%x) bytes", pageSize, pageSize);
					prog.ERROR.addError(null, null, "Memory Section", sb.extract());
					prog.ERROR.addError(null, null, "Memory Section", "========== Done ==========");
				}
				out.endSection();
			} else {
				if (WasmComponent.printSection.MEMORY)
					prog.ERROR.addError(null, null, "Memory Section", "========== Not emitted (no allocation, etc.) ==========");
			}
		}

		// (6') Emit globals section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.GLOBAL) {
			var gvflds = wasm.globalVarsForFields;
			var gvrecs = wasm.globalVarsForRecords;
			var numGlobals = u32.!(gvflds.length + gvrecs.length);
			if (numGlobals > 0) {
				if (WasmComponent.printSection.GLOBAL) {
					var sb = StringBuilder.new().put3("========== Emitting %d globals (fields: %d, records: %d ==========",
									  numGlobals, gvflds.length, gvrecs.length);
					prog.ERROR.addError(null, null, "Global Section", sb.extract());
				}
				out.startSection(WasmSection.GLOBAL.code);
				out.put_uleb32(numGlobals);
				for (i < gvflds.length) {
					var fld = gvflds[i];
					var ft = fld.fieldType;
					var wvt = wasm.gcTypeTable.getValueTypeFor(ft);
					wvt.put(out); // type
					out.putb(1);  // mutable
					match (wvt) {
						I32 => {
							out.putb(WasmOp.I32_CONST.opcode).putb(0).putb(WasmOp.END.opcode);
						}
						I64 => {
							out.putb(WasmOp.I64_CONST.opcode).putb(0).putb(WasmOp.END.opcode);
						}
						F32 => {
							out.putb(WasmOp.F32_CONST.opcode).put_b32(0).putb(WasmOp.END.opcode);
						}
						F64 => {
							out.putb(WasmOp.F64_CONST.opcode).put_b64(0).putb(WasmOp.END.opcode);
						}
						FuncRef => {
							out.putb(WasmOp.REF_NULL.opcode).put_sleb32(int.!(WasmTypeConCode.FUNCREF.val)).putb(WasmOp.END.opcode);
						}
						AnyRef => {
							out.putb(WasmOp.REF_NULL.opcode).put_sleb32(int.!(WasmTypeConCode.ANYREF.val)).putb(WasmOp.END.opcode);
						}
						EqRef => {
							out.putb(WasmOp.REF_NULL.opcode).put_sleb32(int.!(WasmTypeConCode.EQREF.val)).putb(WasmOp.END.opcode);
						}
						RefNull(ht) => {
							out.putb(WasmOp.REF_NULL.opcode).put_sleb32(int.!(ht.index - 1)).putb(WasmOp.END.opcode);
						}
						_ => {}
					}
					if (WasmComponent.printSection.GLOBAL) {
						var sb = StringBuilder.new().put3("#%d %q.%q", i, fld.receiver.render, fld.render)
									    .put2(" type: %q (wasm: %q)", ft.render, wvt.render);
						prog.ERROR.addError(null, null, "Global Section", sb.extract());
					}
				}
				for (i < gvrecs.length) {
					var rec = gvrecs[i];
					var rt = rec.rtype;
					var wht = wasm.gcTypeTable.addHeapType(rt);
					var wvt = WasmValueType.RefNull(wht);
					wvt.put(out); // type
					out.putb(1);  // mutable
					out.putb(WasmOp.REF_NULL.opcode);
					out.put_sleb32(int.!(wht.index - 1));
					out.putb(WasmOp.END.opcode);
					if (WasmComponent.printSection.GLOBAL) {
						var sb = StringBuilder.new().put1("rec #%d", i)
									    .put2(" type: %q (wasm: %q)", rt.render, wvt.render);
						prog.ERROR.addError(null, null, "Global Section", sb.extract());
					}
				}
				out.endSection();
				if (WasmComponent.printSection.GLOBAL)
					prog.ERROR.addError(null, null, "Global Section", "========== Done ==========");
			} else {
				if (WasmComponent.printSection.GLOBAL)
					prog.ERROR.addError(null, null, "Global Section", "========== Not emitted (no globals) ==========");
			}
		}

		// (7) Emit the export section
		//--------------------------------------------------------------------------------
		var mainMeth = prog.getMain();
		var numExports = 0;		  // default exports: main and maybe memory
		var mainIndex: int;
		var mainName: string;
		if (mainMeth != null) {
			mainIndex = mainMeth.asMethod().machIndex;
			mainName = CLOptions.MAIN_EXPORT.get();

			if (wasm.entryStubFuncIndex >= 0) {
				mainIndex = wasm.entryStubFuncIndex;
				mainName = if(test, mainName, CLOptions.ENTRY_EXPORT.get());
			}
			numExports++;
		}
		var hi_index = wasm.heapInitFuncIndex;
		if (hi_index >= 0) numExports++;  // export _start

		if (CLOptions.WASM_EXPORT_MEM.val && hasMemorySection) numExports++;

		for (i < prog.ir.roots.length) {
			var r = prog.ir.roots[i];
			if (r.name != null) numExports++;
		}

		if (WasmComponent.includeSection.EXPORT) {
			if (numExports > 0) {
				if (WasmComponent.printSection.EXPORT) {
					var sb = StringBuilder.new().put1("========== Emitting %d exports ==========", numExports);
					prog.ERROR.addError(null, null, "Export Section", sb.extract());
				}
				var exportIndex = 0;
				out.startSection(WasmSection.EXPORT.code);
				out.putb(numExports);
				if (mainMeth != null) {
					// export main
					out.str(mainName);
					out.putb(WasmExternal.FUNCTION);
					out.put_sleb32(mainIndex);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put3("Export #%d: function %s, function #%d (main)", exportIndex++, mainName, mainIndex);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				if (hi_index >= 0) {
					// export _start
					out.str("_start");
					out.putb(WasmExternal.FUNCTION);
					out.put_sleb32(hi_index);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put2("Export #%d: function _start, function #%d (start)", exportIndex++, hi_index);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}

				// export memory
				if (CLOptions.WASM_EXPORT_MEM.val && hasMemorySection) {
					out.str("memory");
					out.putb(WasmExternal.MEMORY);
					out.put_uleb32(0);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put1("Export #%d: memory 0", exportIndex++);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				// export the rest of exported functions
				for (i < prog.ir.roots.length) {
					var r = prog.ir.roots[i];
					if (r.name == null) continue;
					out.importName(r.name);
					out.putb(WasmExternal.FUNCTION);
					var findex = r.spec.asMethod().machIndex;
					out.put_sleb32(findex);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put3("Export #%d: function %s, function #%d", exportIndex++, r.name, findex);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				if (WasmComponent.printSection.EXPORT)
					prog.ERROR.addError(null, null, "Export Section", "========== Done ==========");
				out.endSection();
			}
		}

		// (7') Emit the start section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.START) {
			var hi_index = wasm.heapInitFuncIndex;
			if (hi_index >= 0) {
				if (WasmComponent.printSection.START) {
					var sb = StringBuilder.new().put1("Start function #%d", hi_index);
					prog.ERROR.addError(null, null, "Start Section", sb.extract());
				}
				out.startSection(WasmSection.START.code);
				out.put_uleb32(u32.!(hi_index));
				out.endSection();
			} else {
				if (WasmComponent.printSection.START) {
					prog.ERROR.addError(null, null, "Code/Start Section", "No start function");
				}
			}
		}


		// (8) Emit the function table entries (Element Section)
		// This includes indirect and dispatch adapter tables for each class that needs them
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.ELEMENT) {
			def ntables = u32.!(tableInfos.length);
			if (ntables > 0) {
				if (WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put1("========== Emitting %d element groups ==========", ntables);
					prog.ERROR.addError(null, null, "Element Section", sb.extract());
				}
				out.startSection(WasmSection.ELEMENT.code);
				out.put_uleb32(ntables);
				for (i < ntables) {
					var entry = tableInfos[int.!(i)];
					var kind = entry.0; var tab = entry.1;
					match (kind) {
						Indirect0 => {
							def nentries = u32.!(tab.length);
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put2("Indirect function table (global) (#%d); # entries %d (including null first slot)", i, nentries + 1);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							// Indirect function table (global)
							if (i == 0) {
					 			out.putb(0);  // Elements kind is "Active Zero: start offset is an expression, table number is 0"
							} else {
								out.putb(2);  // Elements kind is "Active: start offset is an expression, table number is given"
								out.put_uleb32(i);  // table number
							}
							// start init expr for base index of elements
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(1);  // start index of elements; 0 is reserved for null function
							out.putb(WasmOp.END.opcode);
							// end init expr
							if (i != 0) out.putb(0);  // kind byte (0 required)
							// count of entries, followed by their values (function numbers)
							out.put_uleb32(nentries);
							for (j < nentries) {
								var entry = tab[int.!(j)];
								out.put_uleb32(u32.!(entry.funcIndex));
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Indirect function element %d function %d method %s",
													  j + 1, entry.funcIndex, wasm.getMethodName(entry.method));
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
						Indirect(rootSig) => {
							def nentries = u32.!(tab.length);
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put2("Indirect function table (#%d); # entries %d", i, nentries);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							// Indirect function table for a method
							if (i == 0) {
								out.putb(0);  // Elements kind is "Active Zero: start offset is an expression, table number is 0"
							} else {
					 			out.putb(2);  // Elements kind is "Active Index: start offset is an expression, table number is explicit"
								out.put_uleb32(i);  // table number
							}
							// start init expr for base index of elements
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(0);  // start index of elements: 0
							out.putb(WasmOp.END.opcode);
							// end init expr
							if (i != 0) out.putb(0);  // element kind: 0
							// count of entries, followed by their values (function numbers)
							out.put_uleb32(nentries);
							for (j < nentries) {
								var entry = tab[int.!(j)];
								out.put_uleb32(u32.!(entry.funcIndex));
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Indirect function element %d function %d method %s",
													  j, entry.funcIndex, wasm.getMethodName(entry.method));
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
						Dispatch(rootRcvr, rootSig) => {
							def fsig = wasm.getSig(rootRcvr, rootSig);
							def wft = wasm.gcTypeTable.addSignature(fsig);
							def wvt = WasmValueType.RefNull(wft);
							def nentries = u32.!(tab.length);
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put2("Dispatch function table (#%d); # entries %d", i, nentries);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							// Dispatch function table for a method
				 			out.putb(6);  // Elements kind is "Active Expr Index: start offset is an expression, table number is explicit"
							out.put_uleb32(i);  // table number
							// start init expr for base index of elements
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(0);  // start index of elements: 0
							out.putb(WasmOp.END.opcode);
							// end init expr
							wvt.put(out);  // type of function pointers in table
							// count of entries, followed by their values (function numbers)
							out.put_uleb32(nentries);
							for (j < nentries) {
								var entry = tab[int.!(j)];
								out.putb(WasmOp.REF_FUNC.opcode);
								out.put_uleb32(u32.!(entry.funcIndex));
								out.putb(WasmOp.END.opcode);
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Dispatch function element %d function %d method %s",
													  j, entry.funcIndex, wasm.getMethodName(entry.method));
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
					}
				}
				out.endSection();
				if (WasmComponent.printSection.TABLE)
					prog.ERROR.addError(null, null, "Table Section", "========== Done ==========");
			} else {
				if (WasmComponent.printSection.ELEMENT)
					prog.ERROR.addError(null, null, "Element Section", "========== Not emitted (no elements) ==========");
			}
		}

		// (9) Emit the function bodies
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.CODE) {
			var numBodies = functionInfos.length;
			if (WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put1("========== Emitting %d code bodies ==========", numBodies);
				prog.ERROR.addError(null, null, "Code Section", sb.extract());
			}
			out.startSection(WasmSection.CODE.code);
			out.put_sleb32(numBodies);
			out.putmd(codebuf);
			out.endSection();
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Done ==========");
		}

		// (10) Emit the data section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.DATA) {	// turn off for now
			var totalDataSize = 0;
			if (totalDataSize > 0) {
				if (WasmComponent.printSection.DATA) {
					var sb = StringBuilder.new().put1("========== Bytes emitted = %d ==========", totalDataSize);
					prog.ERROR.addError(null, null, "Data Section", sb.extract());
				}
				out.startSection(WasmSection.DATA.code);
				out.putb(1); // 1 data entry
				out.putb(0); // linear memory #0
				out.putb(WasmOp.I32_CONST.opcode).put_sleb32(int.view(dataStartAddr));  // linear memory offset
				out.putb(WasmOp.END.opcode);
				var data_sizepos = out.skip_leb32(); // data size
				var data_start = out.pos;
				out.startAddr = u64.view(i64.!(dataStartAddr) - i64.!(out.end()));

		                rt.recordDataStart(out.addr_end());
				// not sure what might go in the middle
		                rt.recordDataEnd(out.addr_end());

				// Add the heap pointers after the initialized data. XXX: use WASM globals.
				if (false) {
					// EBM: see what our run-time needs
					if (m.allocates || rt.shadowStackSize > 0) rt.addHeapPointers(out);
				}
				WasmCommon.patchSize(out, data_sizepos, out.atEnd().pos - data_start);
				out.endSection();
				if (WasmComponent.printSection.DATA)
					prog.ERROR.addError(null, null, "Data Section", "========== Done ==========");
			} else {
				if (WasmComponent.printSection.DATA)
					prog.ERROR.addError(null, null, "Data Section", "========== Not emitted (no bytes) ==========");
			}
		}

		out.patch(patchAddress(wasm.mach, _, _, _));

		// (11) Emit the name section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.NAME && CLOptions.SYMBOLS.val) {
			out.startSection(WasmSection.UNKNOWN.code);
			out.str("name");
			// output function name subsection
			out.putb(1); // names of functions
			var funcname_sizepos = out.skip_leb32();
			var funcname_start = out.pos;
			var count = u32.!(methods.length);
			if (m.allocates) count++;
			if (wasm.entryStubFuncIndex >= 0) count++;
			out.put_uleb32(count);
			if (wasm.allocateStubFuncIndex >= 0) {
				out.put_uleb32(u32.!(wasm.allocateStubFuncIndex));
				out.str(".alloc");
			}
			if (wasm.entryStubFuncIndex >= 0) {
				out.put_uleb32(u32.!(wasm.entryStubFuncIndex));
				out.str(".entry");
			}

			var namebuf = StringBuilder.new();
			for (i < methods.length) {
				var m = methods[i];
				out.put_uleb32(u32.!(m.machIndex));
				emitMethodName(out, m, namebuf);
			}
			WasmCommon.patchSize(out, funcname_sizepos, out.atEnd().pos - funcname_start);
			out.endSection();
		}

		// Dump the bytes to the file
		var fileName = context.compiler.getOutputFileName(prog.name(), "wasm");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) {
			prog.ERROR.OutputError(fileName);
			return null;
		}
		System.write(fd, out.alias());
		System.fileClose(fd);
		return out;
	}
	def layoutAllRecordsAndFuncs(wasm: WasmGcProgram, m: MachProgram) {
		Vectors.drain(m.recordQueue, 0, layoutRecord(wasm, m, _));
	}
	private def layoutRecord(wasm: WasmGcProgram, m: MachProgram, r: Record) {
		for (v in r.values) layoutVal(wasm, m, v);
	}
	private def layoutVal(wasm: WasmGcProgram, m: MachProgram, val: Val) {
		if (val == null) return;
		match (val) {
			// Can these occur?
//			x: ArrayRangeVal => { addrOfRecord(m, x.array); m.prog.ERROR.addError(null, null, "+++++", "layoutVal saw an ArrayRangeVal"); }
			x: ArrayRangeStart => {}  // nothing intesting here (just an int)
//			x: PointerRangeStart => { m.prog.ERROR.addError(null, null, "+++++", "layoutVal saw a PointerRangeStart"); }
//			x: ByteArrayOffset => { addrOfRecord(m, x.array); m.prog.ERROR.addError(null, null, "+++++", "layoutVal saw a ByteArrayOffset"); }

			// Called for side effect on recordMap; it does not really have an "address"
			x: Record => {
				// avoid infinite recursion on cyclic Record structures
				if (!m.recordMap.has(x)) {
					addrOfRecord(m, x);
					for (v in x.values) layoutVal(wasm, m, v);
				}
			}

			// This serves to insure an indirect adapter is requested and Addr created
			x: FuncVal => {
				var method = x.memberRef.asMethod();
// EBM FUNC add request for indirect adapter
				if (CLOptions.PRINT_RA.get()) {
					Terminal.buf.put3("Request indirect adapter for record val for %q.%q{%d}", method.receiver.render, method.render, method.index).outln();
				}
				wasm.requestIndirectAdapter(method);
				m.addrOfMethod(method);
			}

			// EBM: Ben says Closure should be normalized away
//			x: Closure => { layoutVal(wasm, m, x.val); m.addrOfMethod(x.memberRef.asMethod()); m.prog.ERROR.addError(null, null, "+++++", "layoutVal saw a Closure");  }

			// Insure we find all the things needed for the initial heap
			x: BoxVal => for (e in x.values) layoutVal(wasm, m, e);

//			x: Addr => { m.prog.ERROR.addError(null, null, "+++++", "layoutVal saw an Addr"); }
			// There are a number of other cases, which do not need to be entered into maps
			x: Box<int> => {}
			x: Box<bool> => {}
			x: Box<long> => {}
			x: Box<byte> => {}
			x: Float32Val => {}
			x: Float64Val => {}
			_ => m.prog.ERROR.addError(null, null, "layoutVal", "unexpected Val type");

		}
	}
	def addrOfRecord(m: MachProgram, r: Record) -> Address<Record> {
		var addr = m.recordMap[r];
		if (addr == null) {
//			var sb = StringBuilder.new().put1("addrOfRecord type %q", r.rtype.render);
//			m.prog.ERROR.addError(null, null, "*****", sb.extract());
			// address does not mean much, but we want the "cookie" there in the map
			addr = RECORD_REGION.allocate(r, 1);
			m.recordMap[r] = addr;
			// queue for later processing
			m.recordQueue.put(r);
		}
		return addr;
	}
	def processMethodMapEntry(wasm: WasmGcProgram, item: IrItem, addr: Address<IrMethod>) {
		var m = addr.val;
// EBM FUNC
//		wasm.requestIndirectAdapter(m);
		addr.absolute = m.machIndex;
	}
	// Call this with two function types where container subsumes actual in Virgil;
	// it determines whether they are subsumed in Wasm, which has tighter rules.
	// This test applies to functions being passed / stored, not to calls.
	def wasmSubsumedFuncType(wasm: WasmGcProgram, actual: Type, container: Type) -> bool {
		if (!(FuncType.?(actual))) { /* complain */ }
		if (!(FuncType.?(container))) { /* complain */ }
		var aft = FuncType.!(actual);
		var cft = FuncType.!(container);
		var asig = aft.sig();
		var csig = cft.sig();
		if (asig.paramTypes.length != csig.paramTypes.length) { /* complain */ }
		var waft = WasmFuncType.!(wasm.gcTypeTable.addHeapType(aft));
		var wcft = WasmFuncType.!(wasm.gcTypeTable.addHeapType(cft));
		for (i < waft.params.length) {
			if (!waft.params[i].equals2(wcft.params[i])) return false;
		}
		for (i < waft.results.length) {
			if (!waft.params[i].equals2(wcft.params[i])) return false;
		}
		return true;
	}
	def processForComponent(wasm: WasmGcProgram, recordInfo: HashMap<int,IrClass>, cls: IrClass) {
		var t = cls.ctype;
//		var sb = StringBuilder.new().put1("processForComponent  type: %q", t.render);
//		wasm.mach.prog.ERROR.addError(null, null, "+++++", sb.extract());
		if (!V3.isComponent(t)) return;

		// add global variables for fields of component
		var flds = cls.fields;
		for (i < flds.length) {
			var fld = flds[i];
//			var sb = StringBuilder.new().put3("processForComponent  field: %d  type: %q  global: %d",
//							  i, fld.fieldType.render, wasm.globalVarsForFields.length);
//			wasm.mach.prog.ERROR.addError(null, null, "+++++++", sb.extract());
			wasm.globalVarForField[fld] = wasm.globalVarsForFields.length;
			wasm.globalVarsForFields.put(fld);
		}

		// add Record info
		var decl = V3.componentDecl(t);
		var ri = decl.recordIndex;
		var crs = wasm.mach.prog.compRecords;
		var r: Record;
		if (ri < crs.length && (r = crs[ri]) != null) {
//			var sb = StringBuilder.new().put1("processForComponent  id: %d", r.id);
//			wasm.mach.prog.ERROR.addError(null, null, "+++++++", sb.extract());
			recordInfo[r.id] = cls;
		}
	}
	def getObjectSize(m: MachProgram, t: Type, r: Record) -> int {
		var size: int;
		match (t) {
			x: ClassType => {
				var ic = m.prog.ir.getIrClass(t);
				if (ic == null) m.fail(Strings.format2("getObjectSize(#%d): class %q has no IrClass", r.id, t.render));
				else if (V3.isComponent(t)) size = ic.fields.length;
				else size = 1;
			}
			x: ArrayType => size = 1;  // a ref
			_ => return m.unexpectedType(t, 0);
		}
		return size;
	}
	def patchAddress(mach: MachProgram, w: MachDataWriter, a: Addr, posAddr: int) {
		var abs = mach.absolute(a);
		if (CLOptions.PRINT_BIN.get()) {
			TerminalBuffer.new()
				.puts("patch-address @+")
				.putd(w.pos)
				.puts(" <- ")
				.putcv(a, null)
				.puts(" = ")
				.putx(abs)
				.outln();
		}
		// TODO,XXX: address immediates are in i32.const, which is a signed LEB.
		w.overwrite_sleb32(abs);
	}
	def emitTestWrappers(context: SsaContext, rt: MachRuntime, w: DataWriter, e: ExecuteTestCase) {
		var prog = context.prog;
		var fileName = context.compiler.getOutputFileName(prog.name(), "expect.js");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		var buf = StringBuilder.new();
		buf.put1("// %s\n", prog.name());

		buf.puts("var globalTestRuns = [\n");

		for (r = e.runs; r != null; r = r.tail) {
			var run = r.head;
			buf.puts("\t[");
			putJsValue(buf, run.expected);
			buf.puts(", [");
			for (i = run.input; i != null; i = i.tail) {
				putJsValue(buf, i.head);
				if (i.tail != null) buf.csp();
			}
			buf.puts("]],\n");
		}

		buf.puts("];\n");

		System.fileWriteK(fd, buf.buf, 0, buf.length);
		System.fileClose(fd);

		// emit Wasm spec test wrapper
		fileName = context.compiler.getOutputFileName(prog.name(), "bin.wast");
		fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		buf.reset();
		buf.puts("(module binary\n");
		for (i < w.end()) {
			if ((i & 31) == 0) buf.puts(" \"");
			buf.puts("\\");
			buf.putx_8(w.data[i]);
			if ((i & 31) == 31 || (i == w.end() - 1)) buf.puts("\"").ln();
		}
		buf.puts("\n)\n");
		for (r = e.runs; r != null; r = r.tail) {
			var run = r.head;
			if (Exception.?(run.expected)) buf.puts("(assert_trap ");
			else buf.puts("(assert_return ");
			buf.puts("(invoke \"main\" ");
			for (i = run.input; i != null; i = i.tail) {
				putWasmValue(buf, i.head);
			}
			buf.puts(")\n");
			if (Exception.?(run.expected)) {
				var ex = Exception.!(run.expected);
				if (Strings.equal(V3Exception.DivideByZero, ex.error)) buf.puts("\"integer divide by zero\"");
				else buf.puts("\"unreachable\"");
			}
			else putWasmValue(buf, run.expected);
			buf.puts(")\n");
		}

		System.fileWriteK(fd, buf.buf, 0, buf.length);
		System.fileClose(fd);
	}
	def putWasmValue(buf: StringBuilder, r: Result) -> StringBuilder {
		match (r) {
			x: Box<int> => return buf.puts("(i32.const 0x").putx(x.val).putc(')');
			x: Box<bool> => return buf.puts("(i32.const 0x").putx(if(x.val, 1, 0)).putc(')');
			null => return buf.puts("(i32.const 0x0)");
		}
		return buf;
	}
	def putJsValue(buf: StringBuilder, r: Result) -> StringBuilder {
		match (r) {
			x: Box<int> => return buf.putd(x.val);
			x: Box<bool> => return buf.putd(if(x.val, 1, 0));
			x: Exception => return buf.puts("WebAssembly.RuntimeError");
			null => return buf.puts("0");
		}
		return buf;
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	def getRuntime(prog: Program) -> MachRuntime {
		return MachProgram.!(prog.tprog).runtime;
	}
	def emitMethodName(w: MachDataWriter, m: IrMethod, namebuf: StringBuilder) {
		namebuf.reset();
		m.renderLong(namebuf);
		w.put_uleb32(u32.!(namebuf.length));
		w.putk(namebuf.buf, 0, namebuf.length);
	}
        def emitEngineScript(cmd: string, compiler: Compiler, prog: Program) {
		var programName = prog.name();
		var fileName = compiler.getOutputFileName(programName, null);
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		compiler.emitBashScriptHeader(fd);
		System.write(fd, cmd);
                System.write(fd, " $DIR/");
		System.write(fd, programName);
		System.write(fd, ".wasm");
		System.write(fd, " \"$@\"\n");
		System.fileClose(fd);
		compiler.makeExecutable(fileName);
        }
}

type DispatchAdapter(rootRcvr: Type, rootSig: Signature, rcvr: Type, sig: Signature,
		     funcNum: u32, meth: IrMethod, rootSigIdx: int) {
	def render(sb: StringBuilder) -> StringBuilder {
		sb.put3("root type %q, root sig %q, sig idx %d",
			rootRcvr.render, rootSig.funcType().render, rootSigIdx)
		  .put2(", rcvr %q, sig %q", rcvr.render, sig.funcType().render)
		  .put2("func #%d, method %q", funcNum, meth.render);
		return sb;
	}
}

// class WasmGcProgram(prog: Program, context: SsaContext, test: bool) {
class WasmGcProgram(mach: MachProgram, context: SsaContext, test: bool) {
	var gcTypeTable: WasmGcTypeTable;
	var usesMemory = false;

	//
	// EBM: From WasmProgram; revisit
	//

	//
	// Info for indirect tables
	//

	var anyCallFunctions = false;  // may have indirect call (of null function) w/o any adapters ...
	// Indicates the indirect adapter function number for a given method
	// Initially set to -1 and later updated when laid out
	def indirectAdapterFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);
	def indirectAdapterRequests = Vector<IrMethod>.new();

	// Index in indirect table 0 of a method whose address is taken
	// This includes individual methods plus ones needed from mtables
	def indirectAdapterIndexFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);
	// The indirect adapters, in order
	def indirectAdapterVector = Vector<IrMethod>.new().put(null);  // start with 0 entry

	// Maps from method tables to starting index of entries in table 0
	// At time of request, the base is set to -1 and later updated when laid out
	def indirectTableBase = HashMap<IrMtable,int>.new(IrItem.uid, IrMtable.==);
	def indirectTableRequests = Vector<IrMtable>.new();

	//
	// Info for dispatch tables
	//

	// Indicates the dispatch adapter function number for a given method
	def dispatchAdapterFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);
	var dispatchAdapterBase: u32 = 0;  // function index of first dispatch adapter

	// Maps from method table to corresponding dispatch tables (Wasm table number)
	def dispatchTableFor = HashMap<IrMtable,int>.new(IrItem.uid, IrMtable.==);
	def dispatchTableRequests = Vector<IrMtable>.new();

	//
	// Info for Wasm globals
	//

	// Maps from IrField to corresponding global variable (fields of components)
	def globalVarForField = HashMap<IrField,int>.new(IrItem.uid, IrField.==);
	def globalVarsForFields = Vector<IrField>.new();

	// Maps from Record to corresponding global variable (non-component Records)
	def globalVarForRecord = HashMap<Record,int>.new(Record.id, Record.==);
	def globalVarsForRecords = Vector<Record>.new();

	//
	// Wasm signature and function indexes for entry / alloc / heap init

	var sigIndex_i_i = -1;
	var sigIndex_entryStub = -1;
	var sigIndex_heapInit = -1;

	// known function indices
	var entryStubFuncIndex = -1;
	var allocateStubFuncIndex = -1;
	var heapInitFuncIndex = -1;

	var numImports = 0;

	//
	// End from WasmProgram
	//

	new() {
		gcTypeTable = WasmGcTypeTable.new(wasmGcType, mach.prog.ERROR, mach.prog.ir, this);
	}

	def requestIndirectAdapter(m: IrMethod) {
		if (!indirectAdapterFor.has(m)) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.put3("Adding indirect adapter request for %q.%q{%d}", m.receiver.render, m.render, m.index).outln();
			}
			indirectAdapterFor[m] = -1;
			indirectAdapterRequests.put(m);
			addSig(AnyRef.TYPE, m.sig);
		}
	}
	def requestIndirectTable(m: IrMtable) {
		if (!indirectTableBase.has(m)) {
			indirectTableBase[m] = -1;
			indirectTableRequests.put(m);
		}
	}
	def requestDispatchTable(m: IrMtable) {
		if (!dispatchTableFor.has(m)) {
			dispatchTableFor[m] = -1;
			dispatchTableRequests.put(m);
		}
	}

	def wasmGcType(t: Type) -> WasmValueType {
		return gcTypeTable.getValueTypeFor(t);
	}

	def getSig(receiver: Type, sig: Signature) -> Signature {
//		var sb = StringBuilder.new().put2("receiver=%q  sig=%q", receiver.render, sig.funcType().render);
//		mach.prog.ERROR.addError(null, null, "getSig", sb.extract());
		if (receiver != Void.TYPE && !V3.isComponent(receiver))
			sig = Signature.new(null, Arrays.prepend(receiver, if(sig == null, Array<Type>.new(0), sig.paramTypes)),
					    if(sig == null, Array<Type>.new(0), sig.returnTypes));
		return sig;
	}
	def addSig(receiver: Type, sig: Signature) -> u32 {
		var wft = gcTypeTable.addSignature(getSig(receiver, sig));
		return u32.!(wft.index);
	}
	def getSigIndex(m: IrMethod) -> u32 {
		var sig = getSig(m.receiver, m.sig);
		var wft = gcTypeTable.addSignature(sig);
		var index: u32 = if(wft == null, 0, wft.index);
		if (index == 0) context.fail1("method signature not found: %q", sig.funcType().render);
		return u32.!(index - 1);
	}
	def getMethodName(m: IrMethod) -> string {
		var name = "?";
		var ms = m.source;
		if (ms != null) {
			var sig = getSig(m.receiver, m.sig);
			var wht = gcTypeTable.addSignature(sig);
			var mn = ms.name();
			var rt = m.receiver;
			var rn = getClassName(rt);
			name = StringBuilder.new().put2("%s.%s", rn, mn).extract();
		}
		return name;
	}
	def getClassName(ctype: Type) -> string {
		return if(ClassType.?(ctype),ClassType.!(ctype).classDecl.name(),ctype.typeCon.name);
	}
	def addIrMethodAddr(m: IrItem, addr: Address<IrMethod>) {
		var m = addr.val;
		var name: string = if(WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT,
				      getMethodName(m), null);
		if (m.machIndex < 0) context.fail1("method not assigned an index: %q", m.renderLong);
		requestIndirectAdapter(m);
	}
	def addIrMethods(infos: Vector<FunctionInfo>) -> Vector<IrMethod> {
		var methods = mach.prog.ir.methods;
		// We place imported functions first, locally defined ones later;
		// any stubs will be emitted in between.  Note that position in
		// the original methods Vector does not always correspond to Wasm function number.
		var sorted = Array<IrMethod>.new(methods.length);
		var j = 0;

		// Add all imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source == null || m.source.importName == null) continue;
			addMethod(m, infos, true);
			sorted[j++] = m;
		}
		numImports = j;

		// Add the allocation stub if necessary
		if (mach.allocates) {
			var sig = FuncType.!(Function.newType(Int.TYPE, Int.TYPE)).sig();
			sigIndex_i_i = int.!(addSig(Void.TYPE, sig));
			allocateStubFuncIndex = infos.length;
			infos.put(FunctionInfo.new(FunctionInfoKind.AllocStub, null, sig, u32.!(sigIndex_i_i), null, allocateStubFuncIndex));
			if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Adding alloc stub; sig idx=#%d entry #%d", sigIndex_i_i - 1, allocateStubFuncIndex);
				mach.prog.ERROR.addError(null, null, "Function/Code Section", sb.extract());
			}
		}
		// Add the entry stub if {RiRuntime.init} or {RiRuntime.exit} exists.
		var ri_init = mach.runtime.getRiInit();
		var ri_exit = mach.runtime.getRiExit();
		if (ri_init != null || ri_exit != null) {
			var main = mach.prog.getMain();
			var mainMeth = if(main != null, main.asMethod());
			var mainSig = if(mainMeth != null, mainMeth.sig);
			var sig = mainSig;

			if (test) {
				// no inputs; outputs are arguments to Wasm main, prepared by the testing function
				sigIndex_entryStub = int.!(addSig(Void.TYPE, mainSig));
			} else {
				// inputs are what ri_init needs (none if it is not called)
				var params: Array<Type> = if(ri_init != null, ri_init.sig.paramTypes, TypeUtil.NO_TYPES);
				// outputs are what ri_exit returns if ri_exit is used, otherwise an int success code
				var results: Array<Type> = if(ri_exit != null, ri_exit.sig.returnTypes, [Int.TYPE]);
				sig = Signature.new(null, params, results);
				sigIndex_entryStub = int.!(addSig(Void.TYPE, sig));
			}
			entryStubFuncIndex = infos.length;
			infos.put(FunctionInfo.new(FunctionInfoKind.EntryStub, null, sig, u32.!(sigIndex_entryStub), mainMeth, entryStubFuncIndex));
			if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
				var sb = StringBuilder.new().put2("Adding entry stub; sig idx=#%d entry #%d", sigIndex_entryStub - 1, entryStubFuncIndex);
				mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
			}
		}

		// Add all non-imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source != null && m.source.importName != null) continue;
			addMethod(m, infos, false);
			sorted[j++] = m;
		}

		Arrays.copyInto(sorted, methods.array, 0);  // update the IrModule's method vector.
		return methods;
	}
	def addMethod(m: IrMethod, infos: Vector<FunctionInfo>, imported: bool) {
		var sigIdx = addSig(m.ssa.params[0].vtype, m.sig);
		if (!imported) {
			m.machIndex = infos.length;
			var fi = FunctionInfo.new(FunctionInfoKind.Method, m.receiver, m.sig, sigIdx, m, infos.length);
			infos.put(fi);
		}
		if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
			var name = getMethodName(m);
			var sb = StringBuilder.new().put3("Adding method %s; sig idx=#%d entry #%d", name, sigIdx, m.machIndex);
			mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
		}
	}
}

component AddTypes {

	def addIrTypesSeen = TypeUtil.newTypeMap<void>();
	def methodsSeen = HashMap<IrMethod, void>.new(IrMethod.uid, IrMethod.==);

	// adds to the gcTypeTable all non-class heap types
	def addIrTypes<T>(irObject: T, prog: WasmGcProgram) {
		var errgen = prog.mach.prog.ERROR;
		match (irObject) {
			module: IrModule => {
				if (WasmComponent.printSection.TYPE) {
					errgen.addError(null, null, "Type Section", "Processing module");
					errgen.report();
				}
				// *Add* all the classes first, so their ctypes are in heapTypeMap, etc
				for (i < module.classes.length) prog.gcTypeTable.addClass(module.classes[i]);
				// Now process the classes (etc) more thoroughly
				for (i < module.classes.length) addIrTypes(module.classes[i], prog);
				for (i < module.methods.length) addIrTypes(module.methods[i], prog);
				for (i < module.init.length   ) addIrTypes(module.init   [i], prog);
				for (i < module.roots.length  ) addIrTypes(module.roots  [i], prog);
			}
			cls: IrClass => {
				// finish processing the class - could not process the fields with addClass
				if (WasmComponent.printSection.TYPE) {
					var ctype = cls.ctype;
					var name: string = if(ClassType.?(ctype),ClassType.!(ctype).classDecl.name(),ctype.typeCon.name);
					var line = StringBuilder.new().put1("Processing IR class: %s", name);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				for (m in cls.methods) addIrTypes(m, prog);
				for (f in cls.fields ) addIrTypes(f, prog);
				prog.gcTypeTable.processClass(cls, prog.mach.tagType);
			}
			method: IrMethod => {
				if (methodsSeen.has(method)) return;
				methodsSeen[method] = ();
				if (WasmComponent.printSection.TYPE) {
					var line = StringBuilder.new().put2("Processing IR method: %q.%q",
									    method.receiver.render, method.render);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				addIrTypes(method.receiver, prog);
				prog.gcTypeTable.addSignature(prog.getSig(method.receiver, method.sig));
				// ferret out types lurking in the SSA that we might not see
				var graph = method.ssa;
				if (graph == null) return;
				if (graph.params != null) {
					for (i < graph.params.length) {
						var param = graph.params[i];
						if (param != null) {
							if (WasmComponent.printSection.TYPE) {
								var line = StringBuilder.new().put1("Processing IR graph param type: %q",
												    param.getType().render);
								errgen.addError(null, null, "Type Section", line.extract());
								errgen.report();
							}
							// EBM TODO: if of class type, get IrClass and do recursive call
							// (or add cases for types as the "irObject" in addIrTypes)
							addIrTypes(param.getType(), prog);
							prog.gcTypeTable.addHeapType(param.getType());
						}
					}
				}
				if (graph.values != null) {
					for (i < graph.values.length) {
						var value = graph.values[i];
						if (value != null) {
							if (WasmComponent.printSection.TYPE) {
								var line = StringBuilder.new().put1("Processing IR graph constant type: %q",
												    value.getType().render);
								errgen.addError(null, null, "Type Section", line.extract());
								errgen.report();
							}
							var val = value.val;
							if (FuncVal.?(val)) {
								prog.requestIndirectAdapter(FuncVal.!(val).memberRef.asMethod());
							}
							// EBM TODO: if of class type, get IrClass and do recursive call
							// (or add cases for types as the "irObject" in addIrTypes)
							addIrTypes(value.getType(), prog);
							prog.gcTypeTable.addHeapType(value.getType());
						}
					}
				}
			}
			field: IrField => {
				if (WasmComponent.printSection.TYPE) {
					var line = StringBuilder.new().put3("Processing IR field: %q.%q: %q",
									    field.receiver.render, field.render, field.fieldType.render);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				prog.gcTypeTable.addHeapType(field.fieldType);
			}
			selector: IrSelector => {
				if (WasmComponent.printSection.TYPE) {
					var line = StringBuilder.new().put2("Processing IR selector: %q.%q",
									    selector.receiver.render, selector.render);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				addIrTypes(selector.method, prog);
				addIrTypes(selector.mtable, prog);
			}
			mtable: IrMtable => {
				if (WasmComponent.printSection.TYPE) {
					var line = StringBuilder.new().put1("Processing IR mtable: %q", mtable.render);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				addIrTypes(mtable.root, prog);
				for (meth in mtable.table) addIrTypes(meth, prog);
				prog.gcTypeTable.addHeapType(mtable.record.rtype);
			}
			spec: IrSpec => {
				if (WasmComponent.printSection.TYPE) {
					var line = StringBuilder.new().put1("Processing IR spec: %q", spec.render);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				addIrTypes(spec.member, prog);
				for (typ in spec.typeArgs) prog.gcTypeTable.addHeapType(typ);
			}
			root: IrRoot => {
				if (WasmComponent.printSection.TYPE) {
					var name = if(root.name == null,"??",root.name);
					var line = StringBuilder.new().put1("Processing IR root: %s", name);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				addIrTypes(root.spec, prog);
			}
			typ: Type => {
				// not really an Ir element directly, but the point is to find types, so ...
				if (addIrTypesSeen.has(typ)) return;
				addIrTypesSeen[typ] = ();
				if (WasmComponent.printSection.TYPE) {
					var line = StringBuilder.new().put1("Processing Type in addIrTypes: %q", typ.render);
					errgen.addError(null, null, "Type Section", line.extract());
					errgen.report();
				}
				match (typ.typeCon.kind) {
					ARRAY => {
						addIrTypes(V3Array.elementType(typ), prog);
						prog.gcTypeTable.addArrayType(typ);
					}
					FUNCREF, CLOSURE => {
						var sig = FuncType.!(typ).sig();
						for (t in sig.paramTypes ) addIrTypes(t, prog);
						for (t in sig.returnTypes) addIrTypes(t, prog);
						prog.gcTypeTable.addSignature(sig);
					}
					CLASS, VARIANT => {
						prog.gcTypeTable.addClassType(typ);
						var cls = prog.context.prog.ir.getIrClass(typ);
						if (cls == null) return;
						addIrTypes(cls, prog);
					}
					_ => ;
				}
			}
		}
	}
}

type RangeKind {
	case PtrOnly; // range statically known to be pointer-based
	case ArrayOnly; // range statically known to be array-based
	case Unknown; // range needs run-time discrimination
}
def encodeRangeKind(b : byte) -> RangeKind {
	// The encoding is:
	// 1: PtrOnly
	// 2: ArrayOnly
	// 3: Unknown (conveniently the OR of 1 and 2)
	def encoding = [RangeKind.PtrOnly, RangeKind.ArrayOnly, RangeKind.Unknown];
	return encoding[b - 1];
}

class WasmGcLowering extends MachLowering {

	def wasm: WasmGcProgram;
	def target: WasmGcTarget;

	new(wasm, target, mach: MachProgram, compiler: Compiler, config: MachLoweringConfig)
		super(mach, compiler, config) {	}

	def classIdRange(t: Type) -> (int, int) {
		var r = mach.prog.ir.getIrClass(t);
		if (r == null) return (0, 0);
		return (r.minClassId, r.maxClassId);
	}
	def genSimpleVal(val: Val, tn: TypeNorm) -> Val {
		if (val == null) return null;
		match (val) {
			x: ArrayRangeStart => return Int.box(x.start);
			x: PointerRangeStart => return x.start;
		}
		return mach.machVal(val);
	}
	def genApplyOp(i_old: SsaApplyOp) {
		match(i_old.op.opcode) {
			PtrAdd,
			PtrSub,
			PtrLt,
			PtrLteq,
			PtrAtContents, // disallow
			PtrAtLength, // disallow
			PtrAtObject, // disallow
			PtrAtRangeElem,
			PtrAtArrayElem, // disallow
			PtrAtEnd, // disallow
			PtrAtRef,
			PtrAtComponentField, // disallow
			PtrAtObjectField, // disallow
			PtrAtRefLayoutField,
			PtrAtUnboxedObjectField, // disallow
			PtrAtUnboxedComponentField, // disallow
			PtrCmpSwp,
			PtrLoad,
			PtrStore,
			PtrAddRangeStart => wasm.usesMemory = true;
			_ => ;
		}
		genApplyOp0(i_old);
	}
	def genTypeCast(i_old: SsaApplyOp, castOp: TypeCast) {
		var ft = i_old.op.typeArgs[0], tt = i_old.op.typeArgs[1];
		var i_new: SsaInstr;
		match (castOp) {
			TRUE => i_new = normRef1(i_old.inputs[0]);  // XXX: maybe dead?
			SUBSUME => return void(normId(i_old));  // XXX: maybe dead?
			CLASS_CAST, VARIANT_CAST => i_new = genClassCast(ft, tt, i_old);
			THROW => i_new = addThrow(i_old.source, V3Exception.TypeCheck);
			INT_VIEW_I => return genIntViewI(i_old);
			_ => {
				// other kinds of casts should have been removed
				context.fail1("unexpected cast %s", castOp.name);
				i_new = context.graph.nop();
			}
		}
		return map1(i_old, i_new);
	}
	def genClassCast(ft: Type, tt: Type, i_old: SsaApplyOp) -> SsaInstr {
		var fromIrClass = mach.prog.ir.makeIrClass(ft);
		wasm.gcTypeTable.addClass(fromIrClass);
		var toIrClass = mach.prog.ir.makeIrClass(tt);  // sometimes not otherwise present
		wasm.gcTypeTable.addClass(toIrClass);

		var oobj = i_old.inputs[0], nobj = normRef1(oobj);
		if (context.compiler.DisableTypeChecks) return nobj;
		var t = classIdRange(tt), low = t.0, high = t.1;
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.put3("genClassCast: inst @%d  low %d  high %d", i_old.uid, low, high).outln();
		}
		if (low == high) {
			// no live classes can match, only null
			if (V3Op.needsNullCheck(i_old, oobj.dest)) {
				var cmp = curBlock.opNotEqual(ft, nobj, context.graph.nullConst(ft));
				apply(i_old.source, V3Op.newConditionalThrow(V3Exception.TypeCheck), [cmp]);
				return context.graph.nullConst(tt);
			}
			return addThrow(i_old.source, V3Exception.TypeCheck);
		}
		return genIfNull(i_old, mach.machType(tt), nobj, null, genClassIdCheckAndCast(i_old, low, high, _));
	}
	def genClassIdCheckAndCast(i_old: SsaApplyOp, low: int, high: int, i_new: SsaInstr) -> SsaInstr {
		var tagType = mach.tagType;
		var fromType = i_old.op.typeArgs[0];
		var field = IrField.new(fromType, tagType);
		field.machOffset = 0;  // flags a tag field
		var spec = IrSpec.new(fromType, null, field);
		var i_tid = apply(i_old.source, V3Op.newClassGetField(spec), [i_new]);
		curBlock.opIntRangeCheck(1, low, high, i_tid);
		var i_cast = apply(i_old.source, V3Op.newTypeCast(fromType, i_old.op.typeArgs[1]), [i_new]);
		return i_cast;
	}
	def genTypeQuery(i_old: SsaApplyOp, query: TypeQuery) -> SsaInstr {
		var ft = i_old.op.typeArgs[0], tt = i_old.op.typeArgs[1];
		if (V3.isClass(ft) && V3.isClass(tt)) {
			var oobj = i_old.inputs[0], nobj = normRef1(oobj);
			var t = classIdRange(tt), low = t.0, high = t.1;
			if (low == high) {
				// no live classes can match, and null is not an instance of
				return context.graph.falseConst();
			}
// EBM use first return to demo why REF_TEST does not work
//			return normId(i_old);
			return genIfNull(i_old, Bool.TYPE, nobj, null, genClassIdQuery(i_old, low, high, _));
		}
		return context.graph.trueConst();
	}
	def genClassIdQuery(i_old: SsaApplyOp, low: int, high: int, nobj: SsaInstr) -> SsaInstr {
		var tagType = mach.tagType;
		var fromType = i_old.op.typeArgs[0];
		var field = IrField.new(fromType, tagType);
		field.machOffset = 0;  // flags a tag field
		var spec = IrSpec.new(fromType, null, field);
		var i_tid = apply(i_old.source, V3Op.newClassGetField(spec), [i_old.input0()]);
		return genRangeQuery(i_old, low, high, i_tid);
	}
	def genRangeQuery(i_old: SsaApplyOp, low: int, high: int, val: SsaInstr) -> SsaInstr {
		if (high == low + 1) { // XXX: better factoring of degenerate range checks
			return apply(i_old.source, V3Op.newEqual(Int.TYPE), [val, context.graph.intConst(low)]);
		} else {
			var cmp1 = curBlock.opIntGteq(val, context.graph.intConst(low));
			var cmp2 = curBlock.opIntLt(val, context.graph.intConst(high));
			return apply(i_old.source, V3Op.opBoolAnd, [cmp1, cmp2]);
		}
	}
	def genTypeSubsume(i_old: SsaApplyOp) {
		var fromIrClass = mach.prog.ir.makeIrClass(i_old.op.typeArgs[0]);
		if (fromIrClass != null) wasm.gcTypeTable.addClass(fromIrClass);
		var toIrClass = mach.prog.ir.makeIrClass(i_old.op.typeArgs[1]);  // sometimes not otherwise present
		if (toIrClass != null) wasm.gcTypeTable.addClass(toIrClass);
		// Actually need the (static) type to change in Wasm code, so need a cast
		void(normId(i_old));
	}
	def genArrayAlloc(i_old: SsaApplyOp) -> SsaInstr {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.returnTypes[0]);
		return normId(i_old);
	}
	def genArrayInit(i_old: SsaApplyOp) -> SsaInstr {
		var arrayType = i_old.op.typeArgs[0];
		wasm.gcTypeTable.addHeapType(arrayType);
		return normId(i_old);
	}
	def genArrayTupleInit(i_old: SsaApplyOp, elems: int, length: int) -> SsaInstr {
		// should not happen since MixedArrays is turned off
		wasm.context.fail("genArrayTupleInit called but MixedArrays is false");
		return normId(i_old);	// satisfy compiler
	}
	def genArrayGetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return void(normId(i_old));
	}
	def genArraySetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return void(normId(i_old));
	}
	def genRangeStartPlusIndex(i_old: SsaApplyOp) -> SsaInstr {
		var rangeType = i_old.op.typeArgs[0];
		wasm.gcTypeTable.addHeapType(rangeType);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0];
		var rangeStart = inputs[1];
		var nindex = inputs[2]; // XXX: discarding upper words for normalized integers
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		var i_new: SsaInstr;
		if (CLOptions.PRINT_RA.get()) {
			var sp = SsaPrinter.new();
			sp.buf.put3("genRangeStartPlusIndex: rangeType %q  etype %q  itype %q", rangeType.render, etype.render, itype.render)
			      .put1("  wst %q", wst.render).ln();
			sp.buf.puts("  arr: ");
			sp.printInstrLn(narr);
			sp.buf.puts("  index: ");
			sp.printInstrLn(nindex);
			sp.flush();
		}

		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			if (narr.facts.V_ZERO) {
				i_new = ptrAdd(rangeStart, nindex);
			} else if (narr.facts.V_NON_ZERO) {
				i_new = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
			} else {
				var t = addIfNull(narr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var aresult = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var mresult = ptrAdd(rangeStart, nindex);
				tblock.addGoto(merge.block);

				curBlock = merge;
				i_new = curBlock.addPhi(itype, [aresult, mresult]);
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					if (narr.facts.V_ZERO) {
						var i_scale = context.graph.intConst(scale);
						var prod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						i_new = ptrAdd(rangeStart, prod);
					} else if (narr.facts.V_NON_ZERO) {
						i_new = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
					} else {
						var t = addIfNull(narr);
						var tblock = t.0, fblock = t.1, merge = t.2;
						curBlock = fblock;
						// if (nobj != null) generate the nonnull (array) case
						var aresult = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						fblock.addGoto(merge.block);

						// if (nobj == null) generate the null (memory) case
						curBlock = tblock;
						var i_scale = context.graph.intConst(scale);
						var mprod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var mresult = ptrAdd(rangeStart, mprod);
						tblock.addGoto(merge.block);

						curBlock = merge;
						i_new = curBlock.addPhi(itype, [aresult, mresult]);
					}
				}
				_ => {
					// no explicit null check needed
					i_new = apply(i_old.source, itype.opMul(), [rangeStart, nindex]);
				}
			}
		}
		map1(i_old, i_new);
		return i_new;
	}
	private def rangeLoad(source: Source, // for tagging generated instrs
			      narr: SsaInstr, // the array to access, null for pointer-based accesses
			      rangeStart: SsaInstr, // the pointer for pointer-based accesses, otherwise the array index where the range starts
			      nindex: SsaInstr, // index in the range of the item to access
			      rangeType: Type, // type of the array/range
			      itype: IntType,  // type for indexing that array/pointer (int now, but maybe long in the future)
			      loadType: Type,  // type of value to load (for pointers it may differ from the range element type)
			      kind: RangeKind // whethwr the range is array-only, pointer-only, or unknown at compile time
			     ) -> SsaInstr {
		// cases encodes whether to generate pointer only (1), array only (2), or run-time discriminated (3) code
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		if (CLOptions.PRINT_RA.get()) {
			var sp = SsaPrinter.new();
			sp.buf.put3("rangeLoad: rangeType %q  itype %q  loadType %q", rangeType.render, itype.render, loadType.render)
			      .put1("  kind %s", kind.name).outln();
			sp.buf.puts("  arr: ");
			sp.printInstrLn(narr);
			sp.buf.puts("  rangeStart: ");
			sp.printInstrLn(rangeStart);
			sp.buf.puts("  index: ");
			sp.printInstrLn(nindex).flush();
		}
		// op is usually needed
		var ta = [rangeType, itype];
		var op = Operator.new(Opcode.ArrayGetElem, ta, Function.siga(ta, etype));
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			var sum = apply(source, itype.opAdd(), [rangeStart, nindex]);
			match (kind) {
				PtrOnly => {
					wasm.usesMemory = true;
					return apply(null, V3Op.newPtrLoad(mach.data.ptrType, loadType), [sum]);
				}
				ArrayOnly => {
					return apply(null, op, [narr, sum]);
				}
				Unknown => {
					wasm.usesMemory = true;
					var t = addIfNull(narr);
					var tblock = t.0, fblock = t.1, merge = t.2;
					curBlock = fblock;
					// if (nobj != null) generate the nonnull (array) case
					var aresult = apply(null, op, [narr, sum]);
					fblock.addGoto(merge.block);

					// if (nobj == null) generate the null (memory) case
					curBlock = tblock;
					var mresult = apply(null, V3Op.newPtrLoad(mach.data.ptrType, loadType), [sum]);
					tblock.addGoto(merge.block);

					curBlock = merge;
					return curBlock.addPhi(etype, [aresult, mresult]);
				}
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					match (kind) {
						PtrOnly => {
							wasm.usesMemory = true;
							var prod = apply(source, itype.opMul(), [nindex, i_scale]);
							var sum = apply(source, itype.opAdd(), [rangeStart, prod]);
							return apply(source, V3Op.newPtrLoad(mach.data.ptrType, loadType), [sum]);
						}
						ArrayOnly => {
							var sum = apply(source, itype.opAdd(), [rangeStart, nindex]);
							return apply(source, op, [narr, sum]);
						}
						Unknown => {
							wasm.usesMemory = true;
							var t = addIfNull(narr);
							var tblock = t.0, fblock = t.1, merge = t.2;
							curBlock = fblock;
							// if (nobj != null) generate the nonnull (array) case
							var asum = apply(source, itype.opAdd(), [rangeStart, nindex]);
							var aresult = apply(source, op, [narr, asum]);
							fblock.addGoto(merge.block);

							// if (nobj == null) generate the null (memory) case
							curBlock = tblock;
							var mprod = apply(source, itype.opMul(), [nindex, i_scale]);
							var msum = apply(source, itype.opAdd(), [rangeStart, mprod]);
							var mresult = apply(source, V3Op.newPtrLoad(mach.data.ptrType, loadType), [msum]);
							tblock.addGoto(merge.block);

							curBlock = merge;
							return curBlock.addPhi(etype, [aresult, mresult]);
						}
					}
				}
				_ => {
					// no explicit null check needed
					var sum = apply(source, itype.opAdd(), [rangeStart, nindex]);
					return apply(null, op, [narr, sum]);
				}
			}
		}
	}
	private def rangeStore(source: Source, // for tagging generated instrs
			       narr: SsaInstr, // the array to access, null for pointer-based accesses
			       rangeStart: SsaInstr, // the pointer for pointer-based accesses, otherwise the array index where the range starts
			       nindex: SsaInstr, // index in the range of the item to access
			       nval: SsaInstr, // the value to store
			       rangeType: Type, // type of the array/range
			       itype: IntType,  // type for indexing that array/pointer (int now, but maybe long in the future)
			       storeType: Type,  // type of value to store (for pointers it may differ from the range element type)
			       kind: RangeKind // whethwr the range is array-only, pointer-only, or unknown at compile time
			      ) -> SsaInstr {
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		if (CLOptions.PRINT_RA.get()) {
			var sp = SsaPrinter.new();
			sp.buf.put3("rangeStore: rangeType %q  itype %q  storeType %q", rangeType.render, itype.render, storeType.render)
			      .put1("  kind %s", kind.name).outln();
			sp.buf.puts("  arr: ");
			sp.printInstrLn(narr);
			sp.buf.puts("  rangeStart: ");
			sp.printInstrLn(rangeStart);
			sp.buf.puts("  index: ");
			sp.printInstrLn(nindex);
			sp.buf.puts("  val: ");
			sp.printInstrLn(nval).flush();
		}
		// op is usually needed
		var ta = [rangeType, itype, etype];
		var op = Operator.new(Opcode.ArraySetElem, ta, Signature.new(null, ta, []));
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			var sum = apply(source, itype.opAdd(), [rangeStart, nindex]);
			match (kind) {
				PtrOnly => {
					wasm.usesMemory = true;
					return apply(null, V3Op.newPtrStore(mach.data.ptrType, storeType), [sum, nval]);
				}
				ArrayOnly => {
					return apply(null, op, [narr, sum, nval]);
				}
				Unknown => {
					wasm.usesMemory = true;
					var t = addIfNull(narr);
					var tblock = t.0, fblock = t.1, merge = t.2;
					curBlock = fblock;
					// if (nobj != null) generate the nonnull (array) case
					var aresult = apply(null, op, [narr, sum, nval]);
					fblock.addGoto(merge.block);

					// if (nobj == null) generate the null (memory) case
					curBlock = tblock;
					var mresult = apply(null, V3Op.newPtrStore(mach.data.ptrType, storeType), [sum, nval]);
					tblock.addGoto(merge.block);

					curBlock = merge;
					return null;  // caller should use remove instead of map1
				}
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					match (kind) {
						PtrOnly => {
							wasm.usesMemory = true;
							var prod = apply(source, itype.opMul(), [nindex, i_scale]);
							var sum = apply(source, itype.opAdd(), [rangeStart, prod]);
							return apply(source, V3Op.newPtrStore(mach.data.ptrType, storeType), [sum, nval]);
						}
						ArrayOnly => {
							var sum = apply(source, itype.opAdd(), [rangeStart, nindex]);
							return apply(source, op, [narr, sum, nval]);
						}
						Unknown => {
							wasm.usesMemory = true;
							var t = addIfNull(narr);
							var tblock = t.0, fblock = t.1, merge = t.2;
							curBlock = fblock;
							// if (nobj != null) generate the nonnull (array) case
							var asum = apply(source, itype.opAdd(), [rangeStart, nindex]);
							var aresult = apply(source, op, [narr, asum, nval]);
							fblock.addGoto(merge.block);

							// if (nobj == null) generate the null (memory) case
							curBlock = tblock;
							var mprod = apply(source, itype.opMul(), [nindex, i_scale]);
							var msum = apply(source, itype.opAdd(), [rangeStart, mprod]);
							var mresult = apply(source, V3Op.newPtrStore(mach.data.ptrType, storeType), [msum, nval]);
							tblock.addGoto(merge.block);

							curBlock = merge;
							return null;  // caller should use remove instead of map1
						}
					}
				}
				_ => {
					// no explicit null check needed
					var sum = apply(source, itype.opAdd(), [rangeStart, nindex]);
					return apply(null, op, [narr, sum, nval]);
				}
			}
		}
	}

	def genNormRangeGetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0], rangeStart = inputs[1], nindex = inputs[2], rangeType = i_old.op.typeArgs[0];
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		var cases: byte;
		if (!narr.facts.V_NON_ZERO) cases |= 1;  // not known to be array, so need pointer case
		if (!narr.facts.V_ZERO    ) cases |= 2;  // not known to be pointer, so need array case
		var i_new = rangeLoad(i_old.source, narr, rangeStart, nindex, rangeType, itype, etype, encodeRangeKind(cases));
		map1(i_old, i_new);
	}
	def genNormRangeSetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0], rangeStart = inputs[1], nindex = inputs[2], nval = inputs[3], rangeType = i_old.op.typeArgs[0];
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		var cases: byte;
		if (!narr.facts.V_NON_ZERO) cases |= 1;  // not known to be array, so need pointer case
		if (!narr.facts.V_ZERO    ) cases |= 2;  // not known to be pointer, so need array case
		var i_new = rangeStore(i_old.source, narr, rangeStart, nindex, nval, rangeType, itype, etype, encodeRangeKind(cases));
		if (i_new == null) {
			i_old.remove();
		} else {
			map1(i_old, i_new);
		}
	}
	private def genByteArrayLoads(source: Source, // for tagging generated instrs
				      accesses: Array<Access>, // accesses developed by decomposeByteArrayAccess
				      base: SsaInstr, // pointer- or array-based byte range
				      index: SsaInstr, // place in the range from which to load
				      rangeType: Type, // type of the range (base)
				      itype: IntType, // index type
				      tn: TypeNorm, // needed results
				      fieldType: Type, // type of field being loaded
				      isPointer: bool // whether base is a pointer
				      ) -> Array<SsaInstr> {
		var ai_results = Array<SsaInstr>.new(accesses.length);
		var zeroIdx = context.graph.valConst(itype, null);
		var kind = if(isPointer, RangeKind.PtrOnly, RangeKind.ArrayOnly);
		if (CLOptions.PRINT_RA.get()) {
			var sp = SsaPrinter.new();
			sp.buf.put3("genByteArrayLoads: rangeType %q  itype: %q  kind %s", rangeType.render, itype.render, kind.name)
			      .put1("  fieldType: %q", fieldType.render).ln();
			if (tn == null) sp.buf.puts("  tn: null").ln();
			else sp.buf.put1("  tn: %q", tn.render).ln();
			sp.buf.puts("  base: ");
			sp.printInstrLn(base);
			sp.buf.puts("  index: ");
			sp.printInstrLn(index);
			for (i < accesses.length) {
				sp.buf.put2("  accesses[%d]: %q", i, accesses[i].render).ln();
			}
			sp.flush();
		}
		for (i < accesses.length) {
			var a = accesses[i];
			match (a) {
				Simple(t, offset) => {
					var off = context.graph.valConst(itype, Box<int>.new(offset));
					var load = rangeLoad(source, base, index, off, rangeType, itype, t, kind);
					ai_results[i] = load;
				}
				Compound(t, wordType, datums) => {
					var d: SsaInstr, or = wordType.opOr(), shl = wordType.opShl();
					for (datum in datums) {
						var offset = context.graph.valConst(itype, Box<int>.new(datum.offset));
						var l = rangeLoad(source, base, index, offset, rangeType, itype, datum.t, kind);
						if (datum.t != wordType) l = curBlock.pure(V3Op.newIntViewI(datum.t, wordType), [l]);
						if (datum.shift > 0) l = curBlock.pure(shl, [l, context.graph.intConst(datum.shift)]);
						if (d != null) d = curBlock.pure(or, [d, l]);
						else d = l;
					}
					var op = getAccessViewOp(t, wordType);
					if (op != null) d = curBlock.pure(op, [d]);
					ai_results[i] = d;
				}
			}
		}
//		if (tn != null && tn.newType != fieldType) {
//			var op = getAccessViewOp(fieldType, tn.newType);
//			if (op != null) ai_results = [wideInputs(op, if(tn.size > 1, tn), ai_results, Fact.O_PURE)];
//		}
		return ai_results;
	}
	private def genByteArrayStores(source: Source, // source tag for generated code
				       accesses: Array<Access>, // accesses generated by ...
				       base: SsaInstr, // pointer or array
				       index: SsaInstr, // place from which to load
				       rangeType: Type,
				       itype: IntType, // index type
				       tn: TypeNorm, // needed results
				       fieldType: Type, // type of field being loaded
				       vals: Array<SsaInstr>, // values to store
				       isPointer: bool // whether base is a pointer
				      ) {
		var kind = if(isPointer, RangeKind.PtrOnly, RangeKind.ArrayOnly);
		if (CLOptions.PRINT_RA.get()) {
			var sp = SsaPrinter.new();
			sp.buf.put3("genByteArrayStores: rangeType %q  itype: %q  kind %s", rangeType.render, itype.render, kind.name)
			      .put1("  fieldType: %q", fieldType.render).ln();
			if (tn == null) sp.buf.puts("  tn: null").ln();
			else sp.buf.put1("  tn: %q", tn.render).ln();
			sp.buf.puts("  base: ");
			sp.printInstrLn(base);
			sp.buf.puts("  index: ");
			sp.printInstrLn(index);
			for (i < vals.length) {
				sp.buf.put1("  vals[%d]: ", i);
				sp.printInstrLn(vals[i]);
			}
			for (i < accesses.length) {
				sp.buf.put2("  accesses[%d]: %q", i, accesses[i].render).ln();
				sp.printInstrLn(vals[i]);
			}
			sp.flush();
		}
		for (i < accesses.length) {
			var a = accesses[i], i_val = vals[i];
			match (a) {
				Simple(t, offset) => {
					var offset = context.graph.intConst(offset);
					rangeStore(source, base, index, offset, i_val, rangeType, itype, t, kind);
				}
				Compound(t, wordType, datums) => {
					var shr = wordType.opShr();
					if (t != wordType) match (t) {
						x: FloatType => i_val = curBlock.pure(if(x.is64, V3Op.opIntViewF64, V3Op.opIntViewF32), [i_val]);
					}
					for (datum in datums) {
						var v = if(datum.shift == 0, i_val, curBlock.pure(shr, [i_val, context.graph.intConst(datum.shift)]));
						if (v.getType() != datum.t) match (datum.t) {
							x: IntType => v = curBlock.pure(V3Op.newIntViewI(v.getType(), datum.t), [v]);
						}
						var offset = context.graph.intConst(datum.offset);
						rangeStore(source, base, index, offset, v, rangeType, itype, datum.t, kind);
					}
				}
			}
		}
	}
	def genByteArrayGetField(i_old: SsaApplyOp, offset: int, order: ByteOrder) {
		var inputs = normRefs(i_old.inputs);
		var ni_arr = inputs[0], ni_start = inputs[1];
		var fieldType = i_old.op.typeArgs[0];

		var memoryOrder = if(mach.data.bigEndian, ByteOrder.BIG_ENDIAN, ByteOrder.LITTLE_ENDIAN);

		var tptr: (TypeNorm, Array<Access>);
		var tnptr: TypeNorm;
		var accessesPtr: Array<Access>;
		var tarr: (TypeNorm, Array<Access>);
		var tnarr: TypeNorm;
		var accessesArr: Array<Access>;
		var cases: byte;
		var numAccesses: int;
		if (!ni_arr.facts.V_NON_ZERO) {
			// we need the pointer case
			tptr = MachLowerings.decomposeByteArrayAccess(mach, config, fieldType, offset, order, memoryOrder, false);
			tnptr = tptr.0;
			accessesPtr = tptr.1;
			cases |= 1;
		}
		if (!ni_arr.facts.V_ZERO) {
			// we need the array case
			tarr = MachLowerings.decomposeByteArrayAccess(mach, config, fieldType, offset, order, memoryOrder, true);
			tnarr = tarr.0;
			accessesArr = tarr.1;
			cases |= 2;
		}
		var ai_results: Array<SsaInstr>;
		var rangeType = ni_arr.getType();
		var itype = Int.TYPE;
		var zeroIdx = context.graph.valConst(itype, null);
		var kind = encodeRangeKind(cases);

		if (CLOptions.PRINT_RA.get()) {
			var sp = SsaPrinter.new();
			sp.buf.put2("genByteArrayGetField: rangeType %q  itype %q", rangeType.render, itype.render)
			      .put3("  fieldType %q  kind %s  offset %d", fieldType.render, kind.name, offset)
			      .put1("  order %s", memoryOrder.name).ln();
			sp.buf.puts("  arr: ");
			sp.printInstrLn(ni_arr);
			sp.buf.puts("  start: ");
			sp.printInstrLn(ni_start);
			if (accessesPtr != null) {
				if (tnptr != null) sp.buf.put1("  tnptr: %q", tnptr.render).ln();
				for (i < accessesPtr.length) {
					sp.buf.put2("  accessesPtr[%d]: %q", i, accessesPtr[i].render).ln();
				}
			}
			if (accessesArr != null) {
				if (tnarr != null) sp.buf.put1("  tnarr: %q", tnarr.render).ln();
				for (i < accessesArr.length) {
					sp.buf.put2("  accessesArr[%d]: %q", i, accessesArr[i].render).ln();
				}
			}
			sp.flush();
		}

		match (kind) {
			PtrOnly => {
				var base = ni_start;
				var nullity = context.compiler.nullity(i_old, base);
				if (!nullity.O_NO_NULL_CHECK) genNullCheck0(i_old.source, base);
				ai_results = genByteArrayLoads(i_old.source, accessesPtr, base, zeroIdx, rangeType, itype, tnptr, fieldType, true);
				if (tnptr != null && tnptr.newType != fieldType) {
					var op = getAccessViewOp(fieldType, tnptr.newType);
					if (op != null) ai_results = [wideInputs(op, if(tnptr.size > 1, tnptr), ai_results, Fact.O_PURE)];
				}
			}
			ArrayOnly => {
				ai_results = genByteArrayLoads(i_old.source, accessesArr, ni_arr, ni_start, rangeType, itype, tnarr, fieldType, false);
				if (tnarr != null && tnarr.newType != fieldType) {
					var op = getAccessViewOp(fieldType, tnarr.newType);
					if (op != null) ai_results = [wideInputs(op, if(tnarr.size > 1, tnarr), ai_results, Fact.O_PURE)];
				}
			}
			Unknown => {
				var t = addIfNull(ni_arr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var resultsArr = genByteArrayLoads(i_old.source, accessesArr, ni_arr, ni_start, rangeType, itype, tnptr, fieldType, false);
				if (tnarr != null && tnarr.newType != fieldType) {
					var op = getAccessViewOp(fieldType, tnarr.newType);
					if (op != null) resultsArr = [wideInputs(op, if(tnarr.size > 1, tnarr), resultsArr, Fact.O_PURE)];
				}
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var base = ni_start;
				var nullity = context.compiler.nullity(i_old, base);
				if (!nullity.O_NO_NULL_CHECK) genNullCheck0(i_old.source, base);
				var resultsPtr = genByteArrayLoads(i_old.source, accessesPtr, base, zeroIdx, rangeType, itype, tnarr, fieldType, true);
				if (tnptr != null && tnptr.newType != fieldType) {
					var op = getAccessViewOp(fieldType, tnptr.newType);
					if (op != null) resultsPtr = [wideInputs(op, if(tnptr.size > 1, tnptr), resultsPtr, Fact.O_PURE)];
				}
				tblock.addGoto(merge.block);

				curBlock = merge;
				ai_results = Array<SsaInstr>.new(resultsArr.length);
				for (i < resultsArr.length) {
					ai_results[i] = curBlock.addPhi(resultsArr[i].getType(), [resultsArr[i], resultsPtr[i]]);
				}
			}
		}
		mapN(i_old, ai_results);
	}
	def genByteArraySetField(i_old: SsaApplyOp, offset: int, order: ByteOrder) { // TODO: byte order
		var inputs = normRefs(i_old.inputs);
		var ni_arr = inputs[0], ni_start = inputs[1], vals = Arrays.range(inputs, 2, inputs.length);
		var fieldType = i_old.op.typeArgs[0];

		var memoryOrder = if(mach.data.bigEndian, ByteOrder.BIG_ENDIAN, ByteOrder.LITTLE_ENDIAN);

		var tptr: (TypeNorm, Array<Access>);
		var tnptr: TypeNorm;
		var accessesPtr: Array<Access>;
		var tarr: (TypeNorm, Array<Access>);
		var tnarr: TypeNorm;
		var accessesArr: Array<Access>;
		var cases: byte;
		var numAccesses: int;
		if (!ni_arr.facts.V_NON_ZERO) {
			// we need the pointer case
			tptr = MachLowerings.decomposeByteArrayAccess(mach, config, fieldType, offset, order, memoryOrder, false);
			tnptr = tptr.0;
			accessesPtr = tptr.1;
			cases |= 1;
		}
		if (!ni_arr.facts.V_ZERO) {
			// we need the array case
			tarr = MachLowerings.decomposeByteArrayAccess(mach, config, fieldType, offset, order, memoryOrder, true);
			tnarr = tarr.0;
			accessesArr = tarr.1;
			cases |= 2;
		}
		var ai_results: Array<SsaInstr>;
		var rangeType = ni_arr.getType();
		var etype = V3Array.elementType(rangeType);
		var itype = Int.TYPE;
		var zeroIdx = context.graph.valConst(itype, null);
		var kind = encodeRangeKind(cases);
		
		if (CLOptions.PRINT_RA.get()) {
			var sp = SsaPrinter.new();
			sp.buf.put3("genByteArraySetField: rangeType %q  etype %q  itype %q", rangeType.render, etype.render, itype.render)
			      .put3("  fieldType %q  kind %s  offset %d", fieldType.render, kind.name, offset)
			      .put1("  order %s", memoryOrder.name).ln();
			sp.buf.puts("  arr: ");
			sp.printInstrLn(ni_arr);
			sp.buf.puts("  start: ");
			sp.printInstrLn(ni_start);
			for (i < vals.length) {
				sp.buf.put1("  vals[%d]: ", i);
				sp.printInstrLn(vals[i]);
			}
			if (accessesPtr != null) {
				if (tnptr!= null) sp.buf.put1("  tnptr: %q", tnptr.render).ln();
				for (i < accessesPtr.length) {
					sp.buf.put2("  accessesPtr[%d]: %q", i, accessesPtr[i].render).ln();
				}
			}
			if (accessesArr != null) {
				if (tnarr != null) sp.buf.put1("  tnarr: %q", tnarr.render).ln();
				for (i < accessesArr.length) {
					sp.buf.put2("  accessesArr[%d]: %q", i, accessesArr[i].render).ln();
				}
			}
			sp.flush();
		}

		match (kind) {
			PtrOnly => {
				var base = ni_start;
				var nullity = context.compiler.nullity(i_old, base);
				if (!nullity.O_NO_NULL_CHECK) genNullCheck0(i_old.source, base);
				if (tnptr != null && tnptr.newType != fieldType) {
					var op = getAccessViewOp(tnptr.oldType, fieldType);
					var atn = if(tnptr.size > 1, tnptr);
					if (op != null) vals = wideOutputs(op, atn, vals, Fact.O_PURE);
				}
				genByteArrayStores(i_old.source, accessesPtr, base, zeroIdx, rangeType, itype, tnptr, fieldType, vals, true);
			}
			ArrayOnly => {
				if (tnarr != null && tnarr.newType != fieldType) {
					var op = getAccessViewOp(tnarr.oldType, fieldType);
					var atn = if(tnarr.size > 1, tnarr);
					if (op != null) vals = wideOutputs(op, atn, vals, Fact.O_PURE);
				}
				genByteArrayStores(i_old.source, accessesArr, ni_arr, ni_start, rangeType, itype, tnarr, fieldType, vals, false);
			}
			Unknown => {
				var t = addIfNull(ni_arr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				var nvals = vals;

				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				if (tnarr != null && tnarr.newType != fieldType) {
					var op = getAccessViewOp(tnarr.oldType, fieldType);
					var atn = if(tnarr.size > 1, tnarr);
					if (op != null) nvals = wideOutputs(op, atn, vals, Fact.O_PURE);
				}
				genByteArrayStores(i_old.source, accessesArr, ni_arr, ni_start, rangeType, itype, tnptr, fieldType, nvals, false);
				fblock.addGoto(merge.block);

				nvals = vals;
				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				if (tnptr != null && tnptr.newType != fieldType) {
					var op = getAccessViewOp(tnptr.oldType, fieldType);
					var atn = if(tnptr.size > 1, tnptr);
					if (op != null) nvals = wideOutputs(op, atn, vals, Fact.O_PURE);
				}
				var base = ni_start;
				var nullity = context.compiler.nullity(i_old, base);
				if (!nullity.O_NO_NULL_CHECK) genNullCheck0(i_old.source, base);
				genByteArrayStores(i_old.source, accessesPtr, base, zeroIdx, rangeType, itype, tnarr, fieldType, nvals, true);
				tblock.addGoto(merge.block);

				curBlock = merge;
			}
		}
		i_old.kill();
		i_old.remove();
	}
	def genArrayGetLength(i_old: SsaApplyOp) -> SsaInstr {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return normId(i_old);
	}
	def genClassAlloc(i_old: SsaApplyOp, method: IrMethod) {
		// Leave the ClassAlloc for code gen, which will set the tag
		// If method is non-null, add call to the graph
		var classType = i_old.op.sig.returnTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
		// insert a copy of the current instr (so we can add *after*)
		var dests = Arrays.map(i_old.inputs, SsaDfEdge.getDest);
		var i_new = curBlock.addApply(i_old.source, i_old.op, dests);
		if (method != null) {
			var methodRef = V3Op.extractIrSpec(i_old.op, method);
			var funcRep = mach.funcRep(methodRef);
			var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
			var args = Arrays.prepend(func, Arrays.prepend(i_new, normRefs(i_old.inputs)));
			apply(i_old.source, V3Op.newCallClassMethod(methodRef), args);
		}
		map1(i_old, i_new);
	}
	def genVariantAlloc(i_old: SsaApplyOp) {
		// Leave the VariantAlloc for code gen, which adds the tag itself
		var classType = i_old.op.sig.returnTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
	}
	def genClassGetField(isVariant: bool, i_old: SsaApplyOp, field: IrField) {
		// Leave the ClassGetField for code gen
		var classType = i_old.op.sig.paramTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
		// Ben indicates that the multiple-types for a field should not happen on Wasm Gc;
		// it is for handing 64-bit numbers on 32-bit platforms.
	}
	def genClassSetField(i_old: SsaApplyOp, field: IrField, init: bool) {
		// Leave the ClassGetField for code gen
		var classType = i_old.op.sig.paramTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		return void(normId(i_old));
	}
	def genClassGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {
		genNullCheck(i_old);
		wasm.requestIndirectAdapter(method);
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		return context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
	}
	def genClassGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {
		// insure class is recorded
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and indirect adapters requested
		wasm.requestIndirectTable(selector.mtable);

		// pass through to code gen, after any required null check
		genNullCheck(i_old);
		return i_old;
	}
	def genVariantGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {
		wasm.requestIndirectAdapter(method);
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		return context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
	}
	def genVariantGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {
		// insure class is recorded
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and indirect adapters requested
		wasm.requestIndirectTable(selector.mtable);

		// pass through to code gen, after any required null check
		var i_new = genNullCheck(i_old);
		map1(i_old, i_new);
		return i_new;
	}
	def genComponentGetField(i_old: SsaApplyOp, field: IrField) {
		// Leave the ComponentGetField for code gen
		return void(normId(i_old));
	}
	def genComponentSetField(i_old: SsaApplyOp, field: IrField) {
		// Leave the ComponentSetField for code gen
		return void(normId(i_old));
	}
	def genBoundsCheck0(i_old: SsaApplyOp, nullity: Fact.set, narr: SsaInstr) -> (SsaInstr, Fact.set) {
		return (normId(i_old), nullity);
	}
	def genCallMethod(i_old: SsaApplyOp, method: IrMethod) {
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
		var args = Arrays.prepend(func, normRefs(i_old.inputs));

		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallClassMethod(i_old: SsaApplyOp, method: IrMethod) {
		genNullCheck(i_old);
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
		var args = Arrays.prepend(func, normRefs(i_old.inputs));

		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallClassSelector(i_old: SsaApplyOp, selector: IrSelector) {
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		// insure class type is entered
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and dispatch adapters requested
		wasm.requestDispatchTable(selector.mtable);
//		wasm.getDispatchTableNumber(selector.mtable);

		var args = normRefs(i_old.inputs);
		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallVariantSelector(i_old: SsaApplyOp, selector: IrSelector) {
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		// insure class type is entered
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and dispatch adapters requested
		wasm.requestDispatchTable(selector.mtable);
//		wasm.getDispatchTableNumber(selector.mtable);

		var args = normRefs(i_old.inputs);
		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallFunction(i_old: SsaApplyOp) {
//		wasm.context.fail("genCallFunction called");
		var funcRep = mach.getFuncRep(i_old.op.typeArgs[0]);
		var ptype = funcRep.machType;
		var args = normRefs(i_old.inputs);
		// essentially the same instruction; helps code below work
		var i_new = apply(i_old.source, i_old.op, args);
		wasm.anyCallFunctions = true;
		i_new.facts = i_new.facts | i_old.facts;
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genVariantGetTag(i_old: SsaApplyOp, nobj: SsaInstr) -> SsaInstr {
		var classType = i_old.op.sig.paramTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.put1("genVariantGetTag: classType %q", classType.render).outln();
		}
		if (irClass != null) wasm.gcTypeTable.addClass(irClass);
		return apply(i_old.source, V3Op.newVariantGetTag(i_old.op.typeArgs[0]), [nobj]);
	}
	def genNullCheck0(source: Source, nobj: SsaInstr) {
		if (SsaConst.?(nobj)) {
			var oval = SsaConst.!(nobj).val;
			if (oval == null) addThrow(source, V3Exception.NullCheck);
			return; // constant is non-null
		}
		explicitNullCheck(source, nobj.getType(), nobj);
	}
/*
	def call(i_old: SsaApplyOp, funcRep: Mach_FuncRep, args: Array<SsaInstr>) {
		if (curBlock.end) return;
		var i_new = apply(i_old.source, V3Op.newCallAddress(funcRep), args);
		i_new.facts = i_new.facts | i_old.facts;
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
*/
}
