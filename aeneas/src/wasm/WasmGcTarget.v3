// Copyright 2016-2025 Virgil authors.  All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// TODO(wasm): codegen system ops
// TODO(wasm): stacktrace reconstruction
// XXX(wasm): improve cfg optimizer
// XXX(wasm): default init of locals

component WasmGcComponent {
	new() {
		Aeneas.registerTarget(WasmGcTarget.new("wasm-gc-test", true));
		Aeneas.registerTarget(WasmGcTarget.new("wasm-gc", false));
	}}


// Globals consist of one region, which contains the globals, numbered 0, 1, 2, ...
def GLOBALS_SPACE = AddressSpace.new("globals", false, 32, 4, Alignment.new(1), Alignment.new(1));
def GLOBALS_REGION = Region.new("globals", GLOBALS_SPACE);

// Functions are grouped into (Wasm) tables, each table its own region
// There is one overall table, and one table for each Virgil method table (mtable)
def FUNCTIONS_SPACE = AddressSpace.new("functions", false, 32, 4, Alignment.new(1), Alignment.new(1));
def FUNCTIONS_REGION = Region.new("functions", FUNCTIONS_SPACE);	// the "main" table

// information about a dispatch table entry
type DispatchInfo {
	case Abstract(method: IrMethod) {
		// a method with no implementation
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put1("dispatch function abstract method %q", method.render);
		}
	}
	case Absolute(method: IrMethod, funcIndex: u32) {
		// a function known in advance
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put2("dispatch function %d method %q", funcIndex, method.render);
		}
	}
	case Relative(method: IrMethod, adapterIndex: u32) {
		// an adapter, relative to the dispatch adapter base
		def render(buf: StringBuilder) -> StringBuilder {
			return buf.put2("dispatch adapter %d method %q", adapterIndex, method.render);
		}
	}
	def render(buf: StringBuilder) -> StringBuilder;
}

type TableKind {
	case Indirect0;
	case Indirect(rootSig: Signature);
	case Dispatch(rootReceiver: Type, rootSig: Signature);
}

// Different kinds of Wasm functions we generate
enum FunctionInfoKind { AllocStub, EntryStub, Method, Indirect, Dispatch }

// For entries in data structures related to outputting functions and tables
class FunctionInfo {
	def kind: FunctionInfoKind;
	def rcvr: Type;
	def sig: Signature;
	def sigIndex: u32;
	def method: IrMethod;
	var funcIndex: int;  // may start -1 and be assigned later
	new(kind, rcvr, sig, sigIndex, method, funcIndex) { }
	def render (sb: StringBuilder) -> StringBuilder {
		var sidx = int.!(sigIndex) - 1;
		match (kind) {
			AllocStub => return sb.put3("Alloc Stub sig: %q  sigidx: %d  func #%d",
						    sig.funcType().render, sidx, funcIndex);
			EntryStub => return sb.put3("Entry Stub sig: %q  sigidx: %d  func #%d",
						    sig.funcType().render, sidx, funcIndex)
					      .put2("  rcvr: %q  main: %q",
						    rcvr.render, method.render);
			Method => return sb.put3("Method sig: %q  sigidx: %d  func #%d",
						 sig.funcType().render, sidx, funcIndex)
					   .put2("  rcvr: %q  method: %q",
						 rcvr.render, method.render);
			Indirect => return sb.put3("Indirect sig: %q  sigidx: %d  func #%d",
						   sig.funcType().render, sidx, funcIndex)
					     .put2("  rcvr: %q  method: %q",
						   rcvr.render, method.render);
			Dispatch => return sb.put3("Dispatch sig: %q  sigidx: %d  func #%d",
						   sig.funcType().render, sidx, funcIndex)
					     .put2("  rcvr: %q  method: %q",
						   rcvr.render, method.render);
		}
	}
}

// Started from a copy of class WasmTarget
class WasmGcTarget extends Target {
	def test: bool;

	new(name: string, test) super(name) {
		typedMain = !test;
		requireMain = false;
	}

	def configureCompiler(compiler: Compiler) {
		WasmComponent.includeSection = WasmComponent.getSectionFlags(CLOptions.WASMGC_SECTIONS.get());
		WasmComponent.printSection = WasmComponent.getSectionFlags(CLOptions.PRINT_WASMGC.get());

		compiler.Reachability = true;
		compiler.NormConfig.setSignatureLimits(10000, if(CLOptions.WASM_MULTI_VALUE.val, 1000, 1));
		compiler.NormConfig.GetScalar = getScalar;

		// added for WASM-GC
		compiler.NormConfig.MixedArrays = false;
		compiler.NormConfig.ArrayLengthType = Int.getType(true, 32);
		compiler.NormConfig.ArrayIndexType = Int.getType(true, 32);
		compiler.NormConfig.RangeStartType = Int.getType(true, 32);	// 64-bit memories?
		// compiler.unboxVariantsOpt = false;	// EBM: can't change it here
		// compiler.DisableBoundsChecks = true;	// leave since there can be residual checks
		// compiler.DisableNullChecks = true;	// EBM: look into this
		// compiler.DisableLengthChecks = true;	// EBM: look into this
	}
	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {
		match (t) {
			x: EnumType => return if(x.enumDecl.tagType.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R32, once packed refs
			x: EnumSetType => return if(x.repType.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R32, once packed refs
			x: BoolType => return Scalar.B32;
			x: IntType => return if(x.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64);
			x: FloatType => return if(x.is64, Scalar.F64 | Scalar.B64, Scalar.F32 | Scalar.B32);
			// EBM: concerned about too many things matching the default ...
			// EBM: e.g., what about VoidType?
			_ => return Scalar.Ref;
		}
	}
	def configureProgram(prog: Program) {
		def intNorm = IntNormalizers.I64LE;
		var mach = MachProgram.new(prog, FUNCTIONS_SPACE, GLOBALS_SPACE, intNorm);
		prog.tprog = mach;
		MachModule.install(prog, mach);
		mach.runtime = MachRuntime.new(mach);
		// EBM: Note that Pointer use is somewhat limited on WasmGc (these restrictions are
		// not all set up yet)
		// - atContents and atElement work only on off heap ranges (give bounds trap otherwise)
		// - atObject is prohibited
		// - atField works on on off heap Refs
		var cirt = CiRuntime_TypeCon.new(MachModule.PTR_32.create0(), prog.typeCache);
		prog.typeEnv.add(cirt);
	}
	def emit(compiler: Compiler, prog: Program) {
		var context = SsaContext.new(compiler, prog);
		var rt = getRuntime(prog);
		var e: ExecuteTestCase;
		if (test) {
			e = SpecParser.parseFile(prog.ERROR, prog.files[0], prog.inputs[0]);
			rt.heapSize = e.heapSize;
		}
		var w = emitWasmModule(context, rt);
		if (test) emitTestWrappers(context, rt, w, e);
		if (CLOptions.WASM_RUN_COMMAND.val != null) emitEngineScript(CLOptions.WASM_RUN_COMMAND.val, compiler, prog);
	}
	def emitWasmModule(context: SsaContext, rt: MachRuntime) -> DataWriter {
		def pageSize = CLOptions.WASM_PAGE_SIZE.get();
		if (!Ints.isPowerOf2(pageSize)) context.fail1("expected -wasm.page-size option to be a power of 2, got %d", pageSize);

		def prog = context.prog;

		def wasm = WasmGcProgram.new(rt.mach, context, test);

		// Lower to machine level from V3 level
		def config = MachLoweringConfig.new();
		config.MachLoweringFactory = WasmGcLowering.new(wasm, this, _, _, _);
		config.ImplicitNullChecks = true;
		config.ExplicitDivChecks = false;
		config.Int32Arith = true;
		config.Int64Arith = true;
		config.IntCastFTraps = true;
		config.NativeCmpSwp = false;

		// EBM: MachProgram has some useful data structures and functions;
		// build populates things and gets components in the record queue;
		// it runs lowering, though WasmGcLowering handles some ops
		rt.mach.build(context.compiler, config);

		// (0) Populate type table
		//--------------------------------------------------------------------------------
		// This captures most types, though some may be seen only later when going through
		// IR instructions.

		// Go through all of the heap types
		// Note: importantly this processes the classes *first*, so they will be known
		// when going through other things
		if (WasmComponent.printSection.TYPE)
			prog.ERROR.addError(null, null, "Type Section", "========== Adding types from IR ==========");
		addIrTypes(prog.ir, wasm);
		if (WasmComponent.printSection.TYPE)
			prog.ERROR.addError(null, null, "Type Section", "========== Assigning type indices ==========");
		wasm.gcTypeTable.assignTypeIndices();
		// if printing out information, add source strings
		if (WasmComponent.printSection.TYPE) {
			for (i < prog.ir.classes.length) {
				var cls = prog.ir.classes[i];
				var ctype = cls.ctype;
				var name = wasm.getClassName(ctype);
				var wht = wasm.gcTypeTable.heapTypeMap[ctype];
				wht.source = StringBuilder.new().put1("class/type %s", name).extract();
			}
			for (i < prog.ir.methods.length) {
				var m = prog.ir.methods[i];
				var ms = m.source;
				if (ms == null) continue;
				var sig = wasm.getSig(m.receiver, m.sig);
				var wht = wasm.gcTypeTable.addSignature(sig);
				var name = wasm.getMethodName(m);
				wht.source = StringBuilder.new().put1("method %s", name).extract();
			}
		}

		def initialSize = 300;

		// pageAlign does not mean much for WasmGc
		def out = WasmSectionBuffer.new(Alignment.new(1), initialSize);

		// (1) Encode the WASM header
		//--------------------------------------------------------------------------------
		out.put_b32(WasmCommon.WASM_MAGIC);
		out.put_b32(WasmCommon.WASM_VERSION);

		var sizepos: int, start: int;

		// Add the allocation stub if the program might dynamically
		// allocate memory.
		def m = rt.mach;

		// Will get info about each function, in Wasm order
		def functionInfos = Vector<FunctionInfo>.new();

		// Add all the method signatures to the signatures vector and
		// sort the method array.
		// This will include the allocation and entry stubs (if any)
		// and all non-imported functions.
		def methods = wasm.addIrMethods(functionInfos);

		// The work of these MachProgram calls is done in this module
		// since WasmGc has rather different notions about data,
		// addresses, and so on.

		layoutAllRecordsAndFuncs(m);

		m.methodMap.apply(processMethodMapEntry(wasm, _, _));

		// Generate WASM code into the code buffer. Lowering populates
		// the signatures and requests individual indirect adapters,
		// and indirect and dispatch tables, which must happen before
		// these can be emitted.
		def codebuf = MachDataWriter.new(Alignment.new(1), 0, initialSize);

		// Lowering has set up individual indirectly-referenced
		// functions.  These go into table 0.
		def numIndividualIndirectAdapters = wasm.indirectAdapterRequests.length;
		def needTable0 = (numIndividualIndirectAdapters > 0);
		def table0Infos: Vector<FunctionInfo> = if(needTable0, Vector<FunctionInfo>.new(), null);
		def tableInfos = Vector<(TableKind, Vector<FunctionInfo>)>.new();
		if (needTable0) {
			for (i < numIndividualIndirectAdapters) {
				var meth = wasm.indirectAdapterRequests[i];
				var findex = functionInfos.length;
				wasm.indirectAdapterFor[meth] = findex;
				wasm.indirectAdapterIndexFor[meth] = i + 1;  // + 1 to skip the null entry
				var sigIdx = wasm.addSig(AnyRef.TYPE, meth.sig);
				var fi = FunctionInfo.new(FunctionInfoKind.Indirect, AnyRef.TYPE, meth.sig, sigIdx, meth, findex);
				table0Infos.put(fi);
				functionInfos.put(fi);
				if (WasmComponent.printSection.FUNCTION ||
				    WasmComponent.printSection.TABLE ||
				    WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put1("Adding Adapter %q", fi.render);
					prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
				}
			}
			tableInfos.put((TableKind.Indirect0, table0Infos));
		}
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put2("# of individual indirect adapters = %d, will %semit a table",
							  numIndividualIndirectAdapters, if(needTable0, "", "not "));
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		var nextTableNum = tableInfos.length;

		// Add all the indirect adapter methods from method tables.
		// This also adds their signatures.
		def firstIndirectTable = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# of indirect tables = %d", wasm.indirectTableRequests.length);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		for (i < wasm.indirectTableRequests.length) {
			var mtable = wasm.indirectTableRequests[i];
			if (WasmComponent.printSection.FUNCTION ||
			    WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Indirect table %d for %q", nextTableNum, mtable.render);
				prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
			wasm.indirectTableFor[mtable] = nextTableNum++;
			var finfos = Vector<FunctionInfo>.new();
			var rootSig: Signature = null;
			for (m in mtable.table) {
				if (m == null) continue;
				if (rootSig == null) rootSig = m.sig;
				wasm.requestIndirectAdapter(m);
				var findex = functionInfos.length;
				wasm.indirectAdapterFor[m] = findex;
				var sigIdx = wasm.addSig(AnyRef.TYPE, m.sig);
				var fi = FunctionInfo.new(FunctionInfoKind.Indirect, AnyRef.TYPE, m.sig, sigIdx, m, findex);
				finfos.put(fi);
				functionInfos.put(fi);
				if (WasmComponent.printSection.FUNCTION ||
				    WasmComponent.printSection.TABLE ||
				    WasmComponent.printSection.CODE) {
					var sb = StringBuilder.new().put1("Adding Adapter %q", fi.render);
					prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
				}
			}
			tableInfos.put((TableKind.Indirect(rootSig), finfos));
		}

		// Add all the dispatch adapter methods from method tables.
		// This also add the signature of the root method, which is
		// the signature of all the other dispatch methods.
		def firstDispatchTable = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# of dispatch tables = %d", wasm.dispatchTableRequests.length);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}
		for (i < wasm.dispatchTableRequests.length) {
			// EBM build table entries and assign function numbers
			var mtable = wasm.dispatchTableRequests[i];
			if (WasmComponent.printSection.FUNCTION ||
			    WasmComponent.printSection.TABLE ||
			    WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Dispatch table %d for %q", nextTableNum, mtable.render);
				prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
			}
			var tableNum = nextTableNum++;
			wasm.dispatchTableFor[mtable] = tableNum;

			var root = mtable.root;
			var sigIdx = wasm.addSig(root.receiver, root.sig);	// make sure signature is present
			var superIdx = root.machIndex;
			// superIdx *can* be -1 (e.g., for an ADT with an empty-body default for a method)
			var funcInfo: FunctionInfo = if(superIdx < 0, null, functionInfos[superIdx]);
			var dispIdx = superIdx;
			var entryNum = 0;
			var tableInfo = Vector<FunctionInfo>.new();
			for (m in mtable.table) {
				if (m == null) continue;
				var name = if(WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT,
					      wasm.getMethodName(m), null);
				var mFuncIdx = m.machIndex;
				if (mFuncIdx != superIdx) {
					// New dispatch adapter needed
					dispIdx = functionInfos.length;
					funcInfo = FunctionInfo.new(FunctionInfoKind.Dispatch, m.receiver, m.sig, sigIdx, m, dispIdx);
					functionInfos.put(funcInfo);
					// The dispatch adapter is its own Wasm function
					if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
						var sb = StringBuilder.new().put1("Adding Adapter %q", funcInfo.render);
						prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
					}
					superIdx = mFuncIdx;  // for next iteration
				}
				tableInfo.put(funcInfo);
				wasm.dispatchAdapterFor[m] = dispIdx;
				if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put2("Adding dispatch table entry for %s; func #%d", name, mFuncIdx)
								    .put2(" table %d entry %d", tableNum, entryNum);
					prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
				}
				entryNum++;
			}
			tableInfos.put((TableKind.Dispatch(root.receiver, root.sig), tableInfo));
		}
		def numTables = nextTableNum;
		if (WasmComponent.printSection.FUNCTION ||
		    WasmComponent.printSection.TABLE ||
		    WasmComponent.printSection.CODE) {
			var sb = StringBuilder.new().put1("# tables = %d", numTables);
			prog.ERROR.addError(null, null, "Function/Table/Code Section", sb.extract());
		}

		// Now that we have figured out the adapters, we can emit code
		if (WasmComponent.includeSection.CODE) {
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Building code buffer ==========");
			var codegen = WasmGcCodeGen.new(context, wasm, rt, codebuf);
	                rt.recordCodeStart(codebuf.addr_end());
			for (i < functionInfos.length) {
				var fi = functionInfos[i];
				match (fi.kind) {
					AllocStub => {
						codegen.emitAllocationStub();
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
					EntryStub => {
						codegen.emitEntryStub(test);
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
					Method => {
						codegen.emitWasm(fi.method, fi.funcIndex);
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
					Indirect => {
						codegen.emitIndirectAdapter(fi.method);
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting Adapter %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
					Dispatch => {
						codegen.emitDispatchAdapter(fi.method);
						if (WasmComponent.printSection.CODE) {
							var sb = StringBuilder.new().put2("Emitting Adapter %q (check: %d)", fi.render, i);
							prog.ERROR.addError(null, null, "Code Section", sb.extract());
						}
					}
				}
			}

	                rt.recordCodeEnd(codebuf.addr_end());
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Done building code buffer ==========");
		}

		// (2) Emit types
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.TYPE) {
			out.startSection(WasmSection.TYPE.code);
			out.put_uleb32(u32.!(wasm.gcTypeTable.typeGroups.length));
			wasm.gcTypeTable.emit(out);
			out.endSection();
		}

		// (3) Emit imports
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.IMPORT) {
			if (wasm.numImports > 0) {
				out.startSection(WasmSection.IMPORT.code);
				out.put_sleb32(wasm.numImports);
				if (WasmComponent.printSection.IMPORT) {
					var sb = StringBuilder.new().put1("========== Emitting %d imports ==========", wasm.numImports);
					prog.ERROR.addError(null, null, "Import Section", sb.extract());
				}
				for (i = 0; i < wasm.numImports; i++) {
					var m = methods[i];
					var compName = VstComponent.!(m.source.receiver).importName.image;
					var methName = m.source.importName.image;
					var sigidx = wasm.getSigIndex(m);
					out.importName(compName);
					out.importName(methName);
					out.putb(/*Function import*/0);
					out.put_uleb32(sigidx);
					if (WasmComponent.printSection.IMPORT) {
						var sb = StringBuilder.new().put3("Function sig #%d %s.%s", sigidx, compName, methName);
						prog.ERROR.addError(null, null, "Import Section", sb.extract());
					}
				}
				out.endSection();
				if (WasmComponent.printSection.IMPORT) {
					var sb = StringBuilder.new().put1("========== Done ==========", wasm.numImports);
					prog.ERROR.addError(null, null, "Import Section", sb.extract());
				}
			} else {
				if (WasmComponent.printSection.IMPORT)
					prog.ERROR.addError(null, null, "Import Section", "========== Not emitting (no imports) ==========");
			}
		}

		// (4) Emit function signature declarations
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.FUNCTION) {
			out.startSection(WasmSection.FUNCTION.code);

			var nfsigs = functionInfos.length;
			out.put_sleb32(nfsigs);
			if (WasmComponent.printSection.FUNCTION) {
				var sb = StringBuilder.new().put1("========== Emitting %d function signature indexes ==========", nfsigs);
				prog.ERROR.addError(null, null, "Function Section", sb.extract());
			}

			for (i < nfsigs) {
				var fi = functionInfos[i];
				out.put_sleb32(int.!(fi.sigIndex) - 1);
				if (WasmComponent.printSection.FUNCTION) {
					var sb = StringBuilder.new().put1("Function sig index for %q", fi.render);
					prog.ERROR.addError(null, null, "Function Section", sb.extract());
				}
			}

			out.endSection();
			if (WasmComponent.printSection.FUNCTION)
				prog.ERROR.addError(null, null, "Function Section", "========== Done ==========");
		}

		// (5) Emit tables
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.TABLE) {
			def ntables = tableInfos.length;
			if (WasmComponent.printSection.TABLE) {
				var sb = StringBuilder.new().put1("========== Emitting %d tables ==========", ntables);
				prog.ERROR.addError(null, null, "Table Section", sb.extract());
			}
			out.startSection(WasmSection.TABLE.code);
			out.putb(ntables);  // number of tables
			for (i < ntables) {
				var entry = tableInfos[i];
				var kind = entry.0; var tab = entry.1;
				match (kind) {
					Indirect0 => {
						var len = u32.!(tab.length + 1);  // + 1 for the null entry
						if (WasmComponent.printSection.TABLE) {
							var sb = StringBuilder.new().put2("Indirect function table 0 (#%d); num entries %d", i, len);
							prog.ERROR.addError(null, null, "Table Section", sb.extract());
						}

						out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
						out.putb(1);	// flags = contains maximum
						out.put_uleb32(len);  // initial table length
						out.put_uleb32(len);  // maximum table length
					}
					Indirect(rootSig) => {
						var sigidx = wasm.addSig(AnyRef.TYPE, rootSig);
						var fsig = wasm.getSig(AnyRef.TYPE, rootSig);
						var wft = wasm.gcTypeTable.addSignature(fsig);
						var wvt = WasmValueType.RefNull(wft);

						var count = u32.!(tab.length);
						if (WasmComponent.printSection.TABLE) {
							var sb = StringBuilder.new().put2("Indirect table #%d; num entries %d", i, count)
										    .put2("  sig: %q  sigIdx: %d", rootSig.funcType().render, sigidx);
							prog.ERROR.addError(null, null, "Table Section", sb.extract());
						}
						if (count == 0) {
							// an empty table??
							out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
							out.putb(1);	// flags = contains maximum
							out.put_uleb32(0);  // initial table length
							out.put_uleb32(0);  // maximum table length
							continue;
						}
						wvt.put(out);
						out.putb(1);	// flags = contains maximum
						out.put_uleb32(count);
						out.put_uleb32(count);
					}
					Dispatch(rootRcvr, rootSig) => {
						var sigidx = wasm.addSig(rootRcvr, rootSig);
						var fsig = wasm.getSig(rootRcvr, rootSig);
						var wft = wasm.gcTypeTable.addSignature(fsig);
						var wvt = WasmValueType.RefNull(wft);
						var count = u32.!(tab.length);

						if (WasmComponent.printSection.TABLE) {
							var sb = StringBuilder.new().put2("Dispatch table #%d; num entries %d", i, count)
										    .put3("  rcvr: %q  sig: %q  sigIdx: %d", rootRcvr.render, rootSig.funcType().render, sigidx);
							prog.ERROR.addError(null, null, "Table Section", sb.extract());
						}
						if (count == 0) {
							out.putb(WasmTypeConCode.FUNCREF.code);  // type of table
							out.putb(1);	// flags = contains maximum
							out.put_uleb32(0);  // initial table length
							out.put_uleb32(0);  // maximum table length
							continue;
						}
						wvt.put(out);
						out.putb(1);	// flags = contains maximum
						out.put_uleb32(u32.!(count));
						out.put_uleb32(u32.!(count));
					}
				}
			}
			out.endSection();
			if (WasmComponent.printSection.TABLE)
				prog.ERROR.addError(null, null, "Table Section", "========== Done ==========");
		} else {
			if (WasmComponent.printSection.TABLE)
				prog.ERROR.addError(null, null, "Table Section", "========== Not emitted (no tables) ==========");
		}
			
		// (6) Emit memory section
		//--------------------------------------------------------------------------------
		var hasMemorySection = false;
		if (WasmComponent.includeSection.MEMORY) {
			if (m.allocates && rt.heapSize == 0) {
				rt.heapSize = 65536;	// min of one page to allocate into
			}
			var totalSize = rt.heapSize + rt.shadowStackSize;
			if (totalSize > 0) {
				hasMemorySection = true;
				if (WasmComponent.printSection.MEMORY)
					prog.ERROR.addError(null, null, "Memory Section", "========== Emitting ==========");
				out.startSection(WasmSection.MEMORY.code);
				out.putb(1);	// 1 memory
				// Compute the maximum accessible data address, and from that the pages needed
				var maxDataAddr = u32.!(rt.heapSize + rt.shadowStackSize);
				var pages = (maxDataAddr + pageSize - 1u) / pageSize;
				var flags = 1;
				if (pageSize != 65536) flags |= 1 << 3;		// custom page size
				out.putb(flags);				// flags = contains maximum
				out.put_uleb32(pages);				// initial memory size
				out.put_uleb32(pages);				// maximum memory size
				if (pageSize != 65536) {
					out.put_uleb32(u32.!(Ints.log(pageSize))); // page size log
				}
				if (WasmComponent.printSection.MEMORY) {
					var sb = StringBuilder.new().put2("Size = %d (0x%x) bytes", maxDataAddr, maxDataAddr)
								    .put2(", %d (0x%x) pages", pages, pages)
								    .put2(", page size %d (0x%x) bytes", pageSize, pageSize);
					prog.ERROR.addError(null, null, "Memory Section", sb.extract());
					prog.ERROR.addError(null, null, "Memory Section", "========== Done ==========");
				}
				out.endSection();
			} else {
				if (WasmComponent.printSection.MEMORY)
					prog.ERROR.addError(null, null, "Memory Section", "========== Not emitted (no allocation, etc.) ==========");
			}
		}

		// (7) Emit the export section
		//--------------------------------------------------------------------------------
		var mainMeth = prog.getMain();
		var numExports = 0;		  // default exports: main and maybe memory
		var mainIndex: int;
		var mainName: string;
		if (mainMeth != null) {
			mainIndex = mainMeth.asMethod().machIndex;
			mainName = CLOptions.MAIN_EXPORT.get();

			if (wasm.entryStubFuncIndex >= 0) {
				mainIndex = wasm.entryStubFuncIndex;
				mainName = if(test, mainName, CLOptions.ENTRY_EXPORT.get());
			}
			numExports = 1;
		}
		if (CLOptions.WASM_EXPORT_MEM.val && hasMemorySection) numExports++;
		for (i < prog.ir.roots.length) {
			var r = prog.ir.roots[i];
			if (r.name != null) numExports++;
		}

		if (WasmComponent.includeSection.EXPORT) {
			if (numExports > 0) {
				if (WasmComponent.printSection.EXPORT) {
					var sb = StringBuilder.new().put1("========== Emitting %d exports ==========", numExports);
					prog.ERROR.addError(null, null, "Export Section", sb.extract());
				}
				var exportIndex = 0;
				out.startSection(WasmSection.EXPORT.code);
				out.putb(numExports);
				if (mainMeth != null) {
					// export main
					out.str(mainName);
					out.putb(WasmExternal.FUNCTION);
					out.put_sleb32(mainIndex);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put3("Export #%d: function %s, function #%d (main)", exportIndex++, mainName, mainIndex);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				// export memory
				if (CLOptions.WASM_EXPORT_MEM.val && hasMemorySection) {
					out.str("memory");
					out.putb(WasmExternal.MEMORY);
					out.put_uleb32(0);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put1("Export #%d: memory 0", exportIndex++);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				// export the rest of exported functions
				for (i < prog.ir.roots.length) {
					var r = prog.ir.roots[i];
					if (r.name == null) continue;
					out.importName(r.name);
					out.putb(WasmExternal.FUNCTION);
					var findex = r.spec.asMethod().machIndex;
					out.put_sleb32(findex);
					if (WasmComponent.printSection.EXPORT) {
						var sb = StringBuilder.new().put3("Export #%d: function %s, function #%d", exportIndex++, r.name, findex);
						prog.ERROR.addError(null, null, "Export Section", sb.extract());
					}
				}
				if (WasmComponent.printSection.EXPORT)
					prog.ERROR.addError(null, null, "Export Section", "========== Done ==========");
				out.endSection();
			}
		}

		// (8) Emit the function table entries (Element Section)
		// This includes indirect and dispatch adapter tables for each class that needs them
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.ELEMENT) {
			def ntables = u32.!(tableInfos.length);
			if (ntables > 0) {
				if (WasmComponent.printSection.ELEMENT) {
					var sb = StringBuilder.new().put1("========== Emitting %d element groups ==========", ntables);
					prog.ERROR.addError(null, null, "Element Section", sb.extract());
				}
				out.startSection(WasmSection.ELEMENT.code);
				out.put_uleb32(ntables);
				for (i < ntables) {
					var entry = tableInfos[int.!(i)];
					var kind = entry.0; var tab = entry.1;
					match (kind) {
						Indirect0 => {
							def nentries = u32.!(tab.length);
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put2("Indirect function table (global) (#%d); # entries %d (including null first slot)", i, nentries + 1);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							// Indirect function table (global)
							if (i == 0) {
					 			out.putb(0);  // Elements kind is "Active Zero: start offset is an expression, table number is 0"
							} else {
								out.putb(2);  // Elements kind is "Active: start offset is an expression, table number is given"
								out.put_uleb32(i);  // table number
							}
							// start init expr for base index of elements
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(1);  // start index of elements; 0 is reserved for null function
							out.putb(WasmOp.END.opcode);
							// end init expr
							if (i != 0) out.putb(0);  // kind byte (0 required)
							// count of entries, followed by their values (function numbers)
							out.put_uleb32(nentries);
							for (j < nentries) {
								var entry = tab[int.!(j)];
								out.put_uleb32(u32.!(entry.funcIndex));
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Indirect function element %d function %d method %s",
													  j + 1, entry.funcIndex, wasm.getMethodName(entry.method));
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
						Indirect(rootSig) => {
							def nentries = u32.!(tab.length);
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put2("Indirect function table (#%d); # entries %d", i, nentries);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							// Indirect function table for a method
							if (i == 0) {
								out.putb(0);  // Elements kind is "Active Zero: start offset is an expression, table number is 0"
							} else {
					 			out.putb(2);  // Elements kind is "Active Index: start offset is an expression, table number is explicit"
								out.put_uleb32(i);  // table number
							}
							// start init expr for base index of elements
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(0);  // start index of elements: 0
							out.putb(WasmOp.END.opcode);
							// end init expr
							if (i != 0) out.putb(0);  // element kind: 0
							// count of entries, followed by their values (function numbers)
							out.put_uleb32(nentries);
							for (j < nentries) {
								var entry = tab[int.!(j)];
								out.put_uleb32(u32.!(entry.funcIndex));
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Indirect function element %d function %d method %s",
													  j, entry.funcIndex, wasm.getMethodName(entry.method));
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
						Dispatch(rootRcvr, rootSig) => {
							def fsig = wasm.getSig(rootRcvr, rootSig);
							def wft = wasm.gcTypeTable.addSignature(fsig);
							def wvt = WasmValueType.RefNull(wft);
							def nentries = u32.!(tab.length);
							if (WasmComponent.printSection.ELEMENT) {
								var sb = StringBuilder.new().put2("Dispatch function table (#%d); # entries %d", i, nentries);
								prog.ERROR.addError(null, null, "Element Section", sb.extract());
							}
							// Dispatch function table for a method
				 			out.putb(6);  // Elements kind is "Active Expr Index: start offset is an expression, table number is explicit"
							out.put_uleb32(i);  // table number
							// start init expr for base index of elements
							out.putb(WasmOp.I32_CONST.opcode);
							out.putb(0);  // start index of elements: 0
							out.putb(WasmOp.END.opcode);
							// end init expr
							wvt.put(out);  // type of function pointers in table
							// count of entries, followed by their values (function numbers)
							out.put_uleb32(nentries);
							for (j < nentries) {
								var entry = tab[int.!(j)];
								out.putb(WasmOp.REF_FUNC.opcode);
								out.put_uleb32(u32.!(entry.funcIndex));
								out.putb(WasmOp.END.opcode);
								if (WasmComponent.printSection.ELEMENT) {
									var sb = StringBuilder.new().put3("Dispatch function element %d function %d method %s",
													  j, entry.funcIndex, wasm.getMethodName(entry.method));
									prog.ERROR.addError(null, null, "Element Section", sb.extract());
								}
							}
						}
					}
				}
				out.endSection();
				if (WasmComponent.printSection.TABLE)
					prog.ERROR.addError(null, null, "Table Section", "========== Done ==========");
			} else {
				if (WasmComponent.printSection.ELEMENT)
					prog.ERROR.addError(null, null, "Element Section", "========== Not emitted (no elements) ==========");
			}
		}

		// (9) Emit the function bodies
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.CODE) {
			var numBodies = functionInfos.length;
			if (WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put1("========== Emitting %d code bodies ==========", numBodies);
				prog.ERROR.addError(null, null, "Code Section", sb.extract());
			}
			out.startSection(WasmSection.CODE.code);
			out.put_sleb32(numBodies);
			out.putmd(codebuf);
			out.endSection();
			if (WasmComponent.printSection.CODE)
				prog.ERROR.addError(null, null, "Code Section", "========== Done ==========");
		}

		// (9) Emit the data section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.DATA && false) {	// turn off for now
			out.startSection(WasmSection.DATA.code);
			out.putb(1); // 1 data entry
			out.putb(0); // linear memory #0
			out.putb(WasmOp.I32_CONST.opcode);
// EBM		out.put_sleb32(int.view(dataStartAddr));  // linear memory offset
			out.putb(WasmOp.END.opcode);
			var data_sizepos = out.skip_leb32(); // data size
			var data_start = out.pos;
// EBM		out.startAddr = int.view(dataStartAddr) - out.end();
			// Encode meta region
	                m.layoutMeta(out);
	                // Encode runtime region
	                m.layoutRuntime(out);
			// Encode data region
	                rt.recordDataStart(out.addr_end());
	                m.layoutData(out);
	                rt.recordDataEnd(out.addr_end());
			// Add the heap pointers after the initialized data. XXX: use WASM globals.
			if (m.allocates || rt.shadowStackSize > 0) rt.addHeapPointers(out);

			WasmCommon.patchSize(out, data_sizepos, out.atEnd().pos - data_start);
			out.endSection();
		}

		out.patch(patchAddress(wasm.mach, _, _, _));

		// (10) Emit the name section
		//--------------------------------------------------------------------------------
		if (WasmComponent.includeSection.NAME && CLOptions.SYMBOLS.val) {
			out.startSection(WasmSection.UNKNOWN.code);
			out.str("name");
			// output function name subsection
			out.putb(1); // names of functions
			var funcname_sizepos = out.skip_leb32();
			var funcname_start = out.pos;
			var count = u32.!(methods.length);
			if (m.allocates) count++;
			if (wasm.entryStubFuncIndex >= 0) count++;
			out.put_uleb32(count);
			if (wasm.allocateStubFuncIndex >= 0) {
				out.put_uleb32(u32.!(wasm.allocateStubFuncIndex));
				out.str(".alloc");
			}
			if (wasm.entryStubFuncIndex >= 0) {
				out.put_uleb32(u32.!(wasm.entryStubFuncIndex));
				out.str(".entry");
			}

			var namebuf = StringBuilder.new();
			for (i < methods.length) {
				var m = methods[i];
				out.put_uleb32(u32.!(m.machIndex));
				emitMethodName(out, m, namebuf);
			}
			WasmCommon.patchSize(out, funcname_sizepos, out.atEnd().pos - funcname_start);
			out.endSection();
		}

		// Dump the bytes to the file
		var fileName = context.compiler.getOutputFileName(prog.name(), "wasm");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) {
			prog.ERROR.OutputError(fileName);
			return null;
		}
		System.write(fd, out.alias());
		System.fileClose(fd);
		return out;
	}
	def layoutAllRecordsAndFuncs(m: MachProgram) {
		Vectors.drain(m.recordQueue, 0, layoutRecord(m, _));
	}
	private def layoutRecord(m: MachProgram, r: Record) {
		for (v in r.values) layoutVal(m, v);
	}
	private def layoutVal(m: MachProgram, val: Val) {
		match (val) {
			x: Record => addrOfRecord(m, x);
			x: FuncVal => m.addrOfMethod(x.memberRef.asMethod());
			// EBM: Ben says Closure should be normalized away
			x: Closure => { layoutVal(m, x.val); m.addrOfMethod(x.memberRef.asMethod());  }
			x: BoxVal => for (e in x.values) layoutVal(m, e);
			// There are a number of other cases, which do not need space.
		}
	}
	def addrOfRecord(m: MachProgram, r: Record) -> Address<Record> {
		var addr = m.recordMap[r];
		if (addr == null) {
			// allocate required globals
			// components: one for each field
			// classes/arrays: one for a ref to the object
			addr = GLOBALS_REGION.allocate(r, getObjectSize(m, r.rtype, r));
			m.recordMap[r] = addr;
		}
		return addr;
	}
	def processMethodMapEntry(wasm: WasmGcProgram, item: IrItem, addr: Address<IrMethod>) {
		var m = addr.val;
		wasm.requestIndirectAdapter(m);
		addr.absolute = m.machIndex;
	}
	def getObjectSize(m: MachProgram, t: Type, r: Record) -> int {
		var size: int;
		match (t) {
			x: ClassType => {
				var ic = m.prog.ir.getIrClass(t);
				if (ic == null) m.fail(Strings.format2("getObjectSize(#%d): class %q has no IrClass", r.id, t.render));
				else if (V3.isComponent(t)) size = ic.fields.length;
				else size = 1;
			}
			x: ArrayType => size = 1;  // a ref
			_ => return m.unexpectedType(t, 0);
		}
		return size;
	}
	def patchAddress(mach: MachProgram, w: MachDataWriter, a: Addr, posAddr: int) {
		var abs = mach.absolute(a);
		if (CLOptions.PRINT_BIN.get()) {
			TerminalBuffer.new()
				.puts("patch-address @+")
				.putd(w.pos)
				.puts(" <- ")
				.putcv(a, null)
				.puts(" = ")
				.putx(abs)
				.outln();
		}
		// TODO,XXX: address immediates are in i32.const, which is a signed LEB.
		w.overwrite_sleb32(abs);
	}
	def emitTestWrappers(context: SsaContext, rt: MachRuntime, w: DataWriter, e: ExecuteTestCase) {
		var prog = context.prog;
		var fileName = context.compiler.getOutputFileName(prog.name(), "expect.js");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		var buf = StringBuilder.new();
		buf.put1("// %s\n", prog.name());

		buf.puts("var globalTestRuns = [\n");

		for (r = e.runs; r != null; r = r.tail) {
			var run = r.head;
			buf.puts("\t[");
			putJsValue(buf, run.expected);
			buf.puts(", [");
			for (i = run.input; i != null; i = i.tail) {
				putJsValue(buf, i.head);
				if (i.tail != null) buf.csp();
			}
			buf.puts("]],\n");
		}

		buf.puts("];\n");

		System.fileWriteK(fd, buf.buf, 0, buf.length);
		System.fileClose(fd);

		// emit Wasm spec test wrapper
		fileName = context.compiler.getOutputFileName(prog.name(), "bin.wast");
		fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		buf.reset();
		buf.puts("(module binary\n");
		for (i < w.end()) {
			if ((i & 31) == 0) buf.puts(" \"");
			buf.puts("\\");
			buf.putx_8(w.data[i]);
			if ((i & 31) == 31 || (i == w.end() - 1)) buf.puts("\"").ln();
		}
		buf.puts("\n)\n");
		for (r = e.runs; r != null; r = r.tail) {
			var run = r.head;
			if (Exception.?(run.expected)) buf.puts("(assert_trap ");
			else buf.puts("(assert_return ");
			buf.puts("(invoke \"main\" ");
			for (i = run.input; i != null; i = i.tail) {
				putWasmValue(buf, i.head);
			}
			buf.puts(")\n");
			if (Exception.?(run.expected)) {
				var ex = Exception.!(run.expected);
				if (Strings.equal(V3Exception.DivideByZero, ex.error)) buf.puts("\"integer divide by zero\"");
				else buf.puts("\"unreachable\"");
			}
			else putWasmValue(buf, run.expected);
			buf.puts(")\n");
		}

		System.fileWriteK(fd, buf.buf, 0, buf.length);
		System.fileClose(fd);
	}
	def putWasmValue(buf: StringBuilder, r: Result) -> StringBuilder {
		match (r) {
			x: Box<int> => return buf.puts("(i32.const 0x").putx(x.val).putc(')');
			x: Box<bool> => return buf.puts("(i32.const 0x").putx(if(x.val, 1, 0)).putc(')');
			null => return buf.puts("(i32.const 0x0)");
		}
		return buf;
	}
	def putJsValue(buf: StringBuilder, r: Result) -> StringBuilder {
		match (r) {
			x: Box<int> => return buf.putd(x.val);
			x: Box<bool> => return buf.putd(if(x.val, 1, 0));
			x: Exception => return buf.puts("WebAssembly.RuntimeError");
			null => return buf.puts("0");
		}
		return buf;
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	def getRuntime(prog: Program) -> MachRuntime {
		return MachProgram.!(prog.tprog).runtime;
	}
	def emitMethodName(w: MachDataWriter, m: IrMethod, namebuf: StringBuilder) {
		namebuf.reset();
		m.renderLong(namebuf);
		w.put_uleb32(u32.!(namebuf.length));
		w.putk(namebuf.buf, 0, namebuf.length);
	}
        def emitEngineScript(cmd: string, compiler: Compiler, prog: Program) {
		var programName = prog.name();
		var fileName = compiler.getOutputFileName(programName, null);
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		compiler.emitBashScriptHeader(fd);
		System.write(fd, cmd);
                System.write(fd, " $DIR/");
		System.write(fd, programName);
		System.write(fd, ".wasm");
		System.write(fd, " \"$@\"\n");
		System.fileClose(fd);
		compiler.makeExecutable(fileName);
        }
}

type DispatchAdapter(rootRcvr: Type, rootSig: Signature, rcvr: Type, sig: Signature,
		     funcNum: u32, meth: IrMethod, rootSigIdx: int) {
	def render(sb: StringBuilder) -> StringBuilder {
		sb.put3("root type %q, root sig %q, sig idx %d",
			rootRcvr.render, rootSig.funcType().render, rootSigIdx)
		  .put2(", rcvr %q, sig %q", rcvr.render, sig.funcType().render)
		  .put2("func #%d, method %q", funcNum, meth.render);
		return sb;
	}
}

// class WasmGcProgram(prog: Program, context: SsaContext, test: bool) {
class WasmGcProgram(mach: MachProgram, context: SsaContext, test: bool) {
	var gcTypeTable: WasmGcTypeTable;

	//
	// EBM: From WasmProgram; revisit
	//

	// Indicates the indirect adapter function number for a given method
	def indirectAdapterFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);
	def indirectAdapterRequests = Vector<IrMethod>.new();
	// Index in indirect table 0 of a method whose address is taken
	def indirectAdapterIndexFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);

	// Maps from method tables to corresponding indirection table (Wasm table number)
	def indirectTableFor = HashMap<IrMtable,int>.new(IrItem.uid, IrMtable.==);
	def indirectTableRequests = Vector<IrMtable>.new();

	// Indicates the dispatch adapter function number for a given method
	def dispatchAdapterFor = HashMap<IrMethod,int>.new(IrMethod.uid, IrMethod.==);
	var dispatchAdapterBase: u32 = 0;  // function index of first dispatch adapter

	// Maps from method table to corresponding dispatch tables (Wasm table number)
	def dispatchTableFor = HashMap<IrMtable,int>.new(IrItem.uid, IrMtable.==);
	def dispatchTableRequests = Vector<IrMtable>.new();

	var sigIndex_i_i = -1;
	var sigIndex_entryStub = -1;

	// known function indices
	var entryStubFuncIndex = -1;
	var allocateStubFuncIndex = -1;

	var numImports = 0;
	//
	// End from WasmProgram
	//

	new() {
		gcTypeTable = WasmGcTypeTable.new(wasmGcType, mach.prog.ERROR);
	}

	def requestIndirectAdapter(m: IrMethod) {
		if (!indirectAdapterFor.has(m)) {
			indirectAdapterFor[m] = -1;
			indirectAdapterRequests.put(m);
			addSig(AnyRef.TYPE, m.sig);
		}
	}
	def requestIndirectTable(m: IrMtable) {
		if (!indirectTableFor.has(m)) {
			indirectTableFor[m] = -1;
			indirectTableRequests.put(m);
		}
	}
	def requestDispatchTable(m: IrMtable) {
		if (!dispatchTableFor.has(m)) {
			dispatchTableFor[m] = -1;
			dispatchTableRequests.put(m);
		}
	}

	def wasmGcType(t: Type) -> WasmValueType {
		return gcTypeTable.getValueTypeFor(t);
	}

	def getSig(receiver: Type, sig: Signature) -> Signature {
//		var sb = StringBuilder.new().put2("receiver=%q  sig=%q", receiver.render, sig.funcType().render);
//		mach.prog.ERROR.addError(null, null, "getSig", sb.extract());
		if (receiver != Void.TYPE && !V3.isComponent(receiver))
			sig = Signature.new(null, Arrays.prepend(receiver, sig.paramTypes), sig.returnTypes);
		return sig;
	}
	def addSig(receiver: Type, sig: Signature) -> u32 {
		var wft = gcTypeTable.addSignature(getSig(receiver, sig));
		return u32.!(wft.index);
	}
	def getSigIndex(m: IrMethod) -> u32 {
		var sig = getSig(m.receiver, m.sig);
		var wft = gcTypeTable.addSignature(sig);
		var index: u32 = if(wft == null, 0, wft.index);
		if (index == 0) context.fail1("method signature not found: %q", sig.funcType().render);
		return u32.!(index - 1);
	}
	def getMethodName(m: IrMethod) -> string {
		var name = "?";
		var ms = m.source;
		if (ms != null) {
			var sig = getSig(m.receiver, m.sig);
			var wht = gcTypeTable.addSignature(sig);
			var mn = ms.name();
			var rt = m.receiver;
			var rn = getClassName(rt);
			name = StringBuilder.new().put2("%s.%s", rn, mn).extract();
		}
		return name;
	}
	def getClassName(ctype: Type) -> string {
		return if(ClassType.?(ctype),ClassType.!(ctype).classDecl.name(),ctype.typeCon.name);
	}
	def addIrMethodAddr(m: IrItem, addr: Address<IrMethod>) {
		var m = addr.val;
		var name: string = if(WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT,
				      getMethodName(m), null);
		if (m.machIndex < 0) context.fail1("method not assigned an index: %q", m.renderLong);
		requestIndirectAdapter(m);
	}
	def addIrMethods(infos: Vector<FunctionInfo>) -> Vector<IrMethod> {
		var methods = mach.prog.ir.methods;
		// We place imported functions first, locally defined ones later;
		// any stubs will be emitted in between.  Note that position in
		// the original methods Vector does not always correspond to Wasm function number.
		var sorted = Array<IrMethod>.new(methods.length);
		var j = 0;

		// Add all imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source == null || m.source.importName == null) continue;
			addMethod(m, infos, true);
			sorted[j++] = m;
		}
		numImports = j;

		// Add the allocation stub if necessary
		if (mach.allocates) {
			var sig = FuncType.!(Function.newType(Int.TYPE, Int.TYPE)).sig();
			sigIndex_i_i = int.!(addSig(Void.TYPE, sig));
			allocateStubFuncIndex = infos.length;
			infos.put(FunctionInfo.new(FunctionInfoKind.AllocStub, null, sig, u32.!(sigIndex_i_i), null, allocateStubFuncIndex));
			if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.CODE) {
				var sb = StringBuilder.new().put2("Adding alloc stub; sig idx=#%d entry #%d", sigIndex_i_i - 1, allocateStubFuncIndex);
				mach.prog.ERROR.addError(null, null, "Function/Code Section", sb.extract());
			}
		}
		// Add the entry stub if {RiRuntime.init} or {RiRuntime.exit} exists.
		var ri_init = mach.runtime.getRiInit();
		var ri_exit = mach.runtime.getRiExit();
		if (ri_init != null || ri_exit != null) {
			var main = mach.prog.getMain();
			var mainMeth = if(main != null, main.asMethod());
			var mainSig = if(mainMeth != null, mainMeth.sig);
			var sig = mainSig;

			if (test) {
				// no inputs; outputs are arguments to Wasm main, prepared by the testing function
				sigIndex_entryStub = int.!(addSig(Void.TYPE, mainSig));
			} else {
				// inputs are what ri_init needs (none if it is not called)
				var params: Array<Type> = if(ri_init != null, ri_init.sig.paramTypes, TypeUtil.NO_TYPES);
				// outputs are what ri_exit returns if ri_exit is used, otherwise an int success code
				var results: Array<Type> = if(ri_exit != null, ri_exit.sig.returnTypes, [Int.TYPE]);
				sig = Signature.new(null, params, results);
				sigIndex_entryStub = int.!(addSig(Void.TYPE, sig));
			}
			entryStubFuncIndex = infos.length;
			infos.put(FunctionInfo.new(FunctionInfoKind.EntryStub, null, sig, u32.!(sigIndex_entryStub), mainMeth, entryStubFuncIndex));
			if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
				var sb = StringBuilder.new().put2("Adding entry stub; sig idx=#%d entry #%d", sigIndex_entryStub - 1, entryStubFuncIndex);
				mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
			}
		}

		// Add all non-imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source != null && m.source.importName != null) continue;
			addMethod(m, infos, false);
			sorted[j++] = m;
		}

		Arrays.copyInto(sorted, methods.array, 0);  // update the IrModule's method vector.
		return methods;
	}
	def addMethod(m: IrMethod, infos: Vector<FunctionInfo>, imported: bool) {
		var sigIdx = addSig(m.ssa.params[0].vtype, m.sig);
		if (!imported) {
			m.machIndex = infos.length;
			var fi = FunctionInfo.new(FunctionInfoKind.Method, m.receiver, m.sig, sigIdx, m, infos.length);
			infos.put(fi);
		}
		if (WasmComponent.printSection.FUNCTION || WasmComponent.printSection.ELEMENT) {
			var name = getMethodName(m);
			var sb = StringBuilder.new().put3("Adding method %s; sig idx=#%d entry #%d", name, sigIdx, m.machIndex);
			mach.prog.ERROR.addError(null, null, "Function/Element Section", sb.extract());
		}
	}
}

// adds to the gcTypeTable all non-class heap types
def addIrTypes<T>(irObject: T, prog: WasmGcProgram) {
	var errgen = prog.mach.prog.ERROR;
	match (irObject) {
		module: IrModule => {
			if (WasmComponent.printSection.TYPE) {
				errgen.addError(null, null, "Type Section", "Processing module");
			}
			// *Add* all the classes first, so their ctypes are in heapTypeMap, etc
			for (i < module.classes.length) prog.gcTypeTable.addClass(module.classes[i]);
			// Now process the classes (etc) more thoroughly
			for (i < module.classes.length) addIrTypes(module.classes[i], prog);
			for (i < module.methods.length) addIrTypes(module.methods[i], prog);
			for (i < module.init.length   ) addIrTypes(module.init   [i], prog);
			for (i < module.roots.length  ) addIrTypes(module.roots  [i], prog);
		}
		cls: IrClass => {
			// finish processing the class - could not process the fields with addClass
			if (WasmComponent.printSection.TYPE) {
				var ctype = cls.ctype;
				var name: string = if(ClassType.?(ctype),ClassType.!(ctype).classDecl.name(),ctype.typeCon.name);
				var line = StringBuilder.new().put1("Processing IR class: %s", name);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			prog.gcTypeTable.processClass(cls, prog.mach.tagType);
			// go through the rest
			for (m in cls.methods) addIrTypes(m, prog);
			for (f in cls.fields ) addIrTypes(f, prog);
		}
		method: IrMethod => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put2("Processing IR method: %q.%q",
								    method.receiver.render, method.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			prog.gcTypeTable.addSignature(prog.getSig(method.receiver, method.sig));
		}
		field: IrField => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put3("Processing IR field: %q.%q: %q",
								    field.receiver.render, field.render, field.fieldType.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			prog.gcTypeTable.addHeapType(field.fieldType);
		}
		selector: IrSelector => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put2("Processing IR selector: %q.%q",
								    selector.receiver.render, selector.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(selector.method, prog);
			addIrTypes(selector.mtable, prog);
		}
		mtable: IrMtable => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put1("Processing IR mtable: %q", mtable.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(mtable.root, prog);
			for (meth in mtable.table) addIrTypes(meth, prog);
			prog.gcTypeTable.addHeapType(mtable.record.rtype);
		}
		spec: IrSpec => {
			if (WasmComponent.printSection.TYPE) {
				var line = StringBuilder.new().put1("Processing IR spec: %q", spec.render);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(spec.member, prog);
			for (typ in spec.typeArgs) prog.gcTypeTable.addHeapType(typ);
		}
		root: IrRoot => {
			if (WasmComponent.printSection.TYPE) {
				var name = if(root.name == null,"??",root.name);
				var line = StringBuilder.new().put1("Processing IR root: %s", name);
				errgen.addError(null, null, "Type Section", line.extract());
			}
			addIrTypes(root.spec, prog);
		}
	}
}

class WasmGcLowering extends MachLowering {

	def wasm: WasmGcProgram;
	def target: WasmGcTarget;

	new(wasm, target, mach: MachProgram, compiler: Compiler, config: MachLoweringConfig)
		super(mach, compiler, config) {	}

	def classIdRange(t: Type) -> (int, int) {
		var r = mach.prog.ir.getIrClass(t);
		if (r == null) return (0, 0);
		return (r.minClassId, r.maxClassId);
	}
	def genSimpleVal(val: Val, tn: TypeNorm) -> Val {
		if (val == null) return null;
		match (val) {
			x: ArrayRangeStart => return Int.box(x.start);
			x: PointerRangeStart => return x.start;
		}
		return mach.machVal(val);
	}
	def genClassCast(ft: Type, tt: Type, i_old: SsaApplyOp) -> SsaInstr {
		var fromIrClass = mach.prog.ir.getIrClass(ft);
		wasm.gcTypeTable.addClass(fromIrClass);
		var toIrClass = mach.prog.ir.getIrClass(ft);
		wasm.gcTypeTable.addClass(toIrClass);
		return normId(i_old);
	}
	def genTypeQuery(i_old: SsaApplyOp, query: TypeQuery) -> SsaInstr {
		var ft = i_old.op.typeArgs[0], tt = i_old.op.typeArgs[1];
		if (V3.isClass(ft) && V3.isClass(tt)) {
			var oobj = i_old.inputs[0], nobj = normRef1(oobj);
			var t = classIdRange(tt), low = t.0, high = t.1;
			if (low == high) {
				// no live classes can match, and null is not an instance of
				return context.graph.falseConst();
			}
// EBM use first return to demo why REF_TEST does not work
//			return normId(i_old);
			return genIfNull(i_old, Bool.TYPE, nobj, null, genClassIdQuery(i_old, low, high, _));
		}
		return context.graph.trueConst();
	}
	def genClassIdQuery(i_old: SsaApplyOp, low: int, high: int, nobj: SsaInstr) -> SsaInstr {
		var tagType = mach.tagType;
		var fromType = i_old.op.typeArgs[0];
		var field = IrField.new(fromType, tagType);
		field.machOffset = 0;  // flags a tag field
		var spec = IrSpec.new(fromType, null, field);
		var i_tid = apply(i_old.source, V3Op.newClassGetField(spec), [i_old.input0()]);
		return genRangeQuery(i_old, low, high, i_tid);
	}
	def genRangeQuery(i_old: SsaApplyOp, low: int, high: int, val: SsaInstr) -> SsaInstr {
		if (high == low + 1) { // XXX: better factoring of degenerate range checks
			return apply(i_old.source, V3Op.newEqual(Int.TYPE), [val, context.graph.intConst(low)]);
		} else {
			var cmp1 = curBlock.opIntGteq(val, context.graph.intConst(low));
			var cmp2 = curBlock.opIntLt(val, context.graph.intConst(high));
			return apply(i_old.source, V3Op.opBoolAnd, [cmp1, cmp2]);
		}
	}
	def genTypeSubsume(i_old: SsaApplyOp) {
		// Actually need the (static) type to change in Wasm code, so need a cast
		void(normId(i_old));
	}
	def genArrayAlloc(i_old: SsaApplyOp) -> SsaInstr {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.returnTypes[0]);
		return normId(i_old);
	}
	def genArrayInit(i_old: SsaApplyOp) -> SsaInstr {
		var arrayType = i_old.op.typeArgs[0];
		wasm.gcTypeTable.addHeapType(arrayType);
		return normId(i_old);
	}
	def genArrayTupleInit(i_old: SsaApplyOp, elems: int, length: int) -> SsaInstr {
		// should not happen since MixedArrays is turned off
		wasm.context.fail("genArrayTupleInit called but MixedArrays is false");
		return normId(i_old);	// satisfy compiler
	}
	def genArrayGetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return void(normId(i_old));
	}
	def genArraySetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return void(normId(i_old));
	}
	def genRangeStartPlusIndex(i_old: SsaApplyOp) -> SsaInstr {
		var rangeType = i_old.op.typeArgs[0];
		wasm.gcTypeTable.addHeapType(rangeType);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0];
		var rangeStart = inputs[1];
		var nindex = inputs[2]; // XXX: discarding upper words for normalized integers
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		var i_new: SsaInstr;


		var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			if (narr.facts.V_ZERO) {
				i_new = ptrAdd(rangeStart, nindex);
			} else if (narr.facts.V_NON_ZERO) {
				i_new = sum;
			} else {
				var t = addIfNull(narr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var aresult = sum;
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var mresult = ptrAdd(rangeStart, nindex);
				tblock.addGoto(merge.block);

				curBlock = merge;
				i_new = curBlock.addPhi(etype, [aresult, mresult]);
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					if (narr.facts.V_ZERO) {
						var prod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						i_new = ptrAdd(rangeStart, prod);
					} else if (narr.facts.V_NON_ZERO) {
						i_new = sum;
					} else {
						var t = addIfNull(narr);
						var tblock = t.0, fblock = t.1, merge = t.2;
						curBlock = fblock;
						// if (nobj != null) generate the nonnull (array) case
						var aresult = sum;
						fblock.addGoto(merge.block);

						// if (nobj == null) generate the null (memory) case
						curBlock = tblock;
						var mprod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var mresult = ptrAdd(rangeStart, mprod);
						tblock.addGoto(merge.block);

						curBlock = merge;
						i_new = curBlock.addPhi(etype, [aresult, mresult]);
					}
				}
				_ => {
					// no explicit null check needed
					i_new = sum;
				}
			}
		}
		map1(i_old, i_new);
		return i_new;
	}
	def genNormRangeGetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0], rangeStart = inputs[1], nindex = inputs[2], rangeType = i_old.op.typeArgs[0];
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		// op is usually needed
		var op = Operator.new(Opcode.ArrayGetElem, i_old.op.typeArgs, Function.siga(i_old.op.typeArgs, etype));
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
			if (narr.facts.V_ZERO) {
				var result = apply(null, V3Op.newPtrLoad(mach.data.ptrType, etype), [sum]);
				map1(i_old, result);
			} else if (narr.facts.V_NON_ZERO) {
				var result = apply(null, op, [narr, sum]);
				map1(i_old, result);
			} else {
				var t = addIfNull(narr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var aresult = apply(null, op, [narr, sum]);
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var mresult = apply(null, V3Op.newPtrLoad(mach.data.ptrType, etype), [sum]);
				tblock.addGoto(merge.block);

				curBlock = merge;
				map1(i_old, curBlock.addPhi(etype, [aresult, mresult]));
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					if (narr.facts.V_ZERO) {
						var prod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, prod]);
						var result = apply(i_old.source, V3Op.newPtrLoad(mach.data.ptrType, etype), [sum]);
						map1(i_old, result);
					} else if (narr.facts.V_NON_ZERO) {
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var result = apply(i_old.source, op, [narr, sum]);
						map1(i_old, result);
					} else {
						var t = addIfNull(narr);
						var tblock = t.0, fblock = t.1, merge = t.2;
						curBlock = fblock;
						// if (nobj != null) generate the nonnull (array) case
						var asum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var aresult = apply(i_old.source, op, [narr, asum]);
						fblock.addGoto(merge.block);

						// if (nobj == null) generate the null (memory) case
						curBlock = tblock;
						var mprod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var msum = apply(i_old.source, itype.opAdd(), [rangeStart, mprod]);
						var mresult = apply(i_old.source, V3Op.newPtrLoad(mach.data.ptrType, etype), [msum]);
						tblock.addGoto(merge.block);

						curBlock = merge;
						map1(i_old, curBlock.addPhi(etype, [aresult, mresult]));
					}
				}
				_ => {
					// no explicit null check needed
					var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
					var result = apply(null, op, [narr, sum]);
					map1(i_old, result);
				}
			}
		}
	}
	def genNormRangeSetElem(i_old: SsaApplyOp, elem: int) {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		var inputs = normRefs(i_old.inputs);
		var narr = inputs[0], rangeStart = inputs[1], nindex = inputs[2], nval = inputs[3], rangeType = i_old.op.typeArgs[0];
		var etype = V3Array.elementType(rangeType);
		var wst = wasm.gcTypeTable.getStorageTypeFor(etype, true);
		var itype = IntType.!(i_old.op.typeArgs[1]);
		// op is usually needed
		var arrParamTypes = [i_old.op.sig.paramTypes[0], i_old.op.sig.paramTypes[2], i_old.op.sig.paramTypes[3]];
		var op = Operator.new(Opcode.ArraySetElem, i_old.op.typeArgs, Signature.new(null, arrParamTypes, []));
		if (wst.pack == WasmPacking.PACKED_8) {
			// byte: null ok, no scaling so can add start and index early, then if
			var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
			if (narr.facts.V_ZERO) {
				var result = apply(null, V3Op.newPtrStore(mach.data.ptrType, etype), [sum, nval]);
				map1(i_old, result);
			} else if (narr.facts.V_NON_ZERO) {
				var result = apply(null, op, [narr, sum, nval]);
				map1(i_old, result);
			} else {
				var t = addIfNull(narr);
				var tblock = t.0, fblock = t.1, merge = t.2;
				curBlock = fblock;
				// if (nobj != null) generate the nonnull (array) case
				var aresult = apply(null, op, [narr, sum, nval]);
				fblock.addGoto(merge.block);

				// if (nobj == null) generate the null (memory) case
				curBlock = tblock;
				var mresult = apply(null, V3Op.newPtrStore(mach.data.ptrType, etype), [sum, nval]);
				tblock.addGoto(merge.block);

				curBlock = merge;
				i_old.remove();
			}
		} else {
			match (wst.valType) {
				I32, I64, F32, F64 => {
					var ptype = PrimType.!(etype);
					var scale = ptype.byteSize;
					var i_scale = context.graph.intConst(scale);
					// int/float: null ok, scaling so add start and index*scale later (within if)
					if (narr.facts.V_ZERO) {
						var prod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, prod]);
						var result = apply(i_old.source, V3Op.newPtrStore(mach.data.ptrType, etype), [sum, nval]);
						map1(i_old, result);
					} else if (narr.facts.V_NON_ZERO) {
						var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var result = apply(i_old.source, op, [narr, sum, nval]);
						map1(i_old, result);
					} else {
						var t = addIfNull(narr);
						var tblock = t.0, fblock = t.1, merge = t.2;
						curBlock = fblock;
						// if (nobj != null) generate the nonnull (array) case
						var asum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
						var aresult = apply(i_old.source, op, [narr, asum, nval]);
						fblock.addGoto(merge.block);

						// if (nobj == null) generate the null (memory) case
						curBlock = tblock;
						var mprod = apply(i_old.source, itype.opMul(), [nindex, i_scale]);
						var msum = apply(i_old.source, itype.opAdd(), [rangeStart, mprod]);
						var mresult = apply(i_old.source, V3Op.newPtrStore(mach.data.ptrType, etype), [msum, nval]);
						tblock.addGoto(merge.block);

						curBlock = merge;
						i_old.remove();
					}
				}
				_ => {
					// no explicit null check needed
					var sum = apply(i_old.source, itype.opAdd(), [rangeStart, nindex]);
					var result = apply(null, op, [narr, sum, nval]);
					map1(i_old, result);
				}
			}
		}
	}
	def genArrayGetLength(i_old: SsaApplyOp) -> SsaInstr {
		wasm.gcTypeTable.addHeapType(i_old.op.sig.paramTypes[0]);
		return normId(i_old);
	}
	def genClassAlloc(i_old: SsaApplyOp, method: IrMethod) {
		// Leave the ClassAlloc for code gen, which will set the tag
		// If method is non-null, add call to the graph
		var classType = i_old.op.sig.returnTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
		// insert a copy of the current instr (so we can add *after*)
		var dests = Arrays.map(i_old.inputs, SsaDfEdge.getDest);
		var i_new = curBlock.addApply(i_old.source, i_old.op, dests);
		if (method != null) {
			var methodRef = V3Op.extractIrSpec(i_old.op, method);
			var funcRep = mach.funcRep(methodRef);
			var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
			var args = Arrays.prepend(func, Arrays.prepend(i_new, normRefs(i_old.inputs)));
			apply(i_old.source, V3Op.newCallClassMethod(methodRef), args);
		}
		map1(i_old, i_new);
	}
	def genVariantAlloc(i_old: SsaApplyOp) {
		// Leave the VariantAlloc for code gen, which adds the tag itself
		var classType = i_old.op.sig.returnTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
	}
	def genClassGetField(isVariant: bool, i_old: SsaApplyOp, field: IrField) {
		// Leave the ClassGetField for code gen
		var classType = i_old.op.sig.paramTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		normId(i_old);
		// Ben indicates that the multiple-types for a field should not happen on Wasm Gc;
		// it is for handing 64-bit numbers on 32-bit platforms.
	}
	def genClassSetField(i_old: SsaApplyOp, field: IrField, init: bool) {
		// Leave the ClassGetField for code gen
		var classType = i_old.op.sig.paramTypes[0];
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);
		return void(normId(i_old));
	}
	def genClassGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {
		genNullCheck(i_old);
		wasm.requestIndirectAdapter(method);
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		return context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
	}
	def genClassGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {
		// insure class is recorded
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and indirect adapters requested
		wasm.requestIndirectTable(selector.mtable);

		// pass through to code gen
		return normId(i_old);
	}
	def genVariantGetMethod(i_old: SsaApplyOp, method: IrMethod) -> SsaInstr {
		wasm.requestIndirectAdapter(method);
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		return context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
	}
	def genVariantGetSelector(i_old: SsaApplyOp, selector: IrSelector) -> SsaInstr {
		// insure class is recorded
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and indirect adapters requested
		wasm.requestIndirectTable(selector.mtable);

		// pass through to code gen
		return normId(i_old);
	}
	def genComponentGetField(i_old: SsaApplyOp, field: IrField) {
		// Leave the ComponentGetField for code gen
		return void(normId(i_old));
/*
		var fieldRef = V3Op.extractIrSpec(i_old.op, field);
		var fieldType = mach.machType(fieldRef.getFieldType());
		var ptr = componentFieldPtr(fieldRef);
		var loads = genNormTypedLoads(i_old.source, Fact.O_NO_NULL_CHECK, fieldType, ptr, 0);
		mapN(i_old, loads);
*/
	}
	def genComponentSetField(i_old: SsaApplyOp, field: IrField) {
		// Leave the ComponentSetField for code gen
		return void(normId(i_old));
/*
		var fieldRef = V3Op.extractIrSpec(i_old.op, field);
		var inputs = normRefs(i_old.inputs);
		var machType = mach.machType(fieldRef.getFieldType());
		var ptr = componentFieldPtr(fieldRef);
		// generate remaining stores for normalized fields.
		genNormTypedStores(i_old.source, Fact.O_NO_NULL_CHECK, false, machType, ptr, 0, inputs, 1);
		i_old.kill();
		i_old.remove();
*/
	}
	def genBoundsCheck0(i_old: SsaApplyOp, nullity: Fact.set, narr: SsaInstr) -> (SsaInstr, Fact.set) {
		return (normId(i_old), nullity);
/*
		var oarr = i_old.inputs[0];
		// load length
		// XXX: CSE the array length if possible
		var len = refLoad(nullity, Int.TYPE, i_old, oarr, narr, mach.getArrayLengthOffset(i_old.op.typeArgs[0]));
		var index = normRef1(i_old.inputs[1]);
		var throwOp = V3Op.newConditionalThrow(V3Exception.BoundsCheck);
		// throw BoundsCheckException if ugteq(index, length)
		var op = Int.getType(false, 32).opLtEq();
		apply(i_old.source, throwOp, [apply(i_old.source, op, [len, index])]);
		return (index, nullity | Fact.O_NO_NULL_CHECK);
*/
	}
	def genCallMethod(i_old: SsaApplyOp, method: IrMethod) {
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
		var args = Arrays.prepend(func, normRefs(i_old.inputs));

		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);

//		var tblnum = Int.box(0);
//		var tbl = context.graph.valConst(Int.getType(false, 31), tblnum);
//		args = Arrays.prepend(tbl, args);

//		call(i_old, funcRep, args);
	}
	def genCallClassMethod(i_old: SsaApplyOp, method: IrMethod) {
		var methodRef = V3Op.extractIrSpec(i_old.op, method);
		var funcRep = mach.funcRep(methodRef);
		var func = context.graph.valConst(funcRep.machType, mach.getCodeAddress(methodRef));
		var args = Arrays.prepend(func, normRefs(i_old.inputs));

		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);

//		var tblnum = Int.box(0);
//		var tbl = context.graph.valConst(Int.getType(false, 31), tblnum);
//		args = Arrays.prepend(tbl, args);

//		call(i_old, funcRep, args);
	}
	def genCallClassSelector(i_old: SsaApplyOp, selector: IrSelector) {
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		// insure class type is entered
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and dispatch adapters requested
		wasm.requestDispatchTable(selector.mtable);
//		wasm.getDispatchTableNumber(selector.mtable);

		var args = normRefs(i_old.inputs);
		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallVariantSelector(i_old: SsaApplyOp, selector: IrSelector) {
		var classType = selector.receiver;
		var irClass = mach.prog.ir.getIrClass(classType);
		// insure class type is entered
		wasm.gcTypeTable.addClass(irClass);

		// insure mtable is recorded and dispatch adapters requested
		wasm.requestDispatchTable(selector.mtable);
//		wasm.getDispatchTableNumber(selector.mtable);

		var args = normRefs(i_old.inputs);
		var i_new = apply(i_old.source, i_old.op, args);
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genCallFunction(i_old: SsaApplyOp) {
//		wasm.context.fail("genCallFunction called");
		var funcRep = mach.getFuncRep(i_old.op.typeArgs[0]);
		var ptype = funcRep.machType;
		var args = normRefs(i_old.inputs);
		// essentially the same instruction; helps code below work
		var i_new = apply(i_old.source, i_old.op, args);
		i_new.facts = i_new.facts | i_old.facts;
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
	def genVariantGetTag(i_old: SsaApplyOp, nobj: SsaInstr) -> SsaInstr {
		return normId(i_old);
/*
		var val = ptrLoad(mach.tagType, nobj, 0);
		var root = V3.getRootType(i_old.op.typeArgs[0]);
		var min = mach.classIdRange(root).0;
		if (min != 0) {
			val = apply(i_old.source, mach.tagType.opSub(), [val, context.graph.intConst(min)]);
		}
		var shift = mach.code.addressSizeLog2;
		if (shift > 0) {
			val = apply(i_old.source, mach.tagType.opShr(), [val, context.graph.intConst(shift)]);
		}
		var conv = V3Op.newIntViewI(mach.tagType, i_old.op.sig.returnType());
		return apply(i_old.source, conv, [val]);
*/
	}
	def genNullCheck0(source: Source, nobj: SsaInstr) {
		if (SsaConst.?(nobj)) {
			var oval = SsaConst.!(nobj).val;
			if (oval == null) addThrow(source, V3Exception.NullCheck);
			return; // constant is non-null
		}
		explicitNullCheck(source, nobj.getType(), nobj);
	}
/*
	def call(i_old: SsaApplyOp, funcRep: Mach_FuncRep, args: Array<SsaInstr>) {
		if (curBlock.end) return;
		var i_new = apply(i_old.source, V3Op.newCallAddress(funcRep), args);
		i_new.facts = i_new.facts | i_old.facts;
		var tn = normType(i_old.op.sig.returnType());
		mapMultiReturn(i_old, i_new, tn);
	}
*/
}
