// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Distinguishes an absolute address from an address that refers to a V3 entity.
def ABS_MARKER = 0x44332299;
def REL_MARKER = 0x55443388;
class X86_64AddrRef extends X86_64Addr {
	def ref: Addr;
	new(base: X86_64Gpr, index: X86_64Gpr, scale: byte, ref, relative: bool)
		super(base, index, scale, if(relative, REL_MARKER, ABS_MARKER)) { }
}
class X86_64LabelRef extends X86_64Addr {
	def label: Label;
	new(label) super(null, null, 1, REL_MARKER) { }
}

def ABS32 = '\x99';
def ABS64 = '\x90';
def REL32 = '\x88';

def ASSUME32 = int.view<long>;

// Implementation of address patcher for assembler.
class X86_64AddrPatcherImpl extends X86_64AddrPatcher {
	def mw: MachDataWriter;
	private var labelUses: List<(int, Label)>;

	new(mw) super(ABS_MARKER, REL_MARKER) { }

	def recordAbs32(pos: int, addr: X86_64Addr) {
		recordAbs(pos, addr, ABS32);
	}
	def recordAbs64(pos: int, addr: X86_64Addr) {
		recordAbs(pos, addr, ABS64);
	}
	private def recordAbs(pos: int, addr: X86_64Addr, marker: byte) {
		match (addr) {
			x: X86_64AddrRef => {
				mw.data[pos] = marker;
				var patchKind = if(marker == ABS32, PatchKind.ABS_32, PatchKind.ABS_64);
				mw.recordPatch(patchKind, x.ref, pos);
			}
			x: X86_64LabelRef => {
				mw.data[pos] = marker;
				labelUses = List.new((pos, x.label), labelUses);
			}
		}
	}
	def recordRel32(pos: int, delta: int, addr: X86_64Addr) {
		if (delta != i8.view(delta)) return V3.fail("unexpectedly large relative delta");
		match (addr) {
			x: X86_64AddrRef => {
				mw.data[pos] = REL32;
				mw.data[pos+1] = u8.view(delta);
				mw.recordPatch(PatchKind.RELA_32, x.ref, pos);
			}
			x: X86_64LabelRef => {
				mw.data[pos] = REL32;
				mw.data[pos+1] = u8.view(delta);
				labelUses = List.new((pos, x.label), labelUses);
			}
		}
	}
	def patchLabels() {
		for (l = labelUses; l != null; l = l.tail) {
			var u = l.head, pos = u.0, label = u.1;
			if (label.pos < 0) return V3.fail("unbound label"); // XXX: better error message
			match (mw.data[pos]) {
				REL32 => {
					var delta = i8.view(mw.data[pos + 1]);
					var offset = label.pos - (pos + delta);
					if (CLOptions.PRINT_PATCH.val) Terminal.put2("patch relative label ref @+%d -> +%d\n", pos, offset);
					mw.at(pos).put_b32(offset);
				}
				ABS32 => {
					var addr = mw.addr_of(label.pos);
					if (CLOptions.PRINT_PATCH.val) Terminal.put2("patch absolute label ref @+%d -> 0x%x\n", pos, addr);
					mw.at(pos).put_b32(ASSUME32(addr));
				}
				ABS64 => {
					var addr = mw.addr_of(label.pos);
					if (CLOptions.PRINT_PATCH.val) Terminal.put2("patch absolute label ref @+%d -> 0x%x\n", pos, addr);
					mw.at(pos).put_b64(addr);
				}
			}
		}
		labelUses = null;
	}
}

// Adds additional functionality to the base X86-64 assembler, particularly the
// functionality to record references to addresses in the code.
class X86_64MacroAssembler extends X86_64Assembler {
	def mw: MachDataWriter;
	def patcherImpl = X86_64AddrPatcherImpl.new(mw);

	new(mw) super(mw, X86_64Assemblers.REX_W) {
		var d = X86_64Assembler.new(mw, X86_64Assemblers.NO_REX);
		this.setdq(d, this);
		d.setdq(d, this);
		this.patcher = patcherImpl;
		d.patcher = patcherImpl;
	}
	def callr_v3(addr: Addr) -> this {
		callr_addr(X86_64AddrRef.new(null, null, 1, addr, true));
	}
}
