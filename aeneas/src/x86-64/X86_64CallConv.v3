// Copyright 2026 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Registers used in various calling conventions.
def R: X86_64RegSet;
// XXX: match V3 and System-V register calling conventions exactly
def V3_PARAM_GPRS = [R.RDI, R.RSI, R.RDX, R.RCX, R.R8, R.R9]; 			// System-V
def V3_PARAM_XMMS = [R.XMM0, R.XMM1, R.XMM2, R.XMM3, R.XMM4, R.XMM5, R.XMM6];	// System-V - 1
def V3_RET_GPRS = [R.RAX, R.RDX, R.RCX, R.RSI]; 				// System-V + 2
def V3_RET_XMMS = [R.XMM0, R.XMM1];						// System-V

def SYSV_PARAM_GPRS = [R.RDI, R.RSI, R.RDX, R.RCX, R.R8, R.R9]; 			// System-V
def SYSV_PARAM_XMMS = [R.XMM0, R.XMM1, R.XMM2, R.XMM3, R.XMM4, R.XMM5, R.XMM6, R.XMM7];	// System-V
def SYSV_RET_GPRS = [R.RAX, R.RDX]; 							// System-V
def SYSV_RET_XMMS = [R.XMM0, R.XMM1];							// System-V

// Functions to compute the calling convention for various signatures.
component X86_64CallConv {
	def computeV3 = compute(_, V3_PARAM_GPRS, V3_PARAM_XMMS, V3_RET_GPRS, V3_RET_XMMS, _, _);
	def computeSystemV = compute(_, SYSV_PARAM_GPRS, SYSV_PARAM_XMMS, SYSV_RET_GPRS, SYSV_RET_XMMS, _, _);

	def getForV3Graph(mach: MachProgram, graph: SsaGraph) -> MachCallConv { // XXX: put Signature in SsaGraph
		return computeV3(mach, Arrays.map(graph.params, SsaParam.vtype), Tuple.toTypeArray(graph.returnType));
	}
	def getForV3Func(mach: MachProgram, funcRep: Mach_FuncRep) -> MachCallConv {
		if (funcRep.callConv != null) return funcRep.callConv;
		return funcRep.callConv = computeV3(mach, funcRep.paramTypes, funcRep.returnTypes);
	}
	def getForV3Types(mach: MachProgram, paramTypes: Array<Type>, returnTypes: Array<Type>) -> MachCallConv {
		return computeV3(mach, paramTypes, returnTypes);
	}
	def getForSystemV(mach: MachProgram, paramTypes: Array<Type>, returnTypes: Array<Type>) -> MachCallConv {
		// TODO: frame pointer must be saved
		// TODO: rbx, r12-r15 are callee-saved
		return computeSystemV(mach, paramTypes, returnTypes);
	}
}

def compute(mach: MachProgram, paramGprs: Array<byte>, paramXmms: Array<byte>, retGprs: Array<byte>, retXmms: Array<byte>, paramTypes: Array<Type>, returnTypes: Array<Type>) -> MachCallConv {
	var pt = alloc(mach, paramTypes, paramGprs, paramXmms);
	var ploc = pt.0, pspill = pt.1;
	var rt = alloc(mach, returnTypes, retGprs, retXmms);
	var rloc = rt.0, rspill = rt.1;
	if (returnTypes.length == 0) rloc = [retGprs[0]]; // TODO: workaround for 0-length returns
	if (pspill > rspill) rspill = pspill;
	return MachCallConv.new(R.SET, paramTypes, ploc, returnTypes, rloc, rspill);
}

def alloc(mach: MachProgram, types: Array<Type>, gpr: Array<byte>, xmm: Array<byte>) -> (Array<int>, int) {
	var S = R.SET.spillStart;
	var loc = Array<int>.new(types.length);
	var pspill = 0, iprm = 0, fprm = 0;
	for (i < loc.length) {
		// XXX: allocate 4-byte slots?
		match (mach.toRegClass(types[i])) {
			I32, REF, I64 => {
				if (iprm < gpr.length) loc[i] = gpr[iprm++];
				else loc[i] = S + pspill++;
			}
			F64, F32 => {
				if (fprm < xmm.length) loc[i] = xmm[fprm++];
				else loc[i] = S + pspill++;
			}
		}
	}
	return (loc, pspill);
}
