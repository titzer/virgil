// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The normalization of a type is the representation of its values when translating the
// program to the target machine. Typically, complex types like tuples are flattened
// to multiple scalar values.
class TypeNorm(oldType: Type, newType: Type, sub: Array<Type>) {
	var raFacts: RaFact.set;
	def size = if(sub == null, 1, sub.length);
	def addTo(vec: Vector<Type>) {
		if (sub == null) vec.put(newType);
		else if (sub.length > 0) vec.puta(sub);
	}
	def render(buf: StringBuilder) -> StringBuilder {
		buf.put3("%q ## %q |%d|", oldType.render, newType.render, size);
		if (sub == null) return buf;
		buf.puts(" [");
		for (i < sub.length) {
			if (i > 0) buf.csp();
			sub[i].render(buf);
		}
		buf.puts("]");
		return buf;
	}
	def first() -> Type {
		return if(sub == null, newType, sub[0]);
	}
}
// Integer types might be split into multiple words for target machines < 64 bit.
class IntNorm extends TypeNorm {
	def bigEndian: bool;
	new(oldType: Type, newType: Type, sub: Array<Type>, bigEndian)
		super(oldType, newType, sub) { }
	def bigEndIndex() -> int {
		return if(bigEndian, 0, size - 1);
	}
	def littleEndIndex() -> int {
		return if(bigEndian, size - 1, 0);
	}
	// Select {n} items from {input} corresponding to the low-order words.
	def getLowestN<T>(inputs: Array<T>, n: int) -> Array<T> {
		if (bigEndian) return Arrays.range(inputs, inputs.length - n, inputs.length); // [big,vN,...,v0]
		else return Arrays.range(inputs, 0, n);  // [v0,...,vN,big]
	}
	// Create a new array of {n} items, copying the low order words from {inputs} and
	// extending the upper words with {extend}.
	def growToN<T>(inputs: Array<T>, n: int, extend: T) -> Array<T> {
		var result = Array<T>.new(n);
		if (bigEndian) {
			var d = n - 1;
			for (i = inputs.length - 1; i >= 0; i--) result[d--] = inputs[i];
			while (d >= 0) result[d--] = extend;
		} else {
			var d = 0;
			for (i = 0; i < size; i++) result[d++] = inputs[i];
			while (d < result.length) result[d++] = extend;
		}
		return result;
	}
	// Simulate a shift left by {n} words, filling in the vacant entries with {extend}.
	def shiftLeft<T>(inputs: Array<T>, n: int, extend: T) {
		shift(true, inputs, n, extend);
	}
	// Simulate a shift right by {n} words, filling in the vacant entries with {extend}.
	def shiftRight<T>(inputs: Array<T>, n: int, extend: T) {
		shift(false, inputs, n, extend);
	}
	def shift<T>(left: bool, inputs: Array<T>, n: int, extend: T) {
		if (left == bigEndian) {
			var i = 0;
			while (i < size - n) { inputs[i] = inputs[i + n]; i++; }
			while (i < size) { inputs[i] = extend; i++; }
		} else {
			var i = size - 1;
			while (i >= n) { inputs[i] = inputs[i - n]; i--; }
			while (i >= 0) { inputs[i] = extend; i--; }
		}
	}
}
// Arrays of tuples may be represented as a tuple of arrays or mixed elements, or a
// combination of both.
class ArrayNorm extends TypeNorm {
	var primitive: bool;
	var instances: List<Record>;
	var enorm: TypeNorm; // for mixed arrays

	new(oldType: Type, newType: Type, sub: Array<Type>) super(oldType, newType, sub) {
		var elem = oldType.nested.head;
		match (elem.typeCon.kind) {
			V3Kind.INT, V3Kind.FLOAT, V3Kind.BOOL, V3Kind.VOID => primitive = true;
		}
	}
	def isMixed() -> bool {
		return enorm != null && enorm.size > 1;
	}
}
// Ranges are normalized to a tuple. This class caches the array norm as well.
class RangeNorm extends TypeNorm {
	def arrayNorm: ArrayNorm;

	new(oldType: Type, newType: Type, sub: Array<Type>, arrayNorm) super(oldType, newType, sub) { }
	def startIndex() -> int { return size - 2; }
	def lengthIndex() -> int { return size - 1; }
}
// Tuples are always flattened into multiple scalars.
class TupleNorm extends TypeNorm {
	def nested: Array<TypeNorm>;
	def offsets: Array<int>;
	new(oldType: Type, newType: Type, sub: Array<Type>, nested, offsets)
		super(oldType, newType, sub) { }
	def getElem<T>(array: Array<T>, index: int) -> Array<T> {
		var ntn = nested[index], offset = offsets[index];
		if (ntn == null) return [array[offset]];
		if (ntn.size == 1) return [array[offset]];
		return Arrays.range(array, offset, offset + ntn.size);
	}
}
// Functions might overflow the maximum number of parameters or returns allowed by the target.
class FuncNorm extends TypeNorm {
	def ovfParamTypes: Array<Type>;
	def ovfReturnTypes: Array<Type>;
	var ovfParamFields: Array<IrSpec>;
	var ovfReturnFields: Array<IrSpec>;

	new(oldType: Type, newType: Type, ovfParamTypes, ovfReturnTypes, sub: Array<Type>)
		super(oldType, newType, sub) { }
	def sig() -> Signature {
		return FuncType.!(sub[0]).sig();
	}
}
// Data type or variant classes can be flattened and represented as scalars.
class DataNorm extends TypeNorm {
	def tagType: IntType;
	def origRanges: Array<(int, int)>;
	def normRanges: Array<(int, int)>;

	new(oldType: Type, newType: Type, tagType, origRanges, normRanges, sub: Array<Type>)
		super(oldType, newType, sub) {
	}
}
