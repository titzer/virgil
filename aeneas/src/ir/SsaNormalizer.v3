// Copyright 2013 Google Inc. All rights reserved.
// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Normalizes SSA code by performing polymorphic specialization and expanding all
// tuples. Note that SSA form supports returns with multiple values.
class SsaRaNormalizer extends SsaRebuilder {
	def norm: ReachabilityNormalizer;
	var specSet: SpecSet;
	var arrayByteNorm = ArrayNorm.!(norm.norm(V3.arrayByteType));
	var rangeByteNorm = RangeNorm.!(norm.norm(V3.rangeByteType));
	var rangeStartType: Type;

	new(context: SsaContext, norm) super(context) {
		rangeStartType = if(norm.config.NormalizeRange, V3Range.START_TYPE, norm.config.RangeStartType);
	}

	def build(newMethod: IrMethod) {
//		trace = CLOptions.TRACE_NORM.get().matches(newMethod.source);
//		if (trace) Terminal.put1("normalizing %q\n", newMethod.renderLong);

		newMethod.ssa = genGraph();
		context.method = newMethod;
		context.graph = newMethod.ssa;
		context.printSsa("Normalized");
//TODO		SsaGraphVerifier.new(context).verify();
		if (context.compiler.NormOptimize) {
			var opt = SsaOptimizer.new(context);
			opt.optGraph();
			context.printSsa("Norm Optimized");
			if (context.compiler.LoadOptimize) {
				// Perform load elimination.
				if (SsaLoadOptimizer.new(context).optimize()) {
					context.printSsa("Load Optimized");
				}
			}
//TODO			SsaGraphVerifier.new(context).verify();
		}
	}
	def genGraph() -> SsaGraph {
		if (newGraph != null) return newGraph;

		// Normalize old parameters into new parameters
		instrMap.reset(context.graph);
		var oldParams = context.graph.params;
		var newParams = Vector<SsaParam>.new().grow(oldParams.length);
		var newRanges = Vector<(int,  int)>.new().grow(oldParams.length);
		var funcType = normFuncType(context.method.sig.funcType());
		for (i < oldParams.length) {
			var oldParam = oldParams[i];
			var tn = normType(oldParam.vtype);
			var start = newParams.length;
			if (tn == null) {
				// common case; type already normalized
				newParams.put(SsaParam.new(newParams.length, oldParam.vtype));
				newRanges.put(start, newParams.length);
				continue;
			}
			if (i == 0) {
				if (tn.size == 0) {
					// receiver became void
					newParams.put(SsaParam.new(newParams.length, tn.newType));
					start++; // skip synthesized receiver
				} else if (VariantNorm.?(tn)) {
					// receiver became flattened data
					var newIrType = norm.ra.getClass(tn.oldType).newIrType;
					newParams.put(SsaParam.new(newParams.length, newIrType));
					start++; // skip synthesized receiver
				}
			}
			if (tn.size == 1) {
				// common case; simple normalization
				newParams.put(SsaParam.new(newParams.length, tn.newType));
			} else {
				// general case of 0...many parameters
				for (j < tn.sub.length) {
					newParams.put(SsaParam.new(newParams.length, tn.sub[j]));
				}
			}
			newRanges.put(start, newParams.length);
		}
		// Allocate new values for mapping the old params
		var newValues = Array<SsaInstr>.new(newParams.length);
		for (i < newParams.length) newValues[i] = newParams[i];

		// Create a new graph, respecting overflow params and returns
		var ovfP = funcType.ovfParamTypes.length;
		var maxP = newParams.length - ovfP;
		newParams.length = maxP;
		var rt = context.graph.returnType;
		var tn = normType(rt);
		if (tn != null) {
			var maxR = norm.config.MaxReturnValues;
			if (tn.size > maxR) {
				rt = Tuple.fromTypeArray(Arrays.range(tn.sub, 0, maxR));
			} else {
				rt = tn.newType;
			}
		}
		newGraph = SsaGraph.new(newParams.extract(), rt);

		if (ovfP > 0) {
			// Handle overflow parameters by inserting loads+casts in the first block
			var b = SsaBuilder.new(context, newGraph, newGraph.startBlock);
			var nullConst = newGraph.nullConst(funcType.ovfParamFields[0].receiver);
			for (i < ovfP) {
				var load = b.opGetField(funcType.ovfParamFields[i], nullConst);
				var cast = b.opTypeSubsume(funcType.ovfParamFields[i].getFieldType(), funcType.ovfParamTypes[i], load);
				newValues[i + maxP] = cast;
			}
		}

		// Map old parameters to new parameters
		for (i < newRanges.length) {
			var t = newRanges[i], size = t.1 - t.0;
			var oldParam = oldParams[i];
			if (size == 0) map0(oldParam);
			else if (size == 1) map1(oldParam, newValues[t.0]);
			else mapN(oldParam, Arrays.range(newValues, t.0, t.1));
		}

		// Visit and generate new normalized code
		var oldStart = context.graph.startBlock;
		if (oldStart.succs().length == 0) {
			// common case of a single block that ends in return or throw
			// no need for blockmaps, queueing, or phi handling
			genBlock(oldStart, newGraph.startBlock);
		} else {
			// a method with multiple blocks
			genMultiBlock(oldStart, newGraph.startBlock);
		}
//		if (true) SsaGraphVerifier.new(context.prog, newGraph).verify();
		return newGraph;
	}
	def mapParam1(params: Vector<SsaParam>, i_old: SsaParam, t: Type) {
		var i_new = SsaParam.new(params.length, t);
		params.put(i_new);
		map1(i_old, i_new);
	}
	def genSimpleVal(tn: TypeNorm, v: Val) -> Val {
		return norm.normSimpleVal(tn, v);
	}
	def genValN(i_old: SsaConst, tn: TypeNorm, vec: Vector<SsaInstr>) {
		vec.puta(mapValueN(i_old, i_old.val, tn));
	}
	def mapValue(i_old: SsaInstr, v: Val, tn: TypeNorm) -> SsaConst {
		var val: SsaConst;
		if (tn.sub == null) {
			// simple normalization
			if (tn.size == 0) map0(i_old); // void
			else map1(i_old, val = newGraph.valConst(tn.newType, norm.normSimpleVal(tn, v)));
		} else {
			// complex normalization
			mapValueN(i_old, v, tn);
		}
		return val;
	}
	def mapValueN(i_old: SsaInstr, v: Val, tn: TypeNorm) -> Array<SsaInstr> {
		// complex normalization
		var nv = Array<Val>.new(tn.size);
		norm.normValIntoArray(v, tn, nv, 0);
		var vals = Array<SsaInstr>.new(nv.length);
		for (j < vals.length) vals[j] = newGraph.valConst(tn.sub[j], nv[j]);
		mapNnf(i_old, vals);
		return vals;
	}
	def genApplyOp(i_old: SsaApplyOp) {
//		if (trace) Terminal.put2("genApplyOp @%d %s\n", i_old.uid, i_old.op.opcode.name);
		if (i_old.useList == null && i_old.facts.O_PURE) return; // remove dead code
		curBlock.at(i_old.source);
		var orig = i_old.op, op = i_old.op, args = i_old.inputs;
		if (context.spec != null) op = i_old.op.subst(context.spec.instantiateType);
		match (op.opcode) {
			BoolEq,
			RefEq,
			IntEq =>		normSimpleEqualOp(i_old, op);
			DefaultValue =>		{
				var tn = normType(op.typeArgs[0]);
				var v = norm.ra.defaultValues[tn.oldType];
				return void(mapValue(i_old, v, tn));
			}
			OverloadedEq,
			VariantEq =>		normEqualOp(i_old, op);
			IntViewI =>		normIntViewI(i_old, op);
			TypeCast =>		normTypeCast(i_old, op);
			TypeQuery =>		normTypeQuery(i_old, op);
			TypeSubsume =>		normTypeSubsume(i_old, op);
			ArrayAlloc =>		normArrayAlloc(i_old, op);
			ArrayFill =>		normArrayFill(i_old, op);
			ArrayInit(length) =>	normArrayInit(i_old, op, length);
			ArrayGetElem =>		normArrayGetElem(i_old, op);
			ArraySetElem =>		normArraySetElem(i_old, op);
			ArrayGetLength =>	normArrayGetLength(i_old, op);
			RangeFromTo =>		normRangeFromTo(i_old, op);
			RangeFromPlus =>	normRangeFromPlus(i_old, op);
			RangeGetElem =>		normRangeGetElem(i_old, op);
			RangeSetElem =>		normRangeSetElem(i_old, op);
			RangeGetLength =>	{
				var r = genRefs(args);
				var tn = normType(op.typeArgs[0]);
				return map1(i_old, r[tn.size - 1]);
			}
			ClassAlloc(method) =>	normClassAlloc(i_old, method, op);
			ClassGetField(field) =>	normGetField(false, i_old, field, op);
			ClassInitField(field) =>normClassSetField(i_old, field, op, true);
			ClassSetField(field) =>	normClassSetField(i_old, field, op, false);
			ClassGetMethod(method) => {
				var obj = genRef1(args[0]);
				addNullCheck(i_old, obj);
				mapN(i_old, [funcRef(extractMethodRef(orig, method).1), obj]);
			}
			ClassGetVirtual(method) => {
				var t = extractVirtualRef(orig, method), obj = genRef1(args[0]), m = t.1;
				if (t.2) { // still a virtual dispatch
					mapN(i_old, [curBlock.opGetSelector(t.1, obj), obj]);
				} else {
					addNullCheck(i_old, obj);
					if (m.member.facts.M_ABSTRACT) {
						return mapN(i_old, [newGraph.nullConst(AnyFunction.TYPE), newGraph.nullConst(AnyRef.TYPE)]);
					}
					mapN(i_old, [funcRef(t.1), obj]);
				}
			}
			VariantGetTag => {
				var rc = norm.ra.makeClass(op.typeArgs[0]);
				var t = normVariantGetTag(rc.variantNorm, genRefs(args));
				if (t != null) return map1(i_old, t);
				else normDefault(i_old, op);
			}
			VariantGetField(field) =>	normGetField(true, i_old, field, op);
			VariantGetMethod(method) => {
				var obj = genRef1(args[0]);
				mapN(i_old, [funcRef(extractMethodRef(orig, method).1), obj]);
			}
			VariantGetVirtual(method) => {
				var t = extractVirtualRef(orig, method), obj = genRef1(args[0]);
				if (t.2) { // still a virtual dispatch
					mapN(i_old, [curBlock.opGetSelector(t.1, obj), obj]);
				} else {
					mapN(i_old, [funcRef(t.1), obj]);
				}
			}
			Init =>				map0(i_old);
			ComponentGetField(field) =>	normComponentGetField(i_old, field, op);
			ComponentSetField(field) =>	normComponentSetField(i_old, field, op);
			TupleCreate => {
				mapNnf(i_old, genRefs(args));
			}
			TupleGetElem(index) => {
				normTupleGetElem(i_old, args, op, index);
			}
			NullCheck =>		normNullCheck(i_old, op);
			BoundsCheck =>		normBoundsCheck(i_old, op);
			// XXX: use SsaBuilder.opCallXXX() methods
			CallMethod(method) => {
				var rc = norm.ra.getClass(op.typeArgs[0]);
				var t = extractMethodRef(orig, method), funcNorm = t.0, m = t.1;
				var newOp = V3Op.newCallMethod(m);
				var ai_new = normArgs(funcNorm, genRefs(i_old.inputs));
				if (V3.isVariant(rc.oldType)) {
					if (rc.isUnboxed()) {
						// flattened data type becomes component call and needs new receiver
						ai_new = Arrays.prepend(newGraph.nullReceiver(), ai_new);
					}
				}
				normCall(i_old, funcNorm, newOp, ai_new);
			}
			CallClassMethod(method) => {
				var t = extractMethodRef(orig, method), funcNorm = t.0, m = t.1;
				var newOp = V3Op.newCallClassMethod(m);
				var ai_new = normArgs(funcNorm, genRefs(i_old.inputs));
				var i = normCall(i_old, funcNorm, newOp, ai_new);
				if (ai_new[0].facts.V_NON_ZERO) i.setFact(Fact.O_NO_NULL_CHECK);
			}
			CallClassVirtual(method) => {
				// devirtualize methods that are not overridden
				var t = extractVirtualRef(orig, method), funcNorm = t.0, m = t.1;
				var ai_new = normArgs(funcNorm, genRefs(i_old.inputs));
				var i: SsaInstr;
				if (t.2) { // still a virtual dispatch
					i = normCall(i_old, funcNorm, V3Op.newCallClassSelector(m), ai_new);
				} else {
					// devirtualized to call abstract method => no objects instantiated of that type
					if (m.member.facts.M_ABSTRACT) {
						var sig = funcNorm.sig(), rt = sig.returnTypes;
						var rv = Vector<SsaInstr>.new();
						for (i < rt.length) rv.put(newGraph.nullConst(rt[i]));
						for (i < funcNorm.ovfReturnTypes.length) rv.put(newGraph.nullConst(funcNorm.ovfReturnTypes[i]));
						return mapN(i_old, rv.extract());
					}
					var newOp = V3Op.newCallClassMethod(m);
					i = normCall(i_old, funcNorm, newOp, ai_new);
				}
				if (ai_new[0].facts.V_NON_ZERO) i.setFact(Fact.O_NO_NULL_CHECK);
			}
			CallVariantVirtual(method) => {
				// devirtualize methods that are not overridden
				var rc = norm.ra.getClass(op.typeArgs[0]);
				var t = extractVirtualRef(orig, method), funcNorm = t.0, m = t.1;
				var ai_new = normArgs(funcNorm, genRefs(i_old.inputs));
				if (t.2) { // still a virtual dispatch
					if (rc.isUnboxed()) {
						// use the variant tag as an index into a table of functions
						var tag = normVariantGetTag(rc.variantNorm, ai_new);
						var record = IrSelector.!(m.member).mtable.record;
						var table = newGraph.valConst(record.rtype, record);
						var func = curBlock.opArrayGetElem(record.rtype, rc.variantNorm.tagType(), Facts.O_SAFE_BOUNDS, table, tag);
						ai_new = Arrays.concat([func, newGraph.nullReceiver()], ai_new);
						normCall(i_old, funcNorm, V3Op.newCallFunction(funcNorm.sub[0]), ai_new);
					} else {
						normCall(i_old, funcNorm, V3Op.newCallVariantSelector(m), ai_new);
					}
				} else {
					if (rc.isUnboxed()) {
						// flattened data type becomes component call and needs new receiver
						ai_new = Arrays.prepend(newGraph.nullReceiver(), ai_new);
					}
					normCall(i_old, funcNorm, V3Op.newCallMethod(m), ai_new);
				}
			}
			CallClosure => {
				var funcNorm = normFuncType(op.typeArgs[0]);
				// normalize CallClosure into CallFunction
				// XXX: use SsaBuilder.opCallFunction
				var ai_new = normArgs(funcNorm, genRefs(i_old.inputs));
				normCall(i_old, funcNorm, V3Op.newCallFunction(funcNorm.sub[0]), ai_new);
			}
			CreateClosure(method) => {
				var spec = extractMethodRef(orig, method).1;
				var receiver = if(V3.isComponent(spec.receiver), newGraph.nullReceiver(), genRef1(args[0]));
				return mapN(i_old, [funcRef(spec), receiver]);
			}
			ForgeClosure => {
				var nargs = genRefs(args), nfunc = nargs[0];
				var nobj = if(nargs.length == 1, newGraph.nullConst(normType(op.typeArgs[0]).newType), nargs[1]);
				return mapN(i_old, [nfunc, nobj]);
			}
			UnpackClosure => {
				var ptrType = op.sig.returnTypes[0];
				var nargs = genRefs(args), nfunc = nargs[0];
				var nobj = if(nargs.length == 1, newGraph.nullConst(ptrType), nargs[1]);
				return mapN(i_old, [nfunc, nobj]);
			}
			ForgeRange => {
				var nargs = genRefs(args);
				var en = normTypeArg(op, 0);
				var arrayType = V3Array.newType(en.newType);
				var nullArray = newGraph.nullConst(arrayType);
				var length = nargs[1];
				return mapN(i_old, [nullArray, nargs[0], length]);
			}
			RefLayoutAt => {
				var an = arrayByteNorm;
				var ai_new = genRefs(i_old.inputs);
				if (context.compiler.boundsCheck(i_old.facts)) {
					// XXX: manually CSE the promotions here?
					var array = ai_new[0], offset = ai_new[an.size];
					curBlock.opBoundsCheck(an.newType, array, offset);
					var t = RefType.!(op.typeArgs[0]);
					var layout_size = newGraph.intConst(t.layoutDecl.byteSize);
					var end_index = curBlock.opIntAdd(offset, layout_size);
					var array_length = curBlock.opArrayGetLength(an.newType, array);
					var c1 = curBlock.opIntULt(norm.config.ArrayLengthType, norm.config.ArrayLengthType, array_length, end_index);
					curBlock.opConditionalThrow(V3Exception.BoundsCheck, c1);
				}
				var rangeStart: SsaInstr;
				if (norm.config.NormalizeRange) {
					rangeStart = curBlock.opRangeStartPlusIndex(an.oldType, Int.TYPE, i_old.facts, newGraph.arrayRangeStartConst(0, an.newType), ai_new[an.size]);
				} else {
					rangeStart = ai_new[an.size];
				}
				return mapN(i_old, [ai_new[0], rangeStart]);
			}
			RefLayoutOf => {
				var an = rangeByteNorm;
				var ai_new = genRefs(i_old.inputs);
				if (context.compiler.boundsCheck(i_old.facts)) {
					var array = ai_new[0], start = ai_new[an.startIndex()], length = ai_new[an.lengthIndex()];
					var t = RefType.!(op.typeArgs[0]);
					var layout_size = newGraph.intConst(t.layoutDecl.byteSize);
					var c1 = curBlock.opIntULt(norm.config.ArrayLengthType, norm.config.ArrayLengthType, length, layout_size);
					curBlock.opConditionalThrow(V3Exception.BoundsCheck, c1);
				}
				return mapN(i_old, Arrays.range(ai_new, 0, ai_new.length - 1));
			}
			RefLayoutIn(offset) => {
				var an = arrayByteNorm;
				var ai_new = genRefs(i_old.inputs);
				var array = ai_new[0], start = ai_new[an.size];
				ai_new[an.size] = if(norm.config.NormalizeRange,
					curBlock.opRangeStartPlusIndex(an.oldType, Int.TYPE, i_old.facts, start, newGraph.intConst(offset)),
					curBlock.opIntAdd(start, newGraph.intConst(offset)));
				return mapN(i_old, ai_new);
			}
			RefLayoutGetField(offset) => {
				var an = arrayByteNorm;
				var fn = normTypeArg(op, 1);
				var ai_new = genRefs(i_old.inputs);
				var array = ai_new[0], start = ai_new[an.size];
				var facts: Fact.set = Fact.O_NO_BOUNDS_CHECK;
				var result: SsaInstr;

				match (fn.oldType) {
					x: IntType => result = curBlock.opByteArrayGetField(x, rangeStartType, offset, facts, array, start);
					x: FloatType => result = curBlock.opByteArrayGetField(x, rangeStartType, offset, facts, array, start);
					x: EnumType => {
						var it = IntType.!(x.enumDecl.tagType);
						var wt = Int.getType(false, it.byteSize() * 8);
						result = curBlock.opByteArrayGetField(wt, rangeStartType, offset, facts, array, start);
						var caseCount = newGraph.intConst(x.enumDecl.cases.length);
						var inBound = curBlock.opIntULt(norm.config.ArrayLengthType, it, result, caseCount);
						result = curBlock.opIntViewI0(it, wt, result);
						result = curBlock.addSelect(it, inBound, result, newGraph.nullConst(it));
					}
					_ => context.fail1("unexpected type %q", fn.oldType.render);
				}
				return map1(i_old, result);
			}
			RefLayoutSetField(offset) => {
				var fn = normTypeArg(op, 1);
				var ai_new = genRefs(args);
				var array = ai_new[0], start = ai_new[1], val = ai_new[2];
				var facts: Fact.set = Fact.O_NO_BOUNDS_CHECK;
				var result: SsaInstr;

				match (fn.oldType) {
					x: IntType => result = curBlock.opByteArraySetField(fn.oldType, rangeStartType, offset, facts, array, start, val);
					x: FloatType => result = curBlock.opByteArraySetField(fn.oldType, rangeStartType, offset, facts, array, start, val);
					x: EnumType => {
						var it = IntType.!(x.enumDecl.tagType);
						var wt = Int.getType(false, it.byteSize() * 8);
						result = curBlock.opByteArraySetField(wt, rangeStartType, offset, facts, array, start, val);
					}
				}
				return map1(i_old, result);
			}
			RefLayoutGetRepeatedField(offset, scale, max) => {
				var rn = normTypeArg(op, 0), fn = normTypeArg(op, 1);
				var ai_new = genRefs(args);
				var array = ai_new[0], start = ai_new[1], index = ai_new[2];
				if (context.compiler.boundsCheck(i_old.facts)) {
					var oob = curBlock.opBoolNot(curBlock.opIntULt(norm.config.ArrayLengthType, norm.config.ArrayLengthType,
						index, newGraph.intConst(max)));
					curBlock.opConditionalThrow(V3Exception.BoundsCheck, oob);
				}
				var result = SsaInstr.!(newGraph.intConst(0));
				start = if(norm.config.NormalizeRange,
					curBlock.opRangeStartPlusIndex(rn.sub[0], Int.TYPE, i_old.facts, start, curBlock.opIntMul(index, newGraph.intConst(scale))),
					curBlock.opIntAdd(start, curBlock.opIntMul(index, newGraph.intConst(scale)))
				);
				var facts: Fact.set = Fact.O_NO_BOUNDS_CHECK;
				match (fn.oldType) {
					x: IntType => result = curBlock.opByteArrayGetField(x, rangeStartType, offset, facts, array, start);
					x: FloatType => result = curBlock.opByteArrayGetField(x, rangeStartType, offset, facts, array, start);
					x: EnumType => {
						var it = IntType.!(x.enumDecl.tagType);
						result = curBlock.opByteArrayGetField(it, rangeStartType, offset, facts, array, start);
						var caseCount = newGraph.intConst(x.enumDecl.cases.length);
						var inBound = curBlock.opIntULt(it, it, result, caseCount);
						result = curBlock.addSelect(it, inBound, result, newGraph.nullConst(it));
					}
					_ => ;
				}
				return map1(i_old, result);
			}
			RefLayoutSetRepeatedField(offset, scale, max) => {
				var rn = normTypeArg(op, 0), fn = normTypeArg(op, 1);
				var ai_new = genRefs(args);
				var array = ai_new[0], start = ai_new[1], index = ai_new[2], val = ai_new[3];
				if (context.compiler.boundsCheck(i_old.facts)) {
					var oob = curBlock.opBoolNot(curBlock.opIntULt(norm.config.ArrayLengthType, norm.config.ArrayLengthType,
						index, newGraph.intConst(max)));
					curBlock.opConditionalThrow(V3Exception.BoundsCheck, oob);
				}
				start = if(norm.config.NormalizeRange,
					curBlock.opRangeStartPlusIndex(rn.sub[0], Int.TYPE, i_old.facts, start, curBlock.opIntMul(index, newGraph.intConst(scale))),
					curBlock.opIntAdd(start, curBlock.opIntMul(index, newGraph.intConst(scale)))
				);
				var facts: Fact.set = Fact.O_NO_BOUNDS_CHECK;
				var result: SsaInstr;
				match (fn.oldType) {
					x: IntType => result = curBlock.opByteArraySetField(fn.oldType, rangeStartType, offset, facts, array, start, val);
					x: FloatType => result = curBlock.opByteArraySetField(fn.oldType, rangeStartType, offset, facts, array, start, val);
					x: EnumType => {
						var it = IntType.!(x.enumDecl.tagType);
						result = curBlock.opByteArraySetField(it, rangeStartType, offset, facts, array, start, val);
					}
				}
				return map1(i_old, result);
			}
			PtrAtContents => {
				// rewrite to PtrAtArrayElem
				var rn = RangeNorm.!(normTypeArg(op, 0));
				var ai_new = genRefs(args);
				var narr = ai_new[0], start = ai_new[rn.startIndex()];
				var arrayType = ArrayType.!(rn.sub[0]), ptrType = op.sig.returnType();
				var op = if(norm.config.NormalizeRange, V3Op.newPtrAddRangeStart(ptrType), V3Op.newPtrAtArrayElem(arrayType, norm.config.RangeStartType, ptrType));
				var i_new = curBlock.addApply(curBlock.source, op, [narr, start]);
				i_new.facts |= Fact.O_NO_BOUNDS_CHECK;
				map1(i_old, i_new);
			}
			PtrAtRangeElem => {
				// insert explicit bounds check and rewrite to PtrAtArrayElem
				var rn = RangeNorm.!(normTypeArg(op, 0));
				var ai_new = genRefs(args);
				var narr = ai_new[0], start = ai_new[rn.startIndex()],
					length = ai_new[rn.lengthIndex()], index = ai_new[rn.lengthIndex() + 1];
				var arrayType = ArrayType.!(rn.sub[0]), ptrType = op.sig.returnType();
				addNullCheck(i_old, narr);
				if (context.compiler.boundsCheck(i_old.facts)) {
					var c1 = curBlock.opU32LtEq(length, index);
					curBlock.opConditionalThrow(V3Exception.BoundsCheck, c1);
				}
				var i_new: SsaInstr;
				if (norm.config.NormalizeRange) {
					var nstart = curBlock.opRangeStartPlusIndex(rn.sub[0], Int.TYPE, i_old.facts, start, index);
					var op = V3Op.newPtrAddRangeStart(ptrType);
					i_new = curBlock.addApply(curBlock.source, op, [narr, nstart]);
				} else {
					var nstart = rangeStartAdd(start, index);
					var op = V3Op.newPtrAtArrayElem(arrayType, norm.config.RangeStartType, ptrType);
					i_new = curBlock.addApply(curBlock.source, op, [narr, nstart]);
				}
				i_new.facts |= Fact.O_NO_BOUNDS_CHECK;
				map1(i_old, i_new);
			}
			PtrAtRef => {
				if (norm.config.NormalizeRange) {
					var ai_new = genRefs(args);
					var ptrType = op.sig.returnType();
					var op = V3Op.newPtrAddRangeStart(ptrType);
					var i_new = curBlock.addApply(curBlock.source, op, ai_new);
					map1(i_old, i_new);
				} else {
					normDefault(i_old, op);
				}
			}
			PtrAtObjectField(field) => {
				var receiver = genRef1(i_old.inputs[0]);
				var raField = extractFieldRef(i_old, field);
				var nf = raField.liveFields(norm.ra);
				var i_new = curBlock.addApply(curBlock.source,
					V3Op.newPtrAtObjectField(nf[0], i_old.op.sig.returnType()), [receiver]);
				map1(i_old, i_new);
			}
			PtrAtComponentField(field) => {
				var raField = extractFieldRef(i_old, field);
				var nf = raField.liveFields(norm.ra);
				var i_new = curBlock.addApply(curBlock.source,
					V3Op.newPtrAtComponentField(nf[0], i_old.op.sig.returnType()), Ssa.NO_INSTRS);
				map1(i_old, i_new);
			}
			PtrAtRefLayoutField(offset) => {
				if (norm.config.NormalizeRange) {
					var ai_new = genRefs(args);
					var ptrType = op.sig.returnType();
					var op = V3Op.newPtrAddRangeStart(ptrType);
					var start = curBlock.addApply(curBlock.source, op, ai_new);
					var pt = PointerType.!(start.getType());
					var it = Int.getType(true, pt.width); // TODO: ugly, cache ptr arithmetic
					var i_new = curBlock.pure(V3Op.newPtrAdd(pt, it), [start, newGraph.intConst(offset)]);
					map1(i_old, i_new);
				} else {
					normDefault(i_old, op);
				}
			}
			SystemCall(syscall) => {
				// normalize a syscall operator
				var ptn = normType(Tuple.fromTypeArray(op.sig.paramTypes));
				var paramTypes = Tuple.toTypeArray(ptn.newType);
				var returnType = normReturnType(op);
				var newOp = V3Op.newSystemCall(syscall, paramTypes, returnType.newType);
				var ai_new = genRefs(i_old.inputs);
				var i_new = curBlock.addApply(i_old.source, newOp, ai_new);
				i_new.facts = i_new.facts | i_old.facts;
				mapNorm(i_old, i_new, returnType);
			}
			_ => {
				normDefault(i_old, op);
			}
		}
	}
	def genArrayByteGetMultiple(i_old: SsaApplyOp, it: IntType, array: SsaInstr, i_offset: SsaInstr, offset: int) -> SsaInstr {
		// TODO: little-endian only for now
		curBlock.at(i_old.source);
		var facts: Fact.set = Fact.O_NO_BOUNDS_CHECK;
		var size = it.packedByteSize();
		var wt = Int.getType(false, it.byteSize() * 8); // rounded to next power of two for efficient shifting
		var result: SsaInstr = newGraph.nullConst(wt);
		var indexType = norm.config.RangeStartType;
		for (i < size) {
			var read = curBlock.opArrayGetElem(V3.arrayByteType, indexType, facts,
				array, curBlock.opIntAdd(newGraph.intConst(i + offset), i_offset));
			read = curBlock.opIntViewI0(Byte.TYPE, wt, read);
			var shifted = if(i == 0, read, curBlock.addApplyF(wt.opShl(), [read, newGraph.intConst(8 * i)], Facts.O_SAFE_SHIFT));
			result = curBlock.addApplyF(wt.opOr(), [result, shifted], Fact.O_PURE);
			facts |= Fact.O_NO_NULL_CHECK;
		}
		return result;
	}
	def genArrayByteSetMultiple(i_old: SsaApplyOp, it: IntType, array: SsaInstr, i_offset: SsaInstr, offset: int, val: SsaInstr) {
		// TODO: little-endian only for now
		curBlock.at(i_old.source);
		var size = it.packedByteSize();
		var facts: Fact.set = Fact.O_NO_BOUNDS_CHECK;
		var indexType = norm.config.RangeStartType;
		for (i < size) {
			var shifted = curBlock.addApplyF(it.opShr(), [val, newGraph.intConst(8 * i)], Facts.O_SAFE_SHIFT);
			var b = curBlock.opIntViewI0(it, Byte.TYPE, shifted);
			var write = curBlock.opArraySetElem(array.getType(), indexType, facts,
				array, curBlock.opIntAdd(newGraph.intConst(i + offset), i_offset), b);
			facts |= Fact.O_NO_NULL_CHECK;
		}
	}
	def normDefault(i_old: SsaApplyOp, op: Operator) {
		// normalize a general operator
		var newOp = op;
		var ai_new = genRefs(i_old.inputs);
		var i_new = curBlock.addApply(i_old.source, newOp, ai_new);
		i_new.facts = i_new.facts | i_old.facts;
		mapNorm(i_old, i_new, normReturnType(op));
	}
	def genReturn(oldRet: SsaReturn) {
		// map a return (may return multiple values)
		var vals = genRefs(oldRet.inputs), maxR = norm.config.MaxReturnValues;
		if (vals.length > maxR) {
			var ovfRets = Arrays.range(vals, maxR, vals.length);
			vals = Arrays.range(vals, 0, maxR);
			var funcNorm = normFuncType(context.method.sig.funcType());
			var nullConst = newGraph.nullConst(funcNorm.ovfReturnFields[0].receiver);
			for (i < ovfRets.length) {
				curBlock.opComponentSetField(funcNorm.ovfReturnFields[i], nullConst, ovfRets[i]);
			}
		}
		return curBlock.addReturn(vals);
	}
	def normCall(i_old: SsaApplyOp, funcNorm: FuncNorm, newOp: Operator, ai_new: Array<SsaInstr>) -> SsaInstr {
		// Create the new call instruction
		var call = curBlock.addApply(i_old.source, newOp, ai_new);
		call.facts = call.facts | i_old.facts;

		if (funcNorm.ovfReturnTypes.length > 0) {
			// load overflow return values from globals
			var fsig = funcNorm.sig();
			var rvals = Vector<SsaInstr>.new();
			if (fsig.returnTypes.length == 1) {
				rvals.put(call);
			} else {
				for (i < fsig.returnTypes.length) rvals.put(curBlock.opTupleGetElem(fsig.returnType(), i, call));
			}
			var nullConst = newGraph.nullConst(funcNorm.ovfReturnFields[0].receiver);
			for (i < funcNorm.ovfReturnTypes.length) {
				var load = curBlock.opGetField(funcNorm.ovfReturnFields[i], nullConst);
				var cast = curBlock.opTypeSubsume(funcNorm.ovfReturnFields[i].getFieldType(), funcNorm.ovfReturnTypes[i], load);
				rvals.put(cast);
			}
			mapN(i_old, rvals.extract());
		} else {
			var tn = normType(i_old.op.sig.returnType());
			mapNorm(i_old, call, tn);
		}
		return call;
	}
	def normArgs(funcNorm: FuncNorm, args: Array<SsaInstr>) -> Array<SsaInstr> {
		if (funcNorm.ovfParamTypes.length > 0) {
			// write overflow arguments into globals and truncate args array
			var maxP = args.length - funcNorm.ovfParamTypes.length;
			var ovfArgs = Arrays.range(args, maxP, args.length);
			args = Arrays.range(args, 0, maxP);
			var nullConst = newGraph.nullConst(funcNorm.ovfParamFields[0].receiver);
			for (i < ovfArgs.length) {
				curBlock.opComponentSetField(funcNorm.ovfParamFields[i], nullConst, ovfArgs[i]);
			}
		}
		return args;
	}
	def normTypeSubsume(i_old: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1);
		if (rtn.sub == null) {
			// common case 1-1 mapping
			return map1(i_old, curBlock.opTypeSubsume(atn.newType, rtn.newType, genRef1(i_old.inputs[0])));
		}
		var width = rtn.size;
		if (width > 0) {
			// complex operator
			var ai_new = genRefs(i_old.inputs);
			var vals = Array<SsaInstr>.new(width);
			for (i < width) {
				var ft = if(atn.sub == null, atn.newType, atn.sub[i]);
				vals[i] = curBlock.opTypeSubsume(ft, rtn.sub[i], ai_new[i]);
			}
			mapNnf(i_old, vals);
		}
	}
	// normalize an equality operator
	def normEqualOp(i_old: SsaApplyOp, op: Operator) {
		var tn = normTypeArg(op, 0);
		var refs = genRefs(i_old.inputs);
		match (tn) {
			x: VariantNorm => if (!x.isEnum()) return map1(i_old, normUnboxedVariantEqual(i_old, x, refs));
			_ => if (V3.isVariant(tn.newType)) return map1(i_old, normVariantEqual(i_old, tn.newType, refs[0], refs[1]));
		}
		map1(i_old, normEqual(i_old, tn, refs));
	}
	def normEqual1(i_old: SsaApplyOp, t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (V3.isVariant(t)) return normVariantEqual(i_old, t, x, y);
		return curBlock.opEqual(t, x, y);
	}
	def normEqual(i_old: SsaApplyOp, tn: TypeNorm, refs: Array<SsaInstr>) -> SsaInstr {
		if (tn.size == 0) return newGraph.trueConst();
		if (tn.size == 1) return normEqual1(i_old, tn.newType, refs[0], refs[1]);

		var expr: SsaInstr;
		for (i < tn.size) {
			var cmp = normEqual1(i_old, tn.sub[i], refs[i], refs[i + tn.size]);
			expr = if(expr == null, cmp, opBoolAnd(expr, cmp));
		}
		return expr;
	}
	def normSimpleEqualOp(i_old: SsaApplyOp, op: Operator) {
		var tn = normTypeArg(op, 0);
		var refs = genRefs(i_old.inputs);
		return map1(i_old, curBlock.opEqualOf(op, refs[0], refs[1]));
	}
	def normVariantEqual(i_old: SsaApplyOp, t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var rc = norm.ra.getClass(t);
		var list = rc.methods[IrUtil.EQUALS_METHOD_INDEX];
		if (list == null) {
			return normVariantEqual(i_old, rc.parent.oldType, x, y);
		}
		var rm = list.head;
		// devirtualize methods that are not overridden
		var tn = normType(t);
		var t = tryDevirtualize(rm, [tn.newType]), m = t.0, newOp: Operator; // XXX: inline
		var facts = Fact.O_PURE | Fact.O_COMMUTATIVE;
		if (t.1) {
			newOp = V3Op.newCallVariantSelector(m);
		} else {
			newOp = V3Op.newCallMethod(m);
			facts |= Fact.O_NO_NULL_CHECK;
		}
		var call = curBlock.addApply(i_old.source, newOp, [x, y]);
		call.setFact(facts);
		return call;
	}
	// Normalize equality between two unboxed variants of the same case (e.g. x: T.A == y: T.A)
	def normUnboxedVariantCaseEqual(i_old: SsaApplyOp, vn: VariantNorm, refs: Array<SsaInstr>) -> SsaInstr {
		var join = opBoolAnd;
		var expr: SsaInstr;
		for (i < vn.fields.length) {
			var f = vn.fields[i];
			for (j < f.indexes.length) {
				var idx = f.indexes[j];
				var cmp: SsaInstr, a = refs[idx], b = refs[idx + vn.size];
				a = genVariantScalarView(vn.sub[idx], f.tn.at(j), a);
				b = genVariantScalarView(vn.sub[idx], f.tn.at(j), b);
				cmp = normEqual1(i_old, f.tn.at(j), a, b);
				if (expr == null) expr = cmp;
				else expr = join(expr, cmp);
			}
		}
		return if(expr != null, expr, newGraph.trueConst());
	}
	// Normalize equality between two unboxed variants of unknown case (e.g. x: T == y: T)
	def normUnboxedVariantEqual(i_old: SsaApplyOp, vn: VariantNorm, refs: Array<SsaInstr>) -> SsaInstr {
		if (vn.hasNoTag()) return normEqual(i_old, vn, refs); // we can always do a scalar-by-scalar comparison if no boxes are involved.
		var ct = ClassType.!(vn.oldType);
		if (ct.superType != null) return normUnboxedVariantCaseEqual(i_old, vn, refs);

		var xTag = normVariantGetTag(vn, refs[0 ... vn.size]);
		var yTag = normVariantGetTag(vn, refs[vn.size ...]);

		var tagsEqual = curBlock.opEqual(vn.tagType(), xTag, yTag);
		var ifc = curBlock.splitForIfCascade(Bool.TYPE);

		ifc.addNotCase(tagsEqual);
		ifc.endCase(newGraph.falseConst());

		for (l = vn.children; l != null; l = l.tail) {
			var cn = l.head;
			var tag = V3.getVariantTag(cn.oldType);
			ifc.addCase(curBlock.opEqual(vn.tagType(), xTag, newGraph.intConst(tag)));
			var result = normUnboxedVariantCaseEqual(i_old, cn, refs);
			ifc.endCase(result);
		}

		ifc.addElse();
		ifc.endCase(newGraph.falseConst());
		return ifc.finish();
	}
	def normVariantGetTag(vn: VariantNorm, args: Range<SsaInstr>) -> SsaInstr {
		if (vn == null) return null;
		if (vn.hasNoTag()) return newGraph.zeroConst();
		if (vn.hasExplicitTag() && vn.tag.isPacked()) {
			var tag = vn.tag, tagIdx = tag.indexes[0], tagInterval = tag.intervals[0];
			return genExtractInterval(args[tagIdx], tagInterval, IntRepType.!(vn.at(tagIdx)), tag.tn.at(0));
		}
		return args[vn.tagIndex()];
	}
	def normTupleGetElem(i_old: SsaInstr, args: Array<SsaDfEdge>, op: Operator, index: int) {
		var tn = TupleNorm.!(normTypeArg(op, 0));
		return mapNnf(i_old, tn.getElem(genRefs(args), index));
	}
	def throwTypeCheckException() {
		curBlock.addThrow(curBlock.source, V3Exception.TypeCheck);
	}
	def normTypeCastRec(ai_old: Array<SsaInstr>, offset: int, atn: TypeNorm, rtn: TypeNorm, result: Vector<SsaInstr>) {
		match (TypeSystem.newTypeCast(atn.oldType, rtn.oldType)) {
			TRUE => {
				for (i < rtn.size) result.put(ai_old[offset + i]);
				return;
			}
			SUBSUME => {
				if (atn.sub == null) result.put(curBlock.opTypeSubsume(atn.newType, rtn.newType, ai_old[offset]));
				else for (i < rtn.size) result.put(curBlock.opTypeSubsume(atn.sub[i], rtn.sub[i], ai_old[offset + i]));
				return;
			}
			TUPLE_CAST => {
				var tatn = TupleNorm.!(atn), trtn = TupleNorm.!(rtn);
				if (tatn.nested.length != trtn.nested.length) return throwTypeCheckException();
				for (i < tatn.nested.length) {
					normTypeCastRec(ai_old, offset + tatn.offsets[i], tatn.nested[i], trtn.nested[i], result);
				}
				return;
			}
			// XXX: CLASS_CAST special-case non-allocated classes
			VARIANT_CAST => {
				if (VariantNorm.?(atn) && VariantNorm.?(rtn)) {
					var avn = VariantNorm.!(atn), rvn = VariantNorm.!(rtn);
					var actualTag = normVariantGetTag(avn, ai_old[offset ...]);
					var expectedTag = rvn.tagValue;
					curBlock.opIntRangeCheck(1, expectedTag, expectedTag + 1, actualTag);
					for (i < avn.size) result.put(ai_old[offset + i]);
					return;
				}
				// break
			}
			UNKNOWN_CAST, THROW => {
				throwTypeCheckException();
				return;
			}
			RANGE_PROMOTE_ARRAY => {
				var an = ArrayNorm.!(atn), arrayType = an.first();
				var s = an.size;
				for (i < s) result.put(ai_old[offset + i]);
				var array = ai_old[offset], len: SsaInstr;

				if (norm.config.NormalizeRange && s <= 1) {
					result.put(newGraph.arrayRangeStartConst(0, an.newType));
				} else {
					result.put(newGraph.zeroConst());
				}

				if (array.facts.V_NON_ZERO) {
					len = curBlock.opArrayGetLength(arrayType, array);
				} else {
					var cmp = curBlock.pure(V3Op.newRefEq(arrayType), [array, newGraph.nullConst(arrayType)]);
					var ifc = curBlock.splitForIfCascade(norm.config.ArrayLengthType);
					ifc.addCase(cmp);
					ifc.endCase(newGraph.zeroConst());
					ifc.addElse();
					var get = curBlock.opArrayGetLength(arrayType, array);
					ifc.endCase(get);
					len = ifc.finish();
				}
				result.put(len);
				return;
			}
			_ => ; // break
		}
		if (atn.size > 1) {
			for (i < atn.size) result.put(curBlock.opTypeCast(atn.sub[i], rtn.sub[i], ai_old[offset + i]));
		} else {
			result.put(curBlock.opTypeCast(atn.newType, rtn.newType, ai_old[offset]));
		}
	}
	def normTypeCast(i_old: SsaApplyOp, op: Operator) {
		curBlock.source = i_old.source;
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1);
		var result = Vector<SsaInstr>.new().grow(rtn.size);  // XXX: reuse temp vector here?
		normTypeCastRec(genRefs(i_old.inputs), 0, atn, rtn, result);
		return mapNnf(i_old, result.extract());
	}
	def normIntViewI(i_old: SsaApplyOp, op: Operator) {
		map1(i_old, curBlock.opIntViewI(op, genRef1(i_old.inputs[0])));
	}
	def normTypeQueryRec(ai_old: Array<SsaInstr>, offset: int, atn: TypeNorm, rtn: TypeNorm, left: SsaInstr) -> SsaInstr {
		match (TypeSystem.newTypeQuery(atn.oldType, rtn.oldType)) {
			TRUE => return left;
			UNKNOWN_QUERY, FALSE => return newGraph.falseConst();
			TUPLE_QUERY => {
				var tatn = TupleNorm.!(atn), trtn = TupleNorm.!(rtn);
				if (tatn.nested.length != trtn.nested.length) return newGraph.falseConst();
				for (i < tatn.nested.length) {
					left = normTypeQueryRec(ai_old, offset + tatn.offsets[i], tatn.nested[i], trtn.nested[i], left);
				}
				return left;
			}
			// XXX: CLASS_QUERY special-case non-allocated classes
			VARIANT_QUERY => {
				if (VariantNorm.?(atn) && VariantNorm.?(rtn)) {
					var avn = VariantNorm.!(atn), rvn = VariantNorm.!(rtn);
					var expectedTag = newGraph.intConst(rvn.tagValue);
					var actualTag = normVariantGetTag(avn, ai_old[offset ...]);
					var check = curBlock.pure(V3Op.newIntEq(avn.tagType()), [actualTag, expectedTag]);
					return opAnd(left, check);
				}
				// break
			}
			_ => ; // break
		}
		if (atn.size > 1) {
			for (i < atn.size) left = opAnd(left, curBlock.opTypeQuery(atn.sub[i], rtn.sub[i], ai_old[offset + i]));
		} else {
			left = opAnd(left, curBlock.opTypeQuery(atn.newType, rtn.newType, ai_old[offset]));
		}
		return left;
	}
	def opAnd(left: SsaInstr, right: SsaInstr) -> SsaInstr {
		return if(left == null, right, curBlock.opBoolAnd0(left, right));
	}
	def normTypeQuery(i_old: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1);
		var i_new = normTypeQueryRec(genRefs(i_old.inputs), 0, atn, rtn, null);
		if (i_new == null) i_new = newGraph.trueConst();
		map1(i_old, i_new);
	}
	def normArrayAlloc(i_old: SsaApplyOp, op: Operator) {
		var rtn = nonzero(normReturnType(op));
		var i_length = genRef1(i_old.inputs[0]);
		if (rtn.size == 1) return map1(i_old, curBlock.opArrayAlloc(rtn.newType, i_length));
		// complex array allocation
		return mapN(i_old, Arrays.map(rtn.sub, newArrayAlloc(_, i_old.source, i_length)));
	}
	def newArrayAlloc(arrayType: Type, source: Source, i_length: SsaInstr) -> SsaInstr {
		return curBlock.opArrayAlloc(arrayType, i_length);
	}
	def normArrayFill(i_old: SsaApplyOp, op: Operator) {
		var at = op.typeArgs[0];
		var atn = ArrayNorm.!(normType(at));
		var etn = normType(V3Array.elementType(at));
		var ai_new = genRefs(i_old.inputs);
		var indexType = Int.TYPE;

		if (curBlock.end || allTrivialValues(ai_new[atn.size ..+ etn.size])) {
			return mapN(i_old, Arrays.range(ai_new, 0, atn.size));
		}

		// XXX: manually write a for-loop to implement Array.fill
		var header = SsaBlock.new(), loop = SsaBlock.new(), end = SsaBlock.new();
		var i_len = curBlock.opArrayGetLength(atn.at(0), ai_new[0]); // XXX: get length from allocation
		var i_zero = newGraph.zeroConst(), i_max = newGraph.intConst(int.max);
		curBlock.addGoto(header);
		curBlock.set(header);
		var i_phi = curBlock.addPhi(indexType, [i_zero, i_max]);
		var i_cmp = curBlock.opIntLt(i_phi, i_len);
		curBlock.addIf(i_cmp, loop, end);
		curBlock.set(loop);
		for (i < etn.size) {
			var val = ai_new[atn.size + i];
			if (SsaConst.?(val) && SsaConst.!(val).val == null) continue; // nothing to fill
			if (atn.isMixed()) {
				curBlock.add(V3Op.newArraySetElemElem(atn.newType, indexType, i), [ai_new[0], i_phi, val], Facts.O_SAFE_BOUNDS);
			} else {
				curBlock.add(V3Op.newArraySetElem(atn.at(i), indexType), [ai_new[i], i_phi, val], Facts.O_SAFE_BOUNDS);
			}
		}
		var i_add = curBlock.opIntAdd(i_phi, newGraph.intConst(1));
		i_phi.inputs[1].update(i_add);
		curBlock.addGoto(header);
		curBlock.set(end);
		var ai_out = Arrays.range(ai_new, 0, atn.size);
		return mapN(i_old, ai_out);
	}
	def allTrivialValues(ai: Range<SsaInstr>) -> bool {
		for (i in ai) {
			match (i) {
				x: SsaConst => if (x.val != null) return false;
				_ => return false;
			}
		}
		return true;
	}
	def normArrayInit(i_old: SsaApplyOp, op: Operator, len: int) {
		var rtn = nonzero(normTypeArg(op, 0));
		var etn = normType(V3Array.elementType(op.typeArgs[0]));
		var width = etn.size;
		if (width == 0) { // XXX: remove special handling of rare special case
			// this is a void array
			var length: SsaInstr = newGraph.intConst(len);
			return map1(i_old, curBlock.opArrayAlloc(rtn.newType, length));
		}
		var ai_new = genRefs(i_old.inputs);
		var arrayNorm = ArrayNorm.!(rtn);
		if (arrayNorm.isMixed()) {
			// mixed array initialization
			var array = curBlock.add(V3Op.newArrayTupleInit(arrayNorm.newType, arrayNorm.enorm.size, len), ai_new, i_old.facts);
			map1(i_old, array);
		} else {
			if (rtn.size == 1) return map1(i_old, curBlock.opArrayInit(rtn.newType, ai_new));
			// complex array initialization
			var arrays = Array<SsaInstr>.new(width);
			for (i < width) {
				var vals = Array<SsaInstr>.new(len);
				for (j < len) {
					vals[j] = ai_new[i + j * width];
				}
				arrays[i] = curBlock.opArrayInit(rtn.sub[i], vals);
			}
			mapN(i_old, arrays);
		}
	}
	def normArrayGetElem(i_old: SsaApplyOp, op: Operator) {
		var arrayNorm = ArrayNorm.!(normTypeArg(op, 0)), rtn = normReturnType(op);
		var ai_new = genRefs(i_old.inputs), width = rtn.size;
		var indexType = norm.config.ArrayIndexType;
		if (width == 1) {
			// common case 1-1 mapping
			return map1(i_old, curBlock.opArrayGetElem(arrayNorm.newType, indexType, i_old.facts, ai_new[0], ai_new[1]));
		} else if (width == 0) {
			// void array access
			if (context.compiler.boundsCheck(i_old.facts))	curBlock.opBoundsCheck(arrayNorm.newType, ai_new[0], ai_new[1]);
			return map0(i_old);
		}
		normArrayOrRangeGetElem(i_old, arrayNorm, indexType, width, ai_new, ai_new[arrayNorm.size], Facts.NONE);
	}
	def normRangeFromTo(i_old: SsaApplyOp, op: Operator) {
		var rangeNorm = RangeNorm.!(normTypeArg(op, 0));
		var startNorm = normTypeArg(op, 1), endNorm = normTypeArg(op, 2);
		var ai_new = genRefs(i_old.inputs);
		var rangeStart = ai_new[rangeNorm.startIndex()], rangeLength = ai_new[rangeNorm.lengthIndex()];
		var start = ai_new[rangeNorm.size], end = ai_new[rangeNorm.size + startNorm.size];
		var rangeLengthType = norm.config.ArrayLengthType;
		var startType = IntType.!(startNorm.oldType), endType = IntType.!(endNorm.oldType);
		if (context.compiler.boundsCheck(i_old.facts)) {
			// XXX: manually CSE the promotions here?
			var c1 = curBlock.opIntULt(rangeLengthType, startType, rangeLength, start);
			curBlock.opConditionalThrow(V3Exception.BoundsCheck, c1);
			var c2 = curBlock.opIntULt(endType, startType, end, start);
			curBlock.opConditionalThrow(V3Exception.LengthCheck, c2);
			var c3 = curBlock.opIntULt(rangeLengthType, endType, rangeLength, end);
			curBlock.opConditionalThrow(V3Exception.BoundsCheck, c3);
		}
		var result = Array<SsaInstr>.new(rangeNorm.size);
		for (i < rangeNorm.startIndex()) result[i] = ai_new[i];
		if (startType.width > 32) start = curBlock.opIntViewI0(startType, rangeLengthType, start);

		if (norm.config.NormalizeRange && rangeNorm.arrayNorm.size <= 1) {
			result[rangeNorm.startIndex()] = curBlock.opRangeStartPlusIndex(rangeNorm.oldType, rangeLengthType, i_old.facts, rangeStart, start);
		} else {
			result[rangeNorm.startIndex()] = curBlock.opIntAdd(start, rangeStart);
		}

		if (endType.width > 32) end = curBlock.opIntViewI0(endType, rangeLengthType, end);
		result[rangeNorm.lengthIndex()] = curBlock.opIntSub(end, start);
		mapN(i_old, result);
	}
	def normRangeFromPlus(i_old: SsaApplyOp, op: Operator) {
		var rangeNorm = RangeNorm.!(normTypeArg(op, 0));
		var startNorm = normTypeArg(op, 1), lengthNorm = normTypeArg(op, 2);
		var ai_new = genRefs(i_old.inputs);
		var rangeStart = ai_new[rangeNorm.startIndex()], rangeLength = ai_new[rangeNorm.lengthIndex()];
		var start = ai_new[rangeNorm.size], length = ai_new[rangeNorm.size + startNorm.size];
		var rangeLengthType = norm.config.ArrayLengthType;
		var startType = IntType.!(startNorm.oldType), lengthType = IntType.!(lengthNorm.oldType);
		if (context.compiler.boundsCheck(i_old.facts)) {
			// XXX: manually CSE the promotions here?
			var c1 = curBlock.opIntULt(rangeLengthType, startType, rangeLength, start);
			curBlock.opConditionalThrow(V3Exception.BoundsCheck, c1);
			var c2 = curBlock.opIntULt(rangeLengthType, lengthType, rangeLength, length);
			curBlock.opConditionalThrow(V3Exception.LengthCheck, c2);
			if (startType.width > 32) start = curBlock.opIntViewI0(startType, rangeLengthType, start);
			if (lengthType.width > 32) length = curBlock.opIntViewI0(lengthType, rangeLengthType, length);
			var end = rangeStartAdd(start, length);
			var c3 = curBlock.opU32Lt(rangeLength, end);
			curBlock.opConditionalThrow(V3Exception.BoundsCheck, c3);
		} else {
			if (startType.width > 32) start = curBlock.opIntViewI0(startType, rangeLengthType, start);
			if (lengthType.width > 32) length = curBlock.opIntViewI0(lengthType, rangeLengthType, length);
		}

		var result = Array<SsaInstr>.new(rangeNorm.size);
		for (i < rangeNorm.startIndex()) result[i] = ai_new[i];

		if (norm.config.NormalizeRange && rangeNorm.arrayNorm.size <= 1) {
			result[rangeNorm.startIndex()] = curBlock.opRangeStartPlusIndex(rangeNorm.oldType, rangeLengthType, i_old.facts, rangeStart, start);
		} else {
			result[rangeNorm.startIndex()] = curBlock.opIntAdd(start, rangeStart);
		}
		result[rangeNorm.lengthIndex()] = length;
		mapN(i_old, result);
	}
	def normRangeGetElem(i_old: SsaApplyOp, op: Operator) {
		var rangeNorm = RangeNorm.!(normTypeArg(op, 0)), rtn = normReturnType(op);
		var ai_new = genRefs(i_old.inputs), width = rtn.size;
		var indexType = norm.config.ArrayIndexType;
		var w = rangeNorm.size;
		var facts = i_old.facts;
		var start = ai_new[rangeNorm.startIndex()], length = ai_new[rangeNorm.lengthIndex()], index = ai_new[rangeNorm.size];
		if (context.compiler.boundsCheck(i_old.facts)) {
			// explicit bounds check
			var oob = curBlock.pure(Int.getType(false, 32).opLtEq(), [length, index]);
			curBlock.opConditionalThrow(V3Exception.BoundsCheck, oob);
		}

		if (norm.config.NormalizeRange && rangeNorm.arrayNorm.size <= 1) {
			if (width == 1) {
				var i_new = curBlock.opNormRangeGetElem(rangeNorm.arrayNorm.newType, indexType, facts, ai_new[0], start, index);
				i_new.setFact(Facts.O_SAFE_BOUNDS);
				return map1(i_old, i_new);
			} else if (width == 0) {
				return map0(i_old);
			}

			var vals = Array<SsaInstr>.new(width);
			if (rangeNorm.arrayNorm.isMixed()) {
				var array = ai_new[0];
				for (i < width) {
					vals[i] = curBlock.opNormRangeGetElemElem(rangeNorm.arrayNorm.newType, indexType, i, facts, array, start, index);
					facts = facts | Facts.O_SAFE_BOUNDS;
				}
			} else {
				for (i < width) {
					vals[i] = curBlock.opNormRangeGetElem(rangeNorm.arrayNorm.sub[i], indexType, facts, ai_new[i], start, index);
					facts = facts | Facts.O_SAFE_BOUNDS;
				}
			}
			mapN(i_old, vals);
		} else {
			index = rangeStartAdd(start, index);
			if (width == 1) {
				// common case 1-1 mapping
				var i_new = curBlock.opArrayGetElem(rangeNorm.arrayNorm.newType, indexType, i_old.facts, ai_new[0], index);
				i_new.setFact(Facts.O_SAFE_BOUNDS); // explicit bounds check, cannot be null
				return map1(i_old, i_new);
			} else if (width == 0) {
				// void range access; bounds check was sufficient
				return map0(i_old);
			}
			normArrayOrRangeGetElem(i_old, rangeNorm.arrayNorm, indexType, width, ai_new, index, Facts.O_SAFE_BOUNDS);
		}
	}
	def rangeStartAdd(start: SsaInstr, index: SsaInstr) -> SsaInstr {
		return curBlock.pure(norm.config.RangeStartType.opAdd(), [start, index]); // XXX: constant fold?
	}
	def normArrayOrRangeGetElem(i_old: SsaApplyOp, arrayNorm: ArrayNorm, indexType: IntType, width: int, ai_new: Array<SsaInstr>, index: SsaInstr, facts: Fact.set) {
		var vals = Array<SsaInstr>.new(width);
		facts |= i_old.facts;
		if (arrayNorm.isMixed()) {
			// mixed array access
			var array = ai_new[0];
			for (i < width) {
				vals[i] = curBlock.add(V3Op.newArrayGetElemElem(arrayNorm.newType, indexType, i), [array, index], facts);
				facts = facts | Facts.O_SAFE_BOUNDS;
			}
		} else {
			// complex array access
			for (i < width) {
				vals[i] = curBlock.opArrayGetElem(arrayNorm.sub[i], indexType, facts, ai_new[i], index);
				facts = facts | Facts.O_SAFE_BOUNDS;
			}
		}
		mapN(i_old, vals);
	}
	def normArraySetElem(i_old: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normType(op.sig.paramTypes[2]);
		var indexType = norm.config.ArrayIndexType;
		var width = rtn.size;
		var ai_new = genRefs(i_old.inputs);
		if (width == 1) {
			curBlock.opArraySetElem(atn.newType, indexType, i_old.facts, ai_new[0], ai_new[1], ai_new[2]);
			return;
		} else if (width == 0) {
			if (context.compiler.boundsCheck(i_old.facts)) curBlock.opBoundsCheck(atn.newType, ai_new[0], ai_new[1]);
			return;
		}
		var arrayNorm = ArrayNorm.!(atn);
		if (arrayNorm.isMixed()) {
			// mixed array set
			var array = ai_new[0], index = ai_new[1], facts = i_old.facts;
			for (i < width) {
				curBlock.add(V3Op.newArraySetElemElem(atn.newType, indexType, i), [array, index, ai_new[i + 2]], facts);
				facts = facts | Facts.O_SAFE_BOUNDS;
			}
		} else {
			// complex array set
			var index = ai_new[width], facts = i_old.facts;
			for (i < width) {
				var i = curBlock.opArraySetElem(atn.sub[i], indexType, facts, ai_new[i], index, ai_new[i + 1 + width]);
				i.setFact(facts);
				facts = facts | Facts.O_SAFE_BOUNDS;
			}
		}
	}
	def normRangeSetElem(i_old: SsaApplyOp, op: Operator) {
		var rangeNorm = RangeNorm.!(normTypeArg(op, 0)), rtn = normType(op.sig.paramTypes[2]);
		var indexType = norm.config.RangeStartType;
		var ai_new = genRefs(i_old.inputs), width = rtn.size;
		var start = ai_new[rangeNorm.startIndex()], length = ai_new[rangeNorm.lengthIndex()], index = ai_new[rangeNorm.size];
		if (context.compiler.boundsCheck(i_old.facts)) {
			// explicit bounds check
			var oob = curBlock.pure(Int.getType(false, 32).opLtEq(), [length, index]);
			curBlock.opConditionalThrow(V3Exception.BoundsCheck, oob);
		}

		var arrayNorm = rangeNorm.arrayNorm;
		var facts = i_old.facts;

		if (norm.config.NormalizeRange && arrayNorm.size <= 1) {
			if (width == 1) {
				var val = ai_new[rangeNorm.size + 1];
				var i = curBlock.opNormRangeSetElem(arrayNorm.newType, indexType, facts, ai_new[0], start, index, val);
				i.setFact(Facts.O_SAFE_BOUNDS);
				return;
			} else if (width == 0) {
				// prior bounds check was sufficient
				return;
			}

			if (arrayNorm.isMixed()) {
				for (i < width) {
					var val = ai_new[rangeNorm.size + i + 1];
					curBlock.opNormRangeSetElemElem(arrayNorm.newType, indexType, i, Facts.O_SAFE_BOUNDS, ai_new[0], start, index, val);
				}
			} else {
				for (i < width) {
					var val = ai_new[rangeNorm.size + i + 1];
					curBlock.opNormRangeSetElem(arrayNorm.sub[i], indexType, Facts.O_SAFE_BOUNDS, ai_new[i], start, index, val);
				}
			}
		} else {
			index = rangeStartAdd(start, index);

			if (width == 1) {
				var val = ai_new[rangeNorm.size + 1];
				var i = curBlock.opArraySetElem(arrayNorm.newType, indexType, i_old.facts, ai_new[0], index, val);
				i.setFact(Facts.O_SAFE_BOUNDS);
				return;
			} else if (width == 0) {
				// prior bounds check was sufficient
				return;
			}
			if (arrayNorm.isMixed()) {
				// mixed range set
				var array = ai_new[0];
				for (i < width) {
					var val = ai_new[rangeNorm.size + i + 1];
					curBlock.add(V3Op.newArraySetElemElem(arrayNorm.newType, indexType, i), [array, index, val], Facts.O_SAFE_BOUNDS);
				}
			} else {
				// complex range set
				for (i < width) {
					var val = ai_new[rangeNorm.size + i + 1];
					curBlock.opArraySetElem(arrayNorm.sub[i], indexType, Facts.O_SAFE_BOUNDS, ai_new[i], index, val);
				}
			}
		}
	}
	def normArrayGetLength(i_old: SsaApplyOp, op: Operator) {
		var atn = nonzero(normTypeArg(op, 0));
		var array = genRefs(i_old.inputs);
		// get the length from the first component array
		var arrayType = if(atn.sub == null, atn.newType, atn.sub[0]);
		return map1(i_old, curBlock.opArrayGetLength(arrayType, array[0]));
	}
	def normComponentGetField(i_old: SsaApplyOp, field: IrField, op: Operator) {
		if (i_old.useList == null) return; // remove unused reads of fields
		var raField = extractFieldRef(i_old, field);
		var nf = raField.liveFields(norm.ra);
		if (raField.isConst()) {
			// OPT: inline the field as a constant
			mapValue(i_old, raField.val, normReturnType(i_old.op));
			return;
		} else if (nf.length == 1) {
			// common case 1-1 mapping
			var read = curBlock.opGetField(nf[0], newGraph.nop());
			read.facts = read.facts | raField.facts();
			return map1(i_old, read);
		}
		var reads = Array<SsaInstr>.new(nf.length);
		for (i < reads.length) {
			reads[i] = curBlock.opGetField(nf[i], newGraph.nop());
		}
		return mapN(i_old, reads);
	}
	def normComponentSetField(i_old: SsaApplyOp, field: IrField, op: Operator) {
		var raField = extractFieldRef(i_old, field), fieldVals = genRefs(i_old.inputs);
		var nf = raField.liveFields(norm.ra);
		if (nf.length == 1) {
			// common case 1-1 mapping
			curBlock.opComponentSetField(nf[0], newGraph.nop(), fieldVals[0]);
			return;
		}
		for (i < nf.length) {
			curBlock.opComponentSetField(nf[i], newGraph.nop(), fieldVals[i]);
		}
	}
	def normClassAlloc(i_old: SsaApplyOp, m: IrMethod, op: Operator) {
		var rc = norm.ra.getClass(op.typeArgs[0]);
		var vn = rc.variantNorm;
		if (vn != null) {
			var inputs = genRefs(i_old.inputs);
			var result = genVariantClassAlloc(vn, inputs);
			return mapNnf(i_old, result);
		}
		if (m == null) {
			// trivial constructor
			var spec = IrSpec.new(op.typeArgs[0], op.typeArgs, null);
			return map1(i_old, curBlock.opClassAlloc(spec, Ssa.NO_INSTRS));
		}
		var t = extractMethodRef(i_old.op, m), funcNorm = t.0, m = t.1;
		var ai_new = normArgs(funcNorm, genRefs(i_old.inputs));
		return map1(i_old, curBlock.opClassAlloc(m, ai_new));
	}
	def normGetField(isVariant: bool, i_old: SsaApplyOp, field: IrField, op: Operator) {
		// XXX: propagate O_NO_NULL_CHECK and O_PURE
		var ai_new = genRefs(i_old.inputs);
		if (i_old.useList == null) {
			// OPT: remove unused read of field
			if (!isVariant) addNullCheck(i_old, ai_new[0]);
			return;
		}
		var raField = extractFieldRef(i_old, field);
		if (raField.isConst()) {
			// OPT: inline the field as a constant
			if (!isVariant) addNullCheck(i_old, ai_new[0]);
			mapValue(i_old, raField.val, normReturnType(i_old.op));
			return;
		}
		var rc = norm.ra.getClass(raField.receiver);
		var nf = raField.normOf(rc.liveFields);
		if (nf.length == 0) {
			// OPT: remove read of useless field
			// OPT: remove read of zero-width field
			if (!isVariant) addNullCheck(i_old, ai_new[0]);
			return map0(i_old);
		}
		normType(raField.receiver); // XXX: normType() side-effect of flattening
		if (isVariant && raField != null && rc.isUnboxed()) {
			// field of unboxed data type
			var vals = genVariantGetField(rc, raField, rc.variantNorm, ai_new);
			return mapNnf(i_old, vals);
		}
		var receiver = ai_new[0];
		if (nf.length == 1) {
			// common case 1-1 mapping
			var read = curBlock.opGetField(nf[0], receiver);
			read.facts = read.facts | raField.facts(); // OPT: propagate field facts
			return map1(i_old, read);
		}
		// 1-many mapping
		var vals = Array<SsaInstr>.new(nf.length);
		for (i < vals.length) {
			vals[i] = curBlock.opGetField(nf[i], receiver);
		}
		return mapN(i_old, vals);
	}
	def normClassSetField(i_old: SsaApplyOp, field: IrField, op: Operator, init: bool) {
		// XXX: propagate O_NO_NULL_CHECK
		var raField = extractFieldRef(i_old, field);
		var ai_new = genRefs(i_old.inputs), receiver = ai_new[0];
		var rc = norm.ra.getClass(raField.receiver);
		var nf = raField.normOf(rc.liveFields);

		if (raField.normIndices.0 == raField.normIndices.1 || !raField.raFacts.RF_READ) {
			// OPT: remove write to useless field
			// OPT: remove write of zero-width field
			// OPT: remove write of write-only field
			return addNullCheck(i_old, receiver);
		} else if (rc.isUnboxed()) {
			// init/set of field of flattened data type
			return map0(i_old);
		} else if (nf.length == 1) {
			// common case; 1-1 field mapping
			curBlock.opClassSetField(nf[0], receiver, ai_new[1], init);
			return;
		}
		// 1-many mapping
		var vals = Array<SsaInstr>.new(nf.length);
		for (i < vals.length) {
			curBlock.opClassSetField(nf[i], receiver, ai_new[i + 1], init);
		}
	}
	def genVariantScalarView(oldType: Type, newType: Type, i_scalar: SsaInstr) -> SsaInstr {
		if (IntType.?(oldType) && IntType.?(newType)) return curBlock.opIntView(oldType, IntType.!(newType), i_scalar);
		if (IntType.?(oldType)) {
			match (newType) {
				x: BoolType => return curBlock.opNotEqual(oldType, i_scalar, newGraph.nullConst(oldType));
				x: FloatType => return curBlock.pure(if(x.is64, V3Op.newFloat64ViewI(oldType), V3Op.newFloat32ViewI(oldType)), [i_scalar]);
			}
		}
		if (IntType.?(newType)) {
			var one = newGraph.valConst(newType, IntType.!(newType).box(1)), zero = newGraph.nullConst(newType);
			match (oldType) {
				x: BoolType => return curBlock.addSelect(newType, i_scalar, one, zero);
				x: FloatType => return curBlock.pure(if(x.is64, V3Op.opIntViewF64, V3Op.opIntViewF32), [i_scalar]);
			}
		}
		if (newType == AnyRef.TYPE) return i_scalar;
		return curBlock.opTypeSubsume(oldType, newType, i_scalar);
	}
	def genVariantClassAlloc(vn: VariantNorm, ai_inputs: Array<SsaInstr>) -> Array<SsaInstr> {
		if (vn.isEnum()) return [newGraph.intConst(vn.tagValue)];

		var result = Array<SsaInstr>.new(vn.size);
		for (i < result.length) result[i] = newGraph.nullConst(vn.at(i));

		if (vn.hasExplicitTag()) {
			var tagIdx = vn.tag.indexes[0];
			if (IntRepType.?(vn.at(tagIdx))) result[tagIdx] = genSetInterval(result[tagIdx], newGraph.intConst(vn.tagValue), vn.tag.intervals[0], vn.tag.tn.newType, IntRepType.!(vn.at(tagIdx)));
			else result[tagIdx] = newGraph.intConst(vn.tagValue);
		}

		for (i < vn.fields.length) {
			var f = vn.fields[i];
			var fieldRanges = vn.fieldRanges[i], os = fieldRanges.0;
			for (j < f.indexes.length) {
				var idx = f.indexes[j];
				if (IntRepType.?(vn.at(idx)) && f.intervals != null) result[idx] = genSetInterval(result[idx], ai_inputs[os + j], f.intervals[j], f.tn.at(j), IntRepType.!(vn.at(idx)));
				else result[idx] = genVariantScalarView(f.tn.at(j), vn.at(idx), ai_inputs[os + j]);
			}
		}
		return result;
	}
	def genExtractInterval(scalar: SsaInstr, interval: Interval, ft: IntRepType, tt: Type) -> SsaInstr {
		if (interval.start > 0) scalar = curBlock.addApplyF(ft.opShr(), [scalar, newGraph.intConst(interval.start)], Facts.O_SAFE_SHIFT);
		scalar = genVariantScalarView(ft, tt, scalar);
		return scalar;
	}
	def genSetInterval(scalar: SsaInstr, value: SsaInstr, interval: Interval, ft: Type, tt: IntRepType) -> SsaInstr {
		var intRep = genVariantScalarView(ft, tt, value);
		intRep = curBlock.addApplyF(tt.opShl(), [intRep, newGraph.intConst(interval.start)], Facts.O_SAFE_SHIFT);
		return curBlock.pure(tt.opOr(), [scalar, intRep]);
	}
	def genVariantGetField(rc: RaClass, raField: RaField, vn: VariantNorm, ninputs: Array<SsaInstr>) -> Array<SsaInstr> {
		var nf = raField.liveFields(norm.ra);
		var vals = Array<SsaInstr>.new(nf.length);
		var field = rc.variantNorm.fields[raField.orig.index];

		for (i < vals.length) {
			var idx = field.indexes[i];
			if (IntRepType.?(vn.at(idx)) && field.intervals != null) vals[i] = genExtractInterval(ninputs[idx], field.intervals[i], IntRepType.!(vn.at(idx)), field.tn.at(i));
			else vals[i] = genVariantScalarView(rc.variantNorm.at(idx), field.tn.at(i), ninputs[idx]);
		}
		return vals;
	}
	def normNullCheck(oldApp: SsaApplyOp, op: Operator) {
		var newArgs = genRefs(oldApp.inputs);
		if (newArgs.length >= 1) addNullCheck(oldApp, newArgs[0]);
	}
	def normBoundsCheck(i_old: SsaApplyOp, op: Operator) {
		if (context.compiler.boundsCheck(i_old.facts)) {
			var ai_new = genRefs(i_old.inputs);
			var newCheck = curBlock.opBoundsCheck(op.typeArgs[0], ai_new[0], ai_new[1]);
			if (newCheck != null) newCheck.facts = newCheck.facts | i_old.facts;
		}
	}
	def normType(t: Type) -> TypeNorm {
		if (context.spec != null) t = context.spec.instantiateType(t);
		return norm.norm(t);
	}
	private def normFuncType(t: Type) -> FuncNorm {
		def funcNorm = FuncNorm.!(normType(t));
		norm.allocOverflowFields(funcNorm);
		return funcNorm;
	}
	private def extractFieldRef(i_old: SsaApplyOp, field: IrField) -> RaField {
		var spec = if (specSet != null, specSet.first(), context.spec);
		return norm.ra.makeField(i_old, field, spec);
	}
	private def extractMethodRef(op: Operator, method: IrMethod) -> (FuncNorm, IrSpec) {
		if (specSet != null) op = op.subst(specSet.first().instantiateType);
		else if (context.spec != null) op = op.subst(context.spec.instantiateType);
		var ta = op.typeArgs;
		var t = norm.normalizeMethodRef(IrSpec.new(ta[0], ta, method));
		return (norm.allocOverflowFields(t.0.funcNorm), t.1);
	}
	private def extractVirtualRef(op: Operator, method: IrMethod) -> (FuncNorm, IrSpec, bool) {
		if (specSet != null) op = op.subst(specSet.first().instantiateType);
		else if (context.spec != null) op = op.subst(context.spec.instantiateType);
		var ta = op.typeArgs;
		var t = norm.normalizeMethodRef(IrSpec.new(ta[0], ta, method)), rm = t.0, spec = t.1;
		ta = spec.typeArgs;
		if (rm.virtual == null) {
			return (norm.allocOverflowFields(rm.funcNorm), spec, false);
		}
		if (context.compiler.ChaDevirtualize && !rm.norm.facts.M_OVERRIDDEN) {
			// devirtualize this call because the method is not overridden
			return (norm.allocOverflowFields(rm.funcNorm), spec, false);
		}
		if (context.compiler.RaDevirtualize && rm.virtual.devirtual != null) {
			// devirtualize this call because only one live version exists
			rm = rm.virtual.devirtual;
			ta = Arrays.replace(ta, 0, rm.norm.receiver);
			spec = IrSpec.new(ta[0], ta, rm.norm);
			return (norm.allocOverflowFields(rm.funcNorm), spec, false);
		}
		var receiver = ta[0];
		var selector = IrSelector.new(receiver, rm.norm, rm.virtual.mtable, rm.normIndex);
		return (norm.allocOverflowFields(rm.funcNorm), IrSpec.new(receiver, ta, selector), true);
	}
	def tryDevirtualize(rm: RaMethod, ta: Array<Type>) -> (IrSpec, bool) {
		if (rm.virtual == null) {
			return (IrSpec.new(ta[0], ta, rm.norm), false);
		}
		if (context.compiler.ChaDevirtualize && !rm.norm.facts.M_OVERRIDDEN) {
			// devirtualize this call because the method is not overridden
			return (IrSpec.new(ta[0], ta, rm.norm), false);
		}
		if (context.compiler.RaDevirtualize && rm.virtual.devirtual != null) {
			// devirtualize this call because only one live version exists
			var m = rm.virtual.devirtual.norm;
			return (IrSpec.new(m.receiver, Arrays.replace(ta, 0, m.receiver), m), false);
		}
		// the call remains a virtual dispatch
		var receiver = ta[0];
		var selector = IrSelector.new(receiver, rm.norm, rm.virtual.mtable, rm.normIndex);
		return (IrSpec.new(receiver, ta, selector), true);
	}
	private def normTypeArg(op: Operator, index: int) -> TypeNorm {
		return normType(op.typeArgs[index]);
	}
	private def normReturnType(op: Operator) -> TypeNorm {
		return normType(op.sig.returnType());
	}
	private def funcRef(m: IrSpec) -> SsaInstr {
		return newGraph.valConst(Function.funcRefType(m.getFuncType()), FuncVal.new(m));
	}
	private def nonzero(tn: TypeNorm) -> TypeNorm {
		if (tn.size == 0) context.fail("expected at least one type");
		return tn;
	}
	private def addNullCheck(i_old: SsaInstr, obj: SsaInstr) {
		if (!i_old.facts.O_NO_NULL_CHECK) curBlock.opNullCheck(obj.getType(), obj);
	}
}
