// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def getScalarFromSet(s: Scalar.set) -> Scalar {
	for (i in s) return i;
	return Scalar.B32; // should be unreachable
}
def getTypeFromScalarSet(s: Scalar.set, usePacking: bool) -> Type {
	for (i in s) match (i) {
		R32, R64, Ref => return Oop.TYPE;
		_ => return if(usePacking, IntRep.getType(i), i.ty);
	}
	return null;
}
def copyMap<T, U>(x: HashMap<T, U>) -> HashMap<T, U> {
	var keys = Maps.keyList(x);
	var newMap = HashMap<T, U>.new(x.hash, x.equals);

	for (l = keys; l != null; l = l.tail) {
		newMap[l.head] = x[l.head];
	}
	return newMap;
}
def getTagLength(numCases: int) -> byte {
	var i: byte = 0;
	while (1 << i < numCases) i++;
	return i;
}

class VariantPattern(scalars: Array<ScalarPattern>) {
	def render(buf: StringBuilder) -> StringBuilder {
		for (i < scalars.length) {
			if (i > 0) buf.putc('|');
			buf.put1("%q", scalars[i].render);
		}
		return buf;
	}
	def copy() -> VariantPattern {
		return VariantPattern.new(Arrays.map(scalars, ScalarPattern.copy));
	}
}

// an input to the VariantSolver
class VariantProblem {
	var normFields: Array<Array<Type>>;			// flattened types for each case's fields
	var baseState: Array<VariantPattern>;			// null if no scalar assignments provided
	var assignments = HashMap<CaseField, (int, Interval)>.new(CaseField.hash, CaseField.==); // pre-existing interval assignments
	var usePacking: bool;					// whether to pack multiple fields into the same scalar

	new(normFields, baseState, usePacking) {}

	def render(buf: StringBuilder) -> StringBuilder {
		for (i < normFields.length) {
			if (i > 0) buf.csp();
			// c stands for case
			buf.put1("c%d: [", i);
			for (j < normFields[i].length) {
				if (j > 0) buf.csp();
				var cf = CaseField(i, j);
				var field = normFields[i][j];
				// f stands for field
				buf.put2("f%d=%q: ", j, field.render);

				if (!assignments.has(cf)) {
					buf.puts("?");
				} else {
					var a = assignments[cf], scalarIdx = a.0, interval = a.1;
					if (interval == EMPTY_INTERVAL) buf.put1("#%d@?", scalarIdx);
					else buf.put2("#%d@%q", scalarIdx, interval.render);
				}
			}
			buf.puts("]");
		}
		buf.puts(" ");
		if (baseState != null) for (i < baseState.length) buf.put1("%q|", baseState[i].render);
		return buf;
	}
}

def ON_STACK = -1, IS_RECURSIVE = 2, NOT_RECURSIVE = 1;
def NO_FIELDS = Array<VariantField>.new(0);


class VariantSolution {
	var normFields: Array<Array<Type>>;
	var state: Array<VariantPattern>;
	var assignments: HashMap<CaseField, (int, Interval)>;

	var explicitTag: (int, Interval);
	var types: Array<Type>;

	var hasIntervals = false;
	var hasTagScalar = false;
	var tagType: IntType;

	var cachedScore = -1;

	new(normFields, assignments, state, explicitTag, types) {}

	def copy() -> VariantSolution {
		var vs = VariantSolution.new(
			normFields,
			copyMap<CaseField, (int, Interval)>(assignments),
			Arrays.map(state, VariantPattern.copy),
			explicitTag,
			Arrays.dup(types)
		);
		vs.tagType = tagType;
		vs.hasIntervals = hasIntervals;
		vs.hasTagScalar = hasTagScalar;
		return vs;
	}
	def render(buf: StringBuilder) -> StringBuilder {
		for (i < normFields.length) {
			if (i > 0) buf.csp();
			buf.put1("c%d: [", i);
			for (j < normFields[i].length) {
				if (j > 0) buf.csp();
				var cf = CaseField(i, j);
				var field = normFields[i][j];
				buf.put2("f%d=%q: ", j, field.render);

				if (!assignments.has(cf)) {
					buf.puts("?");
				} else {
					var a = assignments[cf], scalarIdx = a.0, interval = a.1;
					if (interval == EMPTY_INTERVAL) buf.put1("#%d@?", scalarIdx);
					else buf.put2("#%d@%q", scalarIdx, interval.render);
				}
			}
			buf.puts("]");
		}
		buf.puts(" ");
		if (state != null) for (i < state.length) buf.put1("%q|", state[i].render);
		return buf;
	}
	def size() -> byte { 
		Terminal.put1("[VariantSolution.size] solution size = %d\n", types.length);
		return byte.!(types.length); }

	def score() -> int {
		if (cachedScore >= 0) return cachedScore;
		// XXX: better score function
		return 0;
	}
}

class VariantSolver(nc: NormalizerConfig) {
	var normFields: Array<Array<Type>>;

	var fields = Vector<CaseField>.new(); // an ordering of fields to solve for during packing

	var curSoln: VariantSolution;
	var assignments: HashMap<CaseField, (int, Interval)>;
	var baseState: Array<VariantPattern>;
	var state: Array<VariantPattern>;
	var explicitTag: (int, Interval) = (-1, EMPTY_INTERVAL);

	var explicitTagLength: byte;

	var curRep = Vector<Scalar.set>.new();
	var curUsed = Vector<byte>.new();
	var bwCache = TypeUtil.newTypeMap<byte>();
	var usePacking: bool;
	var packingSoln: PackingSolution;

	private def getBitWidth(t: Type) -> byte {
		if (bwCache.has(t)) return bwCache[t];
		return bwCache[t] = nc.GetBitWidth(t);
	}
	private def getScalarsWithWidth(s: Scalar.set, n: byte) -> Scalar.set {
		var newRep = s;
		for (i in s) if (i.width < n) newRep -= i;
		return newRep;
	}
	private def reset() {
		curRep.clear();
		curUsed.clear();
		fields.clear();
		bwCache = TypeUtil.newTypeMap<byte>();
	}
	// Perform recursive backtracking on the potential representation.
	// With each scalar in each case, we have several choices to make:
	// 1. Pack this scalar with an existing scalar
	// 2. Append this scalar as a new scalar.
	// We can only determine distinguishability after all the scalars have been assigned. Heuristics will help speed this part up.
	def solve(problem: VariantProblem) -> VariantSolution {
		reset();
		normFields = problem.normFields;
		usePacking = problem.usePacking;
		assignments = problem.assignments;
		baseState = problem.baseState;

		explicitTagLength = getTagLength(normFields.length);

		if (baseState != null && baseState.length > 0) {
			var numScalars = baseState[0].scalars.length;
			curRep.putn(nc.UsedScalars, numScalars);
			for (i < numScalars) curUsed.put(0);
		}

		for (i < normFields.length) {
			for (j < normFields[i].length) {
				if (!assignments.has(CaseField(i, j))) {
					fields.put(CaseField(i, j));
				} else {
					var assn = assignments[CaseField(i, j)];
					var sc = nc.GetScalar(normFields[i][j]);
					Terminal.put2("[VariantSolver.solve] GetScalar call | caseIdx: %d | fieldIdx: %d\n", i, j);
					printScalarSet(sc);
					curRep[assn.0] &= sc;
				}
			}
		}
		if (baseState != null) {
			for (i < baseState.length) {
				for (j < curRep.length) {
					curRep[j] = getScalarsWithWidth(curRep[j], byte.view(baseState[i].scalars[j].bits.length));
					var scalar = getScalarFromSet(curRep[j]);
					baseState[i].scalars[j] = baseState[i].scalars[j].padTo(scalar.width);
				}
			}
		}
		var solvable = tryRepresentationForField(0, 0);
		return if(solvable, curSoln, null);
	}
	private def tryRepresentationForField(curCase: int, curField: int) -> bool {
		if (curCase >= normFields.length) {
			// XXX: check distinguishable
			return solvePacking();
		}
		if (curField >= normFields[curCase].length) {
			// move on to next case
			curUsed = Vector<byte>.new();
			for (i < curRep.length) curUsed.put(0);
			return tryRepresentationForField(curCase + 1, 0);
		}

		var sc = nc.GetScalar(normFields[curCase][curField]);
		var bw = nc.GetBitWidth(normFields[curCase][curField]);
		var none: Scalar.set;

		for (i < curRep.length) {
			if (usePacking && curUsed[i] + bw > nc.MaxScalarWidth) continue;
			if (!usePacking && curUsed[i] > 0) continue;

			var oldRep = curRep[i];
			var newRep = sc & oldRep;
			for (j in sc & oldRep) if (usePacking && j.width < curUsed[i] + bw) newRep -= j;

			if (newRep != none) {
				curUsed[i] += bw; curRep[i] = newRep;
				assignments[CaseField(curCase, curField)] = (i, EMPTY_INTERVAL);
				if (tryRepresentationForField(curCase, curField + 1)) return true;
				curUsed[i] -= bw; curRep[i] = oldRep;
			}
		}

		var len = curRep.length;
		curRep.put(sc); curUsed.put(bw);
		assignments[CaseField(curCase, curField)] = (curRep.length - 1, EMPTY_INTERVAL);
		if (tryRepresentationForField(curCase, curField + 1)) return true;
		curRep.resize(len); curUsed.resize(len);

		return false;
	}
	private def tryExplicitTaggingHeuristic() -> bool {
		for (i < state[0].scalars.length) {
			var scalar0 = state[0].scalars[i];
			var longest: Interval, curStart: byte = 0;
			for (j < scalar0.bits.length) {
				var allUnassigned = true;
				for (k < state.length) {
					if (state[k].scalars[i].bits[j] != PackingBit.Unassigned) {
						allUnassigned = false;
						break;
					}
				}

				if (allUnassigned) {
					if (j + 1 - curStart > longest.size()) longest = Interval(curStart, byte.!(j + 1));
				} else {
					curStart = byte.!(j + 1);
				}
			}

			if (explicitTagLength > 0 && longest.size() >= explicitTagLength) {
				for (j < state.length) {
					for (k < explicitTagLength) {
						var bit = u1.!((j >> k) & 1);
						state[j].scalars[i].bits[longest.start + k] = PackingBit.Fixed(bit);
					}
				}
				explicitTag = (i, Interval(longest.start, longest.start + explicitTagLength));
				return true;
			}
		}
		return false;
	}
	private def solvePacking() -> bool {
		Terminal.put("[VariantSolver.solvePacking]\n");
		if (usePacking && curRep.length == 1) {
			// Compute maxScalarWidth
			var maxScalarWidth: byte = 0;
			def curWidth = getWidthFromScalarSet(curRep[0]);
			printScalarSet(curRep[0]);
			maxScalarWidth = if(maxScalarWidth < curWidth, curWidth, maxScalarWidth);
			// Initialize Packing fields
			def numCases = normFields.length;
			def casesPacking = Array<Array<PackingField>>.new(numCases);
			for (caseIdx < numCases) {
				def caseNormFields = normFields[caseIdx];
				def packingFields = Array<PackingField>.new(caseNormFields.length);
				for (fieldIdx < caseNormFields.length) packingFields[fieldIdx] = getPackingFieldFromType(caseNormFields[fieldIdx]);
				casesPacking[caseIdx] = packingFields;
			}
			// Run the PackingSolver
			def packingProblem = PackingProblem(casesPacking, []);
			def packingSolver = PackingSolver.new(maxScalarWidth, if(maxScalarWidth == 32, ScalarPatterns.TAGGED_PTR_32, ScalarPatterns.TAGGED_PTR_64));
			packingSoln = packingSolver.solveScalar(packingProblem);
			if (packingSoln == null) return false;
			// Update `assignments`
			for (caseIdx < numCases) {
				for (fieldIdx < normFields[caseIdx].length) {
					def interval = packingSoln.assignments[CaseField(caseIdx, fieldIdx)];
					assignments[CaseField(caseIdx, fieldIdx)] = (0, interval);
				}
			}
			// Update `state`
			state = assignIntervalsToPatterns(packingSoln);
			// Update `explicitTag`
			explicitTag = (0, packingSoln.explicitTag);
			def types = getTypes(false);
			curSoln = VariantSolution.new(normFields, assignments, state, explicitTag, types);
			return true;
		}	
		var cases = Array<VariantPattern>.new(normFields.length);
		// build up patterns from the individual cases
		for (i < normFields.length) {
			var patterns = Array<ScalarPattern>.new(curRep.length);
			for (j < curRep.length) patterns[j] = getScalarPattern(getScalarFromSet(curRep[j]));
			cases[i] = VariantPattern.new(patterns);
		}
		state = cases;
		return solveField(0);
	}
	private def printScalarSet(scalarSet: Scalar.set) {
		Terminal.put("[VariantSolver.printScalarSet] Scalars in set ");
		for (i in scalarSet) {
			match (i) {
				B32 => Terminal.put("| B32 ");
				B64 => Terminal.put("| B64 ");
				F32 => Terminal.put("| F32 ");
				F64 => Terminal.put("| F64 ");
				R32 => Terminal.put("| R32 ");
				R64 => Terminal.put("| R64 ");
				Ref => Terminal.put("| Ref ");
			}
		}
		Terminal.ln();
	}
	// Uses the interval assignments from PackingSolver to assign intervals in ScalarPatterns
	private def assignIntervalsToPatterns(packingSoln: PackingSolution) -> Array<VariantPattern> {
		// XXX: Move this function to PackingSolver? 
		def numCases = normFields.length;
		def singletonPatterns = Array<Array<ScalarPattern>>.new(numCases);
		for (caseIdx < numCases) {
			def caseScalarPattern = packingSoln.patterns[caseIdx].copy();
			// Assign intervals based on PackingSolution
			for (fieldIdx < normFields[caseIdx].length) {
				def interval = packingSoln.assignments[CaseField(caseIdx, fieldIdx)];
				caseScalarPattern.assignInterval(interval);
			}
			singletonPatterns[caseIdx] = [caseScalarPattern];
		}
		return Arrays.map(singletonPatterns, VariantPattern.new);
	}
	private def getPackingFieldFromType(t: Type) -> PackingField {
		return if(isRef(t), PackingField.Ref, PackingField.Nonref(PrimType.!(t).width));
	}
	private def isRef(t: Type) -> bool {
		// Use NormalizerConfig to determine whether the field is a ref or not
		def emptySet: Scalar.set;
		def scalarsForFieldType = nc.GetScalar(t);
		return (scalarsForFieldType & Scalar.Ref) != emptySet;
	}
	private def getWidthFromScalarSet(scalarSet: Scalar.set) -> byte {
		def scalarSetOfAll32 = Scalar.B32 | Scalar.F32 | Scalar.R32;
		def scalarSetOfAll64 = Scalar.B64 | Scalar.F64 | Scalar.R64 | Scalar.Ref;
		def emptySet: Scalar.set;

		if ((scalarSet & scalarSetOfAll64) != emptySet) return 64;
		return if((scalarSet & scalarSetOfAll32) != emptySet, 32, 0);
	}
	private def solveField(idx: int) -> bool {
		if (idx >= fields.length) {
			return checkDistinguishable();
		}
		var field = fields[idx];
		var scalarIdx = assignments[field].0;

		// try to squeeze this field into this scalar
		var casePattern = state[field.caseIdx];
		var bw = nc.GetBitWidth(normFields[field.caseIdx][field.fieldIdx]);
		var scalar = casePattern.scalars[scalarIdx];
		var intervals = scalar.getIntervalsForSize(bw);

		if (intervals.length == 0) return false;
		for (interval in intervals) {
			scalar.assignInterval(interval);
			assignments[field] = (scalarIdx, interval);
			var result = solveField(idx + 1);
			if (result) return true;
			scalar.unassignInterval(interval);
		}
		return false;
	}
	private def getScalarPattern(s: Scalar) -> ScalarPattern {
		// XXX: Should be based on scalar type
		return ScalarPattern.new(Array<PackingBit>.new(s.width));
	}
	private def canDistinguish(active: Array<bool>) {
		// TODO - this is where unassigned bits will get assigned
	}
	private def checkDistinguishable() -> bool {
		if (normFields.length <= 1) {
			var types = getTypes(false);
			curSoln = VariantSolution.new(normFields, assignments, state, explicitTag, types);
			curSoln.hasIntervals = usePacking;
			return true; // single case is always distinguishable
		}

		var packedTag: bool;
		if (usePacking) packedTag = tryExplicitTaggingHeuristic();

		var types = getTypes(!packedTag);
		curSoln = VariantSolution.new(normFields, assignments, state, explicitTag, types);
		curSoln.tagType = Int.getType(false, getTagLength(normFields.length));
		curSoln.hasTagScalar = !packedTag;
		curSoln.hasIntervals = usePacking;

		// TODO: try difficult tagging
		return true;
	}
	private def getTypes(useTagScalar: bool) -> Array<Type> {
		var types = Array<Type>.new(curRep.length + if(useTagScalar, 1));
		for (i < curRep.length) types[i] = getTypeFromScalarSet(curRep[i], usePacking);

		// simplification: if every field assigned to this scalar has the same type, we should use that type instead
		// since there will be no casting necessary
		var uniqueTypes = Array<Type>.new(curRep.length);
		var uses = Array<int>.new(curRep.length);

		if (!useTagScalar && explicitTag.0 >= 0) uses[explicitTag.0]++;
		for (i < normFields.length) {
			var caseUses = Array<int>.new(curRep.length);
			for (j < normFields[i].length) {
				var assignment = assignments[CaseField(i, j)];
				var scalarIdx = assignment.0;
				uses[scalarIdx]++;
				caseUses[scalarIdx]++;

				if (caseUses[scalarIdx] > 1) uniqueTypes[scalarIdx] = null;
				else if (uniqueTypes[scalarIdx] != null && uniqueTypes[scalarIdx] != normFields[i][j]) uniqueTypes[scalarIdx] = null;
				if (uses[scalarIdx] == 1 && uniqueTypes[scalarIdx] == null) uniqueTypes[scalarIdx] = normFields[i][j];
			}
		}
		for (i < uniqueTypes.length) if (uniqueTypes[i] != null) types[i] = uniqueTypes[i];

		var tagType = Int.getType(false, getTagLength(normFields.length));
		if (useTagScalar) types[curRep.length] = tagType;
		return types;
	}
}



def EMPTY_INTERVAL = Interval(0, 0);
