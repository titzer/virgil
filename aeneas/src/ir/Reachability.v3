// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Constants representing flags for reachability analysis
enum RaFact {
	RM_LIVE,
	RF_NORMALIZED,
	RF_READ,
	RF_WRITTEN,
	RF_INIT,
	RF_VAL_ONE,
	RF_VAL_MANY,
	RC_ALLOC,
	RC_LIVE,
	RC_DUMPED,
	RC_EQUALITY,
	RC_VARIANT,
	RC_ENUM,
	RC_CLOSURE,
	RC_BOXED,
}

component Reachability {
	def printWrap() -> TerminalBuffer {
		return Terminal.buf.purple().puts("Wrapping: ").end();
	}
	def printWrapExtra() -> TerminalBuffer {
		return Terminal.buf.red().puts("Wrapping: ").end();
	}
}

def printWrap      = Reachability.printWrap;
def printWrapExtra = Reachability.printWrapExtra;

def DUMP: Terminal;
def NONE: RaFact.set;
def countVals(facts: RaFact.set) -> int {
	return if(facts.RF_VAL_MANY, 2, if(facts.RF_VAL_ONE, 1));
}
def live(facts: RaFact.set) -> bool {
       	return (facts & (RaFact.RC_LIVE | RaFact.RC_ALLOC)) != NONE;
}

def MONO_TYPEARGS: Array<Type> = [AnyRef.TYPE];

def EQUALS_VST_FUNC = VstFunc.new(null, ReturnType.Void, null);
def EQUALS_VST_METHOD = VstMethod.new(false, Token.new(null, "==", 0, 0), null, EQUALS_VST_FUNC);

// Performs polymorphic reachability analysis over a program.
class ReachabilityAnalyzer(compilation: Compilation) {
	def compiler = compilation.compiler;
	def prog = compilation.prog;
	def oldIr = prog.ir;
	def typeMap = TypeUtil.newTypeMap<RaType>();
	def records = V3.newRecordMap<Record>();
	def polyMap = IrUtil.newIrItemMap<List<SsaApplyOp>>();
	def queue = WorkQueue.new();
	def classes = Vector<RaClass>.new();
	def arrays = Vector<RaArray>.new();
	var defaultValues: HashMap<Type, Val>;
	var liveMethods = Vector<RaMethod>.new();
	var normalizer: ReachabilityNormalizer;

	// perform the analysis, starting from the roots
	def analyze() {
		for (i < oldIr.roots.length) {
			var meth = oldIr.roots[i].spec;
			getMethod(null, makeMethod(meth.typeArgs, meth.asMethod(), null));
			makeType(meth.receiver);
		}
		queue.drain(); // do all work
	}
	def transform(config: NormalizerConfig) {
		// make normalizer object available during normalization
		normalizer = ReachabilityNormalizer.new(config, this);
		normalizer.normalize();
		normalizer = null;
	}
	def dump() {
		DUMP.buf.puts("Reachable live methods").outln();
		liveMethods.apply(dumpMethod);
		DUMP.buf.puts("Reachable array types").outln();
		arrays.apply(dumpType);
		DUMP.buf.puts("Reachable classes").outln();
		classes.apply(dumpType);
		DUMP.buf.puts("Reachable records").outln();
		records.apply(dumpRecord);
	}
	def dumpMethod(rm: RaMethod) {
		if (rm == null || rm.setFact(RaFact.RC_DUMPED)) return;
		DUMP.put1("%q", if (rm.spec != null, rm.spec.render, rm.orig.renderLong));
		dumpFacts(rm.raFacts, rm.virtual, null, false);
	}
	def dumpField(receiver: Type, rf: RaField) {
		if (rf == null) return;
		DUMP.put2("%q.%q", receiver.render, rf.orig.render);
		dumpFacts(rf.raFacts, null, rf.val, false);
	}
	def dumpType(rt: RaType) {
		if (live(rt.raFacts)) {
			DUMP.put1("%q", rt.oldType.render);
			dumpFacts(rt.raFacts, null, null, RaClass.?(rt) && RaClass.!(rt).recursive == 2);
		}
		if (RaClass.?(rt)) {
			var rc = RaClass.!(rt);
			DUMP.buf.puts("  methods of class").outln();
			for (list in rc.methods) {
				for (l = list; l != null; l = l.tail) {
					dumpMethod(l.head);
				}
			}
			DUMP.buf.puts("  fields of class").outln();
			for (i = rc.fieldStart(); i < rc.fields.length; i++) {
				dumpField(rt.oldType, rc.fields[i]);
			}
		}
	}
	def dumpRecord(r: Record, x: Record) {
		if (!V3.isComponent(r.rtype)) DUMP.put2("%q #%d\n", r.rtype.render, r.id);
	}
	def dumpFacts(facts: RaFact.set, virtual: RaVirtual, val: Val, recursive: bool) {
		if (facts.RF_READ) DUMP.put(" read");
		if (facts.RF_WRITTEN) DUMP.put(" written");
		if (facts.RF_INIT) DUMP.put(" init");
		if (facts.RF_VAL_MANY) DUMP.put(" many");
		if (facts.RM_LIVE) DUMP.put(" live");
		if (virtual != null) DUMP.put(" virtual");
		if (facts.RC_LIVE) DUMP.put(" live");
		if (facts.RC_ALLOC) DUMP.put(" alloc");
		if (facts.RC_VARIANT) DUMP.put(" variant");
		if (facts.RC_EQUALITY) DUMP.put(" equal");
		if (facts.RC_CLOSURE) DUMP.put(" closure");
		if (facts.RC_BOXED) DUMP.put(" boxed");
		if (countVals(facts) == 1) {
			DUMP.put1(" const[%s]", V3.renderVal(val));
		}
		if (recursive) DUMP.put(" recursive");
		DUMP.ln();
	}
	// a quick check to see if a type is the same as its normalization
	def isNormalType(t: Type) -> bool {
		match(t.typeCon.kind) {
			BOOL, INT, CLASS, ANYREF => return true;
			ARRAY => return isNormalType(V3Array.elementType(t));
			_ => return false;
		}
	}
	// defer analysis of a value
	def deferValue(val: Val) {
		match (val) {
			null => ;
			x: Record => queue.add(analyzeRecord, x);
			x: Closure => queue.add(analyzeValue, x);
			x: BoxVal => queue.add(analyzeValue, x);
			x: ArrayRangeVal => queue.add(analyzeRecord, x.array);
			x: Address<Record> => queue.add(analyzeRecord, x.val);
		}
	}
	// defer analysis of a record
	def deferRecord(r: Record) {
		if (r != null) queue.add(analyzeRecord, r);
	}
	// analyze a value such as a record, closure, or tuple
	def analyzeValue(val: Val) {
		match (val) {
			x: Record => analyzeRecord(x);
			x: Closure => {
				// analyze a record + method closure pair
				var spec = x.memberRef;
				var rm = makeMethod(spec.typeArgs, IrMethod.!(spec.member), null);
				var receiver = makeType(rm.receiver);
				receiver.raFacts |= RaFact.RC_CLOSURE;
				getMethod(null, rm);
				if (x.val != null) analyzeValue(x.val);
			}
			x: BoxVal => for(e in x.values) analyzeValue(e);
		}
	}
	// analyze a record
	def analyzeRecord(record: Record) {
		if (records[record] == record) return;
		records[record] = record;
		var raType = makeType(record.rtype);
		var newlyLive = !live(raType.raFacts);
		raType.raFacts |= RaFact.RC_LIVE;
		match (raType) {
			x: RaClass => {
				// analyze a class object's fields and methods
				x.instances = List.new(record, x.instances);
				if (newlyLive) analyzeLiveClass(x);
				// analyze class fields
				for (rf in x.fields) analyzeField(record, rf);
			}
			x: RaArray => {
				// analyze an array's elements
				x.instances = List.new(record, x.instances);
				if (x.primitive) return;
				for (v in record.values) deferValue(v);
			}
		}
	}
	// analyze a field of a record if the field is live
	def analyzeField(record: Record, rf: RaField) {
		if (rf != null && rf.raFacts.RF_READ) {
			var v = record.values[rf.orig.index];
			rf.addValue(v);
			deferValue(v);
		}
	}
	// analyze a class that just became live
	def analyzeLiveClass(rc: RaClass) {
		for (c = rc; c != null; c = c.parent) {
			c.subtypes = List.new(rc, c.subtypes);
			for (ml in c.methods) {
				for (l = ml; l != null; l = l.tail) analyzeVirtual(rc, l.head);
			}
			if (c.raFacts.RC_EQUALITY) {
				if (!rc.setFact(RaFact.RC_EQUALITY) && V3.isVariant(rc.oldType)) getAndCompareAllFields(rc);
			}
		}
	}
	// analyze a possible virtual dispatch of the given method on the given type
	def analyzeVirtual(rc: RaClass, rm: RaMethod) {
		var rv = rm.virtual;
		if (rv == null) return;
		var spec = oldIr.resolveMethodImpl(rc.oldType, rm.getSpec());
		var impl = makeMethod(spec.typeArgs, IrMethod.!(spec.member), null);
		rv.addImpl(impl);
		getMethod(null, impl);
	}
	def gatherCaseClasses(vec: Vector<IrClass>, decl: VstClass) -> Vector<IrClass> {
		if (decl.cases == null) return vec;
		for (c in decl.cases) {
			vec.put(oldIr.getIrClass(c.decl.getDeclaredType()));
			if (c.decl != decl) gatherCaseClasses(vec, c.decl);
		}
		return vec;
	}
	def generateVariantEquals(t: Type) -> RaClass {
		var rc = makeClass(t);
		while (rc.parent != null) rc = rc.parent;  // get root declaration.
		if (rc.orig.methods[IrUtil.EQUALS_METHOD_INDEX] != null) return rc; // done.

		var decl = V3.classDecl(rc.orig.ctype);
		var cases = gatherCaseClasses(Vector<IrClass>.new(), decl);
		var polyType = decl.getDeclaredType();

		var method = IrMethod.new(polyType, null, Function.sig(polyType, Bool.TYPE));
		method.source = EQUALS_VST_METHOD;
		method.setFact(Fact.M_EQUALS | Fact.M_INLINE);
		rc.orig.methods[IrUtil.EQUALS_METHOD_INDEX] = method;
		method.index = IrUtil.EQUALS_METHOD_INDEX;

		// build overridden methods for each case that has fields
		for (i < cases.length) {
			var ic = cases[i];
			var superType = V3.getSuperType(ic.ctype);
			if (superType == null) superType = ic.ctype;
			var pc = oldIr.getIrClass(superType);
			var pm = pc.methods[IrUtil.EQUALS_METHOD_INDEX];
			if (ic.fields.length > 0) {
				pm.facts |= Fact.M_OVERRIDDEN;
				pm = IrMethod.new(ic.ctype, null, Function.sig(polyType, Bool.TYPE));
				pm.source = EQUALS_VST_METHOD;
				pm.facts |= Fact.M_EQUALS;
				pm.index = IrUtil.EQUALS_METHOD_INDEX;
			}
			ic.methods[IrUtil.EQUALS_METHOD_INDEX] = pm;
		}
		return rc;
	}
	// analyze a method's code
	def analyzeMethod(rm: RaMethod) {
		var graph = rm.orig.ssa;
		if (graph == null) {
			if (rm.orig.facts.M_EQUALS) return; // don't analyze equality methods
			graph = compilation.genSsa(rm.getSpec(), 0);
		}
		if (rm.spec != null) {
			// analyze a polymorphic method
			var polyOps = polyMap[rm.orig];
			if (polyOps == null) {
				analyzeValues(graph);
				polyOps = gatherPolyOps(graph);
				polyMap[rm.orig] = polyOps;
			}
			for (l = polyOps; l != null; l = l.tail) {
				if (l.head != null) analyzeOp(l.head, rm.spec);
			}
		} else {
			analyzeValues(graph);
			// analyze a monomorphic method
			for (b in graph.bfBlocks(null)) { // XXX: iterate over blocks directly
				for (i = b.next; i != b; i = i.next) {
					if (SsaApplyOp.?(i)) analyzeOp(SsaApplyOp.!(i), rm.spec);
				}
			}
		}
	}
	// analyze the values in a graph
	def analyzeValues(graph: SsaGraph) {
		if (graph.values != null) {
			for (v in graph.values) if (v != null) analyzeValue(v.val);
		}
	}
	// gather polymorphic operators
	def gatherPolyOps(graph: SsaGraph) -> List<SsaApplyOp> {
		var polyOps: List<SsaApplyOp>;
		for (b in graph.bfBlocks(null)) { // XXX: iterate over blocks directly
			for (i = b.next; i != b; i = i.next) {
				if (SsaApplyOp.?(i)) {
					var apply = SsaApplyOp.!(i);
					if (apply.op.isPolymorphic()) polyOps = List.new(apply, polyOps);
					else analyzeOp(apply, null);
				}
			}
		}
		if (polyOps == null) polyOps = List.new(null, null); // add at least one element
		return polyOps;
	}
	// analyze an operator
	def analyzeOp(op: SsaApplyOp, context: IrSpec) {
		match (op.op.opcode) {
			VariantEq => getEquality(mono(op.op.typeArgs[0], context), context);
			OverloadedEq,
			RefEq => getRefEquality(op, mono(op.op.typeArgs[0], context), context);
			DefaultValue => {
				var t = mono(op.op.typeArgs[0], context);
				var v = prog.getDefaultValue(t);
				analyzeValue(v);
				if (defaultValues == null) defaultValues = TypeUtil.newTypeMap();
				defaultValues[t] = v;
			}
			ArrayAlloc => allocation(makeType(mono(op.op.typeArgs[0], context)));
			ArrayInit => {
				var typ = mono(op.op.typeArgs[0], context);
				allocation(makeType(typ));
				if (op.inputs != null) {
					var inputs = op.inputs;
					for (i < inputs.length) {
						var input = inputs[i];
						var ft = mono(input.getDest().getType(), context);
						getTypeCast(op, ft, typ);
					}
				}
			}
			ClassAlloc(method) => {
				var rm = opMethod(op, method, context);
				if (rm != null) getMethod(op, rm);
				allocation(makeType(mono(op.op.typeArgs[0], context)));
			}
			ClassGetVirtual(method) => getVirtual(closureMethod(opMethod(op, method, context)));
			ClassGetMethod(method) => getMethod(op, closureMethod(opMethod(op, method, context)));
			CreateClosure(method) => getMethod(op, closureMethod(opMethod(op, method, context)));
			ClassGetField(field) => if (op.useList != null) getField(makeField(op, field, context));
			VariantAlloc => {
				var rc = RaClass.!(makeType(mono(op.op.typeArgs[0], context)));
				allocation(rc);
				if (op.inputs.length == rc.fields.length) {
					for (i < rc.orig.fields.length) {
						var rf = makeField2(rc, rc.orig.fields[i]);
						initField2(rf, op.inputs[i].dest);
					}
				} else { // tuple/arity mismatch, be conservative
					for (f in rc.orig.fields) {
						var rf = makeField2(rc, f);
						rf.setFact(RaFact.RF_VAL_MANY);
						rf.initFacts = Facts.NONE;
					}
				}
			}
			VariantGetField(field) => if (op.useList != null) getField(makeField(op, field, context));
			VariantGetVirtual(method) => getVirtual(closureMethod(opMethod(op, method, context)));
			VariantGetMethod(method) => getMethod(op, closureMethod(opMethod(op, method, context)));
			ComponentGetField(field) => if (op.useList != null) getField(makeField(op, field, context));
			ClassInitField(field) => initField(op, makeField(op, field, context));
			ClassSetField(field) => setField(op, makeField(op, field, context));
			ComponentSetField(field) => setField(op, makeField(op, field, context));
			CallMethod(method) => getMethod(op, opMethod(op, method, context));
			CallClassMethod(method) => getMethod(op, opMethod(op, method, context));
			CallClassVirtual(method) => getVirtual(opMethod(op, method, context));
			CallVariantVirtual(method) => getVirtual(opMethod(op, method, context));
			PtrAtObjectField(field) => if (op.useList != null) getPointerAtField(makeField(op, field, context), op, true);
			PtrAtComponentField(field) => if (op.useList != null) getPointerAtField(makeField(op, field, context), op, true);
			PtrAtUnboxedObjectField(specs) => if (op.useList != null) getPointerAtUnboxedField(op, specs, context);
			PtrAtUnboxedComponentField(specs) => if (op.useList != null) getPointerAtUnboxedField(op, specs, context);
			TypeSubsume, TypeCast => {
				if (compiler.NormConfig.WrapFuncTypeSubsume) {
					var ft = mono(op.op.typeArgs[0], context);
					var tt = mono(op.op.typeArgs[1], context);
					return getTypeCast(op, ft, tt);
				}
			}
			_ => ;
		}
	}

	// Function subsumption wrapping / mapping tables, then functions
	//
	//   When a function type F1 id a subtype of function type F2, but not the
	//   same type, F2 subsumes F1.  Some targets do not allow treating F1 instances
	//   as F2 instances in their run-times, because of stricter type rules.  In
	//   this case f of type F1 requires a wrapper, e.g., wf, of type F2 that just
	//   turns around and calls f.  Example: class B extends class A, F1 is void -> A
	//   and F2 is void -> B.  Let f: void -> B in a context that wants a function
	//   of type void -> A.  We can create internally a wrapper equivalent to:
	//   def wf() -> A { return f(); }.  This generalizes, with some care to handle
	//   nested subsmptions when argument / result types are themselves function
	//   types.
	//
	//   In the case where var v: F1, that is, an unknown function, we require a
	//   *mapper* that takes in a *function* of type F1 and returns a wrapped
	//   version of type F2.  This requires generating a wrapper for *every* function
	//   of type F1, and generating the mapper as well.
	//
	//   If function values are compared (== or !=) other than against null, we need
	//   to ensure that we compare a canonical version of the functions as opposed to
	//   possibly different wrappers for the same underlying function.  In this case,
	//   if required, we generate an *unmapper* that takes in a function are returns
	//   its (fully) unwrapped version.  Those may then me compared.
	//

	// (wrappee func type, wrapper func type) => (wrappee => wrapper)
	//   used to find wrapper for a given wrappee subsumption
	//   requires normalization
	var wrappedFunctionWrapper = TypeUtil.newTypePairMap<HashMap<IrSpec,IrSpec>>();

	// Vector of (wrappee func type, wrapper func type, wrappee, wrapper)
	//   used to iterate and build mappers
	//   requires normalization
	var wrappedFunctionWrapperVec = Vector<(Type, Type, IrSpec, IrSpec)>.new();

	// (wrappee func type, wrapper func type) => mapper method
	//   used to find mapper for a given func type subsumption
	//   requires normalization
	var wrappedFunctionTypeMapper = TypeUtil.newTypePairMap<IrSpec>();

	// Vector of (wrappee func type, wrapper func type, mapper method)
	//   used to iterate over mappers
	//   requires normalization
	var wrappedFunctionTypeMapperVec = Vector<(Type, Type, IrSpec)>.new();

	// Set of (wrapped func type)
	//   used (during reachability analysis) to indicate possible need for an unmapper
	//   does not require normalization
	var unmapperRequests = TypeUtil.newTypeMap<void>();

	// Vector of (wrapped func type)
	//   used to iterate over unmapper requests
	//   does not require normalization
	var unmapperRequestsVec = Vector<Type>.new();

	// Func type => unmapper for that type
	//   used to find unmapper in normalization
	//   requires normalization
	var unmapper = TypeUtil.newTypeMap<IrSpec>();

	// Vector of (func type, unmapper for that type)
	//   used to iterate over unmappers
	//   requires normalization
	var unmapperVec = Vector<(Type, IrSpec)>.new();

	// Type -> List of wrappers that have that type
	//   used to build unmappers
	//   requires normalization
	var wrappers = TypeUtil.newTypeMap<List<IrSpec>>();

	// wrapper => wrappee
	//   used to build unmappers
	//   requires normalization
	var wrappeeForWrapper = HashMap<IrSpec, IrSpec>.new(IrSpec.hash, IrSpec.equals);

	// End of wrapping / mapping tables

	// Note: ft, tt, and spec are always un-normalized, as is the result
	def getWrappedFunction(ft: Type, tt: Type, spec: IrSpec) -> IrSpec {
		if (CLOptions.PRINT_WRAP.get()) {
			printWrap().put2("getWrappedFunction: input types ft %q (open %z)", ft.render, ft.open())
				   .put2("  tt %q (open %z)", tt.render, tt.open()).outln();
			printWrap().put3("getWrappedFunction: spec %q  method receiver %q  open %z",
					 spec.render, spec.asMethod().receiver.render, spec.asMethod().receiver.open()).outln();
		}
		var ftCanon = Function.funcRefType(ft);
		var ttCanon = Function.funcRefType(tt);
		var m = spec.asMethod();
		if (!wrappedFunctionWrapper.has((ftCanon, ttCanon))) {
			if (CLOptions.PRINT_WRAP.get()) {
				printWrap().put3("getWrappedFunction: a FuncVal of %q{%d/%d} not found",
						 m.render, m.index, m.uid)
					   .put3("; ft %q  tt %q  M_NORM %z", ftCanon.render, ttCanon.render, m.facts.M_NORM).outln();
			}
			return null;
		}
		if (CLOptions.PRINT_WRAP.get()) {
			printWrap().put1("getWrappedFunction: lookup spec is %q; ", spec.render)
				   .put3("method %q{%d/%d}", m.render,
					 m.index, m.uid).outln();
		}
		var nspec = wrappedFunctionWrapper[(ftCanon, ttCanon)][spec];
		if (nspec == null) {
			if (CLOptions.PRINT_WRAP.get()) {
				printWrap().put3("getWrappedFunction(2): a FuncVal of %q{%d/%d} not found", spec.asMethod().render,
						 spec.asMethod().index, spec.asMethod().uid).outln();
			}
			return null;
		}
		if (CLOptions.PRINT_WRAP.get()) {
			var nm = nspec.asMethod();
			printWrap().put3("getWrappedFunction: looked up %q{%d/%d}, ", m.render, m.index, m.uid)
				   .put3("returning %q{%d/%d}", nm.render, nm.index, nm.uid).outln();
		}
		return nspec;
	}
	// generate a wrapper for a function so it can appear as a supertype
	def genWrappedFunction(ft: Type, tt: Type, spec: IrSpec, rnorm: TypeNorm) -> IrSpec {
		// rnorm may be null, but if not, indicates the eventual normed receiver type

		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			printWrapExtra().put2("genWrappedFunction: ft %q  tt %q", ft.render, tt.render).outln();
		}
		var nspec = getWrappedFunction(ft, tt, spec);
		if (nspec != null) return nspec;
		var ftCanon = Function.funcRefType(ft);
		var ttCanon = Function.funcRefType(tt);

		if (!wrappedFunctionWrapper.has((ftCanon, ttCanon))) {
			wrappedFunctionWrapper[(ftCanon, ttCanon)] = HashMap<IrSpec,IrSpec>.new(IrSpec.hash,IrSpec.equals);
		}
		var ht = wrappedFunctionWrapper[(ftCanon, ttCanon)];
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			printWrapExtra().put3("genWrappedFunction: a FuncVal of %q{%d/%d}", spec.asMethod().render,
					 spec.asMethod().index, spec.asMethod().uid).outln();
		}

		// build SSA params and types
		def orig = spec.asMethod();
		var receiver = spec.receiver;
		if (receiver.open()) receiver = spec.instantiateType(spec.receiver);
		if (rnorm != null) receiver = rnorm.oldType;
		def ftype = FuncType.!(ft);
		def ttype = FuncType.!(tt);
		def fsig = ftype.sig();
		var tsig = ttype.sig();
		def mtype = spec.getBoundType();
		if (mtype.typeCon.kind == Kind.CLOSURE) {
			tsig = Signature.new(null, tsig.paramTypes, tsig.returnTypes);
			if (CLOptions.PRINT_WRAP_EXTRA.get()) {
				printWrapExtra().put1("genWrappedFunction: bound type %q is a closure", mtype.render)
						.outln();
			}
		}

		// We create the method here
		var typeArgs = orig.typeArgs;
		var ntypeArgs = if (typeArgs == null, null, TypeArgs.new(typeArgs.typeEnv, [receiver]));
		var meth = prog.opBuilder.createIrMethod(spec.asMethod().receiver, ntypeArgs, tsig);
		var vstFunc = VstFunc.new(null, ReturnType.Void, null);
		var oldSrc = spec.asMethod().source;
		var oldName = if(oldSrc == null, "m", oldSrc.name());
		var name = StringBuilder.new().put2("%s$w%d", oldName, meth.uid).extract();
		var source = if(oldSrc == null, VstMethod.new(false, Token.new(null, name, 0, 0), null, vstFunc),
				VstMethod.new(oldSrc.isPrivate, oldSrc.token.copy(name), oldSrc.typeParams, vstFunc));
		meth.source = source;
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			printWrapExtra().put2("genWrappedFunction: ft %q tt %q", ftype.render, ttype.render)
					.put1(" bound type %q", spec.getBoundType().render)
					.put1(" method type %q", spec.asMethod().getMethodType().render)
					.outln();
			Terminal.buf.put1("   wrappee is %q", receiver.render)
				.put3(".%q{%d/%d}", spec.render, orig.index, orig.uid)
				.put1(" with type %q", spec.getBoundType().render).outln();
			Terminal.buf.put1("   wrapper is %q", meth.receiver.render)
				.put3(".%q{%d/%d}", meth.render, meth.index, meth.uid)
				.put3(" with type %q (tsig %q fsig %q)", meth.getMethodType().render, tsig.funcType().render, fsig.funcType().render).outln();
			if (typeArgs == null) {
				Terminal.buf.puts("   orig typeArgs is null").outln();
			} else {
				Terminal.buf.put1("   orig typeArgs %q", orig.typeArgs.render).outln();
			}
			if (meth.typeArgs == null) {
				Terminal.buf.puts("   meth typeArgs is null").outln();
			} else {
				Terminal.buf.put1("   meth typeArgs %q", meth.typeArgs.render).outln();
			}
		}

		meth.setFact(Fact.M_WRAPPER);
		var inner = SsaContext.new(compiler, prog);
		inner.enterMethod(meth);
		var block = prog.opBuilder.createSsa(inner, receiver, meth);
		// build block
		var args = Arrays.map(meth.ssa.params, SsaInstr.!<SsaParam>);
		for (i = 1; i < args.length; ++i) {
			if (tsig.paramTypes[i-1] != fsig.paramTypes[i-1]) {
				args[i] = block.opTypeSubsume0(tsig.paramTypes[i-1], fsig.paramTypes[i-1], args[i], this);
				var op: SsaApplyOp;
				if (SsaApplyOp.?(args[i]) &&
				    (op = SsaApplyOp.!(args[i])).op.opcode == Opcode.TypeSubsume) {
					analyzeOp(op, null);  // may request a mapper
				}
			}
		}
		var apply: SsaInstr;
		var op: Operator;
		var nonClass = (rnorm != null && !V3.isClass(rnorm.newType));
		if (V3.isComponent(receiver) || nonClass) {
			op = V3Op.newCallMethod(spec);
			if (!nonClass) args[0] = inner.graph.nullReceiver();
		} else {
			op = V3Op.newCallClassMethod(spec);
		}
		apply = block.addApply(null, op, args);
		if (ftype.returnType() != ttype.returnType()) {
			if (CLOptions.PRINT_WRAP_EXTRA.get()) {
				printWrapExtra().puts("genWrappedFunction: wrapper includes return subsume").outln();
			}
			apply = block.opTypeSubsume0(ftype.returnType(), ttype.returnType(), apply, this);
		}
		block.addReturn([apply]);
		inner.printSsa("Generated wrapper");
		inner.enterMethod(null);

		// create the IrSpec
		var wrapper = IrSpec.new(spec.receiver, spec.typeArgs, meth);

		ht[spec] = wrapper;
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			printWrapExtra().put1("genWrappedFunction: wrapper stored under spec %q", spec.render).outln();
		}
		wrappedFunctionWrapperVec.put((ftCanon, ttCanon, spec, wrapper));
		wrappers[ttCanon] = List.new(wrapper, wrappers[ttCanon]);
		wrappeeForWrapper[wrapper] = spec;
		if (CLOptions.PRINT_WRAP.get()) {
			printWrap().puts("genWrappedFunction:").outln()
				   .cyan().puts("    from type ").end().put1("%q", ft.render)
				   .cyan().puts("  to type ").end().put1("%q", tt.render).outln()
				   .cyan().puts("    from canoncial type ").end().put1("%q", ftCanon.render)
				   .cyan().puts("  to canonical type ").end().put1("%q", ttCanon.render).outln()
				   .cyan().puts("    wrappee ").end().put3("%q{%d/%d}", spec.render, spec.asMethod().index, spec.asMethod().uid)
				   .cyan().puts("  wrapper ").end().put3("%q{%d/%d}", wrapper.render, wrapper.asMethod().index, wrapper.asMethod().uid).outln()
				   .cyan().puts("    wrappee rcvr ").end().put1("%q", spec.receiver.render)
				   .cyan().puts(" type ").end().put1("%q", spec.asMethod().sig.funcType().render).outln()
				   .cyan().puts("    wrapper rcvr ").end().put1("%q", wrapper.receiver.render)
				   .cyan().puts(" type ").end().put1("%q", wrapper.asMethod().sig.funcType().render).outln();
		}
		return wrapper;
	}
	// obtains a wrapper for a function and creates an RaMethod for it
	def genWrappedFunctionRaMethod(ft: Type, tt: Type, spec: IrSpec, rnorm: TypeNorm) -> RaMethod {
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			var m = spec.asMethod();
			printWrapExtra().put3("genWrappedFunctionRaMethod: method %q{%d/%d} not found",
					      spec.render, m.index, m.uid).outln();
		}
		var nspec = getWrappedFunction(ft, tt, spec);
		if (nspec == null) nspec = genWrappedFunction(ft, tt, spec, rnorm);
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			printWrapExtra().put1("genWrappedFunctionRaMethod: nspec null %z", nspec == null).outln();
		}
		var rm = makeMethod(nspec.typeArgs, nspec.asMethod(), nspec);
		if (!rm.setFact(RaFact.RM_LIVE)) {
			if (CLOptions.PRINT_WRAP_EXTRA.get()) {
				printWrapExtra().put1("genWrappedFunctionRaMethod: adding orig %q to liveMethods", rm.orig.render).outln();
			}
			liveMethods.put(rm);
		}
		var raSpec = rm.getSpec();
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			var m = spec.asMethod();
			printWrapExtra().put3("genWrappedFunctionRaMethod: returning %q{%d/%d",
					      raSpec.render, raSpec.asMethod().index, raSpec.asMethod().uid)
					.put1("/%d}", rm.uid)
					.put3(" nspec %q{%d/%d}", nspec.render,
					      nspec.asMethod().index, nspec.asMethod().uid).outln();
		}
		return rm;
	}
	// obtains a wrapper for a function and return the IrSpec for the RaMethod for that wrapper
	def genWrappedFunctionRASpec(ft: Type, tt: Type, spec: IrSpec) -> IrSpec {
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			var m = spec.asMethod();
			printWrapExtra().put3("genWrappedFunctionRASpec: method %q{%d/%d}",
					      spec.render, m.index, m.uid).outln();
		}
		var rm = genWrappedFunctionRaMethod(ft, tt, spec, null);
		var raSpec = rm.getSpec();
		if (CLOptions.PRINT_WRAP_EXTRA.get()) {
			var m = spec.asMethod();
			printWrapExtra().put3("genWrappedFunctionRASpec: returning %q{%d/%d",
					      raSpec.render, raSpec.asMethod().index, raSpec.asMethod().uid)
					.put1("/%d}", rm.uid).outln();
		}
		return raSpec;
	}
	def getMapper(ft: Type, tt: Type) -> IrSpec {
		var ftCanon = Function.funcRefType(ft);
		var ttCanon = Function.funcRefType(tt);
		if (!wrappedFunctionTypeMapper.has((ftCanon, ttCanon))) {
			if (CLOptions.PRINT_WRAP.get()) {
				printWrap().put2("getMapper: ft %q  tt %q  mapper not found", ft.render, tt.render).outln();
			}
			return null;
		}
		var mapper = wrappedFunctionTypeMapper[(ftCanon, ttCanon)];
		if (CLOptions.PRINT_WRAP.get()) {
			printWrap().put3("getMapper: ft %q  tt %q  mapper %q", ft.render, tt.render, mapper.render).outln();
		}
		return mapper;
	}
	def requestUnmapper(t: Type) {
		var canon = Function.funcRefType(t);
		if (!unmapperRequests.has(canon)) {
			if (CLOptions.PRINT_WRAP.get()) {
				printWrap().put1("requestUnmapper: adding request for t %q", canon.render).outln();
			}
			unmapperRequests[canon] = ();
			unmapperRequestsVec.put(canon);
		}
	}
	def getUnmapper(t: Type) -> IrSpec {
		var canon = Function.funcRefType(t);
		if (!unmapper.has(canon)) {
			if (CLOptions.PRINT_WRAP.get()) {
				printWrap().put1("getUnmapper: unmapper for %q not found", t.render).outln();
			}
			return null;
		}
		var um = unmapper[canon];
		if (CLOptions.PRINT_WRAP.get()) {
			printWrap().put2("getUnmapper: unmapper for %q is %q", t.render, um.render).outln();
		}
		return um;
	}
	def getFuncTypeCast(op: SsaInstr, ft: Type, tt: Type) {
		if (!compiler.NormConfig.WrapFuncTypeSubsume) return;
		if (ft == tt) return;
		if (CLOptions.PRINT_WRAP.get()) {
			if (op == null) {
				printWrap().put2("getFuncTypeCast: ft %q  tt %q  op null", ft.render, tt.render).outln();
			} else {
				printWrap().put3("getFuncTypeCast: ft %q  tt %q  op.getType() %q", ft.render, tt.render, op.getType().render).outln();
			}
		}
		var cast = TypeSystem.newTypeCast(ft, tt);
		if (CLOptions.PRINT_WRAP.get()) {
			printWrap().put1("getFuncTypeCast: cast is %s", cast.name);
			if (op != null) Terminal.buf.put1("  is SsaConst %z", SsaConst.?(op));
			Terminal.buf.outln();
		}
		if (cast != TypeCast.UNKNOWN_CAST && SsaConst.?(op)) {
			var sc = SsaConst.!(op);
			var r = Eval.doCast(cast, ft, tt, sc.val);
			if (r.0) {
				var val = sc.val;
				var fv = FuncVal.!(val);
				var spec = fv.memberRef;
				genWrappedFunctionRaMethod(ft, tt, spec, null);
			}
			return;
		}
		if (cast == TypeCast.TRUE) {
			// make a reasonable effort to find a constant and avoid a mapper
			var arg = op;
			if (SsaApplyOp.?(op)) {
				if (CLOptions.PRINT_WRAP_EXTRA.get()) {
					printWrapExtra().puts("getFuncTypeCast: op is SsaApplyop").outln();
				}
				var apply = SsaApplyOp.!(op);
				arg = op.inputs[0].getDest();
				if (tt == arg.getType()) return;  // no-work subsume
				if (SsaApplyOp.?(arg)) {
					if (CLOptions.PRINT_WRAP_EXTRA.get()) {
						printWrapExtra().puts("getFuncTypeCast: first arg is SsaApplyOp").outln();
					}
					var sa = SsaApplyOp.!(arg);
					if (Opcode.CreateClosure.?(sa.op.opcode)) {
						if (CLOptions.PRINT_WRAP_EXTRA.get()) {
							printWrapExtra().puts("getFuncTypeCast: first arg is CreateClosure").outln();
						}
						var opcode = Opcode.CreateClosure.!(sa.op.opcode);
						var meth = opcode.method;
						var spec = V3Op.extractIrSpec(sa.op, opcode.method);
						genWrappedFunctionRaMethod(ft, tt, spec, null);
						return;
					}
				}
			}
			if (tt == arg.getType()) return;  // no-work subsume
			prog.requestMapper(ft, tt);
		}
	}
	def getTypeCast(op: SsaInstr, ft: Type, tt: Type) {
		match (tt.typeCon.kind) {
			TUPLE => {
				var fts = Tuple.toTypeArray(ft), tts = Tuple.toTypeArray(tt);
				if (fts.length != tts.length) return;  // cast will always fail
				for (i < fts.length) getTypeCast(op, fts[i], tts[i]);
			}
			FUNCREF, CLOSURE => getFuncTypeCast(op, ft, tt);
			_ => ;
		}
	}
	def closureMethod(m: RaMethod) -> RaMethod {
		var receiver = makeType(m.receiver);
		receiver.raFacts |= RaFact.RC_CLOSURE;
		return m;
	}
	// analyze an equality comparison
	def getEquality(t: Type, context: IrSpec) {
		match (t.typeCon.kind) {
			CLASS => {
				var rc = makeClass(t);
				// Set equality on all live subtypes
				if (!rc.setFact(RaFact.RC_EQUALITY)) {
					for (l = rc.subtypes; l != null; l = l.tail) {
						rc.raFacts |= RaFact.RC_EQUALITY;
					}
				}
			}
			VARIANT => {
				var rc = generateVariantEquals(t);
				// Set equality on all live subtypes and mark all fields as read
				if (!rc.setFact(RaFact.RC_EQUALITY)) {
					getAndCompareAllFields(rc);
					for (l = rc.subtypes; l != null; l = l.tail) {
						if (!l.head.setFact(RaFact.RC_EQUALITY)) getAndCompareAllFields(l.head);
					}
				}
				var rm = makeMethod([rc.oldType], rc.orig.methods[IrUtil.EQUALS_METHOD_INDEX], context);
				getVirtual(rm);
			}
			_ => for (l = t.nested; l != null; l = l.tail) getEquality(l.head, context);
		}
	}
	// analyze a reference equality comparison
	def getRefEquality(op: SsaApplyOp, t: Type, context: IrSpec) {
		if (compiler.NormConfig.WrapFuncTypeSubsume &&
		    (t.typeCon.kind == Kind.CLOSURE || t.typeCon.kind == Kind.FUNCREF)) {
			var x = op.inputs[0].dest;
			var y = op.inputs[1].dest;
			var xconst = SsaConst.?(x);
			var yconst = SsaConst.?(y);
			// Two known functions can be compared at compile time
			// so do not need a run-time unmapper
			if (xconst && yconst) { }
			// Comparison with null does not require unmapping
			else if (xconst && (SsaConst.!(x).val == null)) { }
			else if (yconst && (SsaConst.!(y).val == null)) { }
			else requestUnmapper(t);
		}
		getEquality(t, context);
	}
	// analyze an access of a field
	def analyzeGetField(receiver: RaClass, rf: RaField) {
		for (t = receiver.subtypes; t != null; t = t.tail) { // for all live subtypes
			for (l = t.head.instances; l != null; l = l.tail) { // for all instances
				analyzeField(l.head, rf);
			}
		}
	}
	def allocation(raType: RaType) {
		var oldFacts = raType.raFacts;
		raType.raFacts |= RaFact.RC_ALLOC;
		if (RaClass.?(raType) && !live(oldFacts)) {
			// process a newly-live class
			analyzeLiveClass(RaClass.!(raType));
		}
	}
	def getVirtual(rm: RaMethod) {
		if (rm.isVirtual()) return;
		rm.virtual = RaVirtual.new(rm);
		var rc = makeClass(rm.receiver);
		for (l = rc.subtypes; l != null; l = l.tail) {
			analyzeVirtual(l.head, rm);
		}
	}
	private def flattenTypes(input: Array<Type>, context: IrSpec) -> Vector<Type> {
		var flat = Vector<Type>.new();
		var stack = ArrayStack<Type>.new();
		for (i = input.length; --i >= 0; ) {
			var typ = input[i];
			if (context != null) typ = context.instantiateType(typ);
			stack.push(typ);
		}
		while (!stack.empty()) {
			var types = Tuple.toTypeArray(stack.pop());
			match (types.length) {
				0 => continue;
				1 => {
					if (types[0] == Void.TYPE) continue;
					flat.put(types[0]);
				}
				_ => {
					for (i = types.length; --i >= 0; ) stack.push(types[i]);
				}
			}
		}
		return flat;
	}
	def getCall(rm: RaMethod, op: SsaApplyOp, context: IrSpec) {
		if (true) return;
		var mtype = FuncType.!(rm.spec.getBoundType());
		var sig = mtype.sig();
		var atype = FuncType.!(op.op.sig.funcType());
		var asig = atype.sig();
		// flatten tuple types
		def flatParams = flattenTypes(sig.paramTypes, rm.spec);
		def argTypes = asig.paramTypes;
		def flatArgs = flattenTypes(argTypes, context);
		def offset = flatParams.length - flatArgs.length;
		for (i < flatParams.length) {
			var paramType = flatParams[i];
			var argType = flatArgs[i];
			if (argType == paramType || argType == null) continue;
			getTypeCast(null, argType, paramType);
		}
		var callTypes = flattenTypes([op.getType()], context);
		var retTypes = flattenTypes(sig.returnTypes, context);
		for (i < retTypes.length) {
			var returnType = retTypes[i];
			var callType = callTypes[i];
			if (callType == returnType || callType == null) continue;
			getTypeCast(null, returnType, callType);
		}
	}
	def getMethod(op: SsaApplyOp, rm: RaMethod) {
		if (rm.setFact(RaFact.RM_LIVE)) return;
		liveMethods.put(rm);
		queue.add(analyzeMethod, rm);
		if (V3.isVariant(rm.receiver)) { // XXX: this is because of variant null replacement
			var rc = makeClass(V3.getDefaultVariantCaseType(prog, rm.receiver));
			var newlyLive = !live(rc.raFacts);
			rc.raFacts |= RaFact.RC_LIVE;
			if (newlyLive) analyzeLiveClass(rc);
		}
	}
	def getField(rf: RaField) {
		if (rf.setFact(RaFact.RF_READ)) return;
		queue.add(analyzeGetField, (makeClass(rf.receiver), rf));
	}
	def getAndCompareAllFields(rc: RaClass) {
		var typeArgs = V3.getTypeArgs(rc.oldType);
		for (f in rc.orig.fields) {
			var rf = makeField2(rc, f);
			getField(rf);
			getEquality(if(rf.fieldType == null, f.fieldType, rf.fieldType), null);
		}
	}
	def pointedAtTypeLegal(t: Type) -> bool {
		match (t) {
			x: VoidType => return false;	// must come before PrimType
			x: PrimType => return true;
			x: ClassType => return !x.classDecl.isUnboxed();
			x: PointerType => return true;
			x: ArrayType => return true;
			// x: TupleType => return true;	// add when handled
		}
		return false;
	}
	def getPointerAtField(rf: RaField, op: SsaApplyOp, checkType: bool) {
		if (checkType) {
			var ft = rf.fieldType;
			if (ft == null) ft = rf.orig.fieldType;
			if (!pointedAtTypeLegal(ft)) {
				var ERROR = compilation.prog.ERROR;
				var msg = Strings.format1("field must be of non-void primitive type or boxed class type (type is %q)", ft.render);
				ERROR.addError(op.source.range, null, "TypeError", msg);
			}
		}
		// Treat the field as both read and written, with unknown values
		getField(rf);
		rf.raFacts |= RaFact.RF_WRITTEN;
		var none: Fact.set;
		rf.writeFacts = none;
		rf.setFact(RaFact.RF_VAL_MANY);
	}
	def getPointerAtUnboxedField(op: SsaApplyOp, specs: List<IrField>, context: IrSpec) {
		var prevType: Type;
		prevType = if(specs != null, mono(op.op.typeArgs[0], context));
		for (l = specs; l != null; l = l.tail) {
			var fld = l.head;
			var rf = makeField3(prevType, fld, context);
			prevType = rf.fieldType;
			if (prevType == null) prevType = rf.orig.fieldType;
			// check only the last type in the range, since the intermediates
			// are not pointed at
			getPointerAtField(rf, op, l.tail == null);
		}
	}
	def setField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts |= RaFact.RF_WRITTEN;
		var val = op.input1();
		rf.writeFacts = rf.writeFacts & val.facts & Facts.V_FACTS;
		if (SsaConst.?(val)) rf.addValue(SsaConst.!(val).val);
		else rf.setFact(RaFact.RF_VAL_MANY);
	}
	def initField(op: SsaApplyOp, rf: RaField) {
		initField2(rf, op.input1());
	}
	def initField2(rf: RaField, val: SsaInstr) {
		if (SsaConst.?(val)) rf.addValue(SsaConst.!(val).val);
		else rf.setFact(RaFact.RF_VAL_MANY);
		if (!rf.raFacts.RF_INIT) {
			// first initialization seen of the field
			rf.raFacts |= RaFact.RF_INIT;
			rf.initFacts = val.facts & Facts.V_FACTS;
		} else {
			// not the first initialization seen
			rf.initFacts = rf.initFacts & val.facts & Facts.V_FACTS;
		}
	}
	def makeField(op: SsaApplyOp, f: IrField, context: IrSpec) -> RaField {
		var rf = f.raField;
		if (rf != null) return rf;
		// try to make a simple field first
		var receiver = f.receiver;
		if (!receiver.open()) return makeSimpleField(makeClass(receiver), f);
		// get polymorphic receiver type from operator
		receiver = mono(op.op.typeArgs[0], context);
		return makePolyField(makeClass(receiver), f);
	}
	def makeSimpleField(raType: RaClass, f: IrField) -> RaField {
		// monomorphic receiver type
		if (isNormalType(f.fieldType)) {
			// the field is a simple, monomorphic, normalized field
			return f.raField = raType.makeField(f, null);
		}
		return makePolyField(raType, f);
	}
	def makeField2(raType: RaClass, f: IrField) -> RaField {
		var rf = f.raField;
		if (rf != null) return rf;
		// try to make a simple field first
		var receiver = f.receiver;
		if (!receiver.open()) return makeSimpleField(raType, f);
		// make a polymorphic field
		return makePolyField(raType, f);
	}
	def makeField3(rcvrType: Type, f: IrField, context: IrSpec) -> RaField {
		var rf = f.raField;
		if (rf != null) return rf;
		// try to make a simple field first
		var receiver = f.receiver;
		if (!receiver.open()) return makeSimpleField(makeClass(receiver), f);
		// get polymorphic receiver type from operator
		receiver = mono(rcvrType, context);
		return makePolyField(makeClass(receiver), f);
	}
	def makePolyField(raType: RaClass, f: IrField) -> RaField {
		var rf = raType.fields[f.index];
		if (rf == null) {
			// create the RaField from the normalized type
			var ft = f.fieldType;
			if (ft.open()) ft = f.fieldType.substitute(V3.getTypeArgs(raType.oldType));
			rf = raType.makeField(f, ft);
		}
		return rf;
	}
	def opMethod(op: SsaApplyOp, m: IrMethod, context: IrSpec) -> RaMethod {
		if (m == null) return null;
		var rm = makeMethod(op.op.typeArgs, m, context);
		if (rm != null && compiler.NormConfig.WrapFuncTypeSubsume) {
			match (op.op.opcode) {
				CallMethod, CallClassMethod => getCall(rm, op, context);
				_ => ;
			}
		}
		return rm;
	}
	def makeMethod(typeArgs: Array<Type>, m: IrMethod, context: IrSpec) -> RaMethod {
		var rm = m.raMethod;
		if (rm != null) return rm; // RaMethod already cached

		if (typeArgs.length == 1 && !m.receiver.open()) {
			// a monomorphic method
			var rc = makeClass(m.receiver);
			var rm = rc.makeMethod(m, null);
			return rm.orig.raMethod = rm;
		}
		// search for existing specialization
		if (context != null) typeArgs = context.instantiateTypes(typeArgs);
		var rc = makeClass(typeArgs[0]);
		rm = rc.findMethod(m.index, typeArgs);
		if (rm != null) return rm;  // specialization found

		// not found; fully specialize and normalize the method
		var spec = IrSpec.new(rc.oldType, typeArgs, m);
		rm = rc.makeMethod(m, spec);
		return rm;
	}
	def makeClass(t: Type) -> RaClass {
		return RaClass.!(makeType(t));
	}
	def getClass(t: Type) -> RaClass {
		return RaClass.!(typeMap[t]);
	}
	def makeType(t: Type) -> RaType {
		if (t.open()) return V3.fail1("is open %q", t.render);
		var raType = typeMap[t];
		if (raType != null) return raType;
		// not in the hashmap, build appropriately
		match (t.typeCon.kind) {
			COMPONENT => {
				var compDecl = V3.componentDecl(t);
				deferRecord(prog.getComponentRecord(compDecl));
				raType = newRaClass(t, oldIr.makeIrClass(t), null);
			}
			ARRAY => {
				// normalize element type
				var elem = makeType(V3Array.elementType(t));
				var at = RaArray.new(t, elem);
				arrays.put(at);
				raType = at;
			}
			VARIANT => {
				var ic = oldIr.makeIrClass(t);
				var superType = V3.getSuperType(t), parent: RaClass;
				if (superType != null) {
					parent = makeClass(superType);
				}
				var rc = newRaClass(t, ic, parent);
				rc.raFacts |= RaFact.RC_VARIANT;
				raType = rc;
			}
			CLASS => {
				var superType = V3.getSuperType(t);
				var parent = if(superType != null, makeClass(superType));
				var ic = oldIr.makeIrClass(t);
				if (ic == null) ic = IrClass.new(t, null, null, [], []);
				raType = newRaClass(t, ic, parent);
			}
			_ => {
				for (l = t.nested; l != null; l = l.tail) makeType(l.head);
				raType = RaType.new(t);
			}
		}
		typeMap[t] = raType;
		return raType;
	}
	def newRaClass(oldType: Type, ic: IrClass, parent: RaClass) -> RaClass {
		var rc = RaClass.new(oldType, ic, parent);
		classes.put(rc);
		return rc;
	}
	def mono(t: Type, spec: IrSpec) -> Type {
		return if(spec != null, spec.instantiateType(t), t);
	}
}
// Base class which contains facts for all types of entities during analysis
class RaItem {
	var raFacts: RaFact.set;
	// sets the given fact bit; returns true if the fact was already set
	def setFact(fact: RaFact.set) -> bool {
		if ((raFacts & fact) == NONE) {
			raFacts = raFacts | fact;
			return false;
		}
		return true;
	}
}
// Collects facts about a type used during reachability analysis.
class RaType(oldType: Type) extends RaItem {
	var recursive: int;			// 0 if unknown, < 0 if on stack, 1 if not recursive, > 1 if recursive
	def isRecursive() -> bool { return recursive > 1; }
}
// Tracks whether a class is allocated, collects instances, and tracks information
// about fields and methods.
class RaClass extends RaType {
	def orig: IrClass;			// original, polymorphic IrClass
	def parent: RaClass;			// super class, if any
	def fields = Array<RaField>.new(orig.fields.length);          // index of fields
	var methods = Array<List<RaMethod>>.new(orig.methods.length); // index of methods
	var instances: List<Record>;		// list of live records
	var children: List<RaClass>;		// list of all child classes
	var subtypes: List<RaClass>;		// list of live subtypes
	var normClass: IrClass;			// normalized class
	var liveFields: Array<IrSpec>;		// normalized fields
	var normMethods: Array<IrMethod>;	// normalized methods
	var minClassId = -1;			// minimum class ID
	var maxClassId = -1;			// maximum class ID
	var newIrType: Type;

	var variantNorm: VariantNorm;		// non-null for flattened variants
	var variantFields: Array<VariantField>;
	var origFieldTypes: Array<Type>;

	new(oldType: Type, orig, parent) super(oldType) {
		newIrType = oldType;
		if (parent != null) {
			parent.children = List.new(this, parent.children);
			Arrays.copyInto(parent.fields, fields, 0);
		}
		if (oldType.typeCon.kind != Kind.VARIANT) recursive = 1; // not a variant, can't be recursive
	}
	def makeField(f: IrField, fieldType: Type) -> RaField {
		var rf = addField(RaField.new(oldType, f, fieldType));
		return rf;
	}
	private def addField(rf: RaField) -> RaField {
		fields[rf.orig.index] = rf;
		for (l = children; l != null; l = l.tail) l.head.addField(rf);
		return rf;
	}
	def fieldStart() -> int {
		return if(parent != null, parent.fields.length);
	}
	def inheritedField(rf: RaField) -> bool {
		if (parent == null) return false;
		var i = rf.orig.index;
		return i < parent.fields.length && parent.fields[i] == rf;
	}
	def fieldRequiresStorage(i: int) -> bool {
		var rf = fields[i];
		return rf != null && !rf.isConst() && rf.raFacts.RF_READ;
	}
	def makeMethod(m: IrMethod, spec: IrSpec) -> RaMethod {
		if (m.index >= methods.length) methods = Arrays.grow(methods, methods.length + m.index + 1);
		var rm = RaMethod.new(oldType, m, spec);
		methods[m.index] = List.new(rm, methods[m.index]);
		return rm;
	}
	def findMethod(index: int, typeArgs: Array<Type>) -> RaMethod {
		if (index >= methods.length) return null;
		for (l = methods[index]; l != null; l = l.tail) {
			if (compareTypeArgs(l.head, typeArgs)) return l.head;
		}
		return null;
	}
	def findRaMethod(rm: RaMethod) -> RaMethod {
		return findMethod(rm.orig.index, if(rm.spec == null, MONO_TYPEARGS, rm.spec.typeArgs));
	}
	def replaceRaMethod(rm: RaMethod, rmNew: RaMethod) {
		var index = rm.orig.index;
		var typeArgs = if(rm.spec == null, MONO_TYPEARGS, rm.spec.typeArgs);
		if (index >= methods.length) return;
		var prevs: List<RaMethod>;
		for (l = methods[index]; l != null; l = l.tail) {
			if (l.head == rm) {
				var newList = List<RaMethod>.new(rmNew, l.tail);
				while (prevs != null) {
					newList = List<RaMethod>.new(prevs.head, newList);
					prevs = prevs.tail;
				}
				methods[index] = newList;
				return;
			}
			prevs = List<RaMethod>.new(l.head, prevs);
		}
		if (parent == null) return;
		parent.replaceRaMethod(rm, rmNew);
	}
	def findNormedMethod(meth: IrMethod) -> RaMethod {
		for (i < methods.length) {
			for (l = methods[i]; l != null; l = l.tail) {
				if (l.head.norm == meth) return l.head;
			}
		}
		return null;
	}
	def compareTypeArgs(rm: RaMethod, typeArgs: Array<Type>) -> bool {
		if (rm.spec == null) return typeArgs.length == 1;
		var mtypeArgs = rm.spec.typeArgs;
		for (i = 1; i < typeArgs.length; i++) {
			if (mtypeArgs[i] != typeArgs[i]) return false;
		}
		return true;
	}
	def isUnboxed() -> bool { return variantNorm != null; }
}
// Tracks instances of an array type.
class RaArray extends RaType {
	def elem: RaType;
	var instances: List<Record>;		// list of live records
	var primitive: bool;

	new(oldType: Type, elem) super(oldType) {
		var elem = oldType.nested.head;
		match (elem.typeCon.kind) {
			INT, FLOAT, BOOL, VOID => primitive = true;
			_ => ;
		}
	}
}
// Information about a field, including whether it is initialized, written, read,
// and facts about each of the values written to the field
class RaField(receiver: Type, orig: IrField, fieldType: Type) extends RaItem {
	var val: Val;
	var initFacts = Facts.V_DEFAULT;
	var writeFacts = Facts.V_FACTS;
	var typeNorm: TypeNorm;
	var origIndices: (int, int) = (-1, -1);
	var normIndices: (int, int) = (-1, -1);

	def facts() -> Fact.set {
		return initFacts & writeFacts;
	}
	def addValue(v: Val) {
		// add a value to the set for this field
                var count = countVals(raFacts);
		if (count == 1) {
			if (!Values.equal(val, v)) raFacts |= RaFact.RF_VAL_MANY;
		} else if (count == 0) {
			raFacts |= RaFact.RF_VAL_ONE;
			val = v;
		}
		// also set the facts that are true for all values and writes
		var wfacts = Facts.NONE;
		if (v == null) wfacts = Fact.V_ZERO;
		else if (Box<int>.?(v)) wfacts = Facts.intFacts(Int.unbox(v));
		else if (Box<bool>.?(v)) wfacts = if(Bool.unbox(v), Fact.V_NON_ZERO, Fact.V_ZERO);
		else wfacts = Fact.V_NON_ZERO;
		writeFacts = writeFacts & wfacts;
	}
	def isConst() -> bool {
        	var f = raFacts, count = countVals(f);
		if (count == 1) {
			if (f.RF_INIT) return true; // initialized and a value
			if (!f.RF_WRITTEN) return true; // a value and never written
			if (Values.equal(val, null)) return true; // always written null
		} else if (count == 0 && (f & (RaFact.RF_WRITTEN | RaFact.RF_INIT)) == NONE) {
			return true; // neither written nor initialized, nor any values
		}
		return false;
	}
	def normOf<T>(r: Range<T>) -> Range<T> {
		if (normIndices.0 == normIndices.1) return null;
		return r[normIndices.0 ... normIndices.1];
	}
	def liveFields(ra: ReachabilityAnalyzer) -> Range<IrSpec> {
		var rc = ra.getClass(receiver);
		return normOf(rc.liveFields);
	}
	def getClosedType() -> Type {
		return if(fieldType == null, orig.fieldType, fieldType);
	}
}
component RaMethods {
	var uid = 0;
}
// Information about a method, including any specialization, whether it is reusable
// across normalization, etc.
class RaMethod(receiver: Type, orig: IrMethod, spec: IrSpec) extends RaItem {
	var norm: IrMethod;
	var funcNorm: FuncNorm;
	var normIndex = -1;
	var virtual: RaVirtual;
	private var cachedSpec: IrSpec;
	def uid = RaMethods.uid++;

	def getSpec() -> IrSpec {
		if (cachedSpec != null) return cachedSpec;
		if (spec != null) return cachedSpec = spec;
		return cachedSpec = IrSpec.new(receiver, [receiver], orig);
	}
	def isLive() -> bool {
		return raFacts.RM_LIVE;
	}
	def isVirtual() -> bool {
		return virtual != null;
	}
}
// Extra information about a virtual method.
class RaVirtual(raMethod: RaMethod) {
	var mtable: IrMtable;		// mtable used for machine-level virtual calls
	var devirtual: RaMethod;	// RA-devirtualized target, if any
	var impls: List<RaMethod>;	// list of all implementations
	var count = 0;
	def addImpl(rm: RaMethod) {
		if (count == 0) { devirtual = rm; count = 1; }
		else if (count == 1 && devirtual != rm) { devirtual = null; count = 2; }
		for (l = impls; l != null; l = l.tail) {
			if (l.head == rm) return; // XXX: linear search for RaMethod
		}
		impls = List.new(rm, impls);
	}
}
// A target which prints out the results of reachability analysis
def raTarget = Aeneas.registerTarget(RaTarget.new());
class RaTarget extends Target("ra") {
	def configureCompiler(compiler: Compiler) {
		compiler.Reachability = true;
	}
	def configureProgram(prog: Program) {
		SystemCalls.install(prog);
	}
	def emit(compiler: Compiler, prog: Program) {
		IrPrinter.new(prog).print();
	}
}
// Generates the comparator method for a (polymorphic) variant type.
class VariantComparatorGen(context: SsaContext, root: IrClass, receiver: IrClass, method: IrMethod) {
	def numCases = V3.classDecl(root.ctype).cases.length;
	var graph: SsaGraph;
	var p0: SsaInstr, p1: SsaInstr;
	def generate() -> SsaGraph {
		context.enterMethod(method);

		var tag = V3.classDecl(receiver.ctype).variantTag;
		var params = Array<SsaParam>.new(2);
		p0 = params[0] = SsaParam.new(0, receiver.ctype);
		p1 = params[1] = SsaParam.new(1, root.ctype);
		if (tag > 0) p0.facts |= Fact.V_NON_ZERO;
		method.ssa = context.graph = graph = SsaGraph.new(params, Bool.TYPE);

		if (tag == -1) genCompareTag();
		else genCompareFields(tag);

		context.printSsa("Generated");
		return graph;
	}
	def genCompareTag() {
		var b = newBuilder(graph.startBlock);
		var cmp: SsaInstr;
		if (numCases > 1) {
			var op = V3Op.newVariantGetTag(root.ctype);
			var t0 = b.addApply(null, op, [p0]);
			var t1 = b.addApply(null, op, [p1]);
			cmp = b.opEqual(op.sig.returnType(), t0, t1);
		} else {
			cmp = graph.trueConst();
		}
		b.addReturn([cmp]);
	}
	def genCompareFields(tag: int) {
		var b = newBuilder(graph.startBlock);

		var tblock = SsaBlock.new(), fblock = SsaBlock.new();
		b.addIf(b.pure(V3Op.newRefEq(root.ctype), [p0, p1]), tblock, fblock);
		addReturnBool(tblock, true);
		b = newBuilder(fblock);

		var falseBlock = SsaBlock.new();
		addReturnBool(falseBlock, false);

		var fieldCompare: SsaBlock;
		// check p1 for null, TODO: is this necessary?
		var neNull1 = SsaBlock.new();
		b.addIfNull(p1, falseBlock, neNull1);
		fieldCompare = neNull1;

		b = newBuilder(fieldCompare);

		if (numCases > 1) { // tag comparison only necessary if more than 1 case
			var op = V3Op.newVariantGetTag(root.ctype);
			var get = b.addApply(null, op, [p1]);
			get.facts |= Fact.O_NO_NULL_CHECK;
			var cmp = b.opEqual(op.sig.returnType(), get, graph.intConst(tag));

			var eqTag = SsaBlock.new();
			b.addIf(cmp, eqTag, falseBlock);
			b = newBuilder(eqTag);
		}
		p1 = b.opTypeSubsume0(root.ctype, receiver.ctype, p1, null); // safe cast
		p1.setFact(Fact.O_NO_NULL_CHECK | Fact.V_NON_ZERO);
		genFieldComparisons(b, falseBlock);
	}
	def genFieldComparisons(b: SsaBuilder, falseBlock: SsaBlock) {
		// compare each field
		for (f in receiver.fields) {
			var spec = IrSpec.new(receiver.ctype, [receiver.ctype], f);
			var f0 = b.opGetField(spec, p0);
			var f1 = b.opGetField(spec, p1);
			f0.facts |= Fact.O_NO_NULL_CHECK;
			f1.facts |= Fact.O_NO_NULL_CHECK;
			var cmp = b.opEqual(f.fieldType, f0, f1);
			if (f.index == receiver.fields.length - 1) {
				// last field
				b.addReturn([cmp]);
				return;
			}
			var cont = SsaBlock.new();
			b.addIf(cmp, cont, falseBlock);
			b = newBuilder(cont);
		}
		b.addReturn([graph.trueConst()]);
	}
	def newBuilder(block: SsaBlock) -> SsaBuilder {
		return SsaBuilder.new(context, graph, block);
	}
	def addReturnBool(block: SsaBlock, val: bool) {
		SsaBuilder.new(context, graph, block).addReturn([graph.boolConst(val)]);
	}
}
// Globally shareable normalizers.
component IntNormalizers {
	def I32LE = IntNormalizer.new(32);
	def I64LE = IntNormalizer.new(64);
}
// Reports code that is neither used during initialization nor reachable from main().
class DeadCodeAnalyzer(ra: ReachabilityAnalyzer) {
	def buf = TerminalBuffer.new();
	def report() {
		ra.typeMap.apply(processType);
		for (i < ra.prog.ir.classes.length) {
			var c = ra.prog.ir.classes[i];
			processIrClass(c);
			reportClass(c);
		}
	}
	def reportClass(ic: IrClass) {
		buf.reset();
		if (!ic.facts.X_LIVE && !isSynthetic(ic)) {
			// the entire class is dead
			addLine("dead ", ic);
		} else {
			// report dead fields if any
			for (f in ic.fields) {
				if (ic.inherits(f)) continue;
				if (reportDead(f)) {
					if (buf.length == 0) addLine("within ", ic);
					buf.puts("  dead field: ");
					f.render(buf.red());
					buf.end().ln();
				}
			}
			// report dead methods if any
			for (m in ic.methods) {
				if (m == null) continue;
				if (ic.inherits(m)) continue;
				if (m.facts.M_EMPTY) continue;
				if (reportDead(m)) {
					if (buf.length == 0) addLine("within ", ic);
					buf.puts("  dead method: ");
					m.render(buf.red());
					buf.end().ln();
				}
			}
		}
		buf.outt();
	}
	def reportDead(m: IrMember) -> bool {
		if (m.facts.X_LIVE) return false;
		// Don't report dead fields or methods whose names end with "_".
		match (m) {
			x: IrField => return x.source != null && !Strings.endsWith(x.source.name(), "_");
			x: IrMethod => return x.source != null && !Strings.endsWith(x.source.name(), "_");
		}
		return true;
	}
	def addLine(p: string, ic: IrClass) {
		buf.puts(p);
		if (V3.isVariant(ic.ctype)) buf.puts("variant ");
		else if (V3.isClass(ic.ctype)) buf.puts("class ");
		else if (V3.isComponent(ic.ctype)) {
			if (isSynthetic(ic)) buf.puts("file ");
			else buf.puts("component ");
		}
		ic.ctype.render(buf.red());
		buf.end().ln();
	}
	def isSynthetic(ic: IrClass) -> bool {
		return V3.isComponent(ic.ctype) && V3.componentDecl(ic.ctype).isSynthetic;
	}
	def processIrClass(ic: IrClass) {
		for (f in ic.fields) {
			if (f.facts.X_LIVE) markMember(f);
		}
//TODO		for (m in ic.methods) {
//			if (m != null && m.ssa != null) markMember(m);
//		}
	}
	def processType(t: Type, tn: RaType) {
		if (!RaClass.?(tn)) return;
		var rc = RaClass.!(tn);
		for (f in rc.fields) {
			if (f == null) continue;
			if (f.raFacts.RF_READ) markMember(f.orig);
		}
		for (ml in rc.methods) {
			for (l = ml; l != null; l = l.tail) {
				var m = l.head;
				if (m.raFacts.RM_LIVE) markMember(m.orig);
			}
		}
		if (live(rc.raFacts) || rc.orig.facts.X_LIVE) {
			while (rc != null) {
				rc.orig.facts |= Fact.X_LIVE;
				rc = rc.parent;
			}
		}
	}
	def markMember(m: IrMember) {
		m.facts |= Fact.X_LIVE;
		ra.prog.ir.getIrClass(m.receiver).facts |= Fact.X_LIVE;
	}
}
