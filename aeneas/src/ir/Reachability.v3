// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Constants representing flags for reachability analysis
def RM_LIVE       = 0x0001;
def RF_NORMALIZED = 0x0002;
def RF_READ       = 0x0004;
def RF_WRITTEN    = 0x0008;
def RF_INIT       = 0x0010;
def RF_VAL_ONE    = 0x0020;
def RF_VAL_MANY   = 0x0040;
def RF_VALS       = RF_VAL_ONE | RF_VAL_MANY;
def RC_ALLOC      = 0x0080;
def RC_LIVE       = 0x0100;
def RC_DUMPED	  = 0x0200;
def RC_EQUALITY   = 0x0400;
def RC_VARIANT    = 0x0800;
def RC_ENUM       = 0x1000;

// global reachability information for primitive types, accessed frequently
def RA_VOID = TypeNorm.new(Void.TYPE, Void.TYPE, TypeUtil.NO_TYPES);
def RA_BOOL = TypeNorm.new(Bool.TYPE, Bool.TYPE, null);

def NO_RECORDS = Array<Record>.new(0);
def MONO_TYPEARGS = [AnyObject.TYPE];

def EQUALS_VST_METHOD = VstMethod.new(false, Token.new(null, "==", 0, 0), null, null, null, null);

// Performs polymorphic reachability analysis over a program.
class ReachabilityAnalyzer(compiler: Compiler, prog: Program) {
	def oldIr = prog.ir;
	def typeMap = TypeUtil.newTypeMap<TypeNorm>();
	def records = V3.newRecordMap<Record>();
	def polyMap = IrUtil.newIrItemMap<List<SsaApplyOp>>();
	def queue = WorkQueue.new();
	def heapTypes = Vector<TypeNorm>.new();
	var liveMethods = Vector<RaMethod>.new();
	var roots: List<RaRoot>;
	var uniqueCounter = 1;
	def setTypeCon = TypeSet_TypeCon.new(prog.typeCache);

	// perform the analysis, starting from the roots
	def analyze() {
		queue.drain(); // do all work
	}
	def transform() {
		ReachabilityNormalizer.new(this).normalize();
	}
	def dump() {
		liveMethods.apply(dumpMethod);
		heapTypes.apply(dumpType);
		records.apply(dumpRecord);
	}
	def dumpMethod(rm: RaMethod) {
		if (rm == null || rm.setFact(RC_DUMPED)) return;
		Terminal.put1("%1", if (rm.spec != null, rm.spec.render, rm.orig.renderLong));
		dumpFacts(rm.raFacts, rm.virtual, null);
	}
	def dumpField(container: Type, rf: RaField) {
		if (rf == null) return;
		Terminal.put2("%1.%2", container.render, rf.orig.render);
		dumpFacts(rf.raFacts, null, rf.val);
	}
	def dumpType(rt: TypeNorm) {
		if ((rt.raFacts & (RC_LIVE | RC_ALLOC)) != 0) {
			Terminal.put1("%1", rt.oldType.render);
			dumpFacts(rt.raFacts, null, null);
		}
		if (RaClass.?(rt)) {
			var rc = RaClass.!(rt);
			for (list in rc.methods) {
				for (l = list; l != null; l = l.tail) {
					dumpMethod(l.head);
				}
			}
			for (i = rc.fieldStart(); i < rc.fields.length; i++) {
				dumpField(rt.oldType, rc.fields(i));
			}
		}
	}
	def dumpRecord(r: Record, x: Record) {
		if (!V3.isComponent(r.rtype)) Terminal.put2("%1 #%2\n", r.rtype.render, r.id);
	}
	def dumpFacts(facts: int, virtual: RaVirtual, val: Val) {
		if ((facts & RF_READ) != 0) Terminal.put(" r");
		if ((facts & RF_WRITTEN) != 0) Terminal.put(" w");
		if ((facts & RF_INIT) != 0) Terminal.put(" i");
		if ((facts & RM_LIVE) != 0) Terminal.put(" l");
		if (virtual != null) Terminal.put(" v");
		if ((facts & RC_LIVE) != 0) Terminal.put(" l");
		if ((facts & RC_ALLOC) != 0) Terminal.put(" a");
		if ((facts & RC_VARIANT) != 0) Terminal.put(" t");
		if ((facts & RC_EQUALITY) != 0) Terminal.put(" =");
		if ((facts & RF_VALS) == RF_VAL_ONE) {
			Terminal.put(" k");
			Terminal.put1(" = %1", prog.render(val));
		}
		Terminal.ln();
	}
	def addRootMethod(meth: IrSpec) -> RaRoot {
		getMethod(null, makeMethod(meth.typeArgs, meth.asMethod(), null));
		makeType(meth.container);
		var root = RaRoot.new(meth);
		roots = List.new(root, roots);
		return root;
	}
	// a quick check to see if a type is the same as its normalization
	def isNormalType(t: Type) -> bool {
		match(t.typeCon.kind) {
			V3Kind.BOOL, V3Kind.INT, V3Kind.CLASS: return true;
			V3Kind.ARRAY: return isNormalType(V3Array.elementType(t));
		}
		return false;
	}
	// analyze a value
	def analyzeVal(a: (Type, Val), i: SsaValue) {
		if (i.useList != null) analyzeValue(a.1);
	}
	// defer analysis of a value
	def deferValue(val: Val) {
		if (val == null) return;
		if (Record.?(val) || Closure.?(val) || Tuple_Value.?(val)) queue.add(analyzeValue, val);
	}
	// analyze a value such as a record, closure, or tuple
	def analyzeValue(val: Val) {
		if (Record.?(val)) {
			// analyze a simple record
			analyzeRecord(Record.!(val));
		} else if (Closure.?(val)) {
			// analyze a record + method closure pair
			var closure = Closure.!(val), spec = closure.memberRef;
			getMethod(null, makeMethod(spec.typeArgs, IrMethod.!(spec.member), null));
			if (closure.val != null) analyzeRecord(Record.!(closure.val));
		} else if (Tuple_Value.?(val)) {
			// recursively analyze tuple values
			for(e in (Tuple_Value.!(val)).values) analyzeValue(e);
		}
	}
	// analyze a record
	def analyzeRecord(record: Record) {
		if (records.get(record) == record) return;
		records.set(record, record);
		var raType = makeType(record.rtype);
		var newlyLive = (raType.raFacts & (RC_LIVE | RC_ALLOC)) == 0;
		raType.raFacts = raType.raFacts | RC_LIVE;
		if (RaClass.?(raType)) {
			// analyze a class object's fields and methods
			var rc = RaClass.!(raType);
			rc.instances = List.new(record, rc.instances);
			if (newlyLive) analyzeLiveClass(rc);
			// analyze class fields
			for (rf in rc.fields) analyzeField(record, rf);
		} else if (RaArray.?(raType)) {
			// analyze an array's elements
			var ra = RaArray.!(raType);
			ra.instances = List.new(record, ra.instances);
			if (ra.primitive) return;
			for (v in record.values) deferValue(v);
		}
	}
	// analyze a field of a record if the field is live
	def analyzeField(record: Record, rf: RaField) {
		if (rf != null && ((rf.raFacts & RF_READ) != 0)) {
			var v = record.values(rf.orig.index);
			rf.addValue(v);
			deferValue(v);
		}
	}
	// analyze a class that just became live
	def analyzeLiveClass(rc: RaClass) {
		for (c = rc; c != null; c = c.parent) {
			c.subtypes = List.new(rc, c.subtypes);
			for (ml in c.methods) {
				for (l = ml; l != null; l = l.tail) analyzeVirtual(rc, l.head);
			}
			if (0 != (c.raFacts & RC_EQUALITY)) rc.raFacts |= RC_EQUALITY;
		}
	}
	// analyze a possible virtual dispatch of the given method on the given type
	def analyzeVirtual(rc: RaClass, rm: RaMethod) {
		var rv = rm.virtual;
		if (rv == null) return;
		var spec = oldIr.resolveMethodImpl(rc.oldType, rm.getSpec());
		var impl = makeMethod(spec.typeArgs, IrMethod.!(spec.member), null);
		rv.addImpl(impl);
		getMethod(null, impl);
	}
	def gatherCaseClasses(vec: Vector<IrClass>, decl: VstClass) -> Vector<IrClass> {
		if (decl.cases == null) return vec;
		for (c in decl.cases) {
			vec.add(oldIr.getIrClass(c.decl.getDeclaredType()));
			gatherCaseClasses(vec, c.decl);
		}
		return vec;
	}
	def generateVariantEquals(t: Type) -> RaClass {
		var rc = makeClass(t);
		while (rc.parent != null) rc = rc.parent;  // get root declaration.
		if (rc.orig.methods(IrUtil.EQUALS_METHOD_INDEX) != null) return rc; // done.

		var decl = V3Class_TypeCon.!(rc.orig.ctype.typeCon).classDecl;
		var cases = gatherCaseClasses(Vector<IrClass>.new(), decl);
		var polyType = decl.getDeclaredType();

		var method = IrMethod.new(polyType, null, [polyType], Bool.TYPE);
		method.source = EQUALS_VST_METHOD;
		method.setFact(Facts.M_EQUALS | Facts.M_INLINE);
		rc.orig.methods(IrUtil.EQUALS_METHOD_INDEX) = method;
		method.index = IrUtil.EQUALS_METHOD_INDEX;

		// build overridden methods for each case that has fields
		for (i < cases.length) {
			var ic = cases.get(i);
			var pc = oldIr.getIrClass(V3.getSuperType(ic.ctype));
			var pm = pc.methods(IrUtil.EQUALS_METHOD_INDEX);
			if (ic.fields.length > 0) {
				pm.setFact(Facts.M_OVERRIDDEN);
				pm = IrMethod.new(ic.ctype, null, [polyType], Bool.TYPE);
				pm.source = EQUALS_VST_METHOD;
				pm.setFact(Facts.M_EQUALS);
				pm.index = IrUtil.EQUALS_METHOD_INDEX;
			}
			ic.methods(IrUtil.EQUALS_METHOD_INDEX) = pm;
		}
		return rc;
	}
	// analyze a method's code
	def analyzeMethod(rm: RaMethod) {
		var graph = rm.orig.ssa;
		if (graph == null) {
			if (rm.orig.checkFact(Facts.M_EQUALS)) {
				var container = oldIr.getIrClass(rm.orig.container);
				var root = oldIr.getIrClass(V3.getRootType(container.ctype));
				var context = SsaContext.new(compiler, prog);
				graph = VariantComparatorGen.new(context, root, container, rm.orig).generate();
			} else {
				graph = compiler.genSsa(prog, rm.getSpec(), 0);
			}
		}
		if (rm.spec != null) {
			// analyze a polymorphic method
			var polyOps = polyMap.get(rm.orig);
			if (polyOps == null) {
				analyzeValues(graph);
				polyOps = gatherPolyOps(graph);
				polyMap.set(rm.orig, polyOps);
			}
			analyzePolyMethod(rm, polyOps);
		} else {
			analyzeValues(graph);
			// analyze a monomorphic method
			for (b in graph.bfBlocks()) { // XXX: iterate over blocks directly
				for (i = b.next; i != b; i = i.next) {
					if (SsaApplyOp.?(i)) analyzeOp(SsaApplyOp.!(i), rm.spec);
				}
			}
		}
	}
	// analyze the values in a graph
	def analyzeValues(graph: SsaGraph) {
		if (graph.values != null) {
			for (v in graph.values) if (v != null) analyzeValue(v.val);
		}
	}
	// gather polymorphic operators
	def gatherPolyOps(graph: SsaGraph) -> List<SsaApplyOp> {
		var polyOps: List<SsaApplyOp>;
		for (b in graph.bfBlocks()) { // XXX: iterate over blocks directly
			for (i = b.next; i != b; i = i.next) {
				if (SsaApplyOp.?(i)) {
					var apply = SsaApplyOp.!(i);
					if (apply.op.isPolymorphic()) polyOps = List.new(apply, polyOps);
					else analyzeOp(apply, null);
				}
			}
		}
		if (polyOps == null) polyOps = List.new(null, null); // add at least one element
		return polyOps;
	}
	// analyze a polymorphic method
	def analyzePolyMethod(rm: RaMethod, polyOps: List<SsaApplyOp>) {
		for (l = polyOps; l != null; l = l.tail) {
			if (l.head != null) analyzeOp(l.head, rm.spec);
		}
	}
	// analyze an operator
	def analyzeOp(op: SsaApplyOp, context: IrSpec) {
		match (op.op.opcode) {
			OverloadedEq,
			RefEq,
			VariantEq: analyzeEqualOnType(mono(op.op.typeArgs(0), context), context);
			ArrayAlloc,
			ArrayInit: allocation(makeType(mono(op.op.typeArgs(0), context)));
			ClassAlloc: {
				var rm = opMethod(op, context);
				if (rm != null) getMethod(op, rm);
				allocation(makeType(mono(op.op.typeArgs(0), context)));
			}
			ClassGetVirtual,
			CallClassVirtual: getVirtual(opMethod(op, context));
			ClassGetMethod,
			ComponentGetMethod,
			CreateClosure,
			CallMethod: getMethod(op, opMethod(op, context));
			ClassGetField,
			ComponentGetField: {
				if (op.useList != null) { // only analyze getfields if not dead
					getField(makeField(op, context));
				}
			}
			ClassInitField: initField(op, makeField(op, context));
			ClassSetField,
			ComponentSetField: setField(op, makeField(op, context));
			_: ;
		}
		// TODO: system operators, pointer operators, etc
	}
	// analyze an equality comparison
	def analyzeEqualOnType(t: Type, context: IrSpec) {
		match (t.typeCon.kind) {
			V3Kind.CLASS: {
				getClassEquality(t);
			}
			V3Kind.VARIANT: {
				var rc = generateVariantEquals(t);
				getClassEquality(t);
				var rm = makeMethod([rc.oldType], rc.orig.methods(IrUtil.EQUALS_METHOD_INDEX), context);
				getVirtual(rm);
			}
		}
	}
	// analyze an access of a field
	def analyzeGetField(container: RaClass, rf: RaField) {
		for (t = container.subtypes; t != null; t = t.tail) { // for all live subtypes
			for (l = t.head.instances; l != null; l = l.tail) { // for all instances
				analyzeField(l.head, rf);
			}
		}
	}
	def allocation(raType: TypeNorm) {
		var oldFacts = raType.raFacts;
		raType.raFacts = raType.raFacts | RC_ALLOC;
		if (RaClass.?(raType) && (oldFacts & (RC_LIVE | RC_ALLOC)) == 0) {
			// process a newly-live class
			analyzeLiveClass(RaClass.!(raType));
		}
	}
	def getClassEquality(t: Type) {
		var rc = makeClass(t);
		if ((rc.raFacts & RC_EQUALITY) != 0) return; // already marked.
		rc.raFacts |= RC_EQUALITY;
		for (l = rc.subtypes; l != null; l = l.tail) l.head.raFacts |= RC_EQUALITY;
	}
	def getVirtual(rm: RaMethod) {
		if (rm.isVirtual()) return;
		rm.virtual = RaVirtual.new(rm);
		var rc = makeClass(rm.container);
		for (l = rc.subtypes; l != null; l = l.tail) {
			analyzeVirtual(l.head, rm);
		}
	}
	def getMethod(op: SsaApplyOp, rm: RaMethod) {
		if (rm.setFact(RM_LIVE)) return;
		liveMethods.add(rm);
		queue.add(analyzeMethod, rm);
	}
	def getField(rf: RaField) {
		if (rf.setFact(RF_READ)) return;
		queue.add(analyzeGetField, (makeClass(rf.container), rf));
	}
	def setField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts = rf.raFacts | RF_WRITTEN;
		var val = op.input1();
		rf.writeFacts = rf.writeFacts & val.facts & Facts.V_FACTS;
		if (SsaValue.?(val)) rf.addValue(SsaValue.!(val).val);
		else rf.setFact(RF_VAL_MANY);
	}
	def initField(op: SsaApplyOp, rf: RaField) {
		var val = op.input1();
		if (SsaValue.?(val)) rf.addValue(SsaValue.!(val).val);
		else rf.setFact(RF_VAL_MANY);
		if ((rf.raFacts & RF_INIT) == 0) {
			// first initialization seen of the field
			rf.raFacts = rf.raFacts | RF_INIT;
			rf.initFacts = val.facts & Facts.V_FACTS;
		} else {
			// not the first initialization seen
			rf.initFacts = rf.initFacts & val.facts & Facts.V_FACTS;
		}
	}
	def makeField(op: SsaApplyOp, context: IrSpec) -> RaField {
		var f = IrField.!(op.op.attr<IrMember>()), rf = f.raField;
		if (rf != null) return rf;
		var container = f.container, raType: RaClass;
		if (!container.open()) {
			// monomorphic container type
			raType = makeClass(container);
			if (isNormalType(f.fieldType)) {
				// the field is a simple, monomorphic, normalized field
				rf = raType.makeField(f, null, 1);
				return f.raField = rf;
			}
		} else {
			// polymorphic container type
			container = mono(op.op.typeArgs(0), context);
			raType = makeClass(container);
		}
		rf = raType.fields(f.index);
		if (rf == null) {
			// create the RaField from the normalized type
			var ft = f.fieldType;
			if (ft.open()) ft = f.fieldType.substitute(V3.getTypeArgs(container));
			var fieldType = makeType(ft);
			rf = raType.makeField(f, fieldType, fieldType.size);
		}
		return rf;
	}
	def opMethod(op: SsaApplyOp, context: IrSpec) -> RaMethod {
		var m = IrMethod.!(op.op.attr<IrMember>());
		if (m == null) return null;
		return makeMethod(op.op.typeArgs, m, context);
	}
	def makeMethod(typeArgs: Array<Type>, m: IrMethod, context: IrSpec) -> RaMethod {
		var rm = m.raMethod;
		if (rm != null) return rm; // method already seen
		if (!m.container.open() && typeArgs.length == 1) {
			// monomorphic, potentially reusable method
			return makeMonoMethod(m);
		}
		if (context != null) typeArgs = context.instantiateTypes(typeArgs);
		var rc = makeClass(typeArgs(0));
		rm = rc.findMethod(m.index, typeArgs);
		if (rm == null) {
			var spec = IrSpec.new(rc.oldType, typeArgs, m);
			rm = rc.makeMethod(m, spec);
			specializeMethod(rc, rm); // XXX: implies full specialization
		}
		return rm;
	}
	private def makeMonoMethod(m: IrMethod) -> RaMethod {
		// check for non-normal parameter or return types
		var rc = makeClass(m.container);
		for (t in m.paramTypes) {
			if (!isNormalType(t)) return makeNormMethod(rc, m);
		}
		if (m.returnType != Void.TYPE && !isNormalType(m.returnType)) return makeNormMethod(rc, m);
		// all are normal; XXX: reuse the same IrMethod
		var rm = rc.makeMethod(m, null);
		rm.norm = IrMethod.new(m.container, null, m.paramTypes, m.returnType);
		transferFacts(rm);
		rm.raFacts = RF_NORMALIZED;
		return m.raMethod = rm;
	}
	private def makeNormMethod(rc: RaClass, m: IrMethod) -> RaMethod {
		var rm = rc.makeMethod(m, null);
		specializeMethod(rc, rm);
		return m.raMethod = rm;
	}
	def specializeMethod(rc: RaClass, rm: RaMethod) {
		var m = rm.orig, vec = Vector<Type>.new().grow(m.paramTypes.length);
		// normalize the parameter types of method
		for (p in m.paramTypes) {
			var rt = makeType(mono(p, rm.spec));
			if (rt.sub != null) vec.addN(rt.sub);
			else vec.add(rt.newType);
		}
		// create a new IrMethod that will hold the normalized code
		var typeParams = if(rm.spec != null, rm.spec.getTypes().methodTypeArgs);
		rm.norm = IrMethod.new(rc.oldType, typeParams, vec.extract(), norm(mono(m.returnType, rm.spec)));
		transferFacts(rm);
	}
	def transferFacts(rm: RaMethod) {
		rm.norm.facts = rm.orig.facts & (Facts.M_ABSTRACT | Facts.M_INLINE | Facts.M_OPERATOR | Facts.M_NEW | Facts.M_EMPTY | Facts.M_EQUALS);
		rm.norm.source = rm.orig.source;
	}
	def makeClass(t: Type) -> RaClass {
		return RaClass.!(makeType(t));
	}
	def makeType(t: Type) -> TypeNorm {
		if (t.open()) return V3.fail1("is open %1", t.render);
		// first check for primitive types
		match (t.typeCon.kind) {
			V3Kind.VOID: return RA_VOID;
			V3Kind.BOOL: return RA_BOOL;
		}
		// now check the hashmap
		var raType = typeMap.get(t);
		if (raType != null) return raType;
		// not in the hashmap, build appropriately
		match (t.typeCon.kind) {
			V3Kind.COMPONENT: {
				var compDecl = V3.asComponent(t).componentDecl;
				deferValue(prog.getComponentRecord(compDecl));
				raType = newRaClass(t, Void.TYPE, oldIr.makeIrClass(t), null);
			}
			V3Kind.ARRAY: {
				// normalize element type
				var enorm = makeType(V3Array.elementType(t));
				if (enorm.size == 0) {
					raType = RaArray.new(t, V3.voidArrayType, null);
				} else if (enorm.sub == null) {
					raType = RaArray.new(t, V3Array.newType(enorm.newType), null);
				} else {
					var et = Arrays.map(enorm.sub, V3Array.newType);
					raType = RaArray.new(t, Tuple.newType(Lists.fromArray(et)), et);
				}
				heapTypes.add(raType);
			}
			V3Kind.VARIANT: {
				var ic = oldIr.makeIrClass(t);
				var superType = V3.getSuperType(t), parent: RaClass;
				if (superType != null) {
					parent = makeClass(superType);
				} else {
					// make the default variant record for field analysis
					deferValue(V3.makeDefaultVariantRecord(prog, t));
				}
				var rc = newRaClass(t, t, ic, parent);
				rc.raFacts = rc.raFacts | RC_VARIANT;
				raType = rc;
			}
			V3Kind.CLASS: {
				var superType = V3.getSuperType(t);
				var parent = if(superType != null, makeClass(superType));
				var ic = oldIr.makeIrClass(t);
				if (ic == null) ic = IrClass.new(t, null, null, [], []);
				raType = newRaClass(t, t, ic, parent);
			}
			V3Kind.DELEGATE: {
				// normalize parameter and return types independently
				var pt = norm(Function.getParamType(t));
				var rt = norm(Function.getReturnType(t));
				// translate closure into (funcref, object) pair
				var ft = Function.FUNCREF.create(Lists.cons2(pt, rt));
				var ta = [ft, AnyObject.TYPE];
				raType = TypeNorm.new(t, Tuple.newType(Lists.fromArray(ta)), ta);
			}
			V3Kind.TUPLE: {
				// flatten tuples
				var vecT = Vector<Type>.new();
				var vecO = Vector<int>.new();
				var vecN = Vector<TypeNorm>.new();
				for (p = t.nested; p != null; p = p.tail) {
					var n = makeType(p.head);
					vecO.add(vecT.length);
					vecN.add(n);
					n.addTo(vecT);
				}
				var ta = vecT.extract();
				raType = RaTuple.new(t, Tuple.newType(Lists.fromArray(ta)), ta, vecN.extract(), vecO.extract());
			}
			V3Kind.SET: {
				// normalize a set of types
				var n = Lists.map(t.nested, makeType), size = n.head.size;
				for (l = n; l != null; l = l.tail) {
					if (l.head.size != size) { size = 1; break; }
				}
				if (size < 2) {
					// normalize the set as a set
					var newType = setTypeCon.create(Lists.map<TypeNorm, Type>(n, TypeNorm.newType));
					raType = TypeNorm.new(t, newType, if(size == 0, [], null));
				} else {
					// normalize a set of same-sized tuples
					var lists = Array<List<Type>>.new(size);
					for (l = n; l != null; l = l.tail) {
						for (i < size) {
							lists(i) = List.new(l.head.sub(i), lists(i));
						}
					}
					var ta = Arrays.map(lists, setTypeCon.create);
					raType = RaTuple.new(t, Tuple.newType(Lists.fromArray(ta)), ta, null, null);
				}
			}
			_: {
				raType = TypeNorm.new(t, t, null);
			}
		}
		typeMap.set(t, raType);
		return raType;
	}
	def newRaClass(oldType: Type, newType: Type, ic: IrClass, parent: RaClass) -> RaClass {
		var sub = if(newType == Void.TYPE, TypeUtil.NO_TYPES);
		var rc = RaClass.new(oldType, newType, sub, ic, parent);
		heapTypes.add(rc);
		return rc;
	}
	def norm(t: Type) -> Type {
		if (isNormalType(t)) return t;
		return makeType(t).newType;
	}
	def mono(t: Type, spec: IrSpec) -> Type {
		return if(spec != null, spec.instantiateType(t), t);
	}
	def uniquify<T>(v: T) -> int {
		return ++uniqueCounter;
	}
}
// represents a root method, i.e. an entrypoint. Updated to point to normalized code after RMA.
class RaRoot {
	var spec: IrSpec;
	new(spec) { }
}
// Base class which contains facts for all types of entities during analysis
class RaItem {
	var raFacts: int;
	// sets the given fact bit; returns true if the fact was already set
	def setFact(fact: int) -> bool {
		if ((raFacts & fact) == 0) {
			raFacts = raFacts | fact;
			return false;
		}
		return true;
	}
}

// Representation of a normalized integer type.
class RaIntType extends TypeNorm {
	def bigEndian: bool;
	new(oldType: Type, newType: Type, sub: Array<Type>, bigEndian)
		super(oldType, newType, sub) { }
	def bigEndIndex() -> int {
		return if(bigEndian, 0, size - 1);
	}
	def littleEndIndex() -> int {
		return if(bigEndian, size - 1, 0);
	}
	// Select {n} items from {input} corresponding to the low-order words.
	def getLowestN<T>(inputs: Array<T>, n: int) -> Array<T> {
		if (bigEndian) return Arrays.range(inputs, inputs.length - n, inputs.length); // [big,vN,...,v0]
		else return Arrays.range(inputs, 0, n);  // [v0,...,vN,big]
	}
	// Create a new array of {n} items, copying the low order words from {inputs} and
	// extending the upper words with {extend}.
	def growToN<T>(inputs: Array<T>, n: int, extend: T) -> Array<T> {
		var result = Array<T>.new(n);
		if (bigEndian) {
			var d = n - 1;
			for (i = inputs.length - 1; i >= 0; i--) result(d--) = inputs(i);
			while (d >= 0) result(d--) = extend;
		} else {
			var d = 0;
			for (i = 0; i < size; i++) result(d++) = inputs(i);
			while (d < result.length) result(d++) = extend;
		}
		return result;
	}
	// Simulate a shift left by {n} words, filling in the vacant entries with {extend}.
	def shiftLeft<T>(inputs: Array<T>, n: int, extend: T) {
		shift(true, inputs, n, extend);
	}
	// Simulate a shift right by {n} words, filling in the vacant entries with {extend}.
	def shiftRight<T>(inputs: Array<T>, n: int, extend: T) {
		shift(false, inputs, n, extend);
	}
	def shift<T>(left: bool, inputs: Array<T>, n: int, extend: T) {
		if ((left && bigEndian) || (!left && !bigEndian)) {
			var i = 0;
			while (i < size - n) { inputs(i) = inputs(i + n); i++; }
			while (i < size) { inputs(i) = extend; i++; }
		} else {
			var i = size - 1;
			while (i >= n) { inputs(i) = inputs(i - n); i--; }
			while (i >= 0) { inputs(i) = extend; i--; }
		}
	}
}
// Representation of a tuple
class RaTuple extends TypeNorm {
	def nested: Array<TypeNorm>;
	def offsets: Array<int>;
	new(oldType: Type, newType: Type, sub: Array<Type>, nested, offsets)
		super(oldType, newType, sub) { }
	def getElem<T>(array: Array<T>, index: int) -> Array<T> {
		var ntn = nested(index), offset = offsets(index);
		if (ntn == null) return [array(offset)];
		if (ntn.size == 1) return [array(offset)];
		return Arrays.range(array, offset, offset + ntn.size);
	}
}
// Representation of a class type during RMA and normalization, which adds
// representations of the fields and methods of the class
class RaClass extends TypeNorm {
	def orig: IrClass;			// original, polymorphic IrClass
	def parent: RaClass;			// super class, if any
	def fields = Array<RaField>.new(orig.fields.length);          // index of fields
	var methods = Array<List<RaMethod>>.new(orig.methods.length); // index of methods
	var instances: List<Record>;		// list of live records
	var children: List<RaClass>;		// list of all child classes
	var subtypes: List<RaClass>;		// list of live subtypes
	var normClass: IrClass;			// normalized class
	var normFields: Array<IrField>;		// normalized fields
	var normMethods: Array<IrMethod>;	// normalized methods
	var minClassId = -1;			// minimum class ID
	var maxClassId = -1;			// maximum class ID

	new(oldType: Type, newType: Type, sub: Array<Type>, orig, parent) super(oldType, newType, sub) {
		if (parent != null) {
			parent.children = List.new(this, parent.children);
			Arrays.copyInto(parent.fields, fields, 0);
		}
	}
	def makeField(f: IrField, fieldType: TypeNorm, size: int) -> RaField {
		return addField(RaField.new(oldType, f, fieldType, size));
	}
	private def addField(rf: RaField) -> RaField {
		fields(rf.orig.index) = rf;
		for (l = children; l != null; l = l.tail) l.head.addField(rf);
		return rf;
	}
	def fieldStart() -> int {
		return if(parent != null, parent.fields.length);
	}
	def makeMethod(m: IrMethod, spec: IrSpec) -> RaMethod {
		if (m.index >= methods.length) methods = Arrays.grow(methods, methods.length + m.index + 1);
		var rm = RaMethod.new(oldType, m, spec);
		methods(m.index) = List.new(rm, methods(m.index));
		return rm;
	}
	def findMethod(index: int, typeArgs: Array<Type>) -> RaMethod {
		if (index >= methods.length) return null;
		for (l = methods(index); l != null; l = l.tail) {
			if (compareTypeArgs(l.head, typeArgs)) return l.head;
		}
		return null;
	}
	def findRaMethod(rm: RaMethod) -> RaMethod {
		return findMethod(rm.orig.index, if(rm.spec == null, MONO_TYPEARGS, rm.spec.typeArgs));
	}
	def compareTypeArgs(rm: RaMethod, typeArgs: Array<Type>) -> bool {
		if (rm.spec == null) return typeArgs.length == 1;
		var mtypeArgs = rm.spec.typeArgs;
		for (i = 1; i < typeArgs.length; i++) {
			if (mtypeArgs(i) != typeArgs(i)) return false;
		}
		return true;
	}
}
// Information about an array, including its live instances
class RaArray extends TypeNorm {
	var primitive: bool;
	var instances: List<Record>;
	new(oldType: Type, newType: Type, sub: Array<Type>) super(oldType, newType, sub) {
		primitive = V3.isPrimitiveArray(oldType);
	}
}
// Information about a field, including whether it is initialized, written, read,
// and facts about each of the values written to the field
class RaField(container: Type, orig: IrField, fieldType: TypeNorm, size: int) extends RaItem {
	var val: Val;
	var initFacts = Facts.V_DEFAULT;
	var writeFacts = Facts.V_FACTS;
	var norm: Array<IrSpec>;
	var normIndex = -1;
	def facts() -> int {
		return initFacts & writeFacts;
	}
	def addValue(v: Val) {
		// add a value to the set for this field
		var facts = (raFacts & RF_VALS);
		if (facts == RF_VAL_ONE) {
			if (!Values.equal(val, v)) raFacts = raFacts | RF_VAL_MANY;
		} else if (facts == 0) {
			raFacts = raFacts | RF_VAL_ONE;
			val = v;
		}
		// also set the facts that are true for all values and writes
		facts = 0;
		if (v == null) facts = Facts.V_ZERO;
		else if (Box<int>.?(v)) facts = Facts.intFacts(Int.unbox(v));
		else if (Box<bool>.?(v)) facts = if(Bool.unbox(v), Facts.V_NON_ZERO, Facts.V_ZERO);
		else facts = Facts.V_NON_ZERO;
		writeFacts = writeFacts & facts;
	}
	def isValue() -> bool {
		var f = raFacts, vf = (f & RF_VALS);
		if (vf == RF_VAL_ONE) {
			if ((f & RF_INIT) != 0) return true; // initialized and a value
			if ((f & RF_WRITTEN) == 0) return true; // a value and never written
			if (Values.equal(val, null)) return true; // always written null
		} else if (vf == 0 && (f & (RF_WRITTEN | RF_INIT)) == 0) {
			return true; // neither written nor initialized, nor any values
		}
		return false;
	}
}
// Information about a method, including any specialization, whether it is reusable
// across normalization, etc.
class RaMethod(container: Type, orig: IrMethod, spec: IrSpec) extends RaItem {
	var norm: IrMethod;
	var normIndex = -1;
	var virtual: RaVirtual;
	private var cachedSpec: IrSpec;
	def getSpec() -> IrSpec {
		if (cachedSpec != null) return cachedSpec;
		if (spec != null) return cachedSpec = spec;
		return cachedSpec = IrSpec.new(container, [container], orig);
	}
	def isLive() -> bool {
		return (raFacts & RM_LIVE) != 0;
	}
	def isVirtual() -> bool {
		return virtual != null;
	}
}
// Extra information about a virtual method.
class RaVirtual(raMethod: RaMethod) {
	var mtable: IrMtable;		// mtable used for machine-level virtual calls
	var devirtual: RaMethod;	// RA-devirtualized target, if any
	var impls: List<RaMethod>;	// list of all implementations
	var count = 0;
	def addImpl(rm: RaMethod) {
		if (count == 0) { devirtual = rm; count = 1; }
		if (count == 1 && devirtual != rm) { devirtual = null; count = 2; }
		for (l = impls; l != null; l = l.tail) {
			if (l.head == rm) return; // XXX: linear search for RaMethod
		}
		impls = List.new(rm, impls);
	}
}
// Normalizes a program based on the results of reachability analysis.
class ReachabilityNormalizer(ra: ReachabilityAnalyzer) {
	def liveClasses = Vector<RaClass>.new();
	def allClasses = Vector<RaClass>.new();
	def context = SsaContext.new(ra.compiler, ra.prog);
	var recordMap = V3.newRecordMap<Record>(); // XXX: canonicalize equivalent variant records
	var complexRecordMap = V3.newRecordMap<Array<Record>>();
	var newIr = IrPortion.new();
	var specializer: Specializer;
	var virtuals: List<RaVirtual>;

	def normalize() {
		// layout fields into classes
		if (Aeneas.PRINT_DEAD_CODE.get()) DeadCodeAnalyzer.new(ra).report();
		ra.heapTypes.apply(visitHeapType);
		if (ra.compiler.PartialSpecialization) {
			// if partial specialization is enabled, do specialization analysis
			(specializer = Specializer.new(ra, this)).specialize();
		}
		allClasses.apply(layoutVtable);
		Lists.apply(virtuals, layoutMtable);
		allClasses.apply(createIrClass);
		ra.prog.ir = newIr;
		// do remaining work; normalize record instances
		ra.queue.drain();
		// update roots
		for (l = ra.roots; l != null; l = l.tail) {
			l.head.spec = normalizeMethodRef(l.head.spec);
		}
		ra.liveMethods.apply(normCode);
	}
	// visit a live type, deferring normalization of records
	def visitHeapType(raType: TypeNorm) {
		if (RaArray.?(raType)) return visitArrayType(RaArray.!(raType));
		if (RaClass.?(raType)) return visitClassType(RaClass.!(raType));
	}
	def visitClassType(rc: RaClass) {
		layoutClass(rc);
		if (V3.isComponent(rc.oldType)) {
			var comp = V3.asComponent(rc.oldType).componentDecl, newRecord: Record;
			if (rc.instances != null) {
				// normalize component record
				var oldRecord = rc.instances.head;
				newRecord = ra.prog.newRecord(rc.newType, rc.normFields.length);
				complexRecordMap.set(oldRecord, NO_RECORDS);
				ra.queue.add(normClassRecord, (rc, oldRecord, newRecord));
			}
			ra.prog.setComponentRecord(comp, newRecord);
		} else {
			// create and map new records to be normalized
			for (l = rc.instances; l != null; l = l.tail) {
				var oldRecord = l.head, newRecord = ra.prog.newRecord(rc.newType, rc.normFields.length);
				recordMap.set(l.head, newRecord);
				ra.queue.add(normClassRecord, (rc, oldRecord, newRecord));
			}
		}
	}
	def visitArrayType(rt: RaArray) {
		if (rt.oldType != rt.newType) {
			// map complex arrays to arrays of records
			var ta = Tuple.toTypeArray(rt.newType);
			for (l = rt.instances; l != null; l = l.tail) {
				var newRecords = createComplexArrayRecord(l.head, ta, rt);
				ra.queue.add(normComplexArrayRecord, (rt, l.head, newRecords));
			}
		} else if (!rt.primitive) {
			// normalize simple arrays that are not primitive
			for (l = rt.instances; l != null; l = l.tail) {
				ra.queue.add(normSimpleArrayRecord, l.head);
			}
		}
	}
	// lay out a classes' fields and number it according to liveness
	def layoutClass(rc: RaClass) {
		if (rc.minClassId >= 0) return; // already processed this type
		while (rc.parent != null) rc = rc.parent; // start at root
		numberClass(rc);
	}
	// number a class and lay out its fields, recursively visiting children
	def numberClass(rc: RaClass) {
		allClasses.add(rc);
		rc.minClassId = liveClasses.length;
		if (V3.isVariant(rc.oldType)) return numberVariantClass(rc);
		if ((rc.raFacts & (RC_LIVE | RC_ALLOC)) != 0 && !V3.isComponent(rc.oldType)) {
			liveClasses.add(rc);
		}
		layoutFields(rc);
		for (l = rc.children; l != null; l = l.tail) numberClass(l.head);
		rc.maxClassId = liveClasses.length;
	}
	def numberVariantClass(rc: RaClass) {
		layoutFields(rc);
		// number variant classes consistently with their tagging order.
		var isEnum = true;
		for (l = rc.children; l != null; l = l.tail) {
			var c = l.head;
			allClasses.add(c);
			layoutFields(c);
			var index = rc.minClassId + V3.getVariantTag(c.oldType);
			c.minClassId = index;
			c.maxClassId = index + 1;
			liveClasses.grow(index + 1);
			if (liveClasses.length < c.maxClassId) liveClasses.length = index + 1;
			liveClasses.set(index, c);
			if (c.normFields.length > 0) isEnum = false;
		}
		rc.maxClassId = liveClasses.length;
		if (isEnum) {
			// this and all children classes will be represented as enums
			rc.raFacts |= RC_ENUM;
			for (l = rc.children; l != null; l = l.tail) l.head.raFacts |= RC_ENUM;
		}
	}
	// map a complex array to an array of records
	def createComplexArrayRecord(r: Record, types: Array<Type>, rt: RaArray) -> Array<Record> {
		var complex = Array<Record>.new(rt.size);
		for (i < complex.length) {
			complex(i) = ra.prog.newRecord(types(i), r.values.length);
		}
		complexRecordMap.set(r, complex);
		return complex;
	}
	// layout fields for classes and components
	def layoutFields(rc: RaClass) {
		var b = Vector<IrField>.new();
		// add all fields
		for (rf in rc.fields) {
			if (rf == null) continue;
			if (rf.norm != null) {
				// inherited this field from superclass
				for (f in rf.norm) b.add(IrField.!(f.member));
			} else if (requiresStorage(rf)) {
				// this field requires storage to be allocated
				rf.normIndex = b.length;
				if (rf.fieldType == null) addMonoField(rc, rf, b);
				else addPolyField(rc, rf, b);
			}
		}
		if (ra.compiler.target != null) {
			var start = if(rc.parent != null, rc.parent.normFields.length);
			ra.compiler.target.computeFieldOffsets(ra.prog, b, start);
		}
		rc.normFields = b.extract();
	}
	// check if a field can be optimized away
	def requiresStorage(rf: RaField) -> bool {
		if (rf.isValue()) return false; // field is a value
		if ((rf.raFacts & RF_READ) == 0) return false; // field is never read
		return true;
	}
	// add a monomorphic field to the builder
	def addMonoField(rc: RaClass, rf: RaField, b: Vector<IrField>) {
		b.add(rf.orig);
		rf.norm = [IrSpec.new(rc.oldType, [rc.oldType], rf.orig)];
	}
	// add a polymorphic field to the builder
	def addPolyField(rc: RaClass, rf: RaField, b: Vector<IrField>) {
		var norms = Array<IrSpec>.new(rf.fieldType.size);
		for (i < norms.length) {
			var ft = if(rf.fieldType.sub == null, rf.fieldType.newType, rf.fieldType.sub(i));
			var facts = if(rf.fieldType.size > 1, Facts.F_NORM);
			var nf = setSourceAndFacts(rf, IrField.new(rc.oldType, ft), facts);
			norms(i) = IrSpec.new(rc.oldType, [rc.oldType], nf);
			b.add(nf);
		}
		rf.norm = norms;
	}
	// set the source and the facts for a newly allocated IrField
	def setSourceAndFacts(rf: RaField, nf: IrField, facts: int) -> IrField {
		if ((rf.raFacts & RF_WRITTEN) == 0) nf.setFact(Facts.F_VALUE | Facts.O_FOLDABLE);
		nf.setFact(facts);
		nf.source = rf.orig.source;
		return nf;
	}
	// normalize a live instance of a class
	def normClassRecord(rc: RaClass, oldRecord: Record, newRecord: Record) {
		var rfs = rc.fields;
		for (i < rfs.length) {
			var rf = rfs(i);
			if (rf != null && rf.normIndex >= 0) {
				var v = oldRecord.values(i);
				if (rf.fieldType == null) newRecord.values(rf.normIndex) = normSimpleVal(v);
				else normValIntoArray(v, rf.fieldType, newRecord.values, rf.normIndex);
			}
		}
	}
	// normalize the live instances of a simple (i.e. size-1 element) array type
	def normSimpleArrayRecord(record: Record) {
		var old = record.values;
		for (i < old.length) {
			record.values(i) = normSimpleVal(old(i));
		}
	}
	// normalize the live instances of a complex (i.e. size-N element) array type
	def normComplexArrayRecord(rt: RaArray, oldRecord: Record, newRecords: Array<Record>) {
		var etn = ra.makeType(V3Array.elementType(rt.oldType));
		var old = oldRecord.values;
		var temp = Array<Val>.new(newRecords.length);
		for (i < old.length) {
			for (j < temp.length) temp(j) = null; // XXX: must clear temp array first
			normValIntoArray(old(i), etn, temp, 0);
			for (j < newRecords.length) {
				newRecords(j).values(i) = temp(j);
			}
		}
	}
	// normalize a record value into 1 or more records into the given array
	def normRecordIntoArray(r: Record, array: Array<Val>, index: int) {
		var simple = recordMap.get(r);
		if (simple != null) { // simple mapping
			array(index) = simple;
			return;
		}
		var complex = complexRecordMap.get(r);
		if (complex != null) { // complex mapping
			for (i < complex.length) {
				array(index + i) = complex(i);
			}
			return;
		}
		array(index) = r;
	}
	// map a record 1-1
	def normSimpleVal(v: Val) -> Val {
		if (Record.?(v)) {
			// assume that a record without an entry is mapped to itself
			var r = recordMap.get(Record.!(v));
			return if(r == null, v, r);
		}
		return v; // assume all other values can be reused
	}
	def layoutVtable(rc: RaClass) {
		var vtable = Vector<IrMethod>.new();
		if (rc.parent != null) vtable.addN(rc.parent.normMethods); // add superclass methods
		else vtable.add(null); // reserve a space for constructor
		// process all methods
		for (ml in rc.methods) {
			for (l = ml; l != null; l = l.tail) addMethod(vtable, rc, l.head);
		}
		rc.normMethods = vtable.extract();
	}
	def addMethod(vtable: Vector<IrMethod>, rc: RaClass, rm: RaMethod) {
		var m = rm.orig;
		if ((rm.raFacts & RM_LIVE) == 0) {
			// mark methods that are abstract
			rm.norm.ssa = null;
			rm.norm.setFact(Facts.M_ABSTRACT);
			if (!rm.isVirtual()) return; // not live, not virtual
		}
		if (m.checkFact(Facts.M_NEW)) {
			// constructors always end up at slot 0
			rm.norm.setFact(Facts.M_NEW);
			vtable.set(0, rm.norm);
			rm.norm.index = 0;
			return;
		}
		var sm = resolveMethodImpl(rc.parent, rm);
		if (sm == null) { // add a new method to the vtable
			rm.norm.index = rm.normIndex = vtable.length;
			vtable.add(rm.norm);
		} else if (sm != rm) { // overwrite existing vtable entry
			vtable.set(sm.normIndex, rm.norm);
			rm.norm.index = rm.normIndex = sm.normIndex;
			rm.norm.setFact(Facts.M_OVERRIDE);
			sm.norm.setFact(Facts.M_OVERRIDDEN);
		}
		if (rm.virtual != null) virtuals = List.new(rm.virtual, virtuals);
	}
	def layoutMtable(rv: RaVirtual) {
		if (rv.mtable != null) return;
		var rm = rv.raMethod, rc = ra.makeClass(rm.container);
		var size = rc.maxClassId - rc.minClassId;
		if (ra.compiler.RaDevirtualize && size < 2) return; // no need for an mtable
		var table = Array<IrMethod>.new(size);
		rv.mtable = IrMtable.new(rm.norm, rc.minClassId, table);
		for (l = rc.subtypes; l != null; l = l.tail) { // fill out mtable
			var impl = resolveMethodImpl(l.head, rm);
			if (rv.mtable.table.length > 0) {
				rv.mtable.table(l.head.minClassId - rv.mtable.rootId) = impl.norm;
			}
		}
		setMtable(rc, rv); // set mtable for all child virtual methods
	}
	def setMtable(rc: RaClass, rv: RaVirtual) {
		var rm = rc.findRaMethod(rv.raMethod);
		if (rm != null && rm.virtual != null) rm.virtual.mtable = rv.mtable;
		for (l = rc.children; l != null; l = l.tail) {
			setMtable(l.head, rv);
		}
	}
	def resolveMethodImpl(rc: RaClass, rm: RaMethod) -> RaMethod {
		var m = rm.orig, sm: RaMethod;
		for (sc = rc; sc != null; sc = sc.parent) {
			// find super method, if any
			if (m.index >= sc.methods.length) break;
			sm = sc.findRaMethod(rm);
			if (sm != null) break;
		}
		return sm;
	}
	def normValIntoArray(v: Val, tn: TypeNorm, array: Array<Val>, index: int) {
		if (v == null) return;
		if (Record.?(v)) {
			normRecordIntoArray(Record.!(v), array, index);
		} else if (Closure.?(v)) {
			// closure: normalize record and method
			var del = Closure.!(v);
			// normalize closure value as (funcval, object) pair
			array(index) = FuncVal.new(normalizeMethodRef(del.memberRef));
			if (del.val != null) {
				var r = Record.!(del.val); // XXX: assumes closure value is a record
				if (!V3.isComponent(r.rtype)) array(index + 1) = normSimpleVal(r);
			}
		} else if (Tuple_Value.?(v)) {
			// tuple: recursively normalize all of the sub
			var tv = Tuple_Value.!(v);
			var tnn = RaTuple.!(tn).nested;
			for (i < tnn.length) {
				normValIntoArray(tv.values(i), tnn(i), array, index);
				index = index + tnn(i).size;
			}
		} else {
			if (index < array.length) array(index) = v;
		}
	}
	def normalizeMethodRef(spec: IrSpec) -> IrSpec {
		var rm = spec.asMethod().raMethod;
		var ta = spec.typeArgs;
		if (rm == null) {
			var rc = ra.makeClass(spec.container);
			rm = rc.findMethod(spec.member.index, ta);
			if (rm == null) return V3.fail1("ReachabilityError: method %1 not found", spec.render);
		}
		return IrSpec.new(ta(0), ta, rm.norm);
	}
	def createIrClass(rc: RaClass) {
		var sc = if(rc.parent != null, rc.parent.normClass);
		var ic = IrClass.new(rc.oldType, null, sc, rc.normFields, rc.normMethods);
		ic.minClassId = rc.minClassId;
		ic.maxClassId = rc.maxClassId;
		rc.normClass = ic;
		if ((rc.raFacts & RC_LIVE) != 0) ic.setFact(Facts.C_HEAP);
		if ((rc.raFacts & RC_ALLOC) != 0) ic.setFact(Facts.C_ALLOCATED);
		if ((rc.raFacts & RC_ENUM) != 0) ic.setFact(Facts.C_ENUM);
		newIr.setIrClass(rc.oldType, ic);
		var i = 0;
		for (f in ic.fields) {
			if (f != null) f.index = i;
			i++;
		}
	}
	def normCode(rm: RaMethod) {
		context.spec = rm.spec;
		context.enterMethod(rm.orig);
		if (specializer != null && rm.spec != null) {
			// use specializer to generate appropriate code for method
			return specializer.normCode(context, rm);
		}
		return normSpecCode(context, rm);
	}
	def normSpecCode(context: SsaContext, rm: RaMethod) {
		SsaRaNormalizer.new(context, this).build(rm.norm);
		newIr.methods.add(rm.norm);
	}
}
// A target which prints out the results of reachability analysis
def raTarget = Aeneas.registerTarget(RaTarget.new());
class RaTarget extends Target("ra") {
	def configure(compiler: Compiler, prog: Program) {
		SystemModule.install(prog);
		compiler.Reachability = true;
	}
	def emit(compiler: Compiler, prog: Program) {
		IrPrinter.new(prog).print();
	}
}
// Normalizes SSA code by performing polymorphic specialization and expanding all
// tuples. Note that SSA form supports returns with multiple values.
class SsaRaNormalizer extends SsaRebuilder {
	def norm: ReachabilityNormalizer;
	var voidArray: Array<SsaInstr>;
	var specSet: SpecSet;

	new(context: SsaContext, norm) super(context) {}
	def build(newMethod: IrMethod) {
		newMethod.ssa = genGraph();
		context.method = newMethod;
		context.printSsa("Normalized");
	}
	def genSimpleVal(v: Val) -> Val {
		return norm.normSimpleVal(v);
	}
	def genValN(e: SsaDfEdge, index: int, oi: SsaValue, tn: TypeNorm, vec: Vector<SsaInstr>) {
		vec.addN(mapValueN(oi, oi.val, tn));
	}
	def mapValue(oi: SsaInstr, v: Val, tn: TypeNorm) -> SsaValue {
		var val: SsaValue;
		if (tn.sub == null) {
			// simple normalization
			if (tn.size == 0) map0(oi); // void
			else map1(oi, val = newGraph.valConst(tn.newType, norm.normSimpleVal(v)));
		} else {
			// complex normalization
			mapValueN(oi, v, tn);
		}
		return val;
	}
	def mapValueN(oi: SsaInstr, v: Val, tn: TypeNorm) -> Array<SsaInstr> {
		// complex normalization
		var nv = Array<Val>.new(tn.size);
		norm.normValIntoArray(v, tn, nv, 0);
		var vals = Array<SsaInstr>.new(nv.length);
		for (j < vals.length) vals(j) = newGraph.valConst(tn.sub(j), nv(j));
		mapN(oi, vals);
		return vals;
	}
	def genApplyOp(app: SsaApplyOp) {
		if (app.useList == null && app.checkFact(Facts.O_PURE)) return; // remove dead code
		curBlock.at(app.source);
		var orig = app.op, op = app.op, args = app.inputs;
		if (context.spec != null) op = app.op.subst(context.spec.instantiateType);
		match (op.opcode) {
			OverloadedEq:		normEqualOp(app, op);
			BoolEq,
			IntEq,
			RefEq:			normSimpleEqualOp(app, op);
			VariantEq:		normVariantEqualOp(app, op);
			IntConvert:		normIntConvert(app, op);
			TypeCast:		normTypeCast(app, op);
			TypeQuery:		normTypeQuery(app, op);
			TypeSubsume:		normTypeSubsume(app, op);
			ArrayAlloc:		normArrayAlloc(app, op);
			ArrayInit:		normArrayInit(app, op);
			ArrayGetElem:		normArrayGetElem(app, op);
			ArraySetElem:		normArraySetElem(app, op);
			ArrayGetLength:		normArrayGetLength(app, op);
			ClassAlloc:		normClassAlloc(app, op);
			ClassGetField:		normClassGetField(app, op);
			ClassInitField:		normClassSetField(app, op, true);
			ClassSetField:		normClassSetField(app, op, false);
			ClassGetMethod:{
				var obj = genRef1(args(0));
				addNullCheck(app, obj);
				mapN(app, [funcRef(extractMethodRef(orig)), obj]);
			}
			ClassGetVirtual: {
				var t = extractVirtualRef(orig), obj = genRef1(args(0));
				if (t.1) { // still a virtual dispatch
					mapN(app, [curBlock.opClassGetVirtFunc(t.0, obj), obj]);
				} else {
					addNullCheck(app, obj);
					mapN(app, [funcRef(t.0), obj]);
				}
			}
			Init:			map0(app);
			ComponentGetField:	normComponentGetField(app, op);
			ComponentSetField:	normComponentSetField(app, op);
			ComponentGetMethod:	{
				// map ComponentGetMethod to (funcref, null)
				return mapN(app, [funcRef(extractMethodRef(orig)), newGraph.nullConst(AnyObject.TYPE)]);
			}
			TupleCreate: {
				mapN(app, genRefs(args));
			}
			TupleGetElem: {
				normTupleGetElem(app, args, op);
			}
			NullCheck:		normNullCheck(app, op);
			BoundsCheck:		normBoundsCheck(app, op);
			// XXX: use SsaBuilder.opCallXXX() methods
			CallMethod:		normGeneralOp(app, op, V3Op.newCallMethod(extractMethodRef(orig)));
			CallClassVirtual: {
				// devirtualize methods that are not overridden
				var t = extractVirtualRef(orig), m = t.0, newOp: Operator;
				var facts = 0;
				if (t.1) { // still a virtual dispatch
					newOp = V3Op.newCallClassVirtual(m);
				} else {
					// devirtualized to call abstract method => no objects instantiated of that type
					if (m.member.checkFact(Facts.M_ABSTRACT)) return map1(app, newGraph.nullConst(m.getReturnType()));
					else newOp = V3Op.newCallMethod(m);
					// don't emit a null check for devirtualized variant calls
					facts = if(m.container.typeCon.kind == V3Kind.VARIANT, Facts.O_NO_NULL_CHECK);
				}
				var i = normGeneralOp(app, op, newOp);
				i.setFact(facts);
			}
			CallClosure: {
				var tn = normTypeArg(op, 0);
				// normalize CallClosure into CallFunction
				// XXX: use SsaBuilder.opCallFunction
				normGeneralOp(app, op, V3Op.newCallFunction(tn.sub(0)));
			}
			CreateClosure: {
				return mapN(app, [funcRef(extractMethodRef(orig)), genRef1(args(0))]);
			}
			SystemOp:		normGeneralOp(app, op, op);
			ConditionalThrow:	normGeneralOp(app, op, op);
		} else {
			// default to a general operator
			normGeneralOp(app, op, op);
		}
	}
	def genReturn(oldRet: SsaReturn) {
		// map a return (may return multiple values)
		return curBlock.addReturn(genRefs(oldRet.inputs));
	}
	// normalize a general, non-pure, operator
	def normGeneralOp(oldInstr: SsaApplyOp, op: Operator, newOp: Operator) -> SsaInstr {
		var newArgs = genRefs(oldInstr.inputs);
		var newInstr = curBlock.addApply(oldInstr.source, newOp, newArgs);
		newInstr.facts = newInstr.facts | oldInstr.facts;
		mapNorm(oldInstr, newInstr, normReturnType(op));
		return newInstr;
	}
	def normTypeSubsume(oldInstr: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1);
		if (rtn.sub == null) {
			// common case 1-1 mapping
			return map1(oldInstr, curBlock.opTypeSubsume(atn.newType, rtn.newType, genRef1(oldInstr.inputs(0))));
		}
		var width = rtn.size;
		if (width > 0) {
			// complex operator
			var newArgs = genRefs(oldInstr.inputs);
			var vals = Array<SsaInstr>.new(width);
			for (i < width) {
				var ft = if(atn.sub == null, atn.newType, atn.sub(i));
				vals(i) = curBlock.opTypeSubsume(ft, rtn.sub(i), newArgs(i));
			}
			mapN(oldInstr, vals);
		}
	}
	// normalize an equality operator
	def normEqualOp(oldApp: SsaApplyOp, op: Operator) {
		var tn = normTypeArg(op, 0);
		if (tn.size == 0) {
			// comparison is a constant for zero-length values
			return map1(oldApp, newGraph.trueConst());
		}
		var newArgs = genRefs(oldApp.inputs);
		if (tn.size == 1) {
			// a simple comparison
			if (V3.isVariant(tn.newType)) return normVariantEqual(oldApp, tn, newArgs(0), newArgs(1));
			op = V3Op.newEqual(tn.newType);
			return map1(oldApp, curBlock.opEqualOf(op, newArgs(0), newArgs(1)));
		} else {
			// a complex comparison
			genEqualN(oldApp, tn);
			return;
		}
	}
	def normSimpleEqualOp(oldApp: SsaApplyOp, op: Operator) {
		var tn = normTypeArg(op, 0);
		var refs = genRefs(oldApp.inputs);
		return map1(oldApp, curBlock.opEqualOf(op, refs(0), refs(1)));
	}
	def normVariantEqualOp(oldApp: SsaApplyOp, op: Operator) {
		var tn = normTypeArg(op, 0);
		var newArgs = genRefs(oldApp.inputs);
		return normVariantEqual(oldApp, tn, newArgs(0), newArgs(1));
	}
	def normVariantEqual(oldApp: SsaApplyOp, tn: TypeNorm, x: SsaInstr, y: SsaInstr) {
		var rc = RaClass.!(tn);
		if (!context.compiler.GenVariantEqual && (rc.raFacts & RC_ENUM) != 0) {
			// Enum compare is a simple comparison
			return map1(oldApp, curBlock.opEqualOf(V3Op.newIntEqual(tn.newType), x, y));
		}
		var list = rc.methods(IrUtil.EQUALS_METHOD_INDEX);
		if (list == null) {
			tn = normalize(V3.getSuperType(tn.oldType));
			return normVariantEqual(oldApp, tn, x, y);
		}
		var rm = list.head;
		// devirtualize methods that are not overridden
		var t = tryDevirtualize(rm, [rc.newType]), m = t.0, newOp: Operator;
		var facts = Facts.O_PURE | Facts.O_COMMUTATIVE;
		if (t.1) {
			newOp = V3Op.newCallClassVirtual(m);
		} else {
			newOp = V3Op.newCallMethod(m);
			facts = facts | Facts.O_NO_NULL_CHECK;
		}
		var call = curBlock.addApply(oldApp.source, newOp, [x, y]);
		call.setFact(facts);
		map1(oldApp, call);
	}
	def normTupleGetElem(oldInstr: SsaInstr, args: Array<SsaDfEdge>, op: Operator) {
		var tn = RaTuple.!(normTypeArg(op, 0)), index = op.attr<int>();
		return mapN(oldInstr, tn.getElem(genRefs(args), index));
	}
	def normTypeCast(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1), width = rtn.size;
		if (atn.size != width) {
			// cast will always fail
			curBlock.addThrow(oldApp.source, V3Exception.TypeCheck);
			return mapNull(oldApp, rtn);
		} else if (width == 1) {
			// 1-1 mapping
			return map1(oldApp, curBlock.opTypeCast(atn.newType, rtn.newType, genRef1(oldApp.inputs(0))));
		}
		var newArgs = genRefs(oldApp.inputs), vals = Array<SsaInstr>.new(width);
		for (i < width) {
			vals(i) = curBlock.opTypeCast(atn.sub(i), rtn.sub(i), newArgs(i));
		}
		mapN(oldApp, vals);
	}
	def normIntConvert(oldApp: SsaApplyOp, op: Operator) {
		map1(oldApp, curBlock.opIntConvert(op, genRef1(oldApp.inputs(0))));
	}
	def normTypeQuery(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1), width = rtn.size;
		if (atn.size != width) {
			// query will always fail
			return map1(oldApp, newGraph.nullConst(Bool.TYPE));
		} else if (width == 1) {
			// 1-1 mapping
			return map1(oldApp, curBlock.opTypeQuery(atn.newType, rtn.newType, genRef1(oldApp.inputs(0))));
		}
		// a complex or zero arg type query
		var newArgs = genRefs(oldApp.inputs);
		var expr: SsaInstr;
		for (i < atn.size) {
			var cmp = curBlock.opTypeQuery(atn.sub(i), rtn.sub(i), newArgs(i));
			if (SsaValue.?(cmp)) {
				// this part of the type query can be statically decided
				if (cmp.unbox<bool>()) continue;
				return map1(oldApp, cmp);
			}
			if (expr == null) expr = cmp;
			else expr = opBoolAnd(expr, cmp);
		}
		if (expr == null) expr = newGraph.trueConst();
		map1(oldApp, expr);
	}
	def normArrayAlloc(oldApp: SsaApplyOp, op: Operator) {
		var rtn = nonzero(normReturnType(op));
		var length = genRef1(oldApp.inputs(0));
		if (rtn.size == 1) return map1(oldApp, curBlock.opArrayAlloc(rtn.newType, length));
		// complex array allocation
		return mapN(oldApp, Arrays.map(rtn.sub, newArrayAlloc(_, oldApp.source, length)));
	}
	def newArrayAlloc(arrayType: Type, source: Source, length: SsaInstr) -> SsaInstr {
		return curBlock.opArrayAlloc(arrayType, length);
	}
	def normArrayInit(oldApp: SsaApplyOp, op: Operator) {
		var rtn = nonzero(normTypeArg(op, 0));
		var etn = normalize(V3Array.elementType(op.typeArgs(0)));
		var len = op.attr<int>(), width = etn.size;
		if (width == 0) {
			// this is a void array
			var length: SsaInstr = newGraph.intConst(len);
			return map1(oldApp, curBlock.opArrayAlloc(rtn.newType, length));
		}
		var newArgs = genRefs(oldApp.inputs);
		if (rtn.size == 1) return map1(oldApp, curBlock.opArrayInit(rtn.newType, newArgs));
		// complex array initialization
		var arrays = Array<SsaInstr>.new(width);
		for (i < width) {
			var vals = Array<SsaInstr>.new(len);
			for (j < len) {
				vals(j) = newArgs(i + j * width);
			}
			arrays(i) = curBlock.opArrayInit(rtn.sub(i), vals);
		}
		mapN(oldApp, arrays);
	}
	def normArrayGetElem(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normReturnType(op);
		var newArgs = genRefs(oldApp.inputs), width = rtn.size;
		if (width == 1) {
			// common case 1-1 mapping
			return map1(oldApp, curBlock.opArrayGetElem(atn.newType, oldApp.facts, newArgs(0), newArgs(1)));
		} else if (width == 0) {
			// void array access
			curBlock.opBoundsCheck(atn.newType, newArgs(0), newArgs(1));
			return map0(oldApp);
		}
		// complex array access
		var vals = Array<SsaInstr>.new(width);
		var index = newArgs(width), facts = oldApp.facts;
		for (i < width) {
			vals(i) = curBlock.opArrayGetElem(atn.sub(i), facts, newArgs(i), index);
			facts = facts | Facts.O_SAFE_BOUNDS;
		}
		mapN(oldApp, vals);
	}
	def normArraySetElem(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normalize(op.paramTypes(2));
		var width = rtn.size;
		var newArgs = genRefs(oldApp.inputs);
		if (width == 1) {
			curBlock.opArraySetElem(atn.newType, oldApp.facts, newArgs(0), newArgs(1), newArgs(2));
			return;
		} else if (width == 0) {
			curBlock.opBoundsCheck(atn.newType, newArgs(0), newArgs(1));
			return;
		}
		// complex array set
		var index = newArgs(width), facts = oldApp.facts;
		for (i < width) {
			curBlock.opArraySetElem(atn.sub(i), facts, newArgs(i), index, newArgs(i + 1 + width));
			facts = facts | Facts.O_SAFE_BOUNDS;
		}
	}
	def normArrayGetLength(oldApp: SsaApplyOp, op: Operator) {
		var atn = nonzero(normTypeArg(op, 0));
		var array = genRefs(oldApp.inputs);
		// get the length from the first component array
		var arrayType = if(atn.sub == null, atn.newType, atn.sub(0));
		return map1(oldApp, curBlock.opArrayGetLength(arrayType, array(0)));
	}
	def normComponentGetField(oldApp: SsaApplyOp, op: Operator) {
		if (oldApp.useList == null) return; // remove unused reads of fields
		var raField = extractFieldRef(oldApp);
		if (raField.isValue()) {
			// OPT: inline the field as a constant
			mapValue(oldApp, raField.val, normReturnType(oldApp.op));
			return;
		} else if (raField.size == 1) {
			// common case 1-1 mapping
			var read = curBlock.opComponentGetField(raField.norm(0), voidConst());
			read.facts = read.facts | raField.facts();
			return map1(oldApp, read);
		}
		var reads = Array<SsaInstr>.new(raField.size);
		for (i < reads.length) {
			reads(i) = curBlock.opComponentGetField(raField.norm(i), voidConst());
		}
		return mapN(oldApp, reads);
	}
	def normComponentSetField(oldApp: SsaApplyOp, op: Operator) {
		var raField = extractFieldRef(oldApp), fieldVals = genRefs(oldApp.inputs);
		if (raField.norm == null) return; // field has been eliminated
		if (raField.size == 1) {
			// common case 1-1 mapping
			curBlock.opComponentSetField(raField.norm(0), voidConst(), fieldVals(0));
			return;
		}
		for (i < raField.size) {
			curBlock.opComponentSetField(raField.norm(i), voidConst(), fieldVals(i));
		}
	}
	def normClassAlloc(oldApp: SsaApplyOp, op: Operator) {
		var m = op.attr<IrMember>();
		if (m == null) {
			// trivial constructor
			var spec = IrSpec.new(op.typeArgs(0), op.typeArgs, null);
			return map1(oldApp, curBlock.opClassAlloc(spec, Ssa.NO_INSTRS));
		}
		var newArgs = genRefs(oldApp.inputs);
		return map1(oldApp, curBlock.opClassAlloc(extractMethodRef(oldApp.op), newArgs));
	}
	def normClassGetField(oldApp: SsaApplyOp, op: Operator) {
		// XXX: propagate O_NO_NULL_CHECK and O_PURE
		var receiver = genRef1(oldApp.inputs(0));
		if (oldApp.useList == null) {
			// OPT: remove unused read of field
			return addNullCheck(oldApp, receiver);
		}
		var raField = extractFieldRef(oldApp);
		if (raField.size == 0) {
			// OPT: remove read of useless field
			// OPT: remove read of zero-width field
			addNullCheck(oldApp, receiver);
			return map0(oldApp);
		} else if (raField.isValue()) {
			// OPT: inline the field as a constant
			addNullCheck(oldApp, receiver);
			mapValue(oldApp, raField.val, normReturnType(oldApp.op));
			return;
		} else if (raField.size == 1) {
			// common case 1-1 mapping
			var read = curBlock.opClassGetField(raField.norm(0), receiver);
			read.facts = read.facts | raField.facts(); // OPT: propagate field facts
			return map1(oldApp, read);
		}
		// 1-many mapping
		var vals = Array<SsaInstr>.new(raField.size);
		for (i < vals.length) {
			vals(i) = curBlock.opClassGetField(raField.norm(i), receiver);
		}
		return mapN(oldApp, vals);
	}
	def normClassSetField(oldApp: SsaApplyOp, op: Operator, init: bool) {
		// XXX: propagate O_NO_NULL_CHECK
		var raField = extractFieldRef(oldApp);
		var newArgs = genRefs(oldApp.inputs), receiver = newArgs(0);
		if (raField.norm == null || raField.size == 0 || (raField.raFacts & RF_READ) == 0) {
			// OPT: remove write to useless field
			// OPT: remove write of zero-width field
			// OPT: remove write of write-only field
			return addNullCheck(oldApp, receiver);
		} else if (raField.size == 1) {
			// common case; 1-1 field mapping
			curBlock.opClassSetField(raField.norm(0), receiver, newArgs(1), init);
			return;
		}
		// 1-many mapping
		var vals = Array<SsaInstr>.new(raField.size);
		for (i < vals.length) {
			curBlock.opClassSetField(raField.norm(i), receiver, newArgs(i + 1), init);
		}
	}
	def normNullCheck(oldApp: SsaApplyOp, op: Operator) {
		var newArgs = genRefs(oldApp.inputs);
		if (newArgs.length >= 1) addNullCheck(oldApp, newArgs(0));
	}
	def normBoundsCheck(oldInstr: SsaApplyOp, op: Operator) {
		var newArgs = genRefs(oldInstr.inputs);
		var newCheck = curBlock.opBoundsCheck(op.typeArgs(0), newArgs(0), newArgs(1));
		if (newCheck != null) newCheck.facts = newCheck.facts | oldInstr.facts;
	}
	private def normalize(t: Type) -> TypeNorm {
		if (context.spec != null) t = context.spec.instantiateType(t);
		return norm.ra.makeType(t);
	}
	private def extractFieldRef(oldApp: SsaApplyOp) -> RaField {
		var spec = if (specSet != null, specSet.first(), context.spec);
		return norm.ra.makeField(oldApp, spec);
	}
	private def extractMethodRef(op: Operator) -> IrSpec {
		if (specSet != null) op = op.subst(specSet.first().instantiateType);
		else if (context.spec != null) op = op.subst(context.spec.instantiateType);
		return norm.normalizeMethodRef(V3Op.extractIrSpec(op));
	}
	private def extractVirtualRef(op: Operator) -> (IrSpec, bool) {
		if (specSet != null) op = op.subst(specSet.first().instantiateType);
		else if (context.spec != null) op = op.subst(context.spec.instantiateType);
		// look up RaMethod
		var spec = V3Op.extractIrSpec(op);
		var rm = spec.asMethod().raMethod, ta = spec.typeArgs;
		if (rm == null) {
			var rc = norm.ra.makeClass(spec.container);
			rm = rc.findMethod(spec.member.index, ta);
			if (rm == null) return V3.fail1("ReachabilityError: method %1 not found", spec.render);
		}
		return tryDevirtualize(rm, ta);
	}
	def tryDevirtualize(rm: RaMethod, ta: Array<Type>) -> (IrSpec, bool) {
		if (context.compiler.ChaDevirtualize && !rm.norm.checkFact(Facts.M_OVERRIDDEN)) {
			// devirtualize this call because the method is not overridden
			return (IrSpec.new(ta(0), ta, rm.norm), false);
		}
		if (context.compiler.RaDevirtualize && rm.virtual.devirtual != null) {
			// devirtualize this call because only one live version exists
			var m = rm.virtual.devirtual.norm;
			return (IrSpec.new(m.container, Arrays.replace0(m.container, ta), m), false);
		}
		// the call remains a virtual dispatch
		var container = ta(0);
		var selector = IrSelector.new(container, rm.norm, rm.virtual.mtable, rm.normIndex);
		return (IrSpec.new(container, ta, selector), true);
	}
	private def normTypeArg(op: Operator, index: int) -> TypeNorm {
		return normalize(op.typeArgs(index));
	}
	private def normReturnType(op: Operator) -> TypeNorm {
		return normalize(op.resultType);
	}
	private def voidConst() -> SsaInstr {
		return voidConsts()(0);
	}
	private def voidConsts() -> Array<SsaInstr> {
		if (voidArray == null) voidArray = [newGraph.nop()];
		return voidArray;
	}
	private def funcRef(m: IrSpec) -> SsaInstr {
		return newGraph.valConst(Function.funcRefType(m.getFuncType()), FuncVal.new(m));
	}
	private def nonzero(tn: TypeNorm) -> TypeNorm {
		if (tn.size == 0) context.fail("expected at least one type");
		return tn;
	}
	private def addNullCheck(oldApp: SsaInstr, obj: SsaInstr) {
		if (0 == (oldApp.facts & Facts.O_NO_NULL_CHECK)) curBlock.opNullCheck(obj.getType(), obj);
	}
	def mapNull(oi: SsaInstr, rtn: TypeNorm) {
		if (rtn.sub == null) return map1(oi, newGraph.nullConst(rtn.newType));
		return mapN(oi, Arrays.map<Type, SsaInstr>(rtn.sub, newGraph.nullConst));
	}
}
// Generates the comparator method for a (polymorphic) variant type.
class VariantComparatorGen(context: SsaContext, root: IrClass, container: IrClass, method: IrMethod) {
	var graph: SsaGraph;
	var p0: SsaInstr, p1: SsaInstr;
	def generate() -> SsaGraph {
		context.enterMethod(method);

		var tag = V3.classDecl(container.ctype).variantTag;
		var params = Array<SsaParam>.new(2);
		p0 = params(0) = SsaParam.new(0, container.ctype);
		p1 = params(1) = SsaParam.new(1, root.ctype);
		if (tag > 0) p0.setFact(Facts.V_NON_ZERO);
		method.ssa = graph = SsaGraph.new(params, Bool.TYPE);

		if (tag == -1) genCompareTag();
		else genCompareFields(tag);

		context.printSsa("Generated");
		return graph;
	}
	def genCompareTag() {
		var b = newBuilder(graph.startBlock);
		var op = V3Op.newVariantGetTag(root.ctype);
		var t0 = b.addApply(null, op, [p0]);
		var t1 = b.addApply(null, op, [p1]);
		var cmp = b.opEqual(op.resultType, t0, t1);
		b.addReturn([cmp]);
	}
	def genCompareFields(tag: int) {
		var b = newBuilder(graph.startBlock);
		var falseBlock = SsaBlock.new();
		addReturnBool(falseBlock, false);

		var fieldCompare: SsaBlock;
		if (tag == 0) {
			// check p1 for null
			var eqNull1 = SsaBlock.new(), neNull1 = SsaBlock.new();
			b.addIfNull(p1, eqNull1, neNull1);
			b = newBuilder(eqNull1);
			// check p0 for null
			var neNull0a = SsaBlock.new();
			var trueBlock = SsaBlock.new();
			b.addIfNull(p0, trueBlock, neNull0a);
			addReturnBool(trueBlock, true);
			b = newBuilder(neNull0a);
			// if p0 is null, compare p1 fields with default
			genFieldComparisonsWithDefault(false, b, p0, falseBlock);

			b = newBuilder(neNull1);
			var eqNull0b = SsaBlock.new(), neNull0b = SsaBlock.new();
			b.addIfNull(p0, eqNull0b, neNull0b);
			b = newBuilder(eqNull0b);
			genFieldComparisonsWithDefault(true, b, p1, falseBlock);

			fieldCompare = neNull0b;
		} else {
			// check p1 for null
			var neNull1 = SsaBlock.new();
			b.addIfNull(p1, falseBlock, neNull1);
			fieldCompare = neNull1;
		}
		// compare tags and all field values
		b = newBuilder(fieldCompare);

		var op = V3Op.newVariantGetTag(root.ctype);
		var get = b.addApply(null, op, [p1]);
		get.setFact(Facts.O_NO_NULL_CHECK);
		var cmp = b.opEqual(op.resultType, get, graph.intConst(tag));

		var eqTag = SsaBlock.new();
		b.addIf(cmp, eqTag, falseBlock);
		b = newBuilder(eqTag);
		p1 = b.opTypeSubsume(root.ctype, container.ctype, p1);
		p1.setFact(Facts.O_NO_NULL_CHECK | Facts.V_NON_ZERO);
		genFieldComparisons(b, falseBlock);
	}
	def genFieldComparisons(b: SsaBuilder, falseBlock: SsaBlock) {
		// compare each field
		for (f in container.fields) {
			var spec = IrSpec.new(container.ctype, [container.ctype], f);
			var f0 = b.opClassGetField(spec, p0);
			var f1 = b.opClassGetField(spec, p1);
			f0.setFact(Facts.O_NO_NULL_CHECK);
			f1.setFact(Facts.O_NO_NULL_CHECK);
			var cmp = b.opEqual(f.fieldType, f0, f1);
			if (f.index == container.fields.length - 1) {
				// last field
				b.addReturn([cmp]);
				return;
			}
			var cont = SsaBlock.new();
			b.addIf(cmp, cont, falseBlock);
			b = newBuilder(cont);
		}
		b.addReturn([graph.trueConst()]);
	}
	def genFieldComparisonsWithDefault(compareTag: bool, b: SsaBuilder, p0: SsaInstr, falseBlock: SsaBlock) {
		if (compareTag) {
			var cont = SsaBlock.new();
			var t0 = V3Op.newVariantGetTag(root.ctype);
			var get = b.addApply(null, t0, [p0]);
			get.setFact(Facts.O_NO_NULL_CHECK);
			var cmp = b.opEqual(t0.resultType, get, graph.nullConst(t0.resultType));
			if (container.fields.length > 0) {
				b.addIf(cmp, cont, falseBlock);
				b = newBuilder(cont);
				p0 = b.opTypeSubsume(root.ctype, container.ctype, p0);
			} else {
				b.addReturn([cmp]);
				return;
			}
		}
		// compare each field with the default value
		for (f in container.fields) {
			var spec = IrSpec.new(container.ctype, [container.ctype], f);
			var f0 = b.opClassGetField(spec, p0);
			var f1 = graph.nullConst(f.fieldType);
			f0.setFact(Facts.O_NO_NULL_CHECK);
			var cmp = b.opEqual(f.fieldType, f0, f1);
			if (f.index == container.fields.length - 1) {
				// last field
				b.addReturn([cmp]);
				return;
			}
			var cont = SsaBlock.new();
			b.addIf(cmp, cont, falseBlock);
			b = newBuilder(cont);
		}
		b.addReturn([graph.trueConst()]);
	}
	def newBuilder(block: SsaBlock) -> SsaBuilder {
		return SsaBuilder.new(context, graph, block);
	}
	def addReturnBool(block: SsaBlock, val: bool) {
		SsaBuilder.new(context, graph, block).addReturn([graph.boolConst(val)]);
	}
}
// Normalizes integers by scattering/gathering the bits to/from multiple integers.
class IntNormalizer(width: byte, bigEndian: bool) {
	def intMask = (1 << width) - 1;
	def cache = TypeUtil.newTypeMap<RaIntType>();
	def word = Int.getType(false, width);
	def shrOp = word.lookupInfix0(V3Infix.QShr);
	def shlOp = word.lookupInfix0(V3Infix.QShl);
	def addOp = word.lookupInfix0(V3Infix.Add);
	// Normalize an integer value into an array of values.
	def normalizeIntIntoArray(tt: IntType, v: int, array: Array<Val>, index: int) {
		if (width >= 32) {  // degenerate case.
			array(index) = Int.box(v);
			return;
		}
		var words = (tt.width - 1) / width;
		var negative = tt.signed && v < 0;
		for (i < words) {
			var bits = Int.box(v & intMask);
			if (bigEndian) array(index + words - i) = bits;
			else array(index + i) = bits;
			v = v >>> width;
		}
		if (negative) v = v | -1 << width;
		if (bigEndian) array(index) = Int.box(v);
		else array(index + words) = Int.box(v);
	}
	// Normalize a long value into an array of values.
	def normalizeLongIntoArray(tt: IntType, v: long, array: Array<Val>, index: int) {
		if (width >= 64) {
			array(index) = Box.new(v);
			return;
		}
		if (width == 32) {
			var t = Long.split(v), high = Int.box(t.0), low = Int.box(t.1);
			if (bigEndian) {
				array(index) = high;
				array(index + 1) = low;
			} else {
				array(index) = low;
				array(index + 1) = high;
			}
			return;
		}
		// XXX: general case of normalizing a long is ugly and slow!
		var mask = (1L << width) - 1L;
		var words = (tt.width - 1) / width;
		var negative = tt.signed && v < 0;
		for (i < words) {
			var bits = box(v & mask);
			if (bigEndian) array(index + words - i) = bits;
			else array(index + i) = bits;
			v = v >>> width;
		}
		if (negative) v = v | (-1L << width);
		if (bigEndian) array(index) = box(v);
		else array(index + words) = box(v);
	}
	// Check if the given integer type is already normalized.
	def isNormalType(tt: IntType) -> bool {
		return tt.width <= width;
	}
	def normalize(t: Type) -> RaIntType {
		if (!IntType.?(t)) return null;
		var tt = IntType.!(t);
		return if (tt.width > width, makeType(tt));
	}
	// Make the normalized type for a given integer type.
	def makeType(oldType: IntType) -> RaIntType {
		var nt = cache.get(oldType);
		if (nt == null) {
			var words = (oldType.width - 1) / width;
			var sub = Array<Type>.new(words + 1);
			for (i < sub.length) sub(i) = word;
			var bigEnd = Int.getType(oldType.signed, oldType.width - words * width);
			sub(if(bigEndian, 0, sub.length - 1)) = bigEnd;
			var newType = Tuple.newType(Lists.fromArray(sub));
			nt = RaIntType.new(oldType, newType, sub, bigEndian);
			cache.set(oldType, nt);
		}
		return nt;
	}
	def box(v: long) -> Val {
		if (width > 32) return Box<long>.new(v);
		return Box<int>.new(int.!(v));
	}
}
// Reports code that is neither used during initialization nor reachable from main().
class DeadCodeAnalyzer(ra: ReachabilityAnalyzer) {
	def buf = TerminalBuffer.new();
	def report() {
		ra.typeMap.apply(processType);
		for (i < ra.prog.ir.classes.length) {
			var c = ra.prog.ir.classes.get(i);
			processIrClass(c);
			reportClass(c);
		}
	}
	def reportClass(ic: IrClass) {
		buf.reset();
		if (!ic.checkFact(Facts.X_LIVE) && !isSynthetic(ic)) {
			// the entire class is dead
			addLine("dead ", ic);
		} else {
			// report dead fields if any
			for (f in ic.fields) {
				if (ic.inherits(f)) continue;
				if (!f.checkFact(Facts.X_LIVE)) {
					if (buf.length == 0) addLine("within ", ic);
					buf.puts("  dead field: ");
					f.render(buf.red()).end().ln();
				}
			}
			// report dead methods if any
			for (m in ic.methods) {
				if (m == null) continue;
				if (ic.inherits(m)) continue;
				if (m.checkFact(Facts.M_EMPTY)) continue;
				if (!m.checkFact(Facts.X_LIVE)) {
					if (buf.length == 0) addLine("within ", ic);
					buf.puts("  dead method: ");
					m.render(buf.red()).end().ln();
				}
			}
		}
		if (buf.length > 0) Terminal.putb(buf);
	}
	def addLine(p: string, ic: IrClass) {
		buf.puts(p);
		if (V3.isVariant(ic.ctype)) buf.puts("variant ");
		else if (V3.isClass(ic.ctype)) buf.puts("class ");
		else if (V3.isComponent(ic.ctype)) {
			if (isSynthetic(ic)) buf.puts("file ");
			else buf.puts("component ");
		}
		ic.ctype.render(buf.red()).end().ln();
	}
	def isSynthetic(ic: IrClass) -> bool {
		return V3.isComponent(ic.ctype) && V3.asComponent(ic.ctype).componentDecl.isSynthetic;
	}
	def processIrClass(ic: IrClass) {
		for (f in ic.fields) {
			if (f.checkFact(Facts.X_LIVE)) markMember(f);
		}
		for (m in ic.methods) {
			if (m != null && m.ic != null) markMember(m);
		}
	}
	def processType(t: Type, tn: TypeNorm) {
		if (!RaClass.?(tn)) return;
		var rc = RaClass.!(tn);
		for (f in rc.fields) {
			if (f == null) continue;
			if ((f.raFacts & RF_READ) != 0) markMember(f.orig);
		}
		for (ml in rc.methods) {
			for (l = ml; l != null; l = l.tail) {
				var m = l.head;
				if ((m.raFacts & RM_LIVE) != 0) markMember(m.orig);
			}
		}
		if ((rc.raFacts & (RC_LIVE | RC_ALLOC)) != 0 || rc.orig.checkFact(Facts.X_LIVE)) {
			while (rc != null) {
				rc.orig.setFact(Facts.X_LIVE);
				rc = rc.parent;
			}
		}
	}
	def markMember(m: IrMember) {
		m.setFact(Facts.X_LIVE);
		ra.prog.ir.getIrClass(m.container).setFact(Facts.X_LIVE);
	}
}
