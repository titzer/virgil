// Copyright 2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class SsaPacker(builder: SsaBuilder, result: IntType) {
	def scalars = Vector<(PrimType, int, SsaInstr)>.new();
	var pos: int;

	def flatten(ft: Type, input: SsaInstr) {
		if (ft == result) {
			scalars.put(result, pos, input);
			pos += result.width;
			return;
		}
		match (ft) {
			x: TupleType => {
				var es = Lists.toArray(x.nested);
				for (i = es.length -1; i >= 0; i--) {
					var et = es[i];
					var get = builder.pure(V3Op.newTupleGetElem(x, i), [input]);
					flatten(et, get);
				}
			}
			x: PrimType => {
				if (x.width > 0) scalars.put(x, pos, input);
				pos += x.width;
			}
			x: ClassType => {
				// pack the fields of this class type
				var ic = builder.context.prog.ir.makeIrClass(x); // XXX: makeIrClass seems wrong after normalization
				var fs = ic.fields;
				for (i = fs.length -1; i >= 0; i--) {
					var f = fs[i];
					var spec = IrSpec.new(x, TypeUtil.NO_TYPES, f);
					var get = builder.add(V3Op.newVariantGetField(spec), [input], f.facts);
					flatten(spec.getFieldType(), get);
				}
			}
			_ => builder.context.fail(Strings.format2("invalid pack operation %q -> %q", ft.render, result.render));
		}
	}
	def finish() -> SsaInstr {
		if (scalars.length == 0) return builder.graph.nullConst(result);
		var v: SsaInstr;
		for (j < scalars.length) {
			var t = scalars[j], ft = t.0, pos = t.1, i = t.2;
			match (ft) {
				x: IntType => {
					if (j < scalars.length - 1 && x.signed) {
						// Interior signed integers need to be converted to unsigned first to prevent sign pollution.
						var ut = Int.getType(false, ft.width);
						i = builder.opIntViewI0(ft, ut, i);
						ft = ut;
					}
				}
				x: EnumType => {
					ft = x.enumDecl.tagType;
				}
				x: EnumSetType => {
					ft = x.repType;
				}
				x: FloatType => {
					var op = if(x.width == 32, V3Op.opIntViewF32, V3Op.opIntViewF64);
					ft = IntType.!(op.sig.returnType());
					i = builder.pure(op, [i]);
				}
				_ => {
				}
			}
			i = builder.opIntView(ft, result, i); // TODO: will this work for pointer types?
			if (pos != 0) i = builder.add(result.opShl(), [i, builder.graph.intConst(pos)], Fact.O_NO_SHIFT_CHECK);
			if (v == null) v = i;
			else v = builder.pure(result.opOr(), [v, i]);
		}
		return v;		
	}
}
