// Copyright 2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class SsaPacker(builder: SsaBuilder, result: IntType) {
	def scalars = Vector<(PrimType, int, SsaInstr)>.new();
	var pos: int;

	def flatten(ft: Type, input: SsaInstr) {
		if (ft == result) {
			scalars.put(result, pos, input);
			pos += result.width;
			return;
		}
		match (ft) {
			x: TupleType => {
				var es = Lists.toArray(x.nested);
				for (i = es.length -1; i >= 0; i--) {
					var et = es[i];
					var get = builder.pure(V3Op.newTupleGetElem(x, i), [input]);
					flatten(et, get);
				}
			}
			x: PrimType => {
				if (x.width > 0) scalars.put(x, pos, input);
				pos += x.width;
			}
			x: ClassType => {
				// pack the fields of this class type
				var ic = builder.context.prog.ir.makeIrClass(x); // XXX: makeIrClass seems wrong after normalization
				var fs = ic.fields;
				for (i = fs.length -1; i >= 0; i--) {
					var f = fs[i];
					var spec = IrSpec.new(x, TypeUtil.NO_TYPES, f);
					var get = builder.add(V3Op.newVariantGetField(spec), [input], f.facts);
					flatten(spec.getFieldType(), get);
				}
			}
			_ => builder.context.fail(Strings.format2("invalid pack operation %q -> %q", ft.render, result.render));
		}
	}
	def finish() -> SsaInstr {
		if (scalars.length == 0) return builder.graph.nullConst(result);
		var v: SsaInstr;
		for (j < scalars.length) {
			var t = scalars[j], ft = t.0, pos = t.1, i = t.2;
			match (ft) {
				x: IntType => {
					if (j < scalars.length - 1 && x.signed) {
						// Interior signed integers need to be converted to unsigned first to prevent sign pollution.
						var ut = Int.getType(false, ft.width);
						i = builder.opIntViewI0(ft, ut, i);
						ft = ut;
					}
				}
				x: EnumType => {
					ft = x.enumDecl.tagType;
				}
				x: EnumSetType => {
					ft = x.repType;
				}
				x: FloatType => {
					var op = if(x.width == 32, V3Op.opIntViewF32, V3Op.opIntViewF64);
					ft = IntType.!(op.sig.returnType());
					i = builder.pure(op, [i]);
				}
				_ => {
				}
			}
			i = builder.opIntView(ft, result, i); // TODO: will this work for pointer types?
			if (pos != 0) i = builder.add(result.opShl(), [i, builder.graph.intConst(pos)], Fact.O_NO_SHIFT_CHECK);
			if (v == null) v = i;
			else v = builder.pure(result.opOr(), [v, i]);
		}
		return v;		
	}	
}

class SsaUnpacker(builder: SsaBuilder, ft: IntType) {
	// Track the position in the input IntType we are unpacking
	var pos: int = 0;
	// A buffer to hold the scalars so that we can construct tuples and variants. 
	def unpackedBuffer = ListStack<SsaInstr>.new();
	var input: SsaInstr;
	def unpack(tt: Type, i: SsaInstr) -> SsaInstr {
		input = i;
		unpack0(tt);
		if (unpackedBuffer.empty() ) { builder.context.fail(Strings.format1("Error unpacking %q. Nothing unpacked", tt.render)); }
		def unpackedInstr = unpackedBuffer.pop();
		if (!unpackedBuffer.empty() ) { builder.context.fail(Strings.format1("Error unpacking %q. Extraneous instructions found", tt.render)); }
		return unpackedInstr;
	}
	def unpack0(tt: Type) {
		var shiftedInput = input;
		if (pos != 0) { 
			shiftedInput = builder.add(ft.opShr(), [input, builder.graph.intConst(pos)], Fact.O_NO_SHIFT_CHECK);
		}
		
		match (tt) {
			x: IntType => {
				if (x == tt) { unpackedBuffer.push(shiftedInput); }
				// System.puts(Strings.format1("\tWidth of the IntType to unpack: %d", x.width));
				def viewInstr = builder.opIntViewI0(ft, x, shiftedInput);
				unpackedBuffer.push(viewInstr);
				pos += x.width;
			}
			x: BoolType => {
				def bitType: IntType = Int.getType(false, 1);
				def unpackedBit: SsaInstr = builder.opIntViewI0(ft, bitType, shiftedInput);
				// valConst or intConst? valConst for 1: bitType simplifies to intConst(1)
				def cond = builder.addApply(builder.source, bitType.opEq(), [unpackedBit, builder.graph.intConst(1)]);
				def trueBlock = SsaBlock.new();
				def falseBlock = SsaBlock.new();
				builder.addIf(cond, trueBlock, falseBlock);
				def joinBlock = SsaBlock.new();
				trueBlock.append(SsaGoto.new(joinBlock));
				falseBlock.append(SsaGoto.new(joinBlock));
				// Set builder to process on joinBlock
				builder.set(joinBlock);
				def boolInstr = builder.addPhi(x, [builder.graph.boolConst(true), builder.graph.boolConst(false)]);
				unpackedBuffer.push(boolInstr);
				pos += x.width;
			}
			x: FloatType => {
				def op = if(x.is64, V3Op.newFloat64ViewI(ft),V3Op.newFloat32ViewI(ft));
				def unpackedFloat: SsaInstr = builder.add(op, [shiftedInput], Facts.NONE);
				unpackedBuffer.push(unpackedFloat);
				pos += x.width;
			}
			x: EnumType => {
				def tagType: IntType = x.enumDecl.tagType;
				def unpackedTag: SsaInstr = builder.opIntViewI0(ft, tagType, shiftedInput);
				def numCases = x.enumDecl.cases.length;
				def cond: SsaInstr = builder.addApply(builder.source, tagType.opLt(), [unpackedTag, builder.graph.intConst(numCases)]);
				// Valid tag case
				def trueBlock = SsaBlock.new();
				def subsumeOrigTag = SsaApplyOp.new(builder.source, V3Op.newTypeSubsume(tagType, x), [unpackedTag]);
				trueBlock.append(subsumeOrigTag);
				// Invalid tag -> map to 0th enum value 
				def falseBlock = SsaBlock.new();
				def subsumeZero = SsaApplyOp.new(builder.source, V3Op.newTypeSubsume(tagType, x), [builder.graph.intConst(0)]);
				falseBlock.append(subsumeZero);
				builder.addIf(cond, trueBlock, falseBlock);
				// Set builder to process on joinBlock
				def joinBlock = SsaBlock.new();
				trueBlock.append(SsaGoto.new(joinBlock));
				falseBlock.append(SsaGoto.new(joinBlock));
				builder.set(joinBlock);
				def enumInstr = builder.addPhi(x, [subsumeOrigTag, subsumeZero]);

				unpackedBuffer.push(enumInstr);
				pos += tagType.width;
			}
			x: EnumSetType => {
				def repType: IntType = x.repType;
				def unpackedRep = builder.opIntViewI0(ft, repType, shiftedInput); 
				// Do you need to type subsume into an enum set?
				def enumSetInstr = SsaApplyOp.new(builder.source, V3Op.newTypeSubsume(repType, x), [unpackedRep]);
				builder.append(enumSetInstr);

				unpackedBuffer.push(enumSetInstr);
				pos += repType.width;
			}
			x: TupleType => {
				def elemTypes: Array<Type> = Lists.toArray(x.nested);
				for (elemType in elemTypes) {
					unpack0(elemType);
				}
				// Retrieve the unpacked instructions from the buffer 
				def unpackedElems = Array<SsaInstr>.new(elemTypes.length);
				for (i = elemTypes.length-1; i >= 0; i--) {
					if (unpackedBuffer.empty()) { 
						builder.context.fail(Strings.format2("Error unpacking %q. Missing %q", x.render, elemTypes[i].render));
					}
					unpackedElems[i] = unpackedBuffer.pop();
				}
				def tupleCreate = builder.opTupleCreate(x, unpackedElems);
				unpackedBuffer.push(tupleCreate);
			}	
			x: ClassType => {
				var ic = builder.context.prog.ir.makeIrClass(x); // XXX: makeIrClass seems wrong after normalization
				var fs = ic.fields; 
				for (field in fs) {	
					unpack0(field.fieldType);
				}
				def fieldInstr = Array<SsaInstr>.new(fs.length);
				for (i = fs.length - 1; i >= 0; i--) {
					if (unpackedBuffer.empty()) { 
						builder.context.fail(Strings.format2("Error unpacking %q. Missing %q", x.render, fs[i].render));
					}
					fieldInstr[i] = unpackedBuffer.pop();
				}

				def getFieldType(irField: IrField) -> Type { return irField.fieldType; }
				def variantAlloc = builder.add(V3Op.newVariantAlloc(x, Arrays.map<IrField, Type>(fs, getFieldType)), fieldInstr, Facts.NONE);
				unpackedBuffer.push(variantAlloc);
			}
		}
	}
}





