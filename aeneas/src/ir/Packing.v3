// Copyright 2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class SsaPacker(builder: SsaBuilder, result: IntType) {
	def scalars = Vector<(PrimType, int, SsaInstr)>.new();
	var pos: int;

	def flatten(ft: Type, input: SsaInstr) {
		if (ft == result) {
			scalars.put(result, pos, input);
			pos += result.width;
			return;
		}
		match (ft) {
			x: TupleType => {
				var es = Lists.toArray(x.nested);
				for (i = es.length -1; i >= 0; i--) {
					var et = es[i];
					var get = builder.pure(V3Op.newTupleGetElem(x, i), [input]);
					flatten(et, get);
				}
			}
			x: PrimType => {
				if (x.width > 0) scalars.put(x, pos, input);
				pos += x.width;
			}
			x: ClassType => {
				// pack the fields of this class type
				var ic = builder.context.prog.ir.makeIrClass(x); // XXX: makeIrClass seems wrong after normalization
				var fs = ic.fields;
				for (i = fs.length -1; i >= 0; i--) {
					var f = fs[i];
					var spec = IrSpec.new(x, TypeUtil.NO_TYPES, f);
					var get = builder.add(V3Op.newVariantGetField(spec), [input], f.facts);
					flatten(spec.getFieldType(), get);
				}
			}
			_ => builder.context.fail(Strings.format2("invalid pack operation %q -> %q", ft.render, result.render));
		}
	}
	def finish() -> SsaInstr {
		if (scalars.length == 0) return builder.graph.nullConst(result);
		var v: SsaInstr;
		for (j < scalars.length) {
			var t = scalars[j], ft = t.0, pos = t.1, i = t.2;
			match (ft) {
				x: IntType => {
					if (j < scalars.length - 1 && x.signed) {
						// Interior signed integers need to be converted to unsigned first to prevent sign pollution.
						var ut = Int.getType(false, ft.width);
						i = builder.opIntViewI0(ft, ut, i);
						ft = ut;
					}
				}
				x: EnumType => {
					ft = x.enumDecl.tagType;
				}
				x: EnumSetType => {
					ft = x.repType;
				}
				x: FloatType => {
					var op = if(x.width == 32, V3Op.opIntViewF32, V3Op.opIntViewF64);
					ft = IntType.!(op.sig.returnType());
					i = builder.pure(op, [i]);
				}
				_ => {
				}
			}
			i = builder.opIntView(ft, result, i); // TODO: will this work for pointer types?
			if (pos != 0) i = builder.add(result.opShl(), [i, builder.graph.intConst(pos)], Fact.O_NO_SHIFT_CHECK);
			if (v == null) v = i;
			else v = builder.pure(result.opOr(), [v, i]);
		}
		return v;		
	}	
}

// class SsaUnpacker(builder: SsaBuilder, packedIntType: IntType) {
// 	// def scalars = Vector<(PrimType, int, SsaInstr)>.new();
// 	// def nonScalars = Vector<Type>.new();
// 	// var pos: int;
// 	def unpack(tt: Type, input: SsaInstr) -> SsaInstr {
// 		def unpackResult = unpack0(tt, input);
// 		return unpackResult.0;
// 	}
// 	def unpack0(tt: Type, input: SsaInstr) -> (SsaInstr, SsaInstr) {
// 		if (tt == result) {
// 			scalars.put(result, pos, input);
// 			pos += result.width;
// 			return;
// 		}
// 		match (tt) {
// 			x: TupleType => {
// 				var es = Lists.toArray(x.nested);
// 				var parsedElements = Array<SsaInstr>.new(es.length);
// 				// Process the first element because that is the rightmost in the packed input 
// 				for (i = 0; i < es.length; i++) {
// 					var et = es[i];
// 					def unpackResult = unpack(et, input);
// 					// Store results and update input 
// 					parsedElements[i] = unpackResult.0;
// 					input = unpackResult.1;
// 				}
// 				return (builder.opTupleCreate(x, parsedElements), input);
// 			}
// 			x: PrimType => {
// 				var width = x.width;
// 				var mask: i64 = if (width < 64, (1 << width) - 1, -1);
// 				// Add instruction to create the mask. Case on when width >= the int type width
// 				// Create a new value from applying a mask onto the rightmost `width` bits
// 				var maskedResult = builder.pure(packedIntType.opAnd(), [input, builder.graph.intConst(mask)]);
// 				var castInstr = builder.opTypeCast(maskIntType,scalarType,maskedResult);
// 				// Update input instr: shift right to prep for retrieval of next primitive 
// 				if (width < 64) { input = builder.add(packedIntType.opShr(), [input, builder.graph.intConst(width)], Facts.O_NO_SHIFT_CHECK); }
// 				return (castInstr, input);
// 			}
// 			x: EnumType => {
// 				//Take care of the simple case for now: enums are without arguments
// 				// NOTE: The tag type for the variant should be stored within x
// 				var op = V3Op.newVariantAlloc(x, TypeUtil.NO_TYPES);
// 				var variantAlloc = builder.pure(op, Ssa.NO_INSTRS)

// 				def width = x.enumDecl.tagType.width;
// 				var mask: i64 = if (width < 64, (1 << width) - 1, -1);
// 				var maskedResult = builder.pure(packedIntType.opAnd(), [input, builder.graph.intConst(mask)]);
// 				var castInstr = builder.opTypeCast(maskIntType,scalarType,maskedResult);
// 				input = builder.pure(packedIntType.opShr(), [input, builder.graph.intConst(width)], Facts.O_NO_SHIFT_CHECK);
// 				return (variantAlloc, input);


// 				// // Create the enum type
// 				// // Enum needs to be initialized
// 				// def ir = builder.context.prog.ir.makeIrClass(x);
// 				// def irFieldTypes = Array<Type>.new(ir.fields.length);
// 				// for (i < ir_fields.length) { irFieldTypes[i] = ir.fields[i].fieldType; }
// 				// var op = V3Op.newVariantAlloc(x, irFieldTypes);

// 				// // Fields needs to be initialized from first to last 
// 				// def fieldArgs = Array<SsaInstr>.new(irFieldTypes.length);
// 				// for (i < irFieldTypes.length) {
// 				// 	def unpackResult = unpack(irFieldTypes[i], input);
// 				// 	fieldArgs[i] = unpackResult.0;
// 				// 	input = unpackResult.1;
// 				// }
// 				// var curVariant = builder.pure(op, fieldArgs);
// 				// return (curVariant, input);
// 			}
// 			_ => builder.context.fail(Strings.format2("invalid pack operation %q -> %q", tt.render, result.render));
// 		}

// 	}
// }

