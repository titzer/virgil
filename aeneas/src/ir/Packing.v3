// Copyright 2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class SsaPacker(builder: SsaBuilder, result: IntType) {
	def scalars = Vector<(Type, int, SsaInstr)>.new();
	var pos: int;

	def addBigEndian(ft: Type, input: SsaInstr) {
		if (ft == result) {
			scalars.put(ft, pos, input);
			pos += result.width;
			return;
		}
		match (ft) {
			x: TupleType => {
				var es = Lists.toArray(x.nested);
				for (i = es.length -1; i >= 0; i--) {
					var et = es[i];
					var get = builder.pure(V3Op.newTupleGetElem(x, i), [input]);
					addBigEndian(et, get);
				}
			}
			x: FloatType => {
				scalars.put(x, pos, builder.opIntView(x, result, input));
				pos += x.width;
			}
			x: IntType => {
				scalars.put(x, pos, builder.opIntView(x, result, input));
				pos += x.width;
			}
			x: EnumType => {
				scalars.put(x, pos, builder.opIntView(x, result, input));
				pos += x.width;
			}
			x: ClassType => {
				// pack the fields of this class type
				var fs = builder.context.prog.ir.getIrClass(x).fields;
				for (i = fs.length -1; i >= 0; i--) {
					var f = fs[i];
					var spec = IrSpec.new(x, TypeUtil.NO_TYPES, f);
					var get = builder.add(V3Op.newVariantGetField(spec), [input], f.facts);
					addBigEndian(spec.getFieldType(), get);
				}
			}
			x: VoidType => ; // do nothing
			x: PointerType => {
				// TODO
			}
			_ => builder.context.fail(Strings.format2("invalid pack operation %q -> %q", ft.render, result.render));
		}
	}
	def finish() -> SsaInstr {
		if (scalars.length == 0) return builder.graph.nullConst(result);
		var v: SsaInstr;
		for (j < scalars.length) {
			var t = scalars[j];
			var i = t.2;
			if (t.1 != 0) i = builder.add(result.opShl(), [i, builder.graph.intConst(t.1)], Fact.O_NO_SHIFT_CHECK);
			if (v == null) {
				v = i;
			} else {
				v = builder.pure(result.opOr(), [v, i]);
			}
		}
		return v;		
	}
}
