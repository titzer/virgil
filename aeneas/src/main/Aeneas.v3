// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The main component of the Aeneas compiler. It provides many global command line
// options. From the options and command line arguments, it decides what action
// should be performed on the program(s) on the command line.
component Aeneas {
	def options = BasicOptions.new(null);
	def x = options.setUnmatched = setUnmatchedOption;
	def o = options;

	// Action options
	def HELP		= o.newBoolOption("help", false);
	def VERSION		= o.newBoolOption("version", false);
	def TEST		= o.newBoolOption("test", false);
	def TEST_ST		= o.newBoolOption("test.st", false);
	def TEST_GC		= o.newStringOption("test.gc", "");
	def RUN			= o.newBoolOption("run", false);
	def PROFILE		= newMatcherOption(o, "profile");
	def INSTR_PROFILE	= newMatcherOption(o, "iprofile");
	def PROFILE_DEPTH	= o.newIntOption ("profile-depth", 0);
	def COVERAGE		= newMatcherOption(o, "coverage");
	def INSTR_COVERAGE	= o.newBoolOption("icoverage", false);
	// User options
	def MULTIPLE		= o.newBoolOption("multiple", false);
	def TARGET		= o.newOption("target", null, getTarget);
	def OUTPUT		= o.newStringOption("output", null);
	def PROGRAM_NAME	= o.newStringOption("program-name", null);
	def MAIN_EXPORT		= o.newStringOption("main-export", "main");
	def ENTRY_EXPORT	= o.newStringOption("entry-export", "entry");
	// Language options
	def LEGACY_CAST		= o.newBoolOption("legacy-cast", true);
	// Internal testing options
	def EXPECT		= o.newStringOption("expect", null);
	def RA			= o.newBoolOption("ra", false);
	def MA			= o.newBoolOption("ma", false);
	def SET_EXEC		= o.newBoolOption("set-exec", true);
	def HEAP_SIZE		= o.newSizeOption("heap-size", 0);
	def STACK_SIZE		= o.newSizeOption("stack-size", 0);
	def SHADOW_STACK_SIZE	= o.newSizeOption("shadow-stack-size", 0);
	def RT_STTABLES		= o.newBoolOption("rt.sttables", false);
	def RT_GCTABLES		= o.newBoolOption("rt.gctables", false);
	def RT_SYMTAB		= o.newBoolOption("rt.symtab", false);
	def RT_GC		= o.newBoolOption("rt.gc", false);
	def RT_TEST_GC		= o.newBoolOption("rt.test-gc", false);
	def RT_FILES		= o.add(Option.new("rt.files", Array<string>.new(0), parseStringArray));
	def OPT			= o.newStringOption("opt", null);
	def MAXR		= o.newIntOption("maxr", 100000); // max results for a function
	def MAXP		= o.newIntOption("maxp", 100000); // max params for a function
	def MAXD		= o.newIntOption("maxd", 0); // max words for a flat data type
	def MAXV		= o.newIntOption("maxv", 0); // max words for a flat variant type
	// Debugging options
	def PRINT_IC		= newMatcherOption(o, "print-ic");
	def PRINT_ID		= o.newBoolOption("print-id", false);
	def PRINT_INLINING	= o.newBoolOption("print-inlining", false);
	def PRINT_VST		= o.newBoolOption("print-vst", false);
	def PRINT_RA		= o.newBoolOption("print-ra", false);
	def PRINT_SSA		= newMatcherOption(o, "print-ssa");
	def PRINT_SSA_STATS	= newMatcherOption(o, "print-ssa-stats");
	def PRINT_MACH		= newMatcherOption(o, "print-mach");
	def PRINT_PATCH		= o.newBoolOption("print-patch", false);
	def PRINT_MACH_DATA	= o.newBoolOption("print-mach-data", false);
	def PRINT_STACKMAP	= o.newBoolOption("print-stackmap", false);
	def PRINT_CFG		= o.newBoolOption("print-cfg", false);
	def PRINT_BIN		= o.newBoolOption("print-bin", false);
	def PRINT_SIZE		= o.newBoolOption("print-size", false);
	def PRINT_DEAD_CODE	= o.newBoolOption("print-dead-code", false);
	def PRINT_STACKIFY	= o.newBoolOption("print-stackify", false);
	def FATAL		= o.newBoolOption("fatal", false);
	def TRACE		= o.newBoolOption("trace", false);
	def TRACE_PARENT	= o.newBoolOption("trace-parent", false);
	def TRACE_CALLS		= newMatcherOption(o, "trace-calls");
	def FATAL_CALLS		= newMatcherOption(o, "fatal-calls");
	def START_UID		= o.newIntOption("start-uid", 0);

	var targets: List<Target>;
	var startup: void -> void;

	def main(args: Array<string>) -> bool {
		args = options.parse(args);
		if (START_UID.val != 0) UID.next = START_UID.val;
		if (VERSION.get()) {
			printVersion(true, "\n");
			if (startup != null) startup();
			return false;
		}
		if (startup != null) startup();
		if (args.length == 0) return printVersion(false, ": no input files\n");
		if (TEST.get()) return Regression.new().run(args);
		if (HELP.get()) return printHelp(args);
		if (RUN.get()) return compileAndRun(args);
		if (MULTIPLE.get()) return compileMultiple(args);
		return !compile(args).reportErrors();
	}
	def getTarget(name: string) -> Target {
		if (name == null) return null;
		for (list = targets; list != null; list = list.tail) {
			if (Strings.equal(list.head.name, name)) return list.head;
		}
		Terminal.put("Unknown target: ");
		Terminal.put(name);
		Terminal.ln();
		return null;
	}
	def compileMultiple(args: Array<string>) -> bool {
		var failed = false;
		var progress = ProgressPrinter.new(args.length);
		var compiler = Compiler.new(TARGET.get());
		for (i < args.length) {
			progress.begin(args[i]);
			var prog = makeProgram(compiler, [args[i]]);
			var compilation = Compilation.new(compiler, prog);
			compilation.compile();
			if (prog.ERROR.numErrors > 0) {
				failed = true;
				progress.fail(prog.ERROR.firstError());
			} else {
				progress.pass();
			}
		}
		return failed;
	}
	def makeProgram(compiler: Compiler, args: Array<string>) -> Program {
		var prog = Program.new();
		prog.explicitName = PROGRAM_NAME.val;
		if (compiler.target == null) SystemCalls.install(prog);
		setArgs(prog, args);
		return prog;
	}
	def setArgs(prog: Program, args: Array<string>) {
		// parse arguments: "A.v3 ... Z.v3 x y" into {prog.files = ["A.v3", "B.v3"]} and {prog.args = ["x", "y"]}
		for (i = 0; true; i++) {
			if (i == args.length) {
				prog.files = args;
				prog.args = [];
				break;
			}
			var arg = args[i];
			if (!Strings.endsWith(arg, ".v3")) {
				prog.files = Arrays.copy(args, Array<string>.new(i));
				prog.args = Arrays.range(args, i, args.length);
				break;
			}
		}
		// Prepend -rt.files option to program files
		var rtfiles = Aeneas.RT_FILES.get();
		if (rtfiles.length > 0) {
			var v = Vector<string>.new().grow(rtfiles.length + prog.files.length);
			v.puta(prog.files);
			v.puta(rtfiles);
			prog.files = v.extract();
		}
		// Allocate space for all the input data
		prog.inputs = Array.new(prog.files.length);
	}
	def compile(args: Array<string>) -> Program {
		var compiler = Compiler.new(TARGET.get());
		var prog = makeProgram(compiler, args);
		Compilation.new(compiler, prog).compile();
		return prog;
	}
	def compileAndRun(args: Array<string>) -> bool {
		var compiler = Compiler.new(TARGET.get());
		var prog = makeProgram(compiler, args);
		var compilation = Compilation.new(compiler, prog);
		var after: void -> void;
		if (COVERAGE.val != VstMatcher.None) {
			after = IcCoverage.new(compiler, prog, COVERAGE.val, INSTR_COVERAGE.val).report;
		} else if (INSTR_PROFILE.val != VstMatcher.None) {
			after = IcInstrProfiler.new(compiler, prog, INSTR_PROFILE.val).report;
		} else if (PROFILE.val != VstMatcher.None) {
			after = IcTreeProfiler.new(compiler, prog, PROFILE.val).report;
		}
		compilation.compile();
		if (!prog.reportErrors()) return true;
		var result = compilation.runMain();
		if (Exception.?(result)) {
			var rettype = prog.getMain().getReturnType();
			TerminalBuffer.new()
				.putv(result, rettype)
				.outln();
		}
		if (after != null) after();
		return false;
	}
	def registerTarget(target: Target) {
		targets = List<Target>.new(target, targets);
	}
	def printHelp(args: Array<string>) -> bool {
		return printVersion(true, "\n");
	}
	def printVersion(long: bool, next: string) -> bool {
		Terminal.put("Aeneas ");
		Terminal.put(Version.version);
		var data = Version.buildData;
		if (long && data != null) {
			Terminal.put("\nBuild Data: ");
			Terminal.put(data);
		}
		Terminal.put(next);
		return false;
	}
	def newMatcherOption(o: Options, name: string) -> Option<VstMatcher> {
		return o.add(Option.new(name, VstMatcher.None, parseMatcher));
	}
	def parseMatcher(str: string) -> VstMatcher {
		if (str == null) return VstMatcher.All;
		return VstMatchers.parse(str);
	}
	def setUnmatchedOption(str: string, val: string) {
		if (!Strings.startsWith(str, "P")) return;
		for (i = 1; i < str.length; i++) {
			match (str[i]) {
				's' => PRINT_SSA.val = VstMatcher.All;
				'm' => PRINT_MACH.val = VstMatcher.All;
				'd' => PRINT_MACH_DATA.val = true;
				'v' => PRINT_VST.val = true;
				'r' => PRINT_RA.val = true;
				'b' => PRINT_BIN.val = true;
				'c' => PRINT_CFG.val = true;
				't' => PRINT_STACKIFY.val = true;
				'i' => PRINT_IC.val = VstMatcher.All;
				'n' => PRINT_INLINING.val = true;
			}
		}
	}
	def parseStringArray(str: string) -> Array<string> {
		var v = Vector<string>.new();
		var start = 0, pos = 0;
		while (pos < str.length) {
			var ch = str[pos];
			if (ch == ' ' || ch == '\n') {
				if (pos > start) v.put(Arrays.range(str, start, pos));
				start = pos + 1;
			}
			pos++;
		}
		if (pos > start) v.put(Arrays.range(str, start, pos));
		return v.extract();
	}
}
