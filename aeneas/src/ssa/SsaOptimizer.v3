// Copyright 2015 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Coordinates optimizations of SSA graphs, blocks, and individual instructions.
// Provides a facade to the outside that hides details of reduction, analysis, etc.
class SsaOptimizer(context: SsaContext) {
	var marker = SsaInternalMarker.new();
	def iopt = SsaInstrReducer.new(context);

	def reset(graph: SsaGraph) {
		iopt.graph = graph;
		marker.reset(graph);
		context.graph = graph;
		context.block = null;
	}
	def optGraph() {
		marker.reset(context.graph);
		def queue = Vector<(SsaBlock, SsaBlockState)>.new();
		queue.put(context.graph.startBlock, SsaBlockState.new());
		var mark = marker.allocMark(context.graph.startBlock);
		for (i < queue.length) {
			var t = queue[i], block = t.0;
			iopt.state = t.1;
			if (block.facts.O_KILLED) continue;
			iopt.reduceBlock(block);
			var succs = block.succs();
			for (s in succs) {
				var d = s.dest;
				if (marker.getMark(d) < 0) {
					var state: SsaBlockState;
					if (succs.length == 1) state = if(s.dest.preds.length == 1, iopt.state, iopt.state.clear());
					else state = if(s.dest.preds.length == 1, iopt.state.copy(), SsaBlockState.new());
					queue.put(d, state);
					marker.setMark(d, mark);
				}
			}
		}
		checkAndPruneGraph();
	}
	def optLoop(header: SsaBlock, loopBody: SsaBlock, loopEnd: SsaBlock) {
	}
	def optBlock(block: SsaBlock) {
	}
	def reduceIf(state: SsaBlockState, i: SsaIf) {
		iopt.state = state;
		iopt.prev = i.prev;
		iopt.reduceIf(i);
		iopt.state = null;
	}
	def reduceApply(state: SsaBlockState, app: SsaApplyOp) -> SsaInstr {
		iopt.state = state;
		iopt.prev = app.prev;
		var res = iopt.reduceApplyOp(app);
		if (res != app) {
			app.replace(res);
			app.remove();
		}
		iopt.state = null;
		return res;
	}
	def checkAndPruneGraph() -> bool {
		var changed = false, print = context.shouldPrintOpt();
		marker.reset(context.graph);
		def reachable = Vector<SsaBlock>.new();
		reachable.put(context.graph.startBlock);
		var mark = marker.allocMark(context.graph.startBlock);
		// Mark everything reachable from start.
		var markInstrs = false;
		for (i < reachable.length) {
			var block = reachable[i];
			if (print) Terminal.put1("block #%d\n", block.uid);
			var succs = block.succs();
			if (markInstrs) for (x = block.next; x != block; x = x.next) {
				if (print) Terminal.put1(" inst #%d\n", x.uid);
				marker.setMark(x, mark);
			}
			var end = block.end();
			if (end == null) {
				context.fail1("block #%d has no end", block.uid);
				continue;
			}
			marker.setMark(end, mark);
			for (s in succs) {
				var d = s.dest;
				if (marker.getMark(d) < 0) {
					if (print) Terminal.put1(" succ #%d\n", d.uid);
					reachable.put(d);
					marker.setMark(d, mark);
				}
			}
		}
		// Prune off unreachable predecessors and uses.
		var cfopt = SsaCfOptimizer.new(context);
		for (i < reachable.length) {
			var block = reachable[i], j = 0;
			while (j < block.preds.length) {
				var pred = block.preds[j];
				if (marker.getMark(pred.src) < 0) {
					if (context.shouldPrintOpt()) Terminal.put2("  remove edge #%d -> #%d\n", pred.src.uid, pred.dest.uid);
					cfopt.removeEdge(pred);
					changed = true;
				}
				else j++;
			}
		}
		return changed;
	}
}


def ARRAY_LENGTH_FIELD = newField(V3.stringType, Int.TYPE, Fact.F_VALUE);

def newField(receiver: Type, fieldType: Type, facts: Fact.set) -> IrField {
	var f = IrField.new(receiver, fieldType);
	f.facts |= facts;
	return f;
}

// Matches various patterns of SSA instructions, recording the state of the match
// in the exposed fields.
class SsaInstrMatcher {
	var x: SsaInstr;	// First input
	var y: SsaInstr;	// Second input
	var xconst: bool;	// true if {x} is a constant
	var yconst: bool;	// true if {y} is a constant
	var fold: bool;		// true if all inputs are constants
	var wide: bool;		// true if this is a long int operation
	var xval: Val;		// if {x} is a constant, then its value
	var yval: Val;		// if {y} is a constant, then its value
	var xint: int;		// if {x} is an int constant, then its value
	var yint: int;		// if {y} is an int constant, then its value
	var xlong: long;	// if {x} is a long constant, then its value
	var ylong: long;	// if {y} is a long constant, then its value
	var yzero: bool;        // true if {y} is zero
	var inttype: IntType;	// if this is an integer operation, the result type

	// Resets this matcher
	def clear() {
		x = y = null;
		xval = yval = null;
		inttype = null;
		xconst = yconst = yzero = fold = wide = false;
		xint = yint = 0;
		xlong = ylong = 0;
	}
	// Initializes the match state for a binary operation and returns {yval}.
	def binop(i: SsaApplyOp) -> Val {
		x = i.input0();
		y = i.input1();
		yzero = y.facts.V_ZERO;
		fold = false;
		if (xconst = SsaConst.?(x)) {
			xval = SsaConst.!(x).val;
			if (yconst = SsaConst.?(y)) {
				fold = true;
				return yval = SsaConst.!(y).val;
			} else if (i.facts.O_COMMUTATIVE) {
				i.inputs[0].update(y);
				i.inputs[1].update(x);
				xconst = false;
				yconst = true;
				var t = x;
				x = y;
				y = t;
				yval = xval;
				xval = null;
				yzero = y.facts.V_ZERO;
				return yval;
			} else {
				return yval = null;
			}
		}
		return yval = if(yconst = SsaConst.?(y), SsaConst.!(y).val);
	}
	// Initializes the match state for an integer binary operation and returns {yint}.
	def intbinop(i: SsaApplyOp) -> int {
		binop(i);
		inttype = IntType.!(i.op.sig.paramTypes[0]);
		if (inttype.width <= 32) {
			wide = false;
			if (xconst) xint = V3.unboxI32(xval);
			if (yconst) {
				yint = V3.unboxI32(yval);
				yzero = yint == 0;
			}
		} else {
			wide = true;
			if (xconst) xlong = Long.unboxSU(xval, inttype.signed);
			if (yconst) {
				ylong = Long.unboxSU(yval, inttype.signed);
				yzero = ylong == 0;
			}
		}
		return yint;
	}
	// Initializes the match state for an integer binary operation and returns {yint}.
	def boolbinop(i: SsaApplyOp) -> int {
		binop(i);
		inttype = null;
		if (xconst) xint = if(Bool.unbox(xval), 1);
		if (yconst) {
			yint = if(Bool.unbox(yval), 1);
			yzero = yint == 0;
		}
		return yint;
	}
	// Initializes the match state for a unary operation and returns {xval}.
	def unop(i: SsaApplyOp) -> Val {
		x = i.input0();
		return xval = if(fold = xconst = SsaConst.?(x), SsaConst.!(x).val);
	}
	// Initializes the match state for an n-ary operation and returns {xval}.
	def n_op(i: SsaApplyOp) -> Val {
		fold = true;
		var max = i.inputs.length;
		for (j < max) {
			if (!SsaConst.?(i.inputs[j].dest)) return (fold = false, null).last;
		}
		if (max >= 1) {
			x = i.input0();
			xconst = true;
			xval = SsaConst.!(x).val;
		}
		if (max >= 2) {
			y = i.input1();
			yconst = true;
			yval = SsaConst.!(y).val;
		}
		return xval;
	}
	def yis(val: int) -> bool {
		return yconst && if(wide, ylong == val, yint == val);
	}
	def yrange(min: int, max: int) -> bool {
		if (Debug.PARANOID && !yconst) return V3.fail("not const");
		if (wide) return min <= ylong && ylong <= max;
		else return min <= yint && yint <= max;
	}
	def yisPowerOf2() -> bool {
		return yconst && if(wide, (ylong & (ylong - 1)) == 0, (yint & (yint - 1)) == 0);
	}
	def ylog2() -> int {
		if (Debug.PARANOID && !yconst) return V3.fail("not const");
		return if(wide, Longs.log(u64.view(ylong)), Ints.log(u32.view(yint)));
	}
}

// Flow-sensitive state for local optimizations.
class SsaBlockState {
	var end: bool;
	var fields: List<(SsaInstr, IrField, SsaInstr)>;
	var inbounds: List<(SsaInstr, SsaInstr)>;
	var nonnull: List<SsaInstr>;
	var inits: List<IrMethod>;
	def clear() -> this {
		fields = null;
		nonnull = null;
		inits = null;
		inbounds = null;
		end = false;
	}
	def addField(receiver: SsaInstr, field: IrField, value: SsaInstr) {
		fields = List.new((receiver, field, value), fields);
	}
	def copy() -> SsaBlockState {
		var that = SsaBlockState.new();
		that.end = this.end;
		that.fields = this.fields;
		that.inbounds = this.inbounds;
		that.nonnull = this.nonnull;
		that.inits = this.inits;
		return that;
	}
}

// Optimizes SSA instructions one at a time, performing such optimizations
// as const folding, strength reduction, load elimination, and bounds check elimination.
class SsaInstrReducer(context: SsaContext) extends SsaInstrMatcher {
	var optimize_loads = true;		// activates load elimination
	var optimize_nullchecks = true;		// activates null check elimination
	var optimize_inits = false;		// activates init elimination
	var optimize_bounds = true;
	var remove_pure_ops = true;
	var graph: SsaGraph;
	var prev: SsaLink;  			// instruction before the current instruction
	var next: SsaLink;			// instruction after the current instruction
	var state = SsaBlockState.new();	// flow sensitive state

	def reset(graph: SsaGraph, block: SsaBlock, prev: SsaLink) {
		this.context.graph = graph;
		this.context.block = block;
		this.graph = graph;
		this.prev = prev;
		this.state.clear();
	}
	def reduceBlock(block: SsaBlock) {
		graph = context.graph;
		context.block = block;
		for (i = block.next; SsaInstr.?(i); ()) {
			next = i.next;
			reduceInstr(SsaInstr.!(i));
			if (state.end) break;
			i = next;
		}
	}
	def reducePhi(i: SsaPhi) -> bool {
		var i0 = i.input0(), facts = i0.facts, same = true;
		for (n = 1; n < i.inputs.length; n++) {
			var iN = i.inputs[n].dest;
			facts &= iN.facts;
			if (iN != i0) same = false;
		}
		if (same) {
			// phi(x, x, x...) => x
			i.replace(i0);
			return false;
		}
		i.facts |= facts;
		return true;
	}

	def reduceInstr(i: SsaInstr) -> SsaInstr {
		prev = i.prev;
		match (i) {
			x: SsaApplyOp => {
				var res = reduceApplyOp(x);
				if (res != x) {
					x.replace(res);
					x.remove();
				}
				return res;
			}
			x: SsaPhi => {
				var i0 = x.input0();
				return if(!reducePhi(x), i0, x);
			}
			x: SsaIf => {
				return reduceIf(x);
			}
			x: SsaGoto => {
				var cfopt = SsaCfOptimizer.new(context), block = x.block();
				if (cfopt.optEdge(block.succ(0))) next = prev.next;
				return x;
			}
			x: SsaSwitch => {
				var val = x.input0();
				if (SsaConst.?(val)) {
					var cfopt = SsaCfOptimizer.new(context), block = x.block();
					var succ = x.findSucc(SsaConst.!(val).val);
					cfopt.replaceWithGoto(block, x, succ);
					if (cfopt.optEdge(block.succ(0))) next = prev.next;
				}
				return x;
			}
		}
		return i;
	}
	def reduceIf(ifi: SsaIf) -> SsaInstr {
		var cond = ifi.input0(), block = ifi.block();
		if (SsaConst.?(cond)) {
			var cfopt = SsaCfOptimizer.new(context);
			cfopt.replaceWithGoto(block, ifi, block.succ(if(cond.unbox<bool>(), 0, 1)));
			if (cfopt.optEdge(block.succ(0))) next = prev.next;
		} else if (SsaApplyOp.?(cond)) {
			if (SsaApplyOp.!(cond).op.opcode == Opcode.BoolNot) {
				var cc = cond.input0();
				ifi.succs = [ifi.succs[1], ifi.succs[0]];
				ifi.inputs[0].update(cc);
				return ifi;
			}
			// XXX: optimize if(x == true|false) and if(x != true|false)
		}
		return ifi;
	}
	def reduceApplyOp(i: SsaApplyOp) -> SsaInstr {
		def PURE_LOAD = Fact.O_NO_NULL_CHECK | Fact.O_PURE;
		def ZERO_NON_ZERO = Fact.V_ZERO | Fact.V_NON_ZERO;
		def ABOVE_BELOW_ZERO = Fact.V_NON_ZERO | Fact.V_NON_NEGATIVE | Fact.V_BELOW_ZERO;
		if (remove_pure_ops && i.facts.O_PURE && i.useList == null) return killUnused(i);
		match (i.op.opcode) {
			BoolEq,
			IntEq,
			RefEq => {
				norm_binop(i);
				if (fold) return graph.boolConst(Values.equal(xval, yval));
				if (x == y) return graph.trueConst();
				var and = x.facts & y.facts, or = x.facts | y.facts;
				if (Facts.NONE != (and & Fact.V_ZERO)) return graph.trueConst(); // 0 == 0 == true
				// TODO: facts about variants are incorrect (null/zero confusion)
//TODO				if (ZERO_NON_ZERO == (or & ZERO_NON_ZERO)) return graph.falseConst(); // 0 == nonzero == false
				if (ABOVE_BELOW_ZERO == (or & ABOVE_BELOW_ZERO)) return graph.falseConst(); // neg == pos == false
			}
			VariantEq => {
				norm_binop(i);
				if (fold) return graph.boolConst(Values.equal(xval, yval));
				if (x == y) return graph.trueConst();
				var and = x.facts & y.facts, or = x.facts | y.facts;
				if (Facts.NONE != (and & Fact.V_ZERO)) return graph.trueConst(); // 0 == 0 == true
			}
			OverloadedEq => {
				norm_binop(i);
				if (fold) return graph.boolConst(Values.equal(xval, yval));
				var and = x.facts & y.facts;
				if (Facts.NONE != (and & Fact.V_ZERO)) return graph.trueConst(); // 0 == 0 == true
			}
			IntAdd => {
				var yint = norm_intbinop(i);
				if (fold) return fold2i(int.+, long.+); // K + K == K
				if (yzero) return x;                    // x + 0 == x
			}
			IntSub => {
				var yint = norm_intbinop(i);
				if (fold) return fold2i(int.-, long.-); // K - K == K
				if (yzero) return x;                    // x - 0 == x
			}
			IntMul => {
				var yint = norm_intbinop(i);
				if (yzero) return y;                    // x * 0 == 0
				if (fold) return fold2i(int.*, long.*); // K * K == K
				if (yconst) {
					if (yis(1)) return x;           // x * 1 == 1
					if (yis(-1)) return addBinop(inttype.opSub(), graph.zeroConst(), x);  // x * -1 == 0 - x
					if (yis(2)) return addBinop(inttype.opAdd(), x, x);
					if (yisPowerOf2()) {
						// x * 2^k == x << k
						return addBinop(inttype.opShl(), x, graph.intConst(ylog2())).setFact(Fact.O_NO_SHIFT_CHECK);
					}
				}
			}
			IntDiv => {
				var yint = norm_intbinop(i);
				if (yzero) return addThrow(i.source, V3Exception.DivideByZero); // fold x / 0
				if (fold) return fold4i(int./, u32./, long./, u64./);
				if (yconst) {
					i.facts |= Facts.O_SAFE_DIVIDE;
					if (yis(1)) return x;           // x / 1 == x
					if (yis(-1) && inttype.signed) return addBinop(inttype.opSub(), graph.zeroConst(), x); // x / -1 == 0 - x
					if (yisPowerOf2() && x.facts.V_NON_NEGATIVE) {
						// x / 2^k == x >> k
						return addBinop(inttype.opShr(), x, graph.intConst(ylog2())).setFact(Fact.O_NO_SHIFT_CHECK);
					}
				}
			}
			IntMod => {
				var yint = norm_intbinop(i);
				if (yzero) return addThrow(i.source, V3Exception.DivideByZero); // fold x % 0
				if (fold) return fold4i(int.%, u32.%, long.%, u64.%);
				if (yconst) {
					i.facts |= Facts.O_SAFE_DIVIDE;
					if (yis(1) || (yis(-1) && inttype.signed)) {
						// x % +/-1 == 0
						return if(wide, l_const(0), i_const(0));
					}
					if (yisPowerOf2() && x.facts.V_NON_NEGATIVE) {
						// x % 2^k == x & (2^k - 1)
						var mask = if(wide, l_const(ylong - 1), i_const(yint - 1));
						return addBinop(inttype.opAnd(), x, mask).setFact(Fact.V_NON_NEGATIVE);
					}
				}
				if ((x.facts & y.facts & Fact.V_NON_NEGATIVE) == Fact.V_NON_NEGATIVE) i.facts |= Fact.V_NON_NEGATIVE;
			}
			IntAnd => {
				norm_intbinop(i);
				if (yzero) return y;                    // x & 0 == 0
				if (fold) return fold2i(int.&, long.&); // K & K == K
				if (yconst && yis(-1)) return x;        // x & -1 == x
				// (nonneg & x) => nonneg
				i.facts |= ((x.facts | y.facts) & Fact.V_NON_NEGATIVE);
			}
			IntOr => {
				norm_intbinop(i);
				if (yzero) return x;                    // x | 0 == x
				if (fold) return fold2i(int.|, long.|); // K | K == K
				if (yconst && yis(-1)) return y;        // x | -1 == -1
				// (neg | x) => neg, (nonzero | x) => nonzero
				i.facts |= ((x.facts | y.facts) & (Fact.V_BELOW_ZERO | Fact.V_NON_ZERO));
			}
			IntXor => {
				norm_intbinop(i);
				if (yzero) return x;                     // x ^ 0 == x
				if (x == y) return graph.zeroConst();    // x ^ x == 0
				if (fold) return fold2i(int.^, long.^);  // K ^ K == K
				i.facts |= (x.facts & y.facts & Fact.V_NON_NEGATIVE);  // (nonneg ^ nonneg) => nonneg
				if ((x.facts & y.facts & Fact.V_BELOW_ZERO) == Fact.V_NON_NEGATIVE) i.facts |= Fact.V_NON_NEGATIVE;
			}
			IntShl => {
				var yint = norm_intbinop(i);
				if (yzero) return x; // x << 0 == x
				if (fold) {          // K << K == K
					if (wide) {
						var y6 = u6.view(ylong);
						return if(ylong == y6, l_const(xlong << y6), graph.zeroConst());
					} else {
						var y5 = u5.view(yint);
						return if(yint == y5, i_const(xint << y5), graph.zeroConst());
					}
				}
				if (yconst) {
					if (yrange(0, inttype.width - 1)) i.facts |= Fact.O_NO_SHIFT_CHECK;
					else return graph.zeroConst();
				} else {
					shiftcheck(i, y);
				}
			}
			IntSar => {
				var yint = norm_intbinop(i);
				if (yzero) return x;  // x >> 0 == x
				if (fold) {           // K >> K == K
					if (wide) {
						var y6 = u6.view(if(u64.view(ylong) > 63, 63, ylong));
						return l_const(xlong >> y6);
					} else {
						var y5 = u5.view(if(u32.view(yint) > 31, 31, yint));
						return i_const(xint >> y5);
					}
				}
				if (yconst) {
					if (!yrange(0, inttype.width - 1)) {
						if (x.facts.V_NON_NEGATIVE) return graph.zeroConst();
						if (x.facts.V_BELOW_ZERO) return graph.intConst(-1);
						i.inputs[1].update(graph.intConst(inttype.width - 1));
					}
					i.facts |= Fact.O_NO_SHIFT_CHECK;
				} else {
					shiftcheck(i, y);
				}
			}
			IntShr => {
				var yint = norm_intbinop(i);
				if (yzero) return x; // x >>> 0 = x
				if (fold) {          // K >>> K = K
					if (wide) {
						var y6 = u6.view(ylong);
						if (ylong == y6) return l_const(Eval.doIntTruncU64(inttype, xlong) >>> y6);
						return graph.zeroConst();
					} else {
						var y5 = u5.view(yint);
						if (yint == y5) return i_const(Eval.doIntTruncU32(inttype, xint) >>> y5);
						return graph.zeroConst();
					}
				}
				if (yconst) {
					if (yrange(0, inttype.width - 1)) i.facts |= Fact.O_NO_SHIFT_CHECK;
					else return graph.zeroConst();
				} else {
					shiftcheck(i, y);
				}
				if (y.facts.V_NON_ZERO) i.facts |= Fact.V_NON_NEGATIVE;
			}
			IntLt => {
				norm_intbinop(i);
				// XXX: range analysis for comparisons against constants, particularly 0
				if (fold) return fold4b(int.<, u32.<, long.<, u64.<);
			}
			IntLteq => {
				norm_intbinop(i);
				// XXX: range analysis for comparisons against constants, particularly 0
				if (fold) return fold4b(int.<=, u32.<=, long.<=, u64.<=);
			}
			IntViewI => {
				var xval = unop(i);
				if (xconst) {
					var ft = i.op.sig.paramTypes[0], tt = i.op.sig.returnType();
					return graph.valConst(tt, Eval.doIntView(IntType.!(ft), IntType.!(tt), xval));
				}
			}
			BoolAnd => {
				norm_binop(i);
				if (fold) return graph.boolConst(Bool.unbox(xval) && Bool.unbox(yval)); // K && K => K
				if (yconst) return if(Bool.unbox(yval), x, graph.falseConst()); // x && K => x
			}
			BoolOr => {
				norm_binop(i);
				if (fold) return graph.boolConst(Bool.unbox(xval) || Bool.unbox(yval)); // K || K => K
				if (yconst) return if(Bool.unbox(yval), graph.trueConst(), x);  // x || K => x
			}
			BoolNot => {
				var xval = unop(i);
				if (xconst) return graph.boolConst(!Bool.unbox(xval));  // !K  => K
				if (x.optag() == Opcode.BoolNot.tag) return x.input0();  // !!x => x
			}
			NullCheck => {
				var receiver = nullcheck(i);
				if (i.facts.O_NO_NULL_CHECK) return receiver;
			}
			BoundsCheck => {
				var receiver = boundscheck(i);
				if (state.end) return receiver;
				if (i.checkFact(Facts.O_SAFE_BOUNDS)) return killInstr(i);
			}
			TypeSubsume => {
				var xval = unop(i);
				var ft = i.op.typeArgs[0], tt = i.op.typeArgs[1];
				if (xconst) return graph.valConst(tt, xval);
				if (ft == tt) return x; // fold TypeSubsume<T, T>(x)
				if (tt == x.getType()) return x; // fold TypeSubsume<F, T>(x: T)
				match (tt.typeCon.kind) {
					CLASS => {
						if (ft == Null.TYPE) return graph.nullConst(tt);
						if (TypeSystem.isSubtype(ft, tt)) return x; // remove redundant subsume of class
					}
					ENUM_SET => {
						return addEnumToSet(EnumSetType.!(tt), x);
					}
					_ => ;
					// XXX: int subsume and tuples
				}
				if (x.facts.V_NON_ZERO) {
					i.facts |= Fact.O_NO_NULL_CHECK | Fact.V_NON_ZERO;
				}
			}
			TypeCast => {
				var ft = i.op.sig.paramTypes[0], tt = i.op.sig.returnType();
				var cast = TypeSystem.newTypeCast(ft, tt);
				if (i.inputs.length == 0) {
					// special cast of casting void -> X
					if (cast == TypeCast.THROW) return addThrow(i.source, V3Exception.TypeCheck); // fold TypeCast
					return i;
				}
				var xval = unop(i);
				if (xconst && cast != TypeCast.UNKNOWN_CAST) {
					var r = Eval.doCast(cast, ft, tt, xval);
					if (r.0) return graph.valConst(tt, r.1);
					else return addThrow(i.source, V3Exception.TypeCheck);
				}

				match (cast) {
					TRUE, SUBSUME => return x; // fold TypeCast
					THROW => {
						return addThrow(i.source, V3Exception.TypeCheck); // fold TypeCast
					}
					THROW_IF_NOT_NULL => {
						// TypeCast -> ConditionalThrow(x != null)
						var cmp = addNot(addEqual(ft, x, graph.nullConst(ft)));
						addConditionalThrow(i.source, V3Exception.TypeCheck, cmp);
						return graph.nullConst(tt);
					}
					INT_VIEW_I => {
						return replaceOp(i, V3Op.newIntViewI(ft, tt));
					}
					ENUM_TO_SET => {
						return addEnumToSet(EnumSetType.!(tt), x);
					}
					_ => {
						if (x.facts.V_NON_ZERO) {
							i.facts |= Fact.O_NO_NULL_CHECK | Fact.V_NON_ZERO;
						}
					}
				}
			}
			TypeQuery => {
				var ft = i.op.typeArgs[0], tt = i.op.typeArgs[1];
				var query = TypeSystem.newTypeQuery(ft, tt);
				if (i.inputs.length == 0) {
					// special cast of querying void -> X
					if (query == TypeQuery.TRUE) return graph.trueConst();
					if (query == TypeQuery.FALSE) return graph.falseConst();
					return i;
				}
				var xval = unop(i);
				if (xconst && query != TypeQuery.UNKNOWN_QUERY) {
					return graph.boolConst(Eval.doQuery(query, ft, tt, xval));
				}
				if (query == TypeQuery.TRUE) return graph.trueConst();
				if (query == TypeQuery.FALSE) return graph.falseConst();
				if (query == TypeQuery.TRUE_IF_NOT_NULL) return addNotEqual(ft, x, graph.nullConst(ft));
				if (x.facts.V_NON_ZERO) i.facts |= Fact.O_NO_NULL_CHECK;
			}
			ArrayAlloc => {
				var len = i.input0();
				if (len.facts.V_NON_NEGATIVE) i.facts |= Fact.O_NO_NEGATIVE_CHECK;
				state.addField(i, ARRAY_LENGTH_FIELD, i.input0());
			}
			ArrayInit => {
				if (i.op.isPolymorphic()) return i;
				n_op(i);
				if (true || !fold) return i;
				var arrayType = i.op.typeArgs[0];
				var record = context.prog.newRecord(arrayType, i.inputs.length);
				for (j < i.inputs.length) record.values[j] = SsaConst.!(i.inputs[j].dest).val;
				return graph.recordConst(record);
			}
			ArrayGetElem => {
				var receiver = boundscheck(i);
				if (state.end) return receiver;
				if (!i.facts.O_PURE) return i;
				var yval = norm_binop(i);
				// ArrayGetElem(#array, #index) => K
				if (fold) return graph.valConst(i.getType(), Record.!(xval).values[V3.unboxI32(yval)]);
			}
			ArraySetElem => {
				var receiver = boundscheck(i);
				if (state.end) return receiver;
			}
			ArrayGetLength => {
				var receiver = nullcheck(i);
				if (state.end) return receiver;
				var xval = unop(i);
				if (xconst) return graph.intConst(Record.!(xval).values.length);
				if (receiver.optag() == Opcode.ArrayInit.tag) {
					// ArrayGetLength(ArrayInit(...)) => |...|
					return graph.intConst(receiver.inputs.length);
				}
				if (receiver.optag() == Opcode.ArrayAlloc.tag) {
					// ArrayGetLength(ArrayAlloc(x)) => x
					return receiver.input0();
				}
				var len = lookupField(i, receiver, ARRAY_LENGTH_FIELD);
				if (len != i) return len;
			}
			ClassAlloc => {
				if (i.op.isPolymorphic()) return i;
				if (!i.facts.O_PURE) return i;
				n_op(i);
				if (!fold) return i;
				// ClassAlloc(#K, #K ..) => #K (variant)
				var classType = i.op.typeArgs[0];
				var record = context.prog.newRecord(classType, i.inputs.length);
				for (j < i.inputs.length) record.values[j] = SsaConst.!(i.inputs[j].dest).val;
				var ic = context.prog.ir.getIrClass(classType);
				if (ic != null) ic.facts |= Fact.C_HEAP;
				return graph.recordConst(record);
			}
			ClassGetField(field) => {
				var receiver = if(V3.isVariant(field.receiver), i.input0(), nullcheck(i));
				if (state.end) return receiver;
				if (field.isConst()) {
					if (SsaConst.?(receiver)) {
						// ClassGetField(#K) => #K
						return graph.valConst(getFieldType(i.op, field),
							asRecord(receiver).values[field.index]);
					}
					i.setFactIf(Fact.O_NO_NULL_CHECK, Fact.O_PURE);
					i.facts |= Fact.F_VALUE;
					if (remove_pure_ops && i.facts.O_PURE && i.useList == null) return killUnused(i);
					return lookupField(i, receiver, field);
				}
			}
			ClassInitField(field) => {
				i.facts |= Fact.O_NO_NULL_CHECK;
				if (field.isConst()) state.addField(i.input0(), field, i.input1());  // forward stores
			}
			ClassSetField(field) => {
				var receiver = nullcheck(i);
				if (state.end) return receiver;
				if (field.isConst()) state.addField(receiver, field, i.input1());  // forward stores
			}
			ClassGetMethod(method) => {
				var meth = V3Op.extractIrSpec(i.op, method);
				var receiver = nullcheck(i);
				if (state.end) return receiver;
				if (i.op.isPolymorphic()) return i;
				var xval = unop(i);
				if (xconst) {
					// ClassGetMethod[m](#K) => (m, #K)
					var obj = Record.!(xval);
					return graph.valConst(meth.getBoundType(), Closure.new(obj, meth));
				}
			}
			ClassGetVirtual(method) => {
				var meth = V3Op.extractIrSpec(i.op, method);
				var receiver = nullcheck(i);
				if (state.end) return receiver;
				var dv = devirtualize(meth, receiver);
				if (dv != null) {
					var xval = unop(i);
					if (xconst && !i.op.isPolymorphic()) {  // ClassGetVirtual[m](K) => (m, K)
						var obj = Record.!(xval);
						return graph.valConst(dv.getBoundType(), Closure.new(obj, dv));
					}
					return replaceOp(i, V3Op.newClassGetMethod(dv));  // ClassGetVirtual[m](K) => ClassGetMethod[m](K)
				}
			}
			VariantGetMethod(method) => {
				var meth = V3Op.extractIrSpec(i.op, method);
				var receiver = i.input0();
				if (i.op.isPolymorphic()) return i;
				var xval = unop(i);
				if (xconst) {
					// VariantGetMethod[m](#K) => (m, #K)
					var obj = Record.!(xval);
					return graph.valConst(meth.getBoundType(), Closure.new(obj, meth));
				}
			}
			VariantGetVirtual(method) => {
				var meth = V3Op.extractIrSpec(i.op, method);
				var receiver = i.input0();
				var dv = devirtualize(meth, receiver);
				if (dv != null) {
					var xval = unop(i);
					if (xconst && !i.op.isPolymorphic()) {  // VariantGetVirtual[m](K) => (m, K)
						var obj = Record.!(xval);
						return graph.valConst(dv.getBoundType(), Closure.new(obj, dv));
					}
					return replaceOp(i, V3Op.newCreateClosure(dv, i.op.typeArgs[0]));  // VariantGetVirtual[m](K) => CreateClosure[m](K)
				}
			}
			ClassGetSelector(method) => {
				var meth = V3Op.extractIrSpec(i.op, method);
				var receiver = if(V3.isVariant(meth.receiver), i.input0(), nullcheck(i));
				if (state.end) return receiver;
				var dv = devirtualize(meth, receiver);
				if (dv != null) return graph.valConst(dv.getFuncType(), FuncVal.new(dv));
			}
			Init(method) => {
				if (!optimize_inits) return i;
				for (l = state.inits; l != null; l = l.tail) {
					if (l.head == method) return null;  // init[m]; init[m] => init[m]
				}
				state.inits = List.new(method, state.inits);
			}
			ComponentGetField(field) => {
				var sf = VstField.!(field.source);
				if (sf != null && sf.writability == Writability.READ_ONLY) {
					if (Literal.?(sf.init)) {  // C.f => K
						var lit = Literal.!(sf.init);
						var const = graph.valConst(lit.exactType, lit.val);
						return if(lit.exactType != field.fieldType, convert(const, field.fieldType), const);
					}
				}
				if (field.isConst()) return lookupField(i, null, field);
			}
			ComponentSetField(field) => {
				if (field.isConst()) state.addField(null, field, i.input1());  // forward stores
			}
			TupleCreate(length) => {
				if (i.op.isPolymorphic()) return i;
				n_op(i);
				if (!fold) return i;
				// (K, ..., K) => K
				var tupleType = i.op.typeArgs[0];
				var inputs = i.inputs;
				var vals = Array<Val>.new(inputs.length);
				for (j < inputs.length) vals[j] = SsaConst.!(inputs[j].dest).val;
				return graph.valConst(i.op.sig.returnType(), BoxVal.new(null, vals));
			}
			TupleGetElem(index) => {
				var xval = unop(i);
				if (xconst) {
					// fold K.N
					var tupleType = i.op.typeArgs[0];
					var val = BoxVal.!(xval), t = Lists.get(tupleType.nested, index);
					return graph.valConst(t, if(val != null, val.values[index], null));
				}
				if (x.optag() == Opcode.TupleCreate.tag) {
					// TupleGetElem[n](x:TupleCreate(...)) => x[n]
					return SsaApplyOp.!(x).inputs[index].dest;
				}
			}
			CallMethod(method) => {
				i.facts |= method.facts & Fact.O_PURE;
				if (i.inputs.length > 0 && i.input0().facts.V_NON_ZERO) i.facts |= Fact.O_NO_NULL_CHECK;
			}
			CallClassMethod(method) => {
				i.facts |= method.facts & Fact.O_PURE;
				var target = nullcheck(i);
				if (SsaThrow.?(target)) return target;
				if (i.inputs.length > 0 && i.input0().facts.V_NON_ZERO) i.facts |= Fact.O_NO_NULL_CHECK;
			}
			CallClassVirtual(method) => {
				var receiver = i.input0(), meth = V3Op.extractIrSpec(i.op, method);
				receiver = nullcheck(i);
				if (state.end) return receiver;
				if (i.input0().facts.V_NON_ZERO) i.facts |= Fact.O_NO_NULL_CHECK;
				var dv = devirtualize(meth, receiver);
				if (dv != null) return replaceOp(i, V3Op.newCallClassMethod(dv));  // CallClassVirtual[m](K) => CallClassMethod[m](k)
			}
			CallVariantVirtual(method) => {
				var receiver = i.input0(), meth = V3Op.extractIrSpec(i.op, method);
				if (i.input0().facts.V_NON_ZERO) i.facts |= Fact.O_NO_NULL_CHECK;
				var dv = devirtualize(meth, receiver);
				if (dv != null) return replaceOp(i, V3Op.newCallMethod(dv));  // CallVariantVirtual[m](K) => CallMethod[m](k)
			}
			CallClosure => {
				var target = nullcheck(i);
				if (SsaThrow.?(target)) return target;
				var xval = unop(i);
				if (xconst) {
					var d = Closure.!(xval);
					if (d == null) return addThrow(i.source, V3Exception.NullCheck);
					// CallClosure(K) => CallMethod
					var const = graph.valConst(d.memberRef.getClosureReceiver(), d.val);
					var op = V3Op.newCallMethod(d.memberRef);
					var inputs = normSingleArg(op, copyInputs(i, const, 1));
					return add(i.source, op, inputs).setFact(Fact.O_NO_NULL_CHECK);
				}
				if (!SsaApplyOp.?(x)) return i;
				var xop = SsaApplyOp.!(x).op;
				match (xop.opcode) {
					ClassGetMethod(method) => {
						// CallClosure(GetClassMethod) => CallMethod
						var op = V3Op.newCallMethod(V3Op.extractIrSpec(xop, method));
						var inputs = normSingleArg(op, copyInputs(i, x.input0(), 1));
						var ni = add(i.source, op, inputs);
						ni.facts |= i.facts & Fact.O_NO_NULL_CHECK;
						return ni;
					}
					ClassGetVirtual(method) => {
						// CallClosure(GetClassVirtual) => CallClassVirtual
						var op = V3Op.newCallClassVirtual(V3Op.extractIrSpec(xop, method));
						var inputs = normSingleArg(op, copyInputs(i, x.input0(), 1));
						var ni = add(i.source, op, inputs);
						ni.facts |= i.facts & Fact.O_NO_NULL_CHECK;
						return ni;
					}
					CreateClosure(method) => {
						var spec = V3Op.extractIrSpec(xop, method);
						// CallClosure(CreateClosure[m](p), ...) => CallMethod(p, ...);
						var receiver = if (V3.isComponent(spec.receiver), graph.nullReceiver(), x.input0());
						var op = V3Op.newCallMethod(spec);
						var inputs = normSingleArg(op, copyInputs(i, receiver, 1));
						var ni = add(i.source, op, inputs);
						if (V3.isComponent(spec.receiver)) ni.facts |= Fact.O_NO_NULL_CHECK;
						else ni.facts |= x.facts & Fact.O_NO_NULL_CHECK;
						return ni;
					}
					_ => ;
				}
			}
			CallFunction => {
				var target = nullcheck(i);
				if (SsaThrow.?(target)) return target;
				var xval = unop(i);
				if (xconst) {
					var d = FuncVal.!(xval);
					if (d == null) return addThrow(i.source, V3Exception.NullCheck);
					// CallFunction(#K) => CallMethod
					var inputs = copyInputs(i, null, 1);
					return add(i.source, V3Op.newCallMethod(d.memberRef), inputs).setFact(Fact.O_NO_NULL_CHECK);
				}
			}
			CreateClosure(method) => {
				if (i.op.isPolymorphic()) return i;
				var xval = unop(i);
				if (!fold) return i;
				// CreateClosure(#K) => #K
				var spec = V3Op.extractIrSpec(i.op, method);
				return graph.valConst(spec.getBoundType(), Closure.new(xval, spec));
			}
			VariantGetTag => {
				var xval = unop(i);
				if (fold) {
					// GetVariantTag(#K) => #K
					if (Record.?(xval)) return graph.intConst(V3.getVariantTag(Record.!(xval).rtype));
					return graph.intConst(V3.unboxI32(xval));
				}
			}
			ConditionalThrow(exception) => {
				var xval = unop(i);
				if (!fold) return i;
				// ConditionalThrow(#K) => throw | nop
				if (Bool.unbox(xval)) return addThrow(i.source, exception);
				else return killInstr(i);
			}
			_ => ;
		}
		return i;
	}
	def normSingleArg(op: Operator, args: Array<SsaInstr>) -> Array<SsaInstr> {
		if (op.sig.paramTypes.length == 1 && args.length > 1) return [args[0]];
		return args;
	}
	def norm_binop(i: SsaApplyOp) -> Val {
		if (i.inputs.length != 2) norm2(i);
		return binop(i);
	}
	def norm_intbinop(i: SsaApplyOp) -> int {
		if (i.inputs.length != 2) norm2(i);
		return intbinop(i);
	}
	def norm2(i: SsaApplyOp) {
		var t = i.input0();
		var x = SsaApplyOp.new(null, V3Op.newTupleGetElem(t.getType(), 0), [t]);
		var y = SsaApplyOp.new(null, V3Op.newTupleGetElem(t.getType(), 1), [t]);
		i.inputs[0].update(null);
		x.insertBefore(i);
		y.insertBefore(i);
		i.setInputs([x, y]);
	}
	def fold4b(s: (int, int) -> bool, u: (u32, u32) -> bool, sl: (long, long) -> bool, ul: (u64, u64) -> bool) -> SsaInstr {
		if (!wide) return graph.boolConst(if(inttype.signed, s(xint, yint), u(u32.view(xint), u32.view(yint))));
		else return graph.boolConst(if(inttype.signed, sl(xlong, ylong), ul(u64.view(xlong), u64.view(ylong))));
	}
	def fold4i(s: (int, int) -> int, u: (u32, u32) -> u32, sl: (long, long) -> long, ul: (u64, u64) -> u64) -> SsaInstr {
		if (!wide) return if(inttype.signed, i_const(s(xint, yint)), u_const(u(u32.view(xint), u32.view(yint))));
		else return if(inttype.signed, l_const(sl(xlong, ylong)), lu_const(ul(u64.view(xlong), u64.view(ylong))));
	}
	def fold2i(s: (int, int) -> int, sl: (long, long) -> long) -> SsaInstr {
		return if(wide, l_const(sl(xlong, ylong)), i_const(s(xint, yint)));
	}

	def copyInputs(i: SsaInstr, prepend: SsaInstr, start: int) -> Array<SsaInstr> {
		var extra = if(prepend != null, 1);
		var inputs = Array<SsaInstr>.new(i.inputs.length - start + extra);
		if (extra > 0) inputs[0] = prepend;
		for (j = extra; j < inputs.length; j++) inputs[j] = i.inputs[j + start - extra].dest;
		return inputs;
	}
	def killInstr(i: SsaInstr) -> SsaInstr {
		i.remove();
		i.kill();
		i.facts |= Fact.O_KILLED;
		return i;
	}

	def i_const(v: int) -> SsaInstr {
		return graph.intConst(Eval.doIntTrunc32(inttype, v));
	}
	def u_const(v: u32) -> SsaInstr {
		return graph.intConst(Eval.doIntTrunc32(inttype, int.view(v)));
	}
	def l_const(v: long) -> SsaInstr {
		return graph.valConst(inttype, Long.box(Eval.doIntTrunc64(inttype, v)));
	}
	def lu_const(v: u64) -> SsaInstr {
		return graph.valConst(inttype, Long.box(Eval.doIntTrunc64(inttype, long.view(v))));
	}
	def shiftcheck(i: SsaApplyOp, y: SsaInstr) -> SsaInstr {
		var bound = posIntBound(y);
		if (bound >= 0 && bound < IntType.!(i.op.sig.returnType()).width) {
			i.facts |= Fact.O_NO_SHIFT_CHECK;
		}
		return i;
	}
	def boundscheck(i: SsaApplyOp) -> SsaInstr {
		var receiver = nullcheck(i);
		if (!optimize_bounds) return i;
		// XXX: introduce partial bounds checks when length is a known constant.
		if (state.end) return receiver;
		if (findPriorBoundsCheck(i, receiver, i.input1())) return receiver;
		// Initialize the match state for {x} and {y}.
		var yval = binop(i);
		if (yconst && V3.unboxI32(yval) < 0) {
			// will always throw out of bounds, but might need a null check first.
			if (!i.facts.O_NO_NULL_CHECK) addExplicitNullCheck(i.source, receiver);
			return addThrow(i.source, V3Exception.BoundsCheck);
		}
		// Compute the constant length of the array if possible.
		var length = -1;
		if (xconst) {
			length = Record.!(xval).values.length;
		} else if (x.optag() == Opcode.ArrayAlloc.tag) {
			var l = x.inputs[0].dest;
			if (!SsaConst.?(l)) return receiver;
			length = l.unbox<int>();
		} else if (x.optag() == Opcode.ArrayInit.tag) {
			length = x.inputs.length;
		} else {
			return receiver;
		}

		if (yconst) {
			// Array length and index are constants. Static bounds check.
			var index = V3.unboxI32(yval);
			if (index < length) {
				i.facts |= Facts.O_SAFE_BOUNDS;
				return receiver;
			}
			return addThrow(i.source, V3Exception.BoundsCheck);
		}
		// Array length is a constant, try range analysis of the index.
		var bound = posIntBound(y);
		if (bound >= 0 && bound < length) i.facts |= Facts.O_SAFE_BOUNDS;
		return receiver;
	}
	def findPriorBoundsCheck(i: SsaInstr, x: SsaInstr, y: SsaInstr) -> bool {
		for (l = state.inbounds; l != null; l = l.tail) {
			var t = l.head;
			if (t.0 == x) {
				i.facts |= Fact.O_NO_NULL_CHECK;
				if (t.1 == y) {
					i.facts |= Fact.O_NO_BOUNDS_CHECK;
					return true;
				}
				if (SsaConst.?(t.1) && SsaConst.?(y)) {
					var p = V3.unboxI32(SsaConst.!(t.1).val), yy = V3.unboxI32(SsaConst.!(y).val);
					if (p >= 0 && p >= yy) {
						i.facts |= Fact.O_NO_BOUNDS_CHECK;
						return true;
					}
				}
			}
		}
		state.inbounds = List.new((x, y), state.inbounds);
		return false;
	}
	def addExplicitNullCheck(source: Source, receiver: SsaInstr) -> SsaInstr {
		var t = receiver.getType();
		var check = add(source, V3Op.newEqual(t), [receiver, graph.nullConst(t)]);
		return add(source, V3Op.newConditionalThrow(V3Exception.NullCheck), [check]);
	}
	def posIntBound(x: SsaInstr) -> int {
		if (SsaConst.?(x)) {
			var val = SsaConst.!(x).val;
			if (val == null) return 0;
			if (Box<int>.?(val)) return Box<int>.!(val).val;
			return -1;
		}
		var bound = posIntBoundFromType(x);
		if (!SsaApplyOp.?(x)) return bound;
		var i = SsaApplyOp.!(x);
		match (i.op.opcode) {
			IntAnd => {
				var lb = posIntBound(i.input0()), rb = posIntBound(i.input1());
				if (bound < 0 || (lb >= 0 && lb < bound)) bound = lb;
				if (bound < 0 || (rb >= 0 && rb < bound)) bound = rb;
			}
			VariantGetTag => {
				var c = ClassType.!(i.op.typeArgs[0]).classDecl;
				var b = if(c.isVariantCase(), c.variantTag, c.cases.length - 1);
				if (b < bound) bound = b;
			}
			IntViewI, TypeSubsume, TypeCast => {
				var b = posIntBound(i.input0());
				if (bound < 0 || (b >= 0 && b < bound)) {
					var t = i.getType();
					if (IntType.?(t)) {
						// conversion to smaller signed type might overflow.
						var it = IntType.!(t);
						if (it.signed && it.width <= 32 && b > V3.unboxI32(it.max)) b = bound;
					}
					bound = b;
				}
			}
			_ => ;
		}
		return bound;
	}
	def posIntBoundFromType(x: SsaInstr) -> int {
		var t = x.getType();
		if (IntType.?(t)) {
			var it = IntType.!(t);
			if (it.width > 32) return -1;
			if (!it.signed || x.facts.V_NON_NEGATIVE) return V3.unboxI32(it.max);
		}
		if (EnumType.?(t)) {
			return EnumType.!(t).enumDecl.cases.length - 1;
		}
		return -1;
	}

	def nullcheck(i: SsaApplyOp) -> SsaInstr {
		var receiver = i.input0();
		if (i.facts.O_NO_NULL_CHECK) return receiver;
		if (receiver.facts.V_NON_ZERO) {
			i.facts |= Fact.O_NO_NULL_CHECK;
			return receiver;
		}
		if (receiver.facts.V_ZERO) return addThrow(i.source, V3Exception.NullCheck);
		if (!optimize_nullchecks) return receiver;
		for (l = state.nonnull; l != null; l = l.tail) {
			if (l.head == receiver) {
				i.facts |= Fact.O_NO_NULL_CHECK;
				return receiver;
			}
		}
		state.nonnull = List.new(receiver, state.nonnull);
		return receiver;
	}
	def lookupField(load: SsaInstr, receiver: SsaInstr, field: IrField) -> SsaInstr {
		if (!optimize_loads) return load;
		for (l = state.fields; l != null; l = l.tail) {
			var h = l.head;
			if (h.0 == receiver && h.1 == field) return h.2;
		}
		state.addField(receiver, field, load);
		return load;
	}
	def devirtualize(m: IrSpec, x: SsaInstr) -> IrSpec {
		if (!m.member.facts.M_OVERRIDDEN) {
			return m; // CHA devirtualization
		} else if (SsaConst.?(x) && asRecord(x) != null) {
			return context.prog.ir.resolveMethodImpl(asRecord(x).rtype, m); // devirtualize K
		} else if (x.optag() == Opcode.ClassAlloc.tag) {
			return context.prog.ir.resolveMethodImpl(SsaApplyOp.!(x).op.typeArgs[0], m); // devirtualize ClassAlloc
		}
		return null;
	}

	def asRecord(i: SsaInstr) -> Record {
		return Record.!(SsaConst.!(i).val);
	}
	def getFieldType(op: Operator, field: IrField) -> Type {
		return if(op.isPolymorphic(), V3Op.extractIrSpec(op, field).getFieldType(), field.fieldType);
	}

	//======================================================================
	// Editing helpers
	//======================================================================
	def addThrow(source: Source, exception: string) -> SsaInstr {
		if (state.end) return null;
		state.end = true;
		var cfopt = SsaCfOptimizer.new(context);
		return cfopt.insertThrow(prev.next, source, exception, null);
	}
	def addConditionalThrow(source: Source, exception: string, cond: SsaInstr) -> SsaInstr {
		return add(source, V3Op.newConditionalThrow(exception), [cond]);
	}
	def addBinop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return add(null, op, [x, y]);
	}
	def replaceOp(i: SsaApplyOp, op: Operator) -> SsaInstr {
		var args = Array<SsaInstr>.new(i.inputs.length);
		for (j < args.length) args[j] = i.inputs[j].dest;
		var ni = add(i.source, op, args);
		ni.facts |= i.facts;
		return ni;
	}
	def convert(i: SsaConst, t: Type) -> SsaInstr {
		if (i.vtype == t) return i;
		var r = Eval.doCast0(i.vtype, t, i.val);
		return graph.valConst(t, r.1);
	}
	def addEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(!state.end, addBinop(V3Op.newEqual(t), x, y));
	}
	def addNotEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(!state.end, addNot(addBinop(V3Op.newEqual(t), x, y)));
	}
	def addNot(x: SsaInstr) -> SsaInstr {
		return if(!state.end, add(null, V3Op.opBoolNot, [x]));
	}
	def addEnumToSet(tc: EnumSetType, x: SsaInstr) -> SsaInstr {
		// XXX: reduce duplication with V3EnumSet_TypeCon
		var one = graph.valConst(tc.repType, tc.repType.box(1));
		var i = add(null, tc.repType.opShl(), [one, x]);
		i.facts |= Fact.O_NO_SHIFT_CHECK;
		return i;
	}
	def add(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		if (state.end) return null;
		var i = SsaApplyOp.new(source, op, args);
		i.insertBefore(prev.next);
		i.facts |= Opcodes.facts(op.opcode);
		prev = i;
		return i;
	}
	def killUnused(i_old: SsaInstr) -> SsaInstr {
		i_old.kill();
		i_old.remove();
		return graph.nop();
	}
}

// Performs control flow optimizations on a completed SsaGraph.
class SsaCfOptimizer(context: SsaContext) {
	def mark = ++context.graph.markGen;
	def queue = Vector<SsaBlock>.new();

	def optimize() {
		// visit all the blocks of the graph
		// 1. reduce phis with identical inputs
		// 2. merge straight-line blocks (may introduce critical edges)
		// 3. optimize diamond-if patterns arising from if(a && b) patterns
		// 4. XXX iteratively reduce/fold code
		// 5. collapse if-chains into switches, esp if(T.?(e)) ...
		// 6. XXX remove useless branches
		queueBlock(context.graph.startBlock);
		for (i < queue.length) optBlock(queue[i]);
	}
	def queueBlock(block: SsaBlock) {
		if (block.mark < mark) {
			block.mark = mark;
			queue.put(block);
		}
	}
	def optBlock(block: SsaBlock) {
		if (block.facts.O_KILLED) return;
		var next = block.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			var nn = next.next;
			optPhi(SsaPhi.!(next));
			next = nn;
		}
		var i = 0, succ = block.succs();
		while (i < succ.length) {
			if (optEdge(succ[i])) {
				i = 0;
				succ = block.succs();
			} else {
				i++;
			}
		}
		var end = block.end();
		if (SsaIf.?(end)) {
			optIf(block, SsaIf.!(end));
		}
		for (s in block.succs()) {
			if (s.dest != null) queueBlock(s.dest);
		}
	}
	def optPhi(phi: SsaPhi) -> bool {
		var inputs = phi.inputs;
		if (inputs.length == 0) return true; // phi has no remaining inputs
		var i0 = inputs[0].dest;
		if (i0 == null || phi.useList == null) {
			// one of the inputs is dead, or the phi is unused
			killInstr(phi);
			return true;
		}
		var facts = i0.facts, reduce = true;
		for (i in inputs) {
			var d = i.dest;
			if (d != phi) {
				facts = facts & d.facts;
				if (d != i0) reduce = false;
			}
		}
		if (reduce) {
			phi.replace(i0); // the phi can be replaced by its (one) input
			phi.remove();
			return true;
		} else {
			phi.setFact(facts); // phi facts are the intersection of all input facts
			return false;
		}
	}
	def optIf(block: SsaBlock, sw: SsaIf) {
		var e = sw.inputs[0], v = e.dest;
		if (SsaApplyOp.?(v)) {
			var cond = SsaApplyOp.!(v);
			if (Opcode.TypeQuery.?(cond.op.opcode)) {
				// propagate type query success on true successor
				var queryTypes = cond.op.typeArgs;
				applyDominatorOptForInput0(cond.input0(), sw.succs[0], optFoldCast(_, queryTypes));
			} else if (Opcode.RefEq.?(cond.op.opcode)) {
				tryPropagatingCmpNonZero(cond, sw.succs[0], sw.succs[1]);
			} else if (Opcode.IntEq.?(cond.op.opcode)) {
				tryPropagatingCmpNonZero(cond, sw.succs[0], sw.succs[1]);
				tryBuildingSwitch(block, sw, cond.op.typeArgs[0], cond);
			}
			return;
		}
		// Fold branches.
		if (SsaConst.?(v)) {
			var cond = SsaConst.!(v);
			replaceWithGoto(block, sw, block.succ(if(cond.unbox<bool>(), 0, 1)));
			return;
		}

		// match and simplify a control flow pattern where the input to a switch
		// is the merge of a previous branch; e.g. this occurs in if(a && b)

		if (block.next != v) return; // condition not defined as only phi in this block
		if (v.next != sw) return; // more instructions in this block
		if (!SsaPhi.?(v)) return; // branch condition is not a phi
		var phi = SsaPhi.!(v);
		if (!e.isOnlyEdge()) return; // condition is used elsewhere as well

		// search for and remove inputs to the phi that are constants
		var ivec = Vector<SsaInstr>.new(), evec = Vector<SsaCfEdge>.new();
		var inputs = phi.inputs, edges = block.preds;
		for (i < inputs.length) {
			var input = inputs[i], edge = edges[i];
			if (SsaConst.?(input.dest)) {
				// redirect incoming edge to outgoing edge
				var succ = sw.findSucc(SsaConst.!(input.dest).val);
				appendPhiInput(succ.dest, succ.desti);
				edge.connect(succ.dest);
				optEdge(edge);
				input.update(null); // kill the use of the value
			} else {
				ivec.put(input.dest);
				evec.put(edge);
			}
		}

		if (ivec.length == phi.inputs.length) return; // no updates
		if (ivec.length == 0) return killBlock(block); // no predecessors remain
		block.preds = evec.extract();
		if (ivec.length == 1) {
			e.update(ivec[0]); // only one input remains
			optEdge(block.preds[0]);
		} else {
			// more than one input to this phi is remaining, build a new phi
			var newPhi = SsaPhi.new(phi.getType(), block, ivec.extract());
			block.prepend(newPhi);
			e.update(newPhi);
		}
		phi.remove();
	}
	def tryPropagatingCmpNonZero(cmp: SsaApplyOp, eqEdge: SsaCfEdge, neEdge: SsaCfEdge) {
		var left = cmp.input0(), right = cmp.input1();
		if (left.facts.V_NON_ZERO) {
			return applyDominatorOptForInput0(right, eqEdge, optNullCheck);
		}
		if (left.facts.V_ZERO) {
			return applyDominatorOptForInput0(right, neEdge, optNullCheck);
		}
		if (right.facts.V_NON_ZERO) {
			return applyDominatorOptForInput0(left, eqEdge, optNullCheck);
		}
		if (right.facts.V_ZERO) {
			return applyDominatorOptForInput0(left, neEdge, optNullCheck);
		}
	}
	def matchSwitchCmp(key: SsaInstr, block: SsaBlock) -> SwitchCmp {
		// XXX: match commute constants, etc.
		var end = block.end();
		if (!SsaIf.?(end)) return null;
		var i = SsaIf.!(end);
		var edge = i.inputs[0];
		if (!edge.isOnlyEdge()) return null;
		var cmp = edge.dest;
		if (cmp.optag() != Opcode.IntEq.tag) return null;
		if (cmp.inputs[0].dest != key) return null;
		var r = cmp.inputs[1].dest;
		if (!SsaConst.?(r)) return null;
		return SwitchCmp.new(V3.unboxI32(SsaConst.!(r).val), cmp, i, block.succ(0), block.succ(1));
	}
	def verifySwitchCmpBlock(cmp: SwitchCmp, block: SsaBlock) -> bool {
		for (i = block.next; i != block; i = i.next) {
			if (i != cmp.cmp && i != cmp.end) return false;
		}
		return true;
	}
	def tryBuildingSwitch(block: SsaBlock, sw: SsaIf, t: Type, cmp: SsaInstr) {
		if (!context.compiler.EmitSwitch) return;
		if (!IntType.?(t)) return;
		var it = IntType.!(t);
		if (it.width > 32) return;
		var key = cmp.input0();
		var cmp = matchSwitchCmp(key, block);
		if (cmp == null) return;
		var vec = Vector<SwitchCmp>.new();
		vec.put(cmp);
		// add switch case candidates to the list.
		while (true) {
			if (cmp.fSucc.dest.preds.length != 1) break;
			var block = cmp.fSucc.dest;
			cmp = matchSwitchCmp(key, block);
			if (cmp == null) break;
			if (!verifySwitchCmpBlock(cmp, block)) break;
			vec.put(cmp);
		}

		// determine if building a table would be profitable.
		if (vec.length < 4) return;  // not enough cases.
		var min = Int.MAX_VALUE, max = Int.MIN_VALUE;
		for (i < vec.length) {
			var v = vec[i].val;
			if (v < min) min = v;
			if (v > max) max = v;
		}
		var diff = u32.!(max - min) + 1;
		if (diff > vec.length * 2) return; // table would be less than 50% full.
		if (diff > int.max) return;  // table would be too large.
		var size = int.view(diff);
		var table = Array<SsaCfEdge>.new(size);
		// build dispatch table.
		for (i = vec.length - 1; i >= 0; i--) {
			var c = vec[i], index = c.val - min;
			var p = table[index];
			if (p != null) removeEdge(p);
			table[index] = c.tSucc;
		}
		if (min != 0) {
			var sub = SsaApplyOp.new(null, it.opSub(), [key, context.graph.valConst(it, Int.box(min))]);
			key = sub;
			block.append(sub);
			max = max - min;
			min = 0;
		}
		var sw = SsaSwitch.new(key.getType(), max, key);
		// build array of successor edges.
		var dmerge: SsaBlock;
		for (i < size) {
			var e = table[i];
			if (e == null) {  // hole in the table; go to default
				if (dmerge == null) dmerge = SsaBlock.new();
				sw.succs[i].connect(dmerge);
			} else {
				replaceEdge(e, sw.succs[i]);
			}
		}
		// set up default edge.
		var defedge = vec[vec.length - 1].fSucc;
		if (dmerge != null) {
			sw.succs[size].connect(dmerge);
			var goto = SsaGoto.new(null);
			dmerge.append(goto);
			replaceEdge(defedge, goto.succs[0]);
		} else {
			replaceEdge(defedge, sw.succs[size]);
		}

		// Remove the ifs and comparisons from the end of the blocks.
		for (i < vec.length) {
			var c = vec[i];
			c.end.kill();
			c.end.remove();
			c.cmp.kill();
			c.cmp.remove();
		}

		// Replace the first if with a switch.
		block.append(sw);
	}
	def killBlock(block: SsaBlock) {
		if (block.facts.O_KILLED) return;
		// Recursively kill this block and its successor blocks
		block.facts |= Fact.O_KILLED;
		var succs = block.succs();
		var i = block.next;
		while (i != null) {
			// Kill all instructions in the block
			var n = i.next;
			i.next = null;
			i.prev = null;
			if (SsaInstr.?(i)) {
				var j = SsaInstr.!(i);
				j.kill();
				j.facts |= Fact.O_KILLED;
			}
			i = n;
		}
		killSuccs(succs);
	}
	def killSuccs(edges: Array<SsaCfEdge>) {
		// kill the outgoing control flow edges
		var succs = Vector<SsaBlock>.new();
		for (s in edges) {
			var d = s.dest;
			if (d != null) {
				removeEdge(s);
				succs.put(d);
			}
		}
		// kill any dead successor blocks.
		for (i < succs.length) {
			var d = succs[i];
			if (!d.hasPred()) killBlock(d);
		}
	}
	def killInstr(i: SsaInstr) -> SsaInstr {
		i.remove();
		i.kill();
		i.facts |= Fact.O_KILLED;
		return i;
	}
	def optEdge(edge: SsaCfEdge) -> bool {
		var src = edge.src, dest = edge.dest;
		if (dest == null) return false; // edge may have already been optimized away
		if (dest.preds.length > 1) return false; // destination has more than one predecessor
		if (src.succs.length > 1) {
			// try to skip the destination block
			if (dest.succs().length != 1) return false;	// doesn't end with a goto
			if (!dest.empty()) return false;		// is not empty
			var destdest = dest.succ(0).dest;
			if (destdest.hasPhis()) return false;		// has phis
			simplifyPhis(dest);
			edge.connect(destdest);				// redirect edge
			killBlock(dest);				// try to kill the destination
			return true;
		}
		// Kill the end of the previous block
		var block = src.block();
		if (block == null) return V3.fail1("block of @%d is null", src.uid);
		src.kill();
		src.remove();

		// Move destination instructions, including end, into source
		simplifyPhis(dest);
		var first = dest.next, end = dest.end();
		first.prev = null;
		end.next = null;
		if (first != null) block.appendN(first);
		return true;
	}
	def appendPhiInput(dest: SsaBlock, index: int) {
		// add a new edge X -> B, using A's input to each phi as X's input
		var next = dest.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			// for each phi, add a new input corresponding to this edge
			var phi = SsaPhi.!(next);
			var input = phi.inputs[index].dest;
			phi.inputs = Arrays.append(SsaDfEdge.new(phi, input), phi.inputs);
			next = next.next;
		}
	}
	def replaceEdge(abEdge: SsaCfEdge, xbEdge: SsaCfEdge) {
		// replace the old edge A -> B with a new edge X -> B
		xbEdge.replace(abEdge);
	}
	def removeEdge(edge: SsaCfEdge) {
		var dest = edge.dest;
		if (dest == null) return;
		var next = dest.next, index = edge.desti, preds = dest.preds;
		for (i = index + 1; i < preds.length; i++) {
			var p = preds[i];
			preds[i - 1] = p;
			p.desti = i - 1;
		}
		dest.preds = Arrays.range(dest.preds, 0, dest.preds.length - 1);
		while (true) {
			if (!SsaPhi.?(next)) break;
			var phi = SsaPhi.!(next), inputs = phi.inputs;
			// for each phi, remove the corresponding input
			inputs[index].update(null); // kill the DF edge
			phi.inputs = Arrays.deleteAt(phi.inputs, index);
			next = phi.next;
		}
		if (dest.preds.length == 1) simplifyPhis(dest);
	}
	def simplifyPhis(block: SsaBlock) {
		var next = block.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			var phi = SsaPhi.!(next), nn = phi.next;
			phi.replace(phi.input0());
			killInstr(phi);
			next = nn;
		}
	}
	// fold away a type cast if dominated by a type query that evaluates to true
	def optFoldCast(i: SsaInstr, queryTypes: Array<Type>) -> SsaInstr {
		if (i.optag() == Opcode.TypeCast.tag) {
			// fold away a type cast
			var cast = SsaApplyOp.!(i), castTypes = cast.op.typeArgs;
			if (TypeSystem.isSubtype(queryTypes[1], castTypes[1])) {
				return SsaApplyOp.new(cast.source, V3Op.newTypeSubsume(castTypes[0], castTypes[1]), [i.input0()]);
			} else {
				i.facts |= Fact.O_NO_NULL_CHECK;
			}
		}
		return optNullCheck(i);
	}
	// eliminate a null check on this instruction
	def optNullCheck(i: SsaInstr) -> SsaInstr {
		if (!SsaApplyOp.?(i)) return i;
		match (SsaApplyOp.!(i).op.opcode) {
			NullCheck,
			BoundsCheck,
			ArrayGetElem,
			ArraySetElem,
			ArrayGetLength,
			TypeCast,
			TypeQuery,
			ClassGetMethod,
			ClassGetVirtual,
			CallMethod,
			CallClassMethod,
			CallClassVirtual,
			CallClassSelector,
			CallVariantVirtual,
			CallVariantSelector,
			VariantGetField,
			VariantGetVirtual,
			VariantGetSelector,
			ClassGetField,
			ClassSetField => {
				i.facts |= Fact.O_NO_NULL_CHECK;
			}
			_ => ;
		}
		return i;
	}
	// apply the function "f" to every dominated instruction i where i.input0() == obj
	def applyDominatorOptForInput0(obj: SsaInstr, edge: SsaCfEdge, f: SsaInstr -> SsaInstr) {
		if (edge.dest.preds.length > 1) return;
		var block = edge.dest;
		// search this block for instructions to optimize
		// XXX: employ useList and domination numbers to only inspect instructions
		// that use this value
		for (l = block.next; l != block; l = l.next) {
			if (!SsaInstr.?(l)) continue;
			var i = SsaInstr.!(l);
			if (i.inputs.length < 1) continue; // instr doesn't involve obj
			if (i.input0() != obj) continue; // instr doesn't involve obj
			var ni = f(i);
			if (ni != i) {
				ni.insertBefore(i);
				i.remove();
				i.replace(ni);
				l = ni;
			}
		}
		// XXX: propagate the fact to blocks dominated by this block
	}
	def replaceWithGoto(block: SsaBlock, end: SsaEnd, target: SsaCfEdge) {
		// Kill the previous end
		var oldsucc = end.succs;
		end.kill();
		end.remove();
		// Add a goto
		var goto = SsaGoto.new(null);
		goto.succs[0].replace(target);
		block.append(goto);
		// Optimize the dead branches
		for (dead in oldsucc) {
			if (dead == target) continue;
			var dest = dead.dest;
			removeEdge(dead);
			if (!dest.hasPred()) killBlock(dest);
		}
	}
	def insertThrow(next: SsaLink, source: Source, exception: string, vt: Type) -> SsaInstr {
		var t = SsaThrow.new(source, exception);
		t.insertBefore(next);
		// kill the rest of the instructions in the block
		for (p = t.next; !SsaBlock.?(p); ()) {
			var n = p.next;
			p.remove();
			if (SsaEnd.?(p)) {
				var end = SsaEnd.!(p);
				killSuccs(end.succs);
				killInstr(end);
				break;
			}
			if (SsaInstr.?(p)) killInstr(SsaInstr.!(p));
			p = n;
		}
		return if(vt != null, context.graph.valConst(vt, Values.BOTTOM), context.graph.nop());
	}
}
class SwitchCmp(val: int, cmp: SsaInstr, end: SsaIf, tSucc: SsaCfEdge, fSucc: SsaCfEdge) { }


// Performs optimizations on loops.
// 1. eliminate rendundant bounds checks for induction variables.
// 2. XXX eliminate redundant null checks.
// 3. XXX loop rotation (move loop test condition to end of loop)
// 4. XXX loop-invariant code motion (move code out of loops)
// 5. XXX loop peeling (copy first iteration of loop)
// 6. XXX induction variable simplifications
// 7. XXX remove useless loops
class SsaLoopOptimizer {
	def graph: SsaGraph;
	def header: SsaBlock;	// start of loop (ends with loop condition)
	def loopBody: SsaBlock; // first block of loop body
	def loopEnd: SsaBlock;  // first block outside of loop
	def headerMark = ++graph.markGen;
	def gvn = Gvn.new(graph);

	new(graph, header, loopBody, loopEnd) {}

	def optimize() {
		// XXX: optimize phis in header first
		// XXX: pull loop-invariant code out of header
		var c = findLoopControl(), cond = c.0, condTrue = c.1;
		var ivs = findLinearIvs();
		for (l = ivs; l != null; l = l.tail) {
			var iv = l.head;
			if (cond != null) tryBoundingIv(iv, cond, condTrue);
		}
	}
	def tryBoundingIv(iv: SsaLinearIv, cond: SsaInstr, condTrue: bool) {
		var op: BoundOp;
		match (cond.optag()) {
			Opcode.IntLt.tag => op = BoundOp.Lt;
			Opcode.IntLteq.tag => op = BoundOp.Lteq;
			_ => return;
		}
		boundIvInequality(iv, op, cond, condTrue);
		optBoundedIv(iv);
	}
	def boundIvInequality(iv: SsaLinearIv, op: BoundOp, cond: SsaInstr, condTrue: bool) {
		iv.bound = cond.input1();
		if (iv.bound == iv.phi) {
			iv.bound = cond.input0();
			op = op.commute();
		}
		if (!condTrue) op = op.inverse();
		iv.boundOp = op;
	}
	// identify the control condition of the loop
	def findLoopControl() -> (SsaInstr, bool) {
		var e = header.end();
		if (SsaIf.?(e)) {
			var sw = SsaIf.!(e);
			if (sw.trueBlock() == loopBody) return (sw.input0(), true);
			if (sw.falseBlock() == loopBody) return (sw.input0(), false);
		}
		return (null, false);
	}
	// find simple induction variables of the form v = phi(v, v + N, v + N)
	def findLinearIvs() -> List<SsaLinearIv> {
		var list: List<SsaLinearIv>;
		var next = header.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			list = matchIv(SsaPhi.!(next), list);
			next = next.next;
		}
		return list;
	}
	// find a linear induction variable
	def matchIv(phi: SsaPhi, prev: List<SsaLinearIv>) -> List<SsaLinearIv> {
		var init: SsaInstr, step: Box<int>;
		for (i in phi.inputs) {
			var pi = i.dest;
			if (hasInput(pi, phi)) {
				// check increment matches in each induction
				var n = gvn.matchInc(pi);
				if (n == null) step = null;
				else if (step == null) step = n;
				else if (step.val != n.val) return prev;
			} else if (init != null) {
				if (pi != null) return prev;
			} else {
				init = pi;
			}
		}
		if (init == null || step == null) return prev;
		return List.new(SsaLinearIv.new(phi, init, step.val), prev);
	}
	// check whether x has i as one of its inputs
	def hasInput(x: SsaInstr, i: SsaInstr) -> bool {
		for (xi in x.inputs) {
			if (xi.dest == i) return true;
		}
		return false;
	}
	// optimize uses of a bounded linear induction variable
	def optBoundedIv(iv: SsaLinearIv) {
		if (iv.step > 0) {
			// XXX: what about uses before the condition is checked?
			iv.phi.setFact(iv.init.facts & iv.bound.facts & Fact.V_NON_NEGATIVE);
		}
		markHeader(headerMark); // XXX: only mark header once?
		for (u: Edge<SsaInstr> = iv.phi.useList; u != null; u = u.next) {
			var use = u.src;
			if (use.mark != headerMark) optBoundedIvUse(iv, use);
		}
		markHeader(-1);
	}
	def optBoundedIvUse(iv: SsaLinearIv, use: SsaInstr) {
		var opcode = use.optag();
		// XXX: optimize inequalities, especially MachOp.opUgteq
		if (opcode == Opcode.BoundsCheck.tag ||
		    opcode == Opcode.ArrayGetElem.tag ||
		    opcode == Opcode.ArraySetElem.tag) {
			if (use.input1() == iv.phi) optBoundsCheck(iv, use, use.input0());
		}
	}
	def optBoundsCheck(iv: SsaLinearIv, use: SsaInstr, array: SsaInstr) {
		match(iv.boundOp) {
			Lt, Lteq => {
				if (iv.step < 0) return; // must be counting up
				if (!iv.init.facts.V_NON_NEGATIVE) return; // init must be >= 0
				var isBounded = if(iv.boundOp == BoundOp.Lt, gvn.lteqArrayLength, gvn.ltArrayLength);
				if (isBounded(iv.bound, array)) use.setFact(Facts.O_SAFE_BOUNDS);
			}
			Gt, Gteq => {
				if (iv.step > 0) return; // must be counting down
				if (!iv.bound.facts.V_NON_NEGATIVE) return; // bound must be >= 0
				if (gvn.ltArrayLength(iv.init, array)) use.setFact(Facts.O_SAFE_BOUNDS);
			}
		}
	}
	// mark instructions in header, not in body or after loop end
	def markHeader(mark: int) {
		markBlocks(header, [loopBody, loopEnd], mark);
	}
	// mark instructions in body, not in header or after loop end
	def markBody(mark: int) {
		markBlocks(loopBody, [header, loopEnd], mark);
	}
	// mark all the blocks up to but not including [end] with the given mark
	def markBlocks(block: SsaBlock, end: Array<SsaBlock>, mark: int) {
		for (e in end) if (block == e) return; // reached an end block
		if (block.mark == mark) return; // already marked
		block.mark = mark;
		markBlockInstrs(block, mark); // mark phis and instructions block
		for (s in block.succs()) markBlocks(s.dest, end, mark); // recursively mark successors
	}
	// mark all the instructions in a block with a given mark
	def markBlockInstrs(block: SsaBlock, mark: int) {
		for (i = block.next; i != block; i = i.next) i.mark = mark;
	}
}
// an induction variable "x = I + N * i" with optional bound of the form
// x <op> bound, e.g. x < a.length, x >= 3, etc
class SsaLinearIv {
	def phi: SsaPhi;	// x
	def init: SsaInstr;	// I
	def step: int;		// N
	var boundOp: BoundOp;	// operator of bound
	var bound: SsaInstr;	// value of bound
	new(phi, init, step) {}
}
type BoundOp {
	case Lt;
	case Lteq;
	case Gt;
	case Gteq;
	def inverse() -> BoundOp {
		match (this) {
			Lt => return BoundOp.Gteq;
			Lteq => return BoundOp.Gt;
			Gt => return BoundOp.Lteq;
			Gteq => return BoundOp.Lt;
		}
	}
	def commute() -> BoundOp {
		match (this) {
			Lt => return BoundOp.Gt;
			Lteq => return BoundOp.Gteq;
			Gt => return BoundOp.Lt;
			Gteq => return BoundOp.Lteq;
		}
	}
}

// Performs load/store optimizations on a completed SsaGraph.
class SsaLoadOptimizer(context: SsaContext) {
	var pure = SsaLoadedFields.new();
	var impure = SsaLoadedFields.new();
	var any = false;

	def optimize() -> bool {
		// visit all the blocks of the graph, removing redundant loads.
		for (block in context.graph.bfBlocks(null)) optBlock(block);
		return any;
	}
	def optBlock(block: SsaBlock) {
		pure.length = 0;
		impure.length = 0;
		var i = block.next;
		for (i = block.next; SsaInstr.?(i); ()) {
			var next = i.next;
			match (i) {
				instr: SsaApplyOp => {
					var repl = optInstr(instr);
					if (repl != null) {
						any = true;
						instr.replace(repl);
						instr.remove();
					}
				}
			}
			i = next;
		}
		while (SsaApplyOp.?(i)) {
			var instr = SsaApplyOp.!(i);
			var next = instr.next;
			i = next;
		}
	}
	def optInstr(apply: SsaApplyOp) -> SsaInstr {
		match (apply.op.opcode) {
			ClassAlloc(method) => {
				if (method != null) impure.length = 0;
			}
			// XXX: ClassGetMethod, ClassGetVirtual for monomorphic methods.
			ClassGetField(field) => return load(apply.input0(), field, apply);
			VariantGetField(field) => return load(apply.input0(), field, apply);
			ComponentGetField(field) => return load(null, field, apply);
			ClassInitField(field) => {
				var obj = apply.input0();
				var map = if(field.isConst(), pure, impure);
				map.add(obj, field, apply.input1());
			}
			ClassSetField(field) => return store(apply.input0(), field, apply, apply.input1());
			ComponentSetField(field) => return store(null, field, apply, apply.input1());
			Init,
			CallMethod,
			CallClassMethod,
			CallClassVirtual,
			CallClassSelector,
			CallVariantVirtual,
			CallVariantSelector,
			CallClosure,
			CallFunction,
			SystemCall => impure.length = 0;
			_ => ;
		}
		return null;
	}
	def load(obj: SsaInstr, m: IrMember, apply: SsaApplyOp) -> SsaInstr {
		if (apply.useList == null && apply.facts.O_NO_NULL_CHECK) {
			apply.replace(null);
			return context.graph.zeroConst();  // XXX: recursively delete dead code
		}
		var val = find(obj, m);
		if (val != null) return val;
		if (m.isConst() || IrMethod.?(m)) pure.add(obj, m, apply);
		else impure.add(obj, m, apply);
		return null;
	}
	def store(obj: SsaInstr, field: IrField, apply: SsaApplyOp, val: SsaInstr) -> SsaInstr {
		var prev = find(obj, field);
		if (prev == val) { // redundant store of previous value to field
			apply.remove();
			apply.kill();
		} else {
			impure.kill(field);
			impure.add(obj, field, val);
		}
		return null;
	}
	def find(o: SsaInstr, f: IrMember) -> SsaInstr {
		var v = pure.find(o, f);
		return if(v == null, impure.find(o, f), v);
	}
}
// Analysis data for tracking the loaded fields.
class SsaLoadedFields {
	var array = Array<(SsaInstr, IrMember, SsaInstr)>.new(4);
	var length = 0;
	def add(obj: SsaInstr, f: IrMember, val: SsaInstr) {
		if (length == array.length) array = Arrays.grow(array, array.length * 2);
		array[length++] = (obj, f, val);
	}
	def find(obj: SsaInstr, f: IrMember) -> SsaInstr {
		for (i < length) {
			var t = array[i];
			if (t.0 == obj && t.1 == f) return t.2;
		}
		return null;
	}
	def kill(f: IrField) {
		var i = 0;
		for (j < length) {
			var t = array[j];
			if (t.1 != f) {
				if (i != j) array[i] = t;
				i++;
			}
		}
		length = i;
	}
}
