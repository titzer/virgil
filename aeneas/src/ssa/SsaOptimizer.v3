// Copyright 2015 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Coordinates optimizations of SSA graphs, blocks, and individual instructions.
// Provides a facade to the outside that hide details of reduction, analysis,
// etc.
class SsaOptimizer(context: SsaContext) {
	var optimize_loads: bool;
	var optimize_branches: bool;
	var optimize_nullchecks: bool;
	var optimize_inits: bool;
	var optimize_ivs: bool;
	var optimize_licm: bool;
	var dce: bool;
	def iopt = SsaInstrReducer.new(context);
	def copt = SsaCfOptimizer.new(context);

	def reset(graph: SsaGraph) {
		iopt.graph = graph;
		context.graph = graph;
		context.block = null;
	}
	def optGraph() {
		def mark = ++context.graph.markGen;
		def queue = Vector<(SsaBlock, SsaBlockState)>.new();
		queue.add(context.graph.startBlock, SsaBlockState.new());
		context.graph.startBlock.mark = mark;
		for (i < queue.length) {
			var t = queue.get(i), block = t.0;
			iopt.state = t.1;
			if (block.checkFact(Fact.O_KILLED)) continue;
			iopt.reduceBlock(block);
			var succs = block.succs();
			for (s in succs) {
				var d = s.dest;
				if (d.mark != mark) {
					var state: SsaBlockState;
					if (succs.length == 1) state = if(s.dest.preds.length == 1, iopt.state, iopt.state.clear());
					else state = if(s.dest.preds.length == 1, iopt.state.copy(), SsaBlockState.new());
					queue.add(d, state);
					d.mark = mark;
				}
			}
		}
	}
	def optLoop(header: SsaBlock, loopBody: SsaBlock, loopEnd: SsaBlock) {
	}
	def optBlock(block: SsaBlock) {
	}
	def reduceIf(state: SsaBlockState, i: SsaIf) {
		iopt.state = state;
		iopt.prev = i.prev;
		iopt.reduceIf(i);
		iopt.state = null;
	}
	def reduceApply(state: SsaBlockState, app: SsaApplyOp) -> SsaInstr {
		iopt.state = state;
		iopt.prev = app.prev;
		var res = iopt.reduceApplyOp(app);
		if (res != app) {
			app.replace(res);
			app.remove();
		}
		iopt.state = null;
		return res;
	}
}


def ARRAY_LENGTH_FIELD = newField(V3.stringType, Int.TYPE, Fact.F_VALUE);

def newField(container: Type, fieldType: Type, facts: Fact.set) -> IrField {
	var f = IrField.new(container, fieldType);
	f.facts |= facts;
	return f;
}

// Matches various patterns of SSA instructions, recording the state of the match
// in the exposed fields.
class SsaInstrMatcher {
	var x: SsaInstr;	// First input
	var y: SsaInstr;	// Second input
	var xconst: bool;	// true if {x} is a constant
	var yconst: bool;	// true if {y} is a constant
	var fold: bool;		// true if all inputs are constants
	var wide: bool;		// true if this is a long int operation
	var xval: Val;		// if {x} is a constant, then its value
	var yval: Val;		// if {y} is a constant, then its value
	var xint: int;		// if {x} is an int constant, then its value
	var yint: int;		// if {y} is an int constant, then its value
	var xlong: long;	// if {x} is a long constant, then its value
	var ylong: long;	// if {y} is a long constant, then its value
	var yzero: bool;        // true if {y} is zero
	var inttype: IntType;	// if this is an integer operation, the result type

	// Resets this matcher
	def clear() {
		x = y = null;
		xval = yval = null;
		inttype = null;
		xconst = yconst = yzero = fold = wide = false;
		xint = yint = 0;
		xlong = ylong = 0;
	}
	// Initializes the match state for a binary operation and returns {yval}.
	def binop(i: SsaApplyOp) -> Val {
		x = i.input0();
		y = i.input1();
		yzero = y.checkFact(Fact.V_ZERO);
		fold = false;
		if (xconst = SsaValue.?(x)) {
			xval = SsaValue.!(x).val;
			if (yconst = SsaValue.?(y)) {
				fold = true;
				return yval = SsaValue.!(y).val;
			} else if (i.checkFact(Fact.O_COMMUTATIVE)) {
				i.inputs(0).update(y);
				i.inputs(1).update(x);
				xconst = false;
				yconst = true;
				var t = x;
				x = y;
				y = t;
				yval = xval;
				xval = null;
				yzero = y.checkFact(Fact.V_ZERO);
				return yval;
			} else {
				return yval = null;
			}
		}
		return yval = if(yconst = SsaValue.?(y), SsaValue.!(y).val);
	}
	// Initializes the match state for an integer binary operation and returns {yint}.
	def intbinop(i: SsaApplyOp) -> int {
		binop(i);
		inttype = IntType.!(i.op.paramTypes(0));
		if (inttype.width <= 32) {
			wide = false;
			if (xconst) xint = Int.unbox(xval);
			if (yconst) {
				yint = Int.unbox(yval);
				yzero = yint == 0;
			}
		} else {
			wide = true;
			if (xconst) xlong = Long.unboxSU(xval, inttype.signed);
			if (yconst) {
				ylong = Long.unboxSU(yval, inttype.signed);
				yzero = ylong == 0;
			}
		}
		return yint;
	}
	// Initializes the match state for a unary operation and returns {xval}.
	def unop(i: SsaApplyOp) -> Val {
		x = i.input0();
		return xval = if(fold = xconst = SsaValue.?(x), SsaValue.!(x).val);
	}
	// Initializes the match state for an n-ary operation and returns {xval}.
	def n_op(i: SsaApplyOp) -> Val {
		fold = true;
		var max = i.inputs.length;
		for (j < max) {
			if (!SsaValue.?(i.inputs(j).dest)) return (fold = false, null).last;
		}
		if (max >= 1) {
			x = i.input0();
			xconst = true;
			xval = SsaValue.!(x).val;
		}
		if (max >= 2) {
			y = i.input1();
			yconst = true;
			yval = SsaValue.!(y).val;
		}
		return xval;
	}
	def yis(val: int) -> bool {
		return yconst && if(wide, ylong == val, yint == val);
	}
	def yrange(min: int, max: int) -> bool {
		if (Debug.PARANOID && !yconst) return V3.fail("not const");
		if (wide) return min <= ylong && ylong <= max;
		else return min <= yint && yint <= max;
	}
	def yisPowerOf2() -> bool {
		return yconst && if(wide, (ylong & (ylong - 1)) == 0, (yint & (yint - 1)) == 0);
	}
	def ylog2() -> int {
		if (Debug.PARANOID && !yconst) return V3.fail("not const");
		return if(wide, IntOp.logl(ylong), IntOp.log(yint));
	}
}

// Flow-sensitive state for local optimizations.
class SsaBlockState {
	var end: bool;
	var optimize_loads = true;	// activates load elimination
	var optimize_nullchecks = true;	// activates null check elimination
	var optimize_inits = false;	// activates init elimination
	var fields: List<(SsaInstr, IrField, SsaInstr)>;
	var nonnull: List<SsaInstr>;
	var inits: List<IrMethod>;
	def clear() -> SsaBlockState {
		fields = null;
		nonnull = null;
		inits = null;
		end = false;
		return this;
	}
	def addField(receiver: SsaInstr, field: IrField, value: SsaInstr) {
		if (optimize_loads) fields = List.new((receiver, field, value), fields);
	}
	def copy() -> SsaBlockState {
		var that = SsaBlockState.new();
		that.end = this.end;
		that.optimize_loads = this.optimize_loads;
		that.optimize_nullchecks = this.optimize_nullchecks;
		that.optimize_inits = this.optimize_inits;
		that.fields = this.fields;
		that.nonnull = this.nonnull;
		that.inits = this.inits;
		return that;
	}
}

// Optimizes SSA instructions one at a time, performing such optimizations
// as const folding, strength reduction, load elimination, and bounds check elimination.
class SsaInstrReducer(context: SsaContext) extends SsaInstrMatcher {
	var graph: SsaGraph;
	var prev: SsaLink;  			// instruction before the current instruction
	var next: SsaLink;			// instruction after the current instruction
	var state = SsaBlockState.new();	// flow sensitive state

	def reset(graph: SsaGraph, block: SsaBlock, prev: SsaLink) {
		this.context.graph = graph;
		this.context.block = block;
		this.graph = graph;
		this.prev = prev;
		this.state.clear();
	}
	def reduceBlock(block: SsaBlock) {
		graph = context.graph;
		context.block = block;
		for (i = block.next; SsaInstr.?(i); ()) {
			next = i.next;
			reduceInstr(SsaInstr.!(i));
			if (state.end) break;
			i = next;
		}
	}
	def reducePhi(i: SsaPhi) -> bool {
		var i0 = i.input0(), facts = i0.facts, same = true;
		for (n = 1; n < i.inputs.length; n++) {
			var iN = i.inputs(n).dest;
			facts &= iN.facts;
			if (iN != i0) same = false;
		}
		if (same) {
			// phi(x, x, x...) => x
			i.replace(i0);
			return false;
		}
		i.facts |= facts;
		return true;
	}

	def reduceInstr(i: SsaInstr) -> SsaInstr {
		prev = i.prev;
		if (SsaApplyOp.?(i)) {
			var app = SsaApplyOp.!(i);
			var res = reduceApplyOp(app);
			if (res != app) {
				app.replace(res);
				app.remove();
			}
			return res;
		}
		if (SsaPhi.?(i)) {
			var i0 = i.input0();
			if (!reducePhi(SsaPhi.!(i))) return i0;
		}
		if (SsaIf.?(i)) {
			return reduceIf(SsaIf.!(i));
		}
		if (SsaGoto.?(i)) {
			var cfopt = SsaCfOptimizer.new(context), block = SsaGoto.!(i).block();
			if (cfopt.optEdge(block.succ(0))) next = prev.next;
		}
		if (SsaSwitch.?(i)) {
			var sw = SsaSwitch.!(i), val = sw.input0();
			if (SsaValue.?(val)) {
				var cfopt = SsaCfOptimizer.new(context), block = sw.block();
				var succ = sw.findSucc(SsaValue.!(val).val);
				cfopt.replaceWithGoto(block, sw, succ);
				if (cfopt.optEdge(block.succ(0))) next = prev.next;
			}
		}
		return i;
	}
	def reduceIf(ifi: SsaIf) -> SsaInstr {
		var cond = ifi.input0(), block = ifi.block();
		if (SsaValue.?(cond)) {
			var cfopt = SsaCfOptimizer.new(context);
			cfopt.replaceWithGoto(block, ifi, block.succ(if(cond.unbox<bool>(), 0, 1)));
			if (cfopt.optEdge(block.succ(0))) next = prev.next;
		} else if (SsaApplyOp.?(cond)) {
			if (SsaApplyOp.!(cond).op.opcode == Opcode.BoolNot) {
				var cc = cond.input0();
				ifi.succs = [ifi.succs(1), ifi.succs(0)];
				ifi.inputs(0).update(cc);
				return ifi;
			}
			// XXX: optimize if(x == true|false) and if(x != true|false)
		}
		return ifi;
	}
	def reduceApplyOp(i: SsaApplyOp) -> SsaInstr {
		def PURE_LOAD = Fact.O_NO_NULL_CHECK | Fact.O_PURE;
		def ZERO_NON_ZERO = Fact.V_ZERO | Fact.V_NON_ZERO;
		def ABOVE_BELOW_ZERO = Fact.V_NON_ZERO | Fact.V_NON_NEGATIVE | Fact.V_BELOW_ZERO;
		match (i.op.opcode) {
			OverloadedEq,
			BoolEq,
			IntEq,
			RefEq,
			VariantEq: {
				norm_binop(i);
				if (fold) return graph.boolConst(Values.equal(xval, yval));
				if (x == y) return graph.trueConst();
				var and = x.facts & y.facts, or = x.facts | y.facts;
				if (Facts.NONE != (and & Fact.V_ZERO)) return graph.trueConst(); // 0 == 0 == true
				if (ZERO_NON_ZERO == (or & ZERO_NON_ZERO)) return graph.falseConst(); // 0 == nonzero == false
				if (ABOVE_BELOW_ZERO == (or & ABOVE_BELOW_ZERO)) return graph.falseConst(); // neg == pos == false
			}
			IntAdd: {
				var yint = norm_intbinop(i);
				if (fold) return fold2i(int.+, long.+); // K + K == K
				if (yzero) return x;                    // x + 0 == x
			}
			IntSub: {
				var yint = norm_intbinop(i);
				if (fold) return fold2i(int.-, long.-); // K - K == K
				if (yzero) return x;                    // x - 0 == x
			}
			IntMul: {
				var yint = norm_intbinop(i);
				if (yzero) return y;                    // x * 0 == 0
				if (fold) return fold2i(int.*, long.*); // K * K == K
				if (yconst) {
					if (yis(1)) return x;           // x * 1 == 1
					if (yis(-1)) return addBinop(i_infix(V3Infix.Sub), graph.zeroConst(), x);  // x * -1 == 0 - x
					if (yis(2)) return addBinop(i_infix(V3Infix.Add), x, x);
					if (yisPowerOf2()) {
						// x * 2^k == x << k
						return addBinop(i_infix(V3Infix.QShl), x, graph.intConst(ylog2())).setFact(Fact.O_NO_SHIFT_CHECK);
					}
				}
			}
			IntDiv: {
				var yint = norm_intbinop(i);
				if (yzero) return addThrow(i.source, V3Exception.DivideByZero); // fold x / 0
				if (fold) return fold4i(int./, u32./, long./, u64./);
				if (yconst) {
					i.facts |= Facts.O_SAFE_DIVIDE;
					if (yis(1)) return x;           // x / 1 == x
					if (yis(-1) && inttype.signed) return addBinop(i_infix(V3Infix.Sub), graph.zeroConst(), x); // x / -1 == 0 - x
					if (yisPowerOf2() && x.checkFact(Fact.V_NON_NEGATIVE)) {
						// x / 2^k == x >> k
						return addBinop(i_infix(V3Infix.QShr), x, graph.intConst(ylog2())).setFact(Fact.O_NO_SHIFT_CHECK);
					}
				}
			}
			IntMod: {
				var yint = norm_intbinop(i);
				if (yzero) return addThrow(i.source, V3Exception.DivideByZero); // fold x % 0
				if (fold) return fold4i(int.%, u32.%, long.%, u64.%);
				if (yconst) {
					i.facts |= Facts.O_SAFE_DIVIDE;
					if (yis(1) || (yis(-1) && inttype.signed)) {
						// x % +/-1 == 0
						return if(wide, l_const(0), i_const(0));
					}
					if (yisPowerOf2() && x.checkFact(Fact.V_NON_NEGATIVE)) {
						// x % 2^k == x & (2^k - 1)
						var mask = if(wide, l_const(ylong - 1), i_const(yint - 1));
						return addBinop(i_infix(V3Infix.And), x, mask).setFact(Fact.V_NON_NEGATIVE);
					}
				}
				if ((x.facts & y.facts & Fact.V_NON_NEGATIVE) == Fact.V_NON_NEGATIVE) i.facts |= Fact.V_NON_NEGATIVE;
			}
			IntAnd: {
				norm_intbinop(i);
				if (yzero) return y;                    // x & 0 == 0
				if (fold) return fold2i(int.&, long.&); // K & K == K
				if (yconst && yis(-1)) return x;        // x & -1 == x
				// (nonneg & x) => nonneg
				i.facts |= ((x.facts | y.facts) & Fact.V_NON_NEGATIVE);
			}
			IntOr: {
				norm_intbinop(i);
				if (yzero) return x;                    // x | 0 == x
				if (fold) return fold2i(int.|, long.|); // K | K == K
				if (yconst && yis(-1)) return y;        // x | -1 == -1
				// (neg | x) => neg, (nonzero | x) => nonzero
				i.facts |= ((x.facts | y.facts) & (Fact.V_BELOW_ZERO | Fact.V_NON_ZERO));
			}
			IntXor: {
				norm_intbinop(i);
				if (yzero) return x;                     // x ^ 0 == x
				if (x == y) return graph.zeroConst();    // x ^ x == 0
				if (fold) return fold2i(int.^, long.^);  // K ^ K == K
				i.facts |= (x.facts & y.facts & Fact.V_NON_NEGATIVE);  // (nonneg ^ nonneg) => nonneg
				if ((x.facts & y.facts & Fact.V_BELOW_ZERO) == Fact.V_NON_NEGATIVE) i.facts |= Fact.V_NON_NEGATIVE;
			}
			IntShl: {
				var yint = norm_intbinop(i);
				if (yzero) return x; // x << 0 == x
				if (fold) {          // K << K == K
					if (wide) {
						var y6 = u6.!(ylong);
						return if(ylong == y6, l_const(xlong << y6), graph.zeroConst());
					} else {
						var y5 = u5.!(yint);
						return if(yint == y5, i_const(xint << y5), graph.zeroConst());
					}
				}
				if (yconst) {
					if (yrange(0, inttype.width - 1)) i.facts |= Fact.O_NO_SHIFT_CHECK;
					else return graph.zeroConst();
				} else {
					shiftcheck(i, y);
				}
			}
			IntSar: {
				var yint = norm_intbinop(i);
				if (yzero) return x;  // x >> 0 == x
				if (fold) {           // K >> K == K
					if (wide) {
						var y6 = u6.!(if(u64.!(ylong) > 63, 63, ylong));
						return l_const(xlong >> y6);
					} else {
						var y5 = u5.!(if(u32.!(yint) > 31, 31, yint));
						return i_const(xint >> y5);
					}
				}
				if (yconst) {
					if (!yrange(0, inttype.width - 1)) {
						if (x.checkFact(Fact.V_NON_NEGATIVE)) return graph.zeroConst();
						if (x.checkFact(Fact.V_BELOW_ZERO)) return graph.intConst(-1);
						i.inputs(1).update(graph.intConst(inttype.width - 1));
					}
					i.facts |= Fact.O_NO_SHIFT_CHECK;
				} else {
					shiftcheck(i, y);
				}
			}
			IntShr: {
				var yint = norm_intbinop(i);
				if (yzero) return x; // x >>> 0 = x
				if (fold) {          // K >>> K = K
					if (wide) {
						var y6 = u6.!(ylong);
						if (ylong == y6) return l_const(inttype.trunc_u64(xlong) >>> y6);
						return graph.zeroConst();
					} else {
						var y5 = u5.!(yint);
						if (yint == y5) return i_const(inttype.trunc_u32(xint) >>> y5);
						return graph.zeroConst();
					}
				}
				if (yconst) {
					if (yrange(0, inttype.width - 1)) i.facts |= Fact.O_NO_SHIFT_CHECK;
					else return graph.zeroConst();
				} else {
					shiftcheck(i, y);
				}
				if (y.checkFact(Fact.V_NON_ZERO)) i.facts |= Fact.V_NON_NEGATIVE;
			}
			IntLt: {
				norm_intbinop(i);
				if (fold) return fold4b(int.<, u32.<, long.<, u64.<);
			}
			IntLteq: {
				norm_intbinop(i);
				if (fold) return fold4b(int.<=, u32.<=, long.<=, u64.<=);
			}
			IntConvert: {
				var xval = unop(i);
				if (xconst) {
					var tt = i.op.resultType;
					var r = IntOp.evalConversion(i.op.paramTypes(0), tt, xval);
					if (r.approx == CastOp.TRUE) return graph.valConst(tt, xval);
					if (r.approx == CastOp.VALUE) return graph.valConst(tt, r.result);
				}
			}
			BoolAnd: {
				norm_binop(i);
				if (fold) return graph.boolConst(Bool.unbox(xval) && Bool.unbox(yval)); // K && K => K
				if (yconst) return if(Bool.unbox(yval), x, graph.falseConst()); // x && K => x
			}
			BoolOr: {
				norm_binop(i);
				if (fold) return graph.boolConst(Bool.unbox(xval) || Bool.unbox(yval)); // K || K => K
				if (yconst) return if(Bool.unbox(yval), graph.trueConst(), x);  // x || K => x 
			}
			BoolNot: {
				var xval = unop(i);
				if (xconst) return graph.boolConst(!Bool.unbox(xval));  // !K  => K
				if (x.opcode() == Opcode.BoolNot.tag) return x.input0();  // !!x => x
			}
			NullCheck: {
				var receiver = nullcheck(i);
				if (i.checkFact(Fact.O_NO_NULL_CHECK)) return receiver;
			}
			BoundsCheck: {
				var receiver = boundscheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (i.checkFact(Facts.O_SAFE_BOUNDS)) return killInstr(i);
			}
			TypeSubsume: {
				var xval = unop(i);
				var ft = i.op.typeArgs(0), tt = i.op.typeArgs(1);
				if (xconst) return graph.valConst(tt, xval);
				if (ft == tt) return x; // fold TypeSubsume<T, T>(x)
				if (tt == x.getType()) return x; // fold TypeSubsume<F, T>(x: T)
				match (tt.typeCon.kind) {
					V3Kind.CLASS: {
						if (ft == Null.TYPE) return graph.nullConst(tt);
						if (TypeSystem.isSubtype(ft, tt)) return x; // remove redundant subsume of class
					}
					V3Kind.ENUM_SET: {
						return addEnumToSet(V3EnumSet_TypeCon.!(tt.typeCon), x);
					}
					// XXX: int subsume and tuples
				}
				if (x.checkFact(Fact.V_NON_ZERO)) {
					i.facts |= Fact.O_NO_NULL_CHECK | Fact.V_NON_ZERO;
				}
			}
			TypeCast: {
				var ft = i.op.paramTypes(0), tt = i.op.resultType;
				var cast = TypeSystem.newTypeCast(ft, tt);
				if (i.inputs.length == 0) {
					// special cast of casting void -> X
					if (cast.approx == CastOp.FALSE) return addThrow(i.source, V3Exception.TypeCheck); // fold TypeCast
					return i;
				}
				var xval = unop(i);
				if (xconst && cast.approx != CastOp.UNKNOWN_CAST) cast = cast.eval(ft, tt, xval);

				match (cast.approx) {
					CastOp.TRUE: return x; // fold TypeCast
					CastOp.FALSE: {
						return addThrow(i.source, V3Exception.TypeCheck); // fold TypeCast
					}
					CastOp.TRUE_X_NULL: {
						// TypeCast -> ConditionalThrow(x == null)
						var cmp = addEqual(ft, x, graph.nullConst(ft));
						addConditionalThrow(i.source, V3Exception.TypeCheck, cmp);
						return x;
					}
					CastOp.FALSE_X_NULL: {
						// TypeCast -> ConditionalThrow(x != null)
						var cmp = addNot(addEqual(ft, x, graph.nullConst(ft)));
						addConditionalThrow(i.source, V3Exception.TypeCheck, cmp);
						return graph.nullConst(tt);
					}
					CastOp.VALUE: {
						return graph.valConst(tt, cast.result);
					}
					CastOp.INT_CONVERSION: {
						return replaceOp(i, V3Op.newIntConvert(ft, tt));
					}
					CastOp.ENUM_TO_SET: {
						return addEnumToSet(V3EnumSet_TypeCon.!(tt.typeCon), x);
					}
				}
				if (x.checkFact(Fact.V_NON_ZERO)) {
					i.facts |= Fact.O_NO_NULL_CHECK | Fact.V_NON_ZERO;
				}
			}
			TypeQuery: {
				var ft = i.op.typeArgs(0), tt = i.op.typeArgs(1);
				var cast = TypeSystem.newTypeQuery(ft, tt);
				if (i.inputs.length == 0) {
					// special cast of querying void -> X
					if (cast.approx == CastOp.TRUE) return graph.trueConst();
					if (cast.approx == CastOp.FALSE) return graph.falseConst();
					return i;
				}
				var xval = unop(i);
				if (xconst && cast.approx != CastOp.UNKNOWN_QUERY) cast = cast.eval(ft, tt, xval);
				if (cast.approx == CastOp.TRUE) return graph.trueConst();
				if (cast.approx == CastOp.FALSE) return graph.falseConst();
				if (cast.approx == CastOp.TRUE_X_NULL) return addNotEqual(ft, x, graph.nullConst(ft));
				if (x.checkFact(Fact.V_NON_ZERO)) i.facts |= Fact.O_NO_NULL_CHECK;
			}
			ArrayAlloc: {
				var len = i.input0();
				if (len.checkFact(Fact.V_NON_NEGATIVE)) i.facts |= Fact.O_NO_LENGTH_CHECK;
				state.addField(i, ARRAY_LENGTH_FIELD, i.input0());
			}
			ArrayInit: {
				if (i.op.isPolymorphic()) return i;
				n_op(i);
				if (true || !fold) return i;
				// TODO: fold ArrayInit(#K, #K ...) => #K with immutable arrays
				var arrayType = i.op.typeArgs(0);
				var record = context.prog.newRecord(arrayType, i.inputs.length);
				for (j < i.inputs.length) record.values(j) = SsaValue.!(i.inputs(j).dest).val;
				return graph.recordConst(record);
			}
			ArrayGetElem: {
				var receiver = boundscheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (!i.checkFact(Fact.O_PURE)) return i;
				var yval = norm_binop(i);
				// ArrayGetElem(#array, #index) => K
				if (fold) return graph.valConst(i.getType(), Record.!(xval).values(Int.unbox(yval)));
			}
			ArraySetElem: {
				var receiver = boundscheck(i);
				if (SsaThrow.?(receiver)) return receiver;
			}
			ArrayGetLength: {
				var receiver = nullcheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				var xval = unop(i);
				if (xconst) return graph.intConst(Record.!(xval).values.length);
				if (receiver.opcode() == Opcode.ArrayInit.tag) {
					// ArrayGetLength(ArrayInit(...)) => |...|
					return graph.intConst(receiver.inputs.length);
				}
				if (receiver.opcode() == Opcode.ArrayAlloc.tag) {
					// ArrayGetLength(ArrayAlloc(x)) => x
					return receiver.input0();
				}
				var len = lookupField(i, receiver, ARRAY_LENGTH_FIELD);
				if (len != i) return len;
			}
			ClassAlloc: {
				if (i.op.isPolymorphic()) return i;
				if (!i.checkFact(Fact.O_PURE)) return i;
				n_op(i);
				if (!fold) return i;
				// ClassAlloc(#K, #K ..) => #K (variant)
				var classType = i.op.typeArgs(0);
				var record = context.prog.newRecord(classType, i.inputs.length);
				for (j < i.inputs.length) record.values(j) = SsaValue.!(i.inputs(j).dest).val;
				return graph.recordConst(record);
			}
			ClassGetField: {
				var field = getIrField(i);
				var receiver = if(V3.isVariant(field.container), i.input0(), nullcheck(i));
				if (SsaThrow.?(receiver)) return receiver;
				if (field.isConst()) {
					if (SsaValue.?(receiver)) {
						// ClassGetField(#K) => #K
						return graph.valConst(getFieldType(i.op), asRecord(receiver).values(field.index));
					}
					i.setFactIf(Fact.O_NO_NULL_CHECK, Fact.O_PURE);
					i.facts |= Fact.F_VALUE;
					return lookupField(i, receiver, field);
				}
			}
			ClassInitField: {
				var field = getIrField(i);
				i.setFact(Fact.O_NO_NULL_CHECK);
				if (field.isConst()) state.addField(i.input0(), field, i.input1());  // forward stores
			}
			ClassSetField: {
				var receiver = nullcheck(i), field = getIrField(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (field.isConst()) state.addField(receiver, field, i.input1());  // forward stores
			}
			ClassGetMethod: {
				var meth = extractIrSpec(i.op);
				var receiver = if(V3.isVariant(meth.container), i.input0(), nullcheck(i));
				if (SsaThrow.?(receiver)) return receiver;
				if (i.op.isPolymorphic()) return i;
				var xval = unop(i);
				if (xconst) {
					// ClassGetMethod[m](#K) => (m, #K)
					var obj = Record.!(xval);
					return graph.valConst(meth.getBoundType(), Closure.new(obj, meth));
				}
			}
			ClassGetVirtual: {
				var meth = extractIrSpec(i.op);
				var receiver = if(V3.isVariant(meth.container), i.input0(), nullcheck(i));
				if (SsaThrow.?(receiver)) return receiver;
				var dv = devirtualize(meth, receiver);
				if (dv != null) {
					var xval = unop(i);
					if (xconst && !i.op.isPolymorphic()) {  // ClassGetVirtual[m](K) => (m, K)
						var obj = Record.!(xval);
						return graph.valConst(dv.getBoundType(), Closure.new(obj, dv));
					}
					return replaceOp(i, V3Op.newClassGetMethod(dv));  // ClassGetVirtual[m](K) => ClassGetMethod[m](k)
				}
			}
			ClassGetVirtFunc: {
				var meth = extractIrSpec(i.op);
				var receiver = if(V3.isVariant(meth.container), i.input0(), nullcheck(i));
				if (SsaThrow.?(receiver)) return receiver;
				var dv = devirtualize(meth, receiver);
				if (dv != null) return graph.valConst(dv.getFuncType(), FuncVal.new(dv));
			}
			Init: {
				if (!state.optimize_inits) return i;
				var method = i.op.attr<IrMethod>();
				for (l = state.inits; l != null; l = l.tail) {
					if (l.head == method) return null;  // init[m]; init[m] => init[m]
				}
				state.inits = List.new(method, state.inits);
			}
			ComponentGetField: {
				var field = getIrField(i), sf = VstField.!(field.source);
				if (sf != null && sf.isReadOnly) {
					if (Literal.?(sf.init)) {  // C.f => K
						var lit = Literal.!(sf.init);
						var const = graph.valConst(lit.exactType, lit.val);
						return if(lit.exactType != field.fieldType, convert(const, field.fieldType), const);
					}
				}
				if (field.isConst()) return lookupField(i, null, field);
			}
			ComponentSetField: {
				var field = getIrField(i);
				if (field.isConst()) state.addField(null, field, i.input1());  // forward stores
			}
			ComponentGetMethod: {
				var xval = unop(i);
				// XXX: reduce to CreateClosure??
				if (i.op.isPolymorphic()) return i;
				// ComponentGetMethod[m](K) => (null, K)
				var spec = extractIrSpec(i.op);
				return graph.valConst(spec.getBoundType(), Closure.new(null, spec));
			}
			TupleCreate: {
				if (i.op.isPolymorphic()) return i;
				n_op(i);
				if (!fold) return i;
				// (K, ..., K) => K
				var tupleType = i.op.typeArgs(0);
				var inputs = i.inputs;
				var vals = Array<Val>.new(inputs.length);
				for (j < inputs.length) vals(j) = SsaValue.!(inputs(j).dest).val;
				return graph.valConst(i.op.resultType, Tuple_Value.new(vals));
			}
			TupleGetElem: {
				var xval = unop(i);
				if (xconst) {
					// fold K.N
					var index = i.op.attr<int>(), tupleType = i.op.typeArgs(0);
					var val = Tuple_Value.!(xval), t = Lists.get(tupleType.nested, index);
					return graph.valConst(t, if(val != null, val.values(index), null));
				}
				if (x.opcode() == Opcode.TupleCreate.tag) {
					// TupleGetElem[n](x:TupleCreate(...)) => x[n]
					var index = i.op.attr<int>();
					return SsaApplyOp.!(x).inputs(index).dest;
				}
			}
			CallMethod: {
				var m = i.op.attr<IrMember>();
				i.facts |= m.facts & Fact.O_PURE;
				if (m.container.typeCon.kind == V3Kind.CLASS) {
					var target = nullcheck(i);
					if (SsaThrow.?(target)) return target;
				} else {
					if (i.inputs.length > 0 && i.input0().checkFact(Fact.V_NON_ZERO)) i.facts |= Fact.O_NO_NULL_CHECK;
				}
			}
			CallClassVirtual: {
				var receiver = i.input0(), meth = extractIrSpec(i.op);
				if (meth.container.typeCon.kind == V3Kind.CLASS) {
					receiver = nullcheck(i);
					if (SsaThrow.?(receiver)) return receiver;
				} else {
					if (i.input0().checkFact(Fact.V_NON_ZERO)) i.facts |= Fact.O_NO_NULL_CHECK;
				}
				var dv = devirtualize(meth, receiver);
				if (dv != null) return replaceOp(i, V3Op.newCallMethod(dv));  // CallClassVirtual[m](K) => CallMethod[m](k)
			}
			CallClosure: {
				var target = nullcheck(i);
				if (SsaThrow.?(target)) return target;
				var xval = unop(i);
				if (xconst) {
					var d = Closure.!(xval);
					if (d == null) return addThrow(i.source, V3Exception.NullCheck);
					if (V3.isComponent(d.memberRef.container)) {
						// CallClosure(K) => CallMethod
						var inputs = copyInputs(i, null, 1);
						return add(i.source, V3Op.newCallMethod(d.memberRef), inputs).setFact(Fact.O_NO_NULL_CHECK);
					} else {
						// CallClosure(K) => CallMethod
						var const = graph.valConst(d.memberRef.container, d.val);
						var op = V3Op.newCallMethod(d.memberRef);
						var inputs = normSingleArg(op, copyInputs(i, const, 1));
						return add(i.source, op, inputs).setFact(Fact.O_NO_NULL_CHECK);
					}
				}
				var opcode = x.opcode();
				if (opcode == Opcode.ClassGetMethod.tag) {
					// CallClosure(GetClassMethod) => CallMethod
					var op = V3Op.newCallMethod(extractIrSpecI(x));
					var inputs = normSingleArg(op, copyInputs(i, x.input0(), 1));
					var ni = add(i.source, op, inputs);
					ni.facts |= i.facts & Fact.O_NO_NULL_CHECK;
					return ni;
				}
				if (opcode == Opcode.ClassGetVirtual.tag) {
					// CallClosure(GetClassVirtual) => CallClassVirtual
					var op = V3Op.newCallClassVirtual(extractIrSpecI(x));
					var inputs = normSingleArg(op, copyInputs(i, x.input0(), 1));
					var ni = add(i.source, op, inputs);
					ni.facts |= i.facts & Fact.O_NO_NULL_CHECK;
					return ni;
				}
				if (opcode == Opcode.ComponentGetMethod.tag) {
					// CallClosure(GetComponentMethod) => CallMethod
					var inputs = copyInputs(i, null, 1);
					return add(i.source, V3Op.newCallMethod(extractIrSpecI(x)), inputs).setFact(Fact.O_NO_NULL_CHECK);
				}
				if (opcode == Opcode.CreateClosure.tag) {
					var spec = extractIrSpecI(x);
					if (V3.isComponent(spec.container)) {
						// CallClosure(CreateClosure[m](), ...) => CallMethod[m](...)
						var inputs = copyInputs(i, null, 1);
						return add(i.source, V3Op.newCallMethod(spec), inputs).setFact(Fact.O_NO_NULL_CHECK);
					} else {
						// CallClosure(CreateClosure[m](p), ...) => CallMethod(p, ...);
						var receiver = x.input0();
						var op = V3Op.newCallMethod(spec);
						var inputs = normSingleArg(op, copyInputs(i, receiver, 1));
						var ni = add(i.source, op, inputs);
						ni.facts |= x.facts & Fact.O_NO_NULL_CHECK;
						return ni;
					}
				}
			}
			CallFunction: {
				var target = nullcheck(i);
				if (SsaThrow.?(target)) return target;
				var xval = unop(i);
				if (xconst) {
					var d = FuncVal.!(xval);
					if (d == null) return addThrow(i.source, V3Exception.NullCheck);
					if (V3.isComponent(d.memberRef.container)) {
						// CallFunction(#K) => CallMethod
						var inputs = copyInputs(i, null, 2);
						return add(i.source, V3Op.newCallMethod(d.memberRef), inputs).setFact(Fact.O_NO_NULL_CHECK);
					} else if (V3.isClass(d.memberRef.container)) {
						// CallFunction(#K) => CallMethod
						var inputs = copyInputs(i, null, 1);
						return add(i.source, V3Op.newCallMethod(d.memberRef), inputs).setFact(Fact.O_NO_NULL_CHECK);
					}
				}
			}
			CreateClosure: {
				if (i.op.isPolymorphic()) return i;
				var xval = unop(i);
				if (!fold) return i;
				// CreateClosure(#K) => #K
				var spec = extractIrSpec(i.op);
				return graph.valConst(spec.getBoundType(), Closure.new(xval, spec));
			}
			VariantGetTag: {
				var xval = unop(i);
				if (fold) {
					// GetVariantTag(#K) => #K
					if (Record.?(xval)) return graph.intConst(V3.getVariantTag(Record.!(xval).rtype));
					return graph.intConst(Int.unbox(xval));
				}
			}
			ConditionalThrow: {
				var xval = unop(i);
				if (!fold) return i;
				// ConditionalThrow(#K) => throw | nop
				if (Bool.unbox(xval)) return addThrow(i.source, i.op.attr<string>());
				else return killInstr(i);
			}
			_: ;
		}
		return i;
	}
	def normSingleArg(op: Operator, args: Array<SsaInstr>) -> Array<SsaInstr> {
		if (op.paramTypes.length == 1 && args.length > 1) return [args(0)];
		return args;
	}
	def norm_binop(i: SsaApplyOp) -> Val {
		if (i.inputs.length != 2) norm2(i);
		return binop(i);
	}
	def norm_intbinop(i: SsaApplyOp) -> int {
		if (i.inputs.length != 2) norm2(i);
		return intbinop(i);
	}
	def norm2(i: SsaApplyOp) {
		var t = i.input0();
		var x = SsaApplyOp.new(null, V3Op.newTupleGetElem(t.getType(), 0), [t]);
		var y = SsaApplyOp.new(null, V3Op.newTupleGetElem(t.getType(), 1), [t]);
		i.inputs(0).update(null);
		x.insertBefore(i);
		y.insertBefore(i);
		i.setInputs([x, y]);
	}
	def fold4b(s: (int, int) -> bool, u: (u32, u32) -> bool, sl: (long, long) -> bool, ul: (u64, u64) -> bool) -> SsaInstr {
		if (!wide) return graph.boolConst(if(inttype.signed, s(xint, yint), u(u32.!(xint), u32.!(yint))));
		else return graph.boolConst(if(inttype.signed, sl(xlong, ylong), ul(u64.!(xlong), u64.!(ylong))));
	}
	def fold4i(s: (int, int) -> int, u: (u32, u32) -> u32, sl: (long, long) -> long, ul: (u64, u64) -> u64) -> SsaInstr {
		if (!wide) return if(inttype.signed, i_const(s(xint, yint)), u_const(u(u32.!(xint), u32.!(yint))));
		else return if(inttype.signed, l_const(sl(xlong, ylong)), lu_const(ul(u64.!(xlong), u64.!(ylong))));
	}
	def fold2i(s: (int, int) -> int, sl: (long, long) -> long) -> SsaInstr {
		return if(wide, l_const(sl(xlong, ylong)), i_const(s(xint, yint)));
	}

	def copyInputs(i: SsaInstr, prepend: SsaInstr, start: int) -> Array<SsaInstr> {
		var extra = if(prepend != null, 1);
		var inputs = Array<SsaInstr>.new(i.inputs.length - start + extra);
		if (extra > 0) inputs(0) = prepend;
		for (j = extra; j < inputs.length; j++) inputs(j) = i.inputs(j + start - extra).dest;
		return inputs;
	}
	def killInstr(i: SsaInstr) -> SsaInstr {
		i.remove();
		i.kill();
		i.facts |= Fact.O_KILLED;
		return i;
	}

	def i_infix(op: byte) -> Operator {
		return inttype.lookupInfix0(op);
	}
	def i_const(v: int) -> SsaInstr {
		return graph.intConst(inttype.trunc_32(v));
	}
	def u_const(v: u32) -> SsaInstr {
		return graph.intConst(inttype.trunc_32(int.!(v)));
	}
	def l_const(v: long) -> SsaInstr {
		return graph.valConst(inttype, Long.box(inttype.trunc_64(v)));
	}
	def lu_const(v: u64) -> SsaInstr {
		return graph.valConst(inttype, Long.box(inttype.trunc_64(long.!(v))));
	}
	def shiftcheck(i: SsaApplyOp, y: SsaInstr) -> SsaInstr {
		var bound = posIntBound(y);
		if (bound >= 0 && bound < IntType.!(i.op.resultType).width) {
			i.facts |= Fact.O_NO_SHIFT_CHECK;
		}
		return i;
	}
	def boundscheck(i: SsaApplyOp) -> SsaInstr {
		// XXX: introduce partial bounds checks when length is a known constant.
		var receiver = nullcheck(i);
		if (SsaThrow.?(receiver)) return receiver;
		// Initialize the match state for {x} and {y}.
		var yval = binop(i);
		if (yconst && Int.unbox(yval) < 0) {
			// will always throw out of bounds, but might need a null check first.
			if (!i.checkFact(Fact.O_NO_NULL_CHECK)) addExplicitNullCheck(i.source, receiver);
			return addThrow(i.source, V3Exception.BoundsCheck);
		}
		// Compute the constant length of the array if possible.
		var length = -1;
		if (xconst) {
			length = Record.!(xval).values.length;
		} else if (x.opcode() == Opcode.ArrayAlloc.tag) {
			var l = x.inputs(0).dest;
			if (!SsaValue.?(l)) return receiver;
			length = l.unbox<int>();
		} else if (x.opcode() == Opcode.ArrayInit.tag) {
			length = x.inputs.length;
		} else {
			return receiver;
		}

		if (yconst) {
			// Array length and index are constants. Static bounds check.
			var index = Int.unbox(yval);
			if (index < length) {
				i.facts |= Facts.O_SAFE_BOUNDS;
				return receiver;
			}
			return addThrow(i.source, V3Exception.BoundsCheck);
		}
		// Array length is a constant, try range analysis of the index.
		var bound = posIntBound(y);
		if (bound < 0) return receiver;
		if (bound < length) i.facts |= Facts.O_SAFE_BOUNDS;
		return receiver;
	}
	def addExplicitNullCheck(source: Source, receiver: SsaInstr) -> SsaInstr {
		var t = receiver.getType();
		var check = add(source, V3Op.newEqual(t), [receiver, graph.nullConst(t)]);
		return add(source, V3Op.newConditionalThrow(V3Exception.NullCheck), [check]);
	}
	def posIntBound(x: SsaInstr) -> int {
		if (SsaValue.?(x)) {
			var val = SsaValue.!(x).val;
			if (val == null) return 0;
			if (Box<int>.?(val)) return Box<int>.!(val).val;
			return -1;
		}
		var bound = posIntBoundFromType(x);
		if (!SsaApplyOp.?(x)) return bound;
		var i = SsaApplyOp.!(x);
		match (i.op.opcode) {
			IntAnd: {
				var lb = posIntBound(i.input0()), rb = posIntBound(i.input1());
				if (bound < 0 || (lb >= 0 && lb < bound)) bound = lb;
				if (bound < 0 || (rb >= 0 && rb < bound)) bound = rb;
			}
			VariantGetTag: {
				var c = ClassType.!(i.op.typeArgs(0)).classDecl;
				var b = if(c.isVariantCase(), c.variantTag, c.cases.length - 1);
				if (b < bound) bound = b;
			}
			IntConvert, TypeSubsume, TypeCast: {
				var b = posIntBound(i.input0());
				if (bound < 0 || (b >= 0 && b < bound)) {
					var t = i.getType();
					if (IntType.?(t)) {
						// conversion to smaller signed type might overflow.
						var it = IntType.!(t);
						if (it.signed && it.width <= 32 && b > Int.unbox(it.max)) b = bound;
					}
					bound = b;
				}
			}
			_: ;
		}
		return bound;
	}
	def posIntBoundFromType(x: SsaInstr) -> int {
		var t = x.getType();
		if (IntType.?(t)) {
			var it = IntType.!(t);
			if (it.width > 32) return -1;
			if (!it.signed || x.checkFact(Fact.V_NON_NEGATIVE)) return Int.unbox(it.max);
		}
		if (t.typeCon.kind == V3Kind.ENUM) {
			return ClassType.!(t).classDecl.cases.length - 1;
		}
		return -1;
	}

	def nullcheck(i: SsaApplyOp) -> SsaInstr {
		var receiver = i.input0();
		if (i.checkFact(Fact.O_NO_NULL_CHECK)) return receiver;
		if (receiver.checkFact(Fact.V_NON_ZERO)) {
			i.facts |= Fact.O_NO_NULL_CHECK;
			return receiver;
		}
		if (receiver.checkFact(Fact.V_ZERO)) return addThrow(i.source, V3Exception.NullCheck);
		if (!state.optimize_nullchecks) return receiver;
		for (l = state.nonnull; l != null; l = l.tail) {
			if (l.head == receiver) {
				i.facts |= Fact.O_NO_NULL_CHECK;
				return receiver;
			}
		}
		state.nonnull = List.new(receiver, state.nonnull);
		return receiver;
	}	
	def lookupField(load: SsaInstr, receiver: SsaInstr, field: IrField) -> SsaInstr {
		if (!state.optimize_loads) return load;
		for (l = state.fields; l != null; l = l.tail) {
			var h = l.head;
			if (h.0 == receiver && h.1 == field) return h.2;
		}
		state.addField(receiver, field, load);
		return load;
	}
	def devirtualize(m: IrSpec, x: SsaInstr) -> IrSpec {
		if (!m.member.checkFact(Fact.M_OVERRIDDEN)) {
			return m; // CHA devirtualization
		} else if (SsaValue.?(x) && asRecord(x) != null) {
			return context.prog.ir.resolveMethodImpl(asRecord(x).rtype, m); // devirtualize K
		} else if (x.opcode() == Opcode.ClassAlloc.tag) {
			return context.prog.ir.resolveMethodImpl(SsaApplyOp.!(x).op.typeArgs(0), m); // devirtualize ClassAlloc
		}
		return null;
	}

	def extractIrSpecI(x: SsaInstr) -> IrSpec {
		return extractIrSpec(SsaApplyOp.!(x).op);
	}
	def extractIrSpec(op: Operator) -> IrSpec {
		var ta = op.typeArgs;
		return IrSpec.new(ta(0), ta, op.attr<IrMember>());
	}
	def asRecord(i: SsaInstr) -> Record {
		return Record.!(SsaValue.!(i).val);
	}
	def getFieldType(op: Operator) -> Type {
		return if(op.isPolymorphic(), extractIrSpec(op).getFieldType(), IrField.!(op.attr<IrMember>()).fieldType);
	}
	def getIrField(i: SsaApplyOp) -> IrField {
		return IrField.!(i.op.attr<IrMember>());
	}

	//======================================================================
	// Editing helpers
	//======================================================================
	def addThrow(source: Source, exception: string) -> SsaInstr {
		if (state.end) return null;
		state.end = true;
		var t = SsaThrow.new(source, exception);
		t.insertBefore(prev.next);
		// kill the rest of the instructions in the block
		var cfopt = SsaCfOptimizer.new(context);
		for (p = t.next; !SsaBlock.?(p); ()) {
			var n = p.next;
			p.remove();
			if (SsaEnd.?(p)) {
				var end = SsaEnd.!(p);
				cfopt.killSuccs(end.succs);
				cfopt.killInstr(end);
				break;
			}
			if (SsaInstr.?(p)) cfopt.killInstr(SsaInstr.!(p));
			p = n;
		}
		return t;
	}
	def addConditionalThrow(source: Source, exception: string, cond: SsaInstr) -> SsaInstr {
		return add(source, V3Op.newConditionalThrow(exception), [cond]);
	}
	def addBinop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return add(null, op, [x, y]);
	}
	def replaceOp(i: SsaApplyOp, op: Operator) -> SsaInstr {
		var args = Array<SsaInstr>.new(i.inputs.length);
		for (j < args.length) args(j) = i.inputs(j).dest;
		var ni = add(i.source, op, args);
		ni.facts |= i.facts;
		return ni;
	}
	def convert(i: SsaValue, t: Type) -> SsaInstr {
		if (i.vtype == t) return i;
		var cast = TypeSystem.evalTypeCast(i.vtype, t, i.val);
		var val = if(cast.approx == CastOp.VALUE, cast.result, i.val);
		return graph.valConst(t, val);
	}
	def addEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(!state.end, addBinop(V3Op.newEqual(t), x, y));
	}
	def addNotEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(!state.end, addNot(addBinop(V3Op.newEqual(t), x, y)));
	}
	def addNot(x: SsaInstr) -> SsaInstr {
		return if(!state.end, add(null, V3Op.opBoolNot, [x]));
	}
	def addEnumToSet(tc: V3EnumSet_TypeCon, x: SsaInstr) -> SsaInstr {
		// XXX: reduce duplication with V3EnumSet_TypeCon
		var shl = tc.intType.lookupInfix0(V3Infix.QShl);
		var one = graph.valConst(tc.intType, tc.intType.box(1));
		var i = add(null, shl, [one, x]);
		i.setFact(Fact.O_NO_SHIFT_CHECK);
		return i;
	}
	def add(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		if (state.end) return null;
		var i = SsaApplyOp.new(source, op, args);
		i.insertBefore(prev.next);
		i.facts |= Operators.facts(op.opcode);
		prev = i;
		return i;
	}
}

// Performs control flow optimizations on a completed SsaGraph.
class SsaCfOptimizer(context: SsaContext) {
	def mark = ++context.graph.markGen;
	def queue = Vector<SsaBlock>.new();

	def optimize() {
		// visit all the blocks of the graph
		// 1. reduce phis with identical inputs
		// 2. merge straight-line blocks (may introduce critical edges)
		// 3. optimize diamond-if patterns arising from if(a && b) patterns
		// 4. XXX iteratively reduce/fold code
		// 5. collapse if-chains into switches, esp if(T.?(e)) ...
		// 6. XXX remove useless branches
		queueBlock(context.graph.startBlock);
		for (i < queue.length) optBlock(queue.get(i));
	}
	def queueBlock(block: SsaBlock) {
		if (block.mark < mark) {
			block.mark = mark;
			queue.add(block);
		}
	}
	def optBlock(block: SsaBlock) {
		if (block.checkFact(Fact.O_KILLED)) return;
		var next = block.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			var nn = next.next;
			optPhi(SsaPhi.!(next));
			next = nn;
		}
		var i = 0, succ = block.succs();
		while (i < succ.length) {
			if (optEdge(succ(i))) {
				i = 0;
				succ = block.succs();
			} else {
				i++;
			}
		}
		var end = block.end();
		if (SsaIf.?(end)) {
			optIf(block, SsaIf.!(end));
		}
		for (s in block.succs()) {
			if (s.dest != null) queueBlock(s.dest);
		}
	}
	def optPhi(phi: SsaPhi) -> bool {
		var inputs = phi.inputs;
		if (inputs.length == 0) return true; // phi has no remaining inputs
		var i0 = inputs(0).dest;
		if (i0 == null || phi.useList == null) {
			// one of the inputs is dead, or the phi is unused
			killInstr(phi);
			return true;
		}
		var facts = i0.facts, reduce = true;
		for (i in inputs) {
			var d = i.dest;
			if (d != phi) {
				facts = facts & d.facts;
				if (d != i0) reduce = false;
			}
		}
		if (reduce) {
			phi.replace(i0); // the phi can be replaced by its (one) input
			phi.remove();
			return true;
		} else {
			phi.setFact(facts); // phi facts are the intersection of all input facts
			return false;
		}
	}
	def optIf(block: SsaBlock, sw: SsaIf) {
		var e = sw.inputs(0), v = e.dest;
		if (SsaApplyOp.?(v)) {
			var cond = SsaApplyOp.!(v);
			if (cond.op.opcode == Opcode.TypeQuery) {
				// propagate type query success on true successor
				var queryTypes = cond.op.typeArgs;
				applyDominatorOptForInput0(cond.input0(), sw.succs(0), optFoldCast(_, queryTypes));
			} else if (cond.op.opcode == Opcode.RefEq) {
				tryPropagatingCmpNonZero(cond, sw.succs(0), sw.succs(1));
			} else if (cond.op.opcode == Opcode.IntEq) {
				tryPropagatingCmpNonZero(cond, sw.succs(0), sw.succs(1));
				tryBuildingSwitch(block, sw, cond.op.typeArgs(0), cond);
			}
			return;
		}

		// match and simplify a control flow pattern where the input to a switch
		// is the merge of a previous branch; e.g. this occurs in if(a && b)
		if (!e.isOnlyEdge()) return; // condition is used elsewhere as well
		if (!block.empty()) return; // block is not empty
		if (!SsaPhi.?(v)) return; // branch condition is not a phi
		var phi = SsaPhi.!(v);
		if (phi.block != block) return; // phi is in a different block
		if (SsaPhi.?(phi.next)) return; // other phis in this block

		// search for and remove inputs to the phi that are constants
		var ivec = Vector<SsaInstr>.new(), evec = Vector<SsaCfEdge>.new();
		var inputs = phi.inputs, edges = block.preds;
		for (i < inputs.length) {
			var input = inputs(i), edge = edges(i);
			if (SsaValue.?(input.dest)) {
				// redirect incoming edge to outgoing edge
				var succ = sw.findSucc(SsaValue.!(input.dest).val);
				appendPhiInput(succ.dest, succ.desti);
				edge.connect(succ.dest);
				optEdge(edge);
				input.update(null); // kill the use of the value
			} else {
				ivec.add(input.dest);
				evec.add(edge);
			}
		}

		if (ivec.length == phi.inputs.length) return; // no updates
		if (ivec.length == 0) return killBlock(block); // no predecessors remain
		block.preds = evec.extract();
		if (ivec.length == 1) {
			e.update(ivec.get(0)); // only one input remains
			optEdge(block.preds(0));
		} else {
			// more than one input to this phi is remaining, build a new phi
			var newPhi = SsaPhi.new(phi.getType(), block, ivec.extract());
			block.prepend(newPhi);
			e.update(newPhi);
		}
	}
	def tryPropagatingCmpNonZero(cmp: SsaApplyOp, eqEdge: SsaCfEdge, neEdge: SsaCfEdge) {
		var left = cmp.input0(), right = cmp.input1();
		if (left.checkFact(Fact.V_NON_ZERO)) {
			return applyDominatorOptForInput0(right, eqEdge, optNullCheck);
		}
		if (left.checkFact(Fact.V_ZERO)) {
			return applyDominatorOptForInput0(right, neEdge, optNullCheck);
		}
		if (right.checkFact(Fact.V_NON_ZERO)) {
			return applyDominatorOptForInput0(left, eqEdge, optNullCheck);
		}
		if (right.checkFact(Fact.V_ZERO)) {
			return applyDominatorOptForInput0(left, neEdge, optNullCheck);
		}
	}
	def matchSwitchCmp(key: SsaInstr, block: SsaBlock) -> SwitchCmp {
		// XXX: match commute constants, etc.
		var end = block.end();
		if (!SsaIf.?(end)) return null;
		var i = SsaIf.!(end);
		var edge = i.inputs(0);
		if (!edge.isOnlyEdge()) return null;
		var cmp = edge.dest;
		if (cmp.opcode() != Opcode.IntEq.tag) return null;
		if (cmp.inputs(0).dest != key) return null;
		var r = cmp.inputs(1).dest;
		if (!SsaValue.?(r)) return null;
		return SwitchCmp.new(Int.unbox(SsaValue.!(r).val), cmp, i, block.succ(0), block.succ(1));
	}
	def verifySwitchCmpBlock(cmp: SwitchCmp, block: SsaBlock) -> bool {
		for (i = block.next; i != block; i = i.next) {
			if (i != cmp.cmp && i != cmp.end) return false;
		}
		return true;
	}
	def tryBuildingSwitch(block: SsaBlock, sw: SsaIf, t: Type, cmp: SsaInstr) {
		if (!context.compiler.EmitSwitch) return;
		if (!V3.isInt32(t)) return;
		var key = cmp.input0();
		var cmp = matchSwitchCmp(key, block);
		if (cmp == null) return;
		var vec = Vector<SwitchCmp>.new();
		vec.add(cmp);
		// add switch case candidates to the list.
		while (true) {
			if (cmp.fSucc.dest.preds.length != 1) break;
			var block = cmp.fSucc.dest;
			cmp = matchSwitchCmp(key, block);
			if (cmp == null) break;
			if (!verifySwitchCmpBlock(cmp, block)) break;
			vec.add(cmp);
		}

		// determine if building a table would be profitable.
		if (vec.length < 4) return;  // not enough cases.
		var min = Int.MAX_VALUE, max = Int.MIN_VALUE;
		for (i < vec.length) {
			var v = vec.get(i).val;
			if (v < min) min = v;
			if (v > max) max = v;
		}
		var diff = u32.!(max - min) + 1;
		if (diff > vec.length * 2) return; // table would be less than 50% full.
		if (diff > int.max) return;  // table would be too large.
		var size = int.!(diff);
		var table = Array<SsaCfEdge>.new(size);
		// build dispatch table.
		for (i = vec.length - 1; i >= 0; i--) {
			var c = vec.get(i), index = c.val - min;
			var p = table(index);
			if (p != null) removeEdge(p);
			table(index) = c.tSucc;
		}
		var sw = SsaSwitch.new(key.getType(), min, max, key);
		// build array of successor edges.
		var dmerge: SsaBlock;
		for (i < size) {
			var e = table(i);
			if (e == null) {  // hole in the table; go to default
				if (dmerge == null) dmerge = SsaBlock.new();
				sw.succs(i).connect(dmerge);
			} else {
				replaceEdge(e, sw.succs(i));
			}
		}
		// set up default edge.
		var defedge = vec.get(vec.length - 1).fSucc;
		if (dmerge != null) {
			sw.succs(size).connect(dmerge);
			var goto = SsaGoto.new(null);
			dmerge.append(goto);
			replaceEdge(defedge, goto.succs(0));
		} else {
			replaceEdge(defedge, sw.succs(size));
		}

		// Remove the ifs and comparisons from the end of the blocks.
		for (i < vec.length) {
			var c = vec.get(i);
			c.end.kill();
			c.end.remove();
			c.cmp.kill();
			c.cmp.remove();
		}

		// Replace the first if with a switch.
		block.append(sw);
	}
	def killBlock(block: SsaBlock) {
		if (block.checkFact(Fact.O_KILLED)) return;
		// Recursively kill this block and its successor blocks
		block.setFact(Fact.O_KILLED);
		var succs = block.succs();
		var i = block.next;
		while (i != null) {
			// Kill all instructions in the block
			var n = i.next;
			i.next = null;
			i.prev = null;
			if (SsaInstr.?(i)) {
				var j = SsaInstr.!(i);
				j.kill();
				j.setFact(Fact.O_KILLED);
			}
			i = n;
		}
		killSuccs(succs);
	}
	def killSuccs(edges: Array<SsaCfEdge>) {
		// kill the outgoing control flow edges
		var succs = Vector<SsaBlock>.new();
		for (s in edges) {
			var d = s.dest;
			if (d != null) {
				removeEdge(s);
				succs.add(d);
			}
		}
		// kill any dead successor blocks.
		for (i < succs.length) {
			var d = succs.get(i);
			if (!d.hasPred()) killBlock(d);
		}
	}
	def killInstr(i: SsaInstr) -> SsaInstr {
		i.remove();
		i.kill();
		i.facts |= Fact.O_KILLED;
		return i;
	}
	def optEdge(edge: SsaCfEdge) -> bool {
		var src = edge.src, dest = edge.dest;
		if (dest == null) return false; // edge may have already been optimized away
		if (dest.preds.length > 1) return false; // destination has more than one predecessor
		if (src.succs.length > 1) {
			// try to skip the destination block
			if (dest.succs().length != 1) return false;	// doesn't end with a goto
			if (!dest.empty()) return false;		// is not empty
			var destdest = dest.succ(0).dest;
			if (destdest.hasPhis()) return false;		// has phis
			simplifyPhis(dest);
			edge.connect(destdest);				// redirect edge
			killBlock(dest);				// try to kill the destination
			return true;
		}
		// Kill the end of the previous block
		var block = src.block();
		if (block == null) return V3.fail1("block of @%1 is null", src.uid);
		src.kill();
		src.remove();

		// Move destination instructions, including end, into source
		simplifyPhis(dest);
		var first = dest.next, end = dest.end();
		first.prev = null;
		end.next = null;
		if (first != null) block.appendN(first);
		return true;
	}
	def appendPhiInput(dest: SsaBlock, index: int) {
		// add a new edge X -> B, using A's input to each phi as X's input
		var next = dest.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			// for each phi, add a new input corresponding to this edge
			var phi = SsaPhi.!(next);
			var input = phi.inputs(index).dest;
			phi.inputs = Arrays.append(SsaDfEdge.new(phi, input), phi.inputs);
			next = next.next;
		}
	}
	def replaceEdge(abEdge: SsaCfEdge, xbEdge: SsaCfEdge) {
		// replace the old edge A -> B with a new edge X -> B
		xbEdge.replace(abEdge);
	}
	def removeEdge(edge: SsaCfEdge) {
		var dest = edge.dest;
		if (dest == null) return;
		var next = dest.next, index = edge.desti, preds = dest.preds;
		for (i = index + 1; i < preds.length; i++) {
			var p = preds(i);
			preds(i - 1) = p;
			p.desti = i - 1;
		}
		dest.preds = Arrays.range(dest.preds, 0, dest.preds.length - 1);
		while (true) {
			if (!SsaPhi.?(next)) break;
			var phi = SsaPhi.!(next), inputs = phi.inputs;
			// for each phi, remove the corresponding input
			inputs(index).update(null); // kill the DF edge
			phi.inputs = Arrays.deleteAt(phi.inputs, index);
			next = phi.next;
		}
		if (dest.preds.length == 1) simplifyPhis(dest);
	}
	def simplifyPhis(block: SsaBlock) {
		var next = block.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			var phi = SsaPhi.!(next), nn = phi.next;
			phi.replace(phi.input0());
			killInstr(phi);
			next = nn;
		}
	}
	// fold away a type cast if dominated by a type query that evaluates to true
	def optFoldCast(i: SsaInstr, queryTypes: Array<Type>) -> SsaInstr {
		if (i.opcode() == Opcode.TypeCast.tag) {
			// fold away a type cast
			var cast = SsaApplyOp.!(i), castTypes = cast.op.typeArgs;
			if (TypeSystem.isSubtype(queryTypes(1), castTypes(1))) {
				return SsaApplyOp.new(cast.source, V3Op.newTypeSubsume(castTypes(0), castTypes(1)), [i.input0()]);
			} else {
				i.setFact(Fact.O_NO_NULL_CHECK);
			}
		}
		return optNullCheck(i);
	}
	// eliminate a null check on this instruction
	def optNullCheck(i: SsaInstr) -> SsaInstr {
		if (!SsaApplyOp.?(i)) return i;
		match (SsaApplyOp.!(i).op.opcode) {
			NullCheck,
			BoundsCheck,
			ArrayGetElem,
			ArraySetElem,
			ArrayGetLength,
			TypeCast,
			TypeQuery,
			ClassGetMethod,
			ClassGetVirtual,
			CallMethod,
			CallClassVirtual,
			ClassGetField,
			ClassSetField: {
				i.setFact(Fact.O_NO_NULL_CHECK);
			}
			_: ;
		}
		return i;
	}
	// apply the function "f" to every dominated instruction i where i.input0() == obj
	def applyDominatorOptForInput0(obj: SsaInstr, edge: SsaCfEdge, f: SsaInstr -> SsaInstr) {
		if (edge.dest.preds.length > 1) return;
		var block = edge.dest;
		// search this block for instructions to optimize
		// XXX: employ useList and domination numbers to only inspect instructions
		// that use this value
		for (l = block.next; l != block; l = l.next) {
			if (!SsaInstr.?(l)) continue;
			var i = SsaInstr.!(l);
			if (i.inputs.length < 1) continue; // instr doesn't involve obj
			if (i.input0() != obj) continue; // instr doesn't involve obj
			var ni = f(i);
			if (ni != i) {
				ni.insertBefore(i);
				i.remove();
				i.replace(ni);
				l = ni;
			}
		}
		// XXX: propagate the fact to blocks dominated by this block
	}
	def replaceWithGoto(block: SsaBlock, end: SsaEnd, target: SsaCfEdge) {
		// Kill the previous end
		var oldsucc = end.succs;
		end.kill();
		end.remove();
		// Add a goto
		var goto = SsaGoto.new(null);
		goto.succs(0).replace(target);
		block.append(goto);
		// Optimize the dead branches
		for (dead in oldsucc) {
			if (dead == target) continue;
			var dest = dead.dest;
			removeEdge(dead);
			if (!dest.hasPred()) killBlock(dest);
		}
	}

}
class SwitchCmp(val: int, cmp: SsaInstr, end: SsaIf, tSucc: SsaCfEdge, fSucc: SsaCfEdge) { }


// Performs optimizations on loops.
// 1. eliminate rendundant bounds checks for induction variables.
// 2. XXX eliminate redundant null checks.
// 3. XXX loop rotation (move loop test condition to end of loop)
// 4. XXX loop-invariant code motion (move code out of loops)
// 5. XXX loop peeling (copy first iteration of loop)
// 6. XXX induction variable simplifications
// 7. XXX remove useless loops
class SsaLoopOptimizer {
	def graph: SsaGraph;
	def header: SsaBlock;	// start of loop (ends with loop condition)
	def loopBody: SsaBlock; // first block of loop body
	def loopEnd: SsaBlock;  // first block outside of loop
	def headerMark = ++graph.markGen;
	def bodyMark = ++graph.markGen;
	def gvn = Gvn.new(graph);
	new(graph, header, loopBody, loopEnd) {}
	def optimize() {
		// XXX: optimize phis in header first
		// XXX: pull loop-invariant code out of header
		var c = findLoopControl(), cond = c.0, condTrue = c.1;
		var ivs = findLinearIvs();
		for (l = ivs; l != null; l = l.tail) {
			var iv = l.head;
			if (cond != null) tryBoundingIv(iv, cond, condTrue);
		}
	}
	def tryBoundingIv(iv: SsaLinearIv, cond: SsaInstr, condTrue: bool) {
		var op: BoundOp;
		match (cond.opcode()) {
			Opcode.IntLt.tag: op = BoundOp.Lt;
			Opcode.IntLteq.tag: op = BoundOp.Lteq;
			_: return;
		}
		boundIvInequality(iv, op, cond, condTrue);
		optBoundedIv(iv);
	}
	def boundIvInequality(iv: SsaLinearIv, op: BoundOp, cond: SsaInstr, condTrue: bool) {
		iv.bound = cond.input1();
		if (iv.bound == iv.phi) {
			iv.bound = cond.input0();
			op = op.commute();
		}
		if (!condTrue) op = op.inverse();
		iv.boundOp = op;
	}
	// identify the control condition of the loop
	def findLoopControl() -> (SsaInstr, bool) {
		var e = header.end();
		if (SsaIf.?(e)) {
			var sw = SsaIf.!(e);
			if (sw.trueBlock() == loopBody) return (sw.input0(), true);
			if (sw.falseBlock() == loopBody) return (sw.input0(), false);
		}
		return (null, false);
	}
	// find simple induction variables of the form v = phi(v, v + N, v + N)
	def findLinearIvs() -> List<SsaLinearIv> {
		var list: List<SsaLinearIv>;
		var next = header.next;
		while (true) {
			if (!SsaPhi.?(next)) break;
			list = matchIv(SsaPhi.!(next), list);
			next = next.next;
		}
		return list;
	}
	// find a linear induction variable
	def matchIv(phi: SsaPhi, prev: List<SsaLinearIv>) -> List<SsaLinearIv> {
		var init: SsaInstr, step: Box<int>;
		for (i in phi.inputs) {
			var pi = i.dest;
			if (hasInput(pi, phi)) {
				// check increment matches in each induction
				var n = gvn.matchInc(pi);
				if (n == null) step = null;
				else if (step == null) step = n;
				else if (step.val != n.val) return prev;
			} else if (init != null) {
				if (pi != null) return prev;
			} else {
				init = pi;
			}
		}
		if (init == null || step == null) return prev;
		return List.new(SsaLinearIv.new(phi, init, step.val), prev);
	}
	// check whether x has i as one of its inputs
	def hasInput(x: SsaInstr, i: SsaInstr) -> bool {
		for (xi in x.inputs) {
			if (xi.dest == i) return true;
		}
		return false;
	}
	// optimize uses of a bounded linear induction variable
	def optBoundedIv(iv: SsaLinearIv) {
		if (iv.step > 0) {
			// XXX: what about uses before the condition is checked?
			iv.phi.setFact(iv.init.facts & iv.bound.facts & Fact.V_NON_NEGATIVE);
		}
		markHeader(headerMark); // XXX: only mark header once?
		for (u: Edge<SsaInstr> = iv.phi.useList; u != null; u = u.next) {
			var use = u.src;
			if (use.mark != headerMark) optBoundedIvUse(iv, use);
		}
		markHeader(-1);
	}
	def optBoundedIvUse(iv: SsaLinearIv, use: SsaInstr) {
		var opcode = use.opcode();
		// XXX: optimize inequalities, especially MachOp.opUgteq
		if (opcode == Opcode.BoundsCheck.tag ||
		    opcode == Opcode.ArrayGetElem.tag ||
		    opcode == Opcode.ArraySetElem.tag) {
			if (use.input1() == iv.phi) optBoundsCheck(iv, use, use.input0());
		}
	}
	def optBoundsCheck(iv: SsaLinearIv, use: SsaInstr, array: SsaInstr) {
		match(iv.boundOp) {
			Lt, Lteq: {
				if (iv.step < 0) return; // must be counting up
				if (!iv.init.checkFact(Fact.V_NON_NEGATIVE)) return; // init must be >= 0
				var isBounded = if(iv.boundOp == BoundOp.Lt, gvn.lteqArrayLength, gvn.ltArrayLength);
				if (isBounded(iv.bound, array)) use.setFact(Facts.O_SAFE_BOUNDS);
			}
			Gt, Gteq: {
				if (iv.step > 0) return; // must be counting down
				if (!iv.bound.checkFact(Fact.V_NON_NEGATIVE)) return; // bound must be >= 0
				if (gvn.ltArrayLength(iv.init, array)) use.setFact(Facts.O_SAFE_BOUNDS);
			}
			_: ;
		}
	}
	// mark instructions in header, not in body or after loop end
	def markHeader(mark: int) {
		markBlocks(header, [loopBody, loopEnd], mark);
	}
	// mark instructions in body, not in header or after loop end
	def markBody(mark: int) {
		markBlocks(loopBody, [header, loopEnd], mark);
	}
	// mark all the blocks up to but not including [end] with the given mark
	def markBlocks(block: SsaBlock, end: Array<SsaBlock>, mark: int) {
		for (e in end) if (block == e) return; // reached an end block
		if (block.mark == mark) return; // already marked
		block.mark = mark;
		markBlockInstrs(block, mark); // mark phis and instructions block
		for (s in block.succs()) markBlocks(s.dest, end, mark); // recursively mark successors
	}
	// mark all the instructions in a block with a given mark
	def markBlockInstrs(block: SsaBlock, mark: int) {
		for (i = block.next; i != block; i = i.next) i.mark = mark;
	}
}
// an induction variable "x = I + N * i" with optional bound of the form
// x <op> bound, e.g. x < a.length, x >= 3, etc
class SsaLinearIv {
	def phi: SsaPhi;	// x
	def init: SsaInstr;	// I
	def step: int;		// N
	var boundOp: BoundOp;	// operator of bound
	var bound: SsaInstr;	// value of bound
	new(phi, init, step) {}
}
type BoundOp {
	case Lt;
	case Lteq;
	case Gt;
	case Gteq;
	def inverse() -> BoundOp {
		match (this) {
			Lt: return BoundOp.Gteq;
			Lteq: return BoundOp.Gt;
			Gt: return BoundOp.Lteq;
			Gteq: return BoundOp.Lt;
		}
	}
	def commute() -> BoundOp {
		match (this) {
			Lt: return BoundOp.Gt;
			Lteq: return BoundOp.Gteq;
			Gt: return BoundOp.Lt;
			Gteq: return BoundOp.Lteq;
		}
	}
}

// Performs load/store optimizations on a completed SsaGraph.
class SsaLoadOptimizer(context: SsaContext) {
	var pure = SsaLoadedFields.new();
	var impure = SsaLoadedFields.new();
	var any = false;

	def optimize() -> bool {
		// visit all the blocks of the graph, removing redundant loads.
		for (block in context.graph.bfBlocks()) optBlock(block);
		return any;
	}
	def optBlock(block: SsaBlock) {
		pure.length = 0;
		impure.length = 0;
		var i = block.next;
		while (SsaApplyOp.?(i)) {
			var instr = SsaApplyOp.!(i);
			var next = instr.next;
			var repl = optInstr(instr);
			if (repl != null) {
				any = true;
				instr.replace(repl);
				instr.remove();
			}
			i = next;
		}
	}
	def optInstr(apply: SsaApplyOp) -> SsaInstr {
		match (apply.op.opcode) {
			ClassAlloc: {
				if (memberOf(apply) != null) impure.length = 0;
			}
			// XXX: ClassGetMethod, ClassGetVirtual for monomorphic methods.
			ClassGetField: return load(apply.input0(), apply);
			ComponentGetField: return load(null, apply);
			ClassInitField: {
				var obj = apply.input0(), f = fieldOf(apply);
				pure.add(obj, f, apply.input1());
			}
			ClassSetField: return store(apply.input0(), apply);
			ComponentSetField: return store(null, apply);
			Init,
			CallMethod,
			CallClassVirtual,
			CallClosure,
			CallFunction,
			SystemOp: impure.length = 0;
			_: ;
		}
		return null;
	}
	def load(obj: SsaInstr, apply: SsaApplyOp) -> SsaInstr {
		if (apply.useList == null && apply.checkFact(Fact.O_NO_NULL_CHECK)) {
			apply.replace(null);
			return context.graph.zeroConst();  // XXX: recursively delete dead code
		}
		var m = memberOf(apply), val = find(obj, m);
		if (val != null) return val;
		if (m.isConst() || IrMethod.?(m)) pure.add(obj, m, apply);
		else impure.add(obj, m, apply);
		return null;
	}
	def store(obj: SsaInstr, apply: SsaApplyOp) -> SsaInstr {
		var f = fieldOf(apply);
		impure.kill(f);
		impure.add(obj, f, apply.input1());
		return null;
	}
	def find(o: SsaInstr, f: IrMember) -> SsaInstr {
		var v = pure.find(o, f);
		return if(v == null, impure.find(o, f), v);
	}
	def fieldOf(apply: SsaApplyOp) -> IrField {
		return IrField.!(apply.op.attr<IrMember>());
	}
	def memberOf(apply: SsaApplyOp) -> IrMember {
		return apply.op.attr<IrMember>();
	}
}
// Analysis data for tracking the loaded fields.
class SsaLoadedFields {
	var array = Array<(SsaInstr, IrMember, SsaInstr)>.new(4);
	var length = 0;
	def add(obj: SsaInstr, f: IrMember, val: SsaInstr) {
		if (length == array.length) array = Arrays.grow(array, array.length * 2);
		array(length++) = (obj, f, val);
	}
	def find(obj: SsaInstr, f: IrMember) -> SsaInstr {
		for (i < length) {
			var t = array(i);
			if (t.0 == obj && t.1 == f) return t.2;
		}
		return null;
	}
	def kill(f: IrField) {
		var i = 0;
		for (j < length) {
			var t = array(j);
			if (t.1 != f) {
				if (i != j) array(i) = t;
				i++;
			}
		}
		length = i;
	}
}
