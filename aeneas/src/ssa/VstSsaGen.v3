// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def INDEX_0 = [0];
// Information about a local variable, including whether it is written (i.e. non-SSA),
// and all loops in which it is written
class VstSsaVar {
	var instr: SsaInstr;
	var writeFlags: int;
	var index: int = -1;
	var extWriteFlags: Array<bool>;

	def setWrittenInLoop(loopIndex: int) {
		var bit = u5.view(loopIndex);
		if (bit == loopIndex) { // use the flags word if loop index is low enough
			writeFlags = writeFlags | (1 << bit);
			return;
		}
		var extIndex = loopIndex - 32;
		if (extWriteFlags == null) extWriteFlags = Array.new(extIndex + 3);
		if (extIndex >= extWriteFlags.length) extWriteFlags = Arrays.grow(extWriteFlags, extIndex + 3);
		extWriteFlags[extIndex] = true;
	}
	def isWritten() -> bool {
		return index >= 0;
	}
	def isWrittenInLoop(loopIndex: int) -> bool {
		var bit = u5.view(loopIndex);
		if (bit == loopIndex) return ((writeFlags >>> bit) & 1) != 0;
		if (extWriteFlags == null) return false;
		if (loopIndex - 32 >= extWriteFlags.length) return false;
		return extWriteFlags[loopIndex - 32];
	}
}
def elimTypeVars = VstIr.elimTypeVars;
// Generates SSA (static single assignment) form from VST syntax trees
// XXX: simplify conservative phis generated for loops
class VstSsaGen extends VstVisitor<VstSsaEnv, SsaInstr> {
	def context: SsaContext;		// compiler, program, method, etc
	def ir = context.prog.ir;
	var graph: SsaGraph;
	def meth = context.method.source;	// the VST method
	def opBuilder: IrOpMethodBuilder;	// builder for IrOpMethods
	var nonSsaVars: Array<VarDecl>;		// variables that are assigned more than once
	var recordDirectCalls: bool;
	var directCallTargets: List<IrSpec>;
	var directCallBlocks: List<SsaBlock>;

	new(context, opBuilder) {
		var params = Array<SsaParam>.new(meth.numParams);
		var receiver = params[0] = newParam(meth.thisParam);
		if (V3.isVariant(receiver.vtype)) {
			if (V3.getVariantTag(receiver.vtype) > 0) receiver.facts |= Fact.V_NON_ZERO;
		} else if (V3.isClass(receiver.vtype)) {
			receiver.facts |= Fact.V_NON_ZERO;
		}
		for (l = meth.params.list; l != null; l = l.tail) {
			params[l.head.index] = newParam(l.head);
		}
		context.graph = graph = SsaGraph.new(params, context.method.sig.returnType());
		if (meth != null) nonSsaVars = Array.new(meth.numNonSsa);
	}
	private def newParam(p: ParamDecl) -> SsaParam {
		var np = SsaParam.new(p.index, p.vtype);
		p.ssa.instr = np;
		return np;
	}
	def generate() -> SsaGraph {
		if (EmptyStmt.?(meth.body)) {
			// simply add a throw
			var source = tokenSource(EmptyStmt.!(meth.body).point);
			graph.startBlock.append(SsaThrow.new(source, V3Exception.Unimplemented));
		} else if (CLOptions.FATAL_CALLS.val.matches(meth)) {
			var source = tokenSource(meth.body.range());
			graph.startBlock.append(SsaThrow.new(source, V3Exception.FatalCall));
		} else {
			// build SSA code
			var initialEnv = VstSsaEnv.new(meth.numNonSsa, this, null, graph.startBlock);
			setInitialParam(meth.thisParam, initialEnv);
			Lists.apply(meth.params.list, setInitialParam(_, initialEnv));
			Lists.apply(meth.params.list, initialEnv.addNewVarDecl);
			if (VstNew.?(meth)) addConstructorCode(VstNew.!(meth), initialEnv);
			meth.body.accept(this, initialEnv);
			if (!initialEnv.end) {
				// add an appropriate return
				if (meth.returnThis) initialEnv.addReturn([getThisParam()]);
				else initialEnv.addReturn([graph.nop()]);
			}
		}
		context.method.ssa = graph;
		context.printSsa("Generated");
		return graph;
	}
	def addConstructorCode(decl: VstNew, env: VstSsaEnv) {
		if (decl.receiver.isEnum()) return addEnumParamInitCode(env);
		appendImplicitFieldInits(decl.params.list, env);
		appendFieldInits(decl.memberinits, env);
		appendSuperClause(decl.superclause, env);
	}
	def addEnumParamInitCode(env: VstSsaEnv) {
		var params = meth.receiver.params.asArray();
		var types = Array<Type>.new(params.length);
		var consts = Array<SsaConst>.new(params.length);
		for (i < params.length) {
			var r = VstField.!(params[i].member).enumVals;
			consts[i] = context.graph.valConst(r.rtype, r);
			types[i] = r.rtype;
		}
		var cases = VstEnum.!(meth.receiver).cases;
		for (i < cases.length) {
			var c = cases[i], args = c.args.asArray();
			for (j < args.length) {
				var val = env.genExpr(args[j]);
				var index = context.graph.intConst(i);
				env.opArraySetElem(types[j], Int.TYPE, Facts.O_SAFE_BOUNDS, consts[j], index, val);
			}
		}
	}
	def getThisParam() -> SsaInstr {
		return graph.params[0];
	}
	def appendImplicitFieldInits(plist: List<ParamDecl>, env: VstSsaEnv) {
		while (plist != null) {
			var member = plist.head.member;
			if (member != null) {
				// add an assignment to the field / value
				var memberRef = ir.fromVstMember(member);
				var param: SsaInstr = graph.params[plist.head.index];
				var it = member.getType(), xt = plist.head.vtype;
				var exp = env.at(tokenSource(plist.head.token)).opTypeSubsume(xt, it, param); // implicit conversion if necessary
				env.opClassSetField(memberRef, getThisParam(), exp, true);
			}
			plist = plist.tail;
		}
	}
	def appendSuperClause(sclause: SuperClause, env: VstSsaEnv) {
		if (sclause != null) {
			var na = sclause.args.exprs.mapArray(env.genExpr);
			if (sclause.constructor.nontrivial()) {
				var superType = V3.getSuperType(meth.receiver.getDeclaredType());
				var superRef = ir.fromVstMemberAndType(superType, sclause.constructor);
				env.at(tokenSource(sclause.point)).opCallMethod(superRef, Arrays.prepend(getThisParam(), na));
			}
		}
	}
	def appendFieldInits(list: List<VstField>, env: VstSsaEnv) {
		var isClass = VstClass.?(meth.receiver);
		for (l = list; l != null; l = l.tail) {
			var member = l.head, memberRef = ir.fromVstMember(member);
			var r = getThisParam(), v = env.genExpr(member.init);
			env.at(exprSource(member.init));
			var f = memberRef.member;
			// transfer facts about initializing value to field
			if (v == null) return context.fail1("member init is null for %q", f.renderLong);
			if (f.facts.F_VALUE) f.facts = f.facts | (v.facts & Facts.V_FACTS);
			if (isClass) env.opClassSetField(memberRef, r, v, true);
			else env.opComponentSetField(memberRef, r, v);
		}
	}
	def setInitialParam(p: ParamDecl, env: VstSsaEnv) {
		if (p.ssa.index >= 0) {
			nonSsaVars[p.ssa.index] = p;
			env[p.ssa] = p.ssa.instr;
		}
	}
	// -- Statements --------------------------------------------------------
	def visitIf(stmt: IfStmt, env: VstSsaEnv) -> SsaInstr {
		// translate an if statement into control flow
		var cond = env.genExpr(stmt.cond);
		if (env.end) return null; // condition ended the block somehow
		if (context.compiler.VstBranchOpt && SsaConst.?(cond)) {
			if (cond.unbox<bool>()) {
				// fold a branch that is always true
				env.genStmt(stmt.tbranch);
				return null;
			} else {
				// fold a branch that is always false
				if (stmt.fbranch != null) env.genStmt(stmt.fbranch);
				return null;
			}
		}
		var tenv = env.split();
		if (stmt.fbranch == null) {
			// no else clause is present
			var cont = VstSsaMerge.new(this);
			env.addIf(cond, tenv.block, cont.block);
			cont.mergeIncoming(env);
			tenv.genStmt(stmt.tbranch);
			cont.merge(tenv);
			cont.setEnv(env);
			return null;
		} else {
			// else clause is present
			var fenv = env.split();
			var cont = VstSsaMerge.new(this);
			env.addIf(cond, tenv.block, fenv.block);
			tenv.genStmt(stmt.tbranch);
			cont.merge(tenv);
			fenv.genStmt(stmt.fbranch);
			cont.merge(fenv);
			cont.setEnv(env);
			return null;
		}
	}
	def visitBlock(stmt: BlockStmt, env: VstSsaEnv) -> SsaInstr {
		stmt.stmts.apply(env.genStmt);
		env.addDeleteVar(stmt.localVars.length);
		return null;
	}
	def visitWhile(stmt: WhileStmt, env: VstSsaEnv) -> SsaInstr {
		var loopStart = VstSsaMerge.new(this); // merge point for start of loop
		var header = loopStart.block;
		var loopEnv = loopStart.startLoop(env, stmt.loopNum);
		var cond = loopEnv.genExpr(stmt.cond);
		if (loopEnv.end) return null; // condition ended the block somehow
		if (context.compiler.VstBranchOpt && Ssa.isFalseConst(cond)) {
			// this is not a loop at all; skip the body
			return loopFallThru(env, loopEnv);
		}
		var loopEnd = VstSsaMerge.new(this);   // merge point for end of loop
		loopEnv.loopStart = loopStart;
		loopEnv.loopEnd = loopEnd;
		if (context.compiler.VstBranchOpt && Ssa.isTrueConst(cond)) {
			// this is an infinite loop that can only terminate with a break inside
			loopEnv.genStmt(stmt.body);
			loopStart.merge(loopEnv);
			loopEnd.setEnv(env);
			return null;
		}
		// this is a general while loop
		var bodyEnv = loopEnv.split();
		var loopBody = bodyEnv.block;
		loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		bodyEnv.genStmt(stmt.body);
		loopStart.merge(bodyEnv);
		if (context.compiler.VstLoopOpt) {
			var l = SsaLoopOptimizer.new(graph, header, loopBody, loopEnd.block);
			l.optimize();
		}
		loopEnd.setEnv(env);
		return null;
	}
	def visitFor(stmt: ForStmt, env: VstSsaEnv) -> SsaInstr {
		return genThreePartFor(stmt.loopNum, stmt.varDecl, stmt.cond, stmt.update, stmt.body, env);
	}
	def visitForeach(stmt: ForeachStmt, env: VstSsaEnv) -> SsaInstr {
		var arrayType = stmt.expr.exactType;
		if (EnumType.?(arrayType)) return genEnumIteration(stmt, EnumType.!(arrayType), env);
		var arrayExpr = env.genExpr(stmt.expr);
		if (env.end) return null; // expression generated a throw
		if (EnumSetType.?(arrayType)) return genEnumSetIteration(stmt, EnumSetType.!(arrayType), arrayExpr, env);

		env[stmt.loopVar] = graph.zeroConst();
		// XXX: it's a hack to use a VarDecl in the nonSsaVars array
		var varDecl = VarDecl.new(null, null, null);
		varDecl.vtype = Int.TYPE;
		varDecl.ssa = stmt.loopVar;
		nonSsaVars[stmt.loopVar.index] = varDecl;
		var lengthExpr = env.at(exprSource(stmt.expr)).opArrayGetLength(arrayType, arrayExpr);
		// XXX: simplify loops with 0 and 1 iterations

		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, stmt.loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		// add the loop control expression
		var cond = loopEnv.opIntLt(loopEnv[stmt.loopVar], lengthExpr);

		var bodyEnv = loopEnv.split();
		loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		// generate the array access to define the element variable
		var elem = bodyEnv.opArrayGetElem(arrayType, Int.TYPE, Facts.O_SAFE_BOUNDS, arrayExpr, loopEnv[stmt.loopVar]);
		var elemType = V3Array.elementType(arrayType);
		if (elemType != stmt.varDecl.vtype) {
			// insert a coercion
			elem = bodyEnv.opTypeSubsume(elemType, stmt.varDecl.vtype, elem);
		}
		bodyEnv[stmt.varDecl.ssa] = elem;
		// generate the body
		bodyEnv.genStmt(stmt.body);
		loopUpdate.merge(bodyEnv);

		if (loopUpdate.reachable()) {
			// add the update to the loop control variable
			var env = loopUpdate.toEnv(loopEnv);
			var update = env.at(exprSource(stmt.expr)).opIntAdd(env[stmt.loopVar], graph.oneConst());
			env[stmt.loopVar] = update;
			loopCond.merge(env);
		}
		loopEnd.setEnv(env);
		return null;
	}
	def genEnumIteration(stmt: ForeachStmt, enumType: EnumType, env: VstSsaEnv) -> SsaInstr {
		// TODO: desugar and use genThreePartFor
		env[stmt.loopVar] = graph.zeroConst();
		var varDecl = VarDecl.new(null, null, null);
		varDecl.vtype = Int.TYPE;
		varDecl.ssa = stmt.loopVar;
		nonSsaVars[stmt.loopVar.index] = varDecl;
		var limitExpr = graph.intConst(enumType.enumDecl.cases.length);
		env.at(exprSource(stmt.expr));

		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, stmt.loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		// add the loop control expression
		var cond = loopEnv.opIntLt(loopEnv[stmt.loopVar], limitExpr);

		var bodyEnv = loopEnv.split();
		loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		// convert int to the enum element with the same tag
		var elem = bodyEnv.opIntViewI0(Int.TYPE, enumType.enumDecl.tagType, loopEnv[stmt.loopVar]);
		bodyEnv[stmt.varDecl.ssa] = elem;

		// generate the body
		bodyEnv.genStmt(stmt.body);
		loopUpdate.merge(bodyEnv);

		// add the update to the loop control variable
		if (loopUpdate.reachable()) {
			var env = loopUpdate.toEnv(loopEnv);
			var update = env.at(exprSource(stmt.expr)).opIntAdd(env[stmt.loopVar], graph.oneConst());
			env[stmt.loopVar] = update;
			loopCond.merge(env);
		}
		loopEnd.setEnv(env);
		return null;
	}
	def genEnumSetIteration(stmt: ForeachStmt, tc: EnumSetType, set: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		// TODO: desugar and use genThreePartFor
		// XXX: shift the set down by a bit each iteration and terminate when zero
		env[stmt.loopVar] = graph.zeroConst();
		// XXX: it's a hack to use a VarDecl in the nonSsaVars array
		var varDecl = VarDecl.new(null, null, null);
		varDecl.vtype = Int.TYPE;
		varDecl.ssa = stmt.loopVar;
		nonSsaVars[stmt.loopVar.index] = varDecl;
		var limitExpr = graph.intConst(tc.repType.width);
		env.at(exprSource(stmt.expr));

		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, stmt.loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		// add the loop control expression
		var cond = loopEnv.opIntLt(loopEnv[stmt.loopVar], limitExpr);

		var testEnv = loopEnv.split();
		loopEnv.addIf(cond, testEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		// convert int to the enum element with the same tag
		var e = testEnv.opIntViewI0(Int.TYPE, tc.enumDecl.tagType, loopEnv[stmt.loopVar]);
		var elem = e;
		if (EnumSetType.?(stmt.varDecl.vtype)) {
			// insert a coercion from enum to set
			elem = tc.genEnumToSet(elem, testEnv);
		}
		testEnv[stmt.varDecl.ssa] = elem;

		// check the elem is a member
		var isMember = testEnv.opEnumSetHas(tc, set, e);
		var bodyEnv = testEnv.split();
		testEnv.addIf(isMember, bodyEnv.block, loopUpdate.block);
		loopUpdate.mergeIncoming(testEnv);

		// generate the body
		bodyEnv.genStmt(stmt.body);
		loopUpdate.merge(bodyEnv);

		// add the update to the loop control variable
		if (loopUpdate.reachable()) {
			var env = loopUpdate.toEnv(loopEnv);
			var update = env.at(exprSource(stmt.expr)).opIntAdd(env[stmt.loopVar], graph.oneConst());
			env[stmt.loopVar] = update;
			loopCond.merge(env);
		}
		loopEnd.setEnv(env);
		return null;
	}
	def visitForLess(stmt: ForLessStmt, env: VstSsaEnv) -> SsaInstr {
		// desugar "for(i < E) S" to "for(i = 0; i < E; i++) S"
		var t = IntType.!(stmt.varDecl.vtype);
		var ref = VarExpr.new(null, null, VstIdent.new(stmt.varDecl.token, 0, null));
		ref.varbind = VarBinding.Local(stmt.varDecl);
		ref.exactType = stmt.varDecl.vtype;

		var infix = InfixOp.new(stmt.lt, V3Infix.Lt, V3Infix.prec(V3Infix.Lt), false);
		infix.op = t.opLt();
		var cond = BinOpExpr.new(ref, infix, stmt.expr);
		cond.exactType = Bool.TYPE;

		var update = AutoExpr.new(stmt.varDecl.token, ref, V3Infix.Add, true);
		update.op = t.opAdd();
		update.exactType = stmt.varDecl.vtype;
		update.facts |= Fact.O_NO_INT_TRUNC; // induction variable cannot wrap around

		return genThreePartFor(stmt.loopNum, stmt.varDecl, cond, update, stmt.body, env);
	}
	def genThreePartFor(loopNum: int, loopVar: VarDecl, cond: Expr, update: Expr, body: Stmt, env: VstSsaEnv) -> SsaInstr {
		env.genVarDecl(loopVar);
		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var header = loopCond.block;
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		var cond = loopEnv.genExpr(cond);
		if (loopEnv.end) return null; // condition ended the block somehow
		if (context.compiler.VstBranchOpt && Ssa.isFalseConst(cond)) {
			// this is not a loop at all; skip the body
			return loopFallThru(env, loopEnv);
		}
		var loopBody: SsaBlock;
		if (context.compiler.VstBranchOpt && Ssa.isTrueConst(cond)) {
			// this is an infinite loop that can only terminate with a break inside
			loopEnv.genStmt(body);
			loopUpdate.merge(loopEnv);
		} else {
			// this is a regular for loop
			var bodyEnv = loopEnv.split();
			loopBody = bodyEnv.block;
			loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
			loopEnd.mergeIncoming(loopEnv);
			bodyEnv.genStmt(body);
			loopUpdate.merge(bodyEnv);
		}
		if (loopUpdate.reachable()) {
			var env = loopUpdate.toEnv(loopEnv);
			env.genExpr(update);
			loopCond.merge(env);
		}
		if (loopBody != null && context.compiler.VstLoopOpt) {
			var l = SsaLoopOptimizer.new(graph, header, loopBody, loopEnd.block);
			l.optimize();
		}
		loopEnd.setEnv(env);
		env.addDeleteVar(1); // delete loopVar
		return null;
	}
	def loopFallThru(env: VstSsaEnv, loopEnv: VstSsaEnv) -> SsaInstr {
		env.end = loopEnv.end;
		env.block = loopEnv.block;
		env.varMap = loopEnv.varMap;
		return null;
	}
	def visitLocal(stmt: LocalStmt, env: VstSsaEnv) -> SsaInstr {
		// generate initialization of var variables
		env.at(tokenSource(stmt.range()));
		Lists.apply(stmt.vars, env.genVarDecl);
		return null;
	}
	def visitBreak(stmt: BreakStmt, env: VstSsaEnv) -> SsaInstr {
		// break out of the current loop and merge state with end
		for (p = env; p != null; p = p.parent) {
			if (p.loopEnd != null) {
				p.loopEnd.merge(env);
				return null;
			}
		}
		return error(null, "break not in loop");
	}
	def visitContinue(stmt: ContinueStmt, env: VstSsaEnv) -> SsaInstr {
		// continue back to beginning of current loop and merge state
		for (p = env; p != null; p = p.parent) {
			if (p.loopStart != null) {
				p.loopStart.merge(env);
				return null;
			}
		}
		return error(null, "continue not in loop");
	}
	def visitExpr(stmt: ExprStmt, env: VstSsaEnv) -> SsaInstr {
		// generate code for the expression
		env.genExpr(stmt.expr);
		return null;
	}
	def visitMatch(stmt: MatchStmt, env: VstSsaEnv) -> SsaInstr {
		// generate code for key
		var key = env.genExpr(stmt.expr), keyType = stmt.expr.exactType;
		var origKey = key;
		if (env.end) return null; // condition ended the block somehow
		// gather all the cases, putting the default at the end
		var cases = Vector<MatchCase>.new().grow(stmt.cases.length());
		for (l = stmt.cases.list; l != null; l = l.tail) {
			if (l.head.default != null) continue;
			cases.put(l.head);
		}
		var defcase = stmt.defcase;
		if (defcase != null) cases.put(defcase);

		if (V3.isVariant(keyType)) {
			// match on the variant's tag
			key = env.addApply(null, V3Op.newVariantGetTag(keyType), [key]); // XXX: constant fold
			keyType = V3.classDecl(keyType).tagType;
		} else if (EnumType.?(keyType)) {
			// match on the enum value (represented by its tag)
			keyType = EnumType.!(keyType).enumDecl.tagType;
		} else if (defcase == null) {
			// materialize an empty default case if not exhaustive
			defcase = MatchCase.new(null, null, EmptyStmt.new(null));
			cases.put(defcase);
		}
		if (context.compiler.VstBranchOpt && SsaConst.?(key)) {
			// the key for the match is a value, fold the match
			var val = SsaConst.!(key).val, limit = cases.length - 1;
			for (i < limit) {
				var c = cases[i];
				if (matchPatterns(keyType, c.patterns.list, val)) {
					if (c.patterns.length() == 1) genCaseBindings(key, c, env);
					env.genStmt(c.stmt);
					return null;
				}
			}
			// no values matched, generate the default case
			env.genStmt(cases[limit].stmt);
			return null;
		}
		// generate an if cascade for the switch statement
		var end = VstSsaMerge.new(this);
		var cur: SsaBuilder = env;
		for (i < cases.length) {
			var c = cases[i], cenv = env.split();
			var pat: MatchPattern;
			if (i < cases.length - 1) {
				// generate comparisons for all patterns
				var pats = c.patterns.asArray();
				for (pat in pats) {
					var fblock = SsaBuilder.new(context, graph, SsaBlock.new());
					cur.addIf(genPatternCond(keyType, cur, pat, origKey, key), cenv.block, fblock.block);
					cur = fblock;
				}
				if (pats.length == 1) pat = pats[0];
			} else {
				// last case
				cenv.block = cur.block;
				if (c.patterns != null && c.patterns.length() == 1) pat = c.patterns.list.head;
			}
			// generate the body of the case and merge to end
			if (pat != null) genCaseBindings(origKey, c, cenv);
			cenv.genStmt(c.stmt);
			end.merge(cenv);
		}
		end.setEnv(env);
		return null;
	}
	def genPatternCond(keyType: Type, cur: SsaBuilder, pat: MatchPattern, origKey: SsaInstr, key: SsaInstr) -> SsaInstr {
		if (pat.vdecl != null && pat.variantCase == null) {
			// type case, generate "T.?(key)"
			var query = V3Op.newTypeQuery(keyType, pat.vdecl.tref.binding);
			return cur.addApply(null, query, [key]);
		} else {
			// this is a value / tag case, generate "key == const"
			var const = graph.valConst(keyType, pat.val);
			return cur.addApply(null, V3Op.newEqual(keyType), [key, const]); // XXX: cache equality operator
		}
	}
	def matchPatterns(keyType: Type, pl: List<MatchPattern>, val: Val) -> bool {
		while (pl != null) {
			var pat = pl.head;
			if (pat.vdecl != null) {
				var r = Eval.doQuery0(keyType, pat.vdecl.tref.binding, val);
				if (r) return true;
			} else if (Values.equal(val, pat.val)) {
				return true;
			}
			pl = pl.tail;
		}
		return false;
	}
	def genCaseBindings(key: SsaInstr, c: MatchCase, env: VstSsaEnv) {
		// bind variant parameters in the body if necessary
		var p = c.patterns.first(), keyType = key.getType();
		var newKey: SsaInstr, newKeyType: Type;
		if (p.vdecl != null) {
			newKeyType = p.vdecl.tref.binding;
			newKey = env.opTypeSubsume(keyType, newKeyType, key);
			p.vdecl.ssa.instr = newKey;
		}
		if (p.params != null) {
			if (newKey == null) {
				newKeyType = V3.getSyntheticVariantType(keyType, p.variantCase);
				newKey = env.opTypeSubsume(keyType, newKeyType, key);
			}
			if (newKey.inputs.length > 0 && newKey.input0() == key) {
				// type subsume shouldn't have been folded away
				if (p.decl().variantTag > 0) newKey.facts |= Fact.O_NO_NULL_CHECK;
			}
			var ta = [keyType], args = [newKey], i = 0;
			var ic = ir.makeIrClass(newKeyType);
			for (pl = p.params.list; pl != null; pl = pl.tail) { // XXX: mark and skip unused params
				var fieldRef = IrSpec.new(newKeyType, ta, ic.fields[i++]);
				pl.head.ssa = VstSsaVar.new();
				var op = V3Op.newVariantGetField(fieldRef);
				var load = env.add(op, [newKey], fieldRef.member.facts);
				pl.head.ssa.instr = load;
				if (load.inputs.length == 1 && load.input0() == newKey) {
					// loads of non-default variants don't need null checks
					if (p.decl().variantTag > 0) load.facts |= Fact.O_NO_NULL_CHECK;
				}
			}
		}
	}
	def visitEmpty(stmt: EmptyStmt, env: VstSsaEnv) -> SsaInstr {
		return null; // nothing
	}
	def visitReturn(stmt: ReturnStmt, env: VstSsaEnv) -> SsaInstr {
		// generate a return statement
		var vals = Ssa.NO_INSTRS;
		if (meth.returnThis) {
			if (stmt.expr != null) env.genExpr(stmt.expr);
			vals = [getThisParam()];
		} else if (stmt.expr != null) {
			vals = [env.genExpr(stmt.expr)];
		}
		env.at(tokenSource(stmt.range()));
		env.addReturn(vals);
		return null;
	}
	// -- Expressions -----------------------------------------------------
	def visitTuple(expr: TupleExpr, env: VstSsaEnv) -> SsaInstr {
		// generate code for a tuple creation
		var len = expr.exprs.length();
		if (len == 0) return graph.nop();
		if (len == 1) return env.genExpr(expr.exprs.list.head);
		return env.at(exprSource(expr)).opTupleCreate(expr.exactType, expr.exprs.mapArray(env.genExpr));
	}
	def visitAutoExpr(expr: AutoExpr, env: VstSsaEnv) -> SsaInstr {
		var t = genReadModifyWrite(exprSource(expr), expr.expr, genInc(expr, _, _), env);
		return if(expr.post, t.0, t.1);
	}
	def genInc(expr: AutoExpr, pre: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		var rtype = expr.op.sig.paramTypes[1], val: Val;
		match (rtype.typeCon.kind) {
			V3Kind.INT => val = IntType.!(rtype).box(1);
			V3Kind.FLOAT => val = if(V3.isDouble(rtype), Float.F64_ONE, Float.F32_ONE);
			V3Kind.POINTER => val = Int.ONE;
		}
		var result = env.addApply(env.source, expr.op, [pre, graph.valConst(rtype, val)]);
		result.facts |= expr.facts;
		return result;
	}
	def genBinop(c: Operator, pre: SsaInstr, expr: Expr, env: VstSsaEnv) -> SsaInstr {
		var val = env.genExpr(expr);
		return env.addApply(env.source, c, [pre, val]);
	}
	def genVarRead(obj: SsaInstr, binding: VarBinding, env: VstSsaEnv) -> SsaInstr {
		match(binding) {
			Void => return env.graph.nullConst(Void.TYPE);
			Const(val, vtype) => return env.graph.valConst(vtype, val);
			EnumConst(member) => {
				return env.graph.valConst(member.receiver.getDeclaredType(), Int.box(member.tag));
			}
			Local(decl) => return env[decl.ssa];
			ObjectMethod(receiver, member, typeArgs) => {
				var spec = specOf(receiver, member, typeArgs);
				return env.opGetVirtual(spec, obj);
			}
			ObjectField(receiver, member) => {
				var const = fieldConst(receiver, member, obj, env);
				if (const != null) return const;
				var spec = specOf(receiver, member, null);
				var op = V3Op.newClassGetField(spec);
				return env.addApplyF(op, [obj], spec.member.facts);
			}
			ClassMethod(receiver, member, typeArgs) => {
				var spec = specOf(receiver, member, typeArgs);
				return env.addOp(V3Op.bestCallVirtual(spec), Facts.NONE);
			}
			ClassField(receiver, member) => {
				var spec = specOf(receiver, member, null);
				var op = if(V3.isVariant(receiver), V3Op.newVariantGetField(spec), V3Op.newClassGetField(spec));
				return env.addOp(op, Facts.NONE);
			}
			RefLayoutField(receiver, member) => {
				var op = V3Op.newRefLayoutGetField(receiver, member.byteOffset, member.mtref.getType());
				return env.addApplyF(op, [obj], Facts.NONE);
			}
			RefLayoutNested(receiver, member) => {
				var op = V3Op.newRefLayoutIn(receiver, member.byteOffset, member.mtref.mtlayout);
				return env.addApplyF(op, [obj], Facts.NONE);
			}
			LayoutField(receiver, member) => {
				var op = V3Op.newRefLayoutGetField(receiver, member.byteOffset, member.mtref.getType());
				return env.addOp(op, Facts.NONE);
			}
			LayoutNested(receiver, member) => {
				var op = V3Op.newRefLayoutIn(receiver, member.byteOffset, member.mtref.mtlayout);
				return env.addOp(op, Facts.NONE);
			}
			ClassNew(receiver, member, funcType) => {
				var spec = specOf(receiver, member, null);
				return env.addOp(newClassAllocOp(spec, funcType, env), Facts.NONE);
			}
			ComponentMethod(member, typeArgs) => {
				var spec = specOf(member.receiver.getDeclaredType(), member, typeArgs);
				if (obj == null) obj = initOf(member, env);
				return env.opCreateClosure(spec, obj);
			}
			ComponentField(member) => {
				if (obj == null) obj = initOf(member, env);
				var receiver = member.receiver.getDeclaredType();
				var const = fieldConst(receiver, member, obj, env);
				if (const != null) return const;
				var spec = specOf(receiver, member, null);
				var op = V3Op.newComponentGetField(spec);
				return env.addApplyF(op, [obj], spec.member.facts);
			}
			VariantField(receiver, member) => {
				var spec = specOf(receiver, member, null);
				var op = V3Op.newVariantGetField(spec);
				return env.addApplyF(op, [obj], spec.member.facts);
			}
			Inst(c, facts) => {
				var comp = c.subst(elimTypeVars);
				return env.addOp(comp, facts);
			}
			Apply(c, facts) => {
				var args = [obj];
				var comp = c.subst(elimTypeVars);
				var i = env.addApply(env.source, comp, args);
				i.setFact(facts);
				return i;
			}
			VariantCase(c, vcase) => {
				var receiver = elimTypeVars(c);
				var variant = V3.getSyntheticVariantType(receiver, vcase);
				if (vcase.decl.params == null) {
					if (variant.open()) {
						// polymorphic; generate an allocation
						var spec = IrSpec.new(variant, [variant], null);
						return env.opClassAlloc(spec, Ssa.NO_INSTRS);
					} else {
						// monomorphic; generate a constant
						var r = context.prog.newRecord(variant, 0);
						return graph.valConst(receiver, r);
					}
				}
				var constructor = ir.makeIrClass(variant).methods[0];
				var spec = IrSpec.new(variant, [variant], constructor);
				var op = newClassAllocOp(spec, variant, env);
				return env.addOp(op, Fact.O_PURE);
			}
			Partial(c, facts) => {
				var comp = c.subst(elimTypeVars);
				return env.addClosureCreate(comp, [obj], INDEX_0);
			}
			RefLayoutRepeatedNested,
			RefLayoutRepeatedField,
			LayoutRepeatedNested,
			LayoutRepeatedField,
			PtrAtField,
			LayoutDecl,
			LayoutFieldDecl,
			Type => {
				context.fail1("unexpected binding kind %s", binding.name);
				return null;
			}
			None => {
				context.fail("unbound in genVarRead()");
				return null;
			}
		}
	}
	def fieldConst(receiver: Type, member: VstField, obj: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		if (member.writability != Writability.READ_ONLY) return null;
		receiver = elimTypeVars(receiver);
		var m = ir.makeIrClass(receiver).fields[member.index];
		m.facts |= Fact.X_LIVE; // XXX: liveness analysis here?
		if (!Literal.?(member.init)) return null;
		if (receiver.typeCon.kind == V3Kind.CLASS) env.opNullCheck(receiver, obj);
		var lit = Literal.!(member.init);
		var ftype = m.fieldType;
		if (lit.val == null) return graph.valConst(ftype, lit.val);
		// XXX: fold conversion of constant field initialization instead of using typecast
		var const = graph.valConst(lit.exactType, lit.val);
		if (lit.exactType != ftype) return env.opTypeCast(lit.exactType, ftype, const);
		return const;
	}
	def genVarWrite(varbind: VarBinding, varSource: Source, obj: SsaInstr, val: SsaInstr, checked: bool, env: VstSsaEnv) -> SsaInstr {
		match(varbind) {
			Local(decl) => env[decl.ssa] = val;
			ObjectField(receiver, member) => {
				var spec = specOf(receiver, member, null);
				var i = env.at(varSource).opClassSetField(spec, obj, val, false);
				if (checked && i != null) i.facts |= Fact.O_NO_NULL_CHECK;
			}
			ComponentField(member) => {
				var spec = specOf(member.receiver.getDeclaredType(), member, null);
				if (obj == null) obj = initOf(member, env);
				env.opComponentSetField(spec, obj, val);
			}
			RefLayoutField(receiver, member) => {
				var op = V3Op.newRefLayoutSetField(receiver, member.byteOffset, member.mtref.getType());
				return env.addApplyF(op, [obj, val], Facts.NONE);
			}
			_ => {
				context.fail1("unexpected binding %s in genVarWrite()", varbind.name);
			}
		}
		return val;
	}
	def genAppRead(appbind: AppBinding, target: SsaInstr, args: Array<SsaInstr>, env: VstSsaEnv) -> SsaInstr {
		match (appbind) {
			None => {
				context.fail("unbound in genAppRead()");
				return null;
			}
			Void => {
				return graph.nullConst(Void.TYPE);
			}
			CallClosure(t) => {
				return env.opCallClosure(elimTypeVars(t), Arrays.prepend(target, args));
			}
			CallComponentMethod(receiver, member, typeArgs) => {
				var spec = specOf(receiver, member, typeArgs);
				if (target == null) initOf(member, env);
				var args = Arrays.prepend(graph.nullReceiver(), args);
				return env.opCallMethod(spec, args);
			}
			CallObjectMethod(receiver, member, typeArgs) => {
				var spec = specOf(receiver, member, typeArgs);
				var instr = env.opCallVirtual(spec, Arrays.prepend(target, args));
				if (instr != null && member.returnThis) {
					instr.setFact(Fact.V_NON_ZERO);
					// XXX: use result of call, instead of original receiver, if the
					// target platform is untyped, in order to avoid keeping the original
					// receiver value live across the call.
					return target;
				}
				return instr;
			}
			CallClassMethod(receiver, member, typeArgs) => {
				var spec = specOf(receiver, member, typeArgs);
				var instr = env.opCallVirtual(spec, args);
				if (instr != null && member.returnThis) instr.setFact(Fact.V_NON_ZERO);
				return instr;
			}
			ClassNew(receiver, member) => {
				var spec = specOf(receiver, member, null);
				return env.opClassAlloc(spec, args);
			}
			Apply(op, facts) => {
				var nop = op.subst(elimTypeVars);
				if (target != null) args = Arrays.prepend(target, args);
				return env.addApply(env.source, nop, args);
			}
			Partial(boundMap) => {
				// XXX: optimize C.m(... _ ...) and o.m(... _ ...) and <val>(... _ ...)
				args = Arrays.prepend(target, args);
				return env.addClosureCreate(V3Op.newCallClosure(target.getType()), args, boundMap);
			}
			PtrAtComponentField(receiver, field, ptrType) => {
				var spec = specOf(receiver, field, null);
				return env.addApply(env.source, V3Op.newPtrAtComponentField(spec, ptrType), Ssa.NO_INSTRS);
			}
			PtrAtObjectField(receiver, field, ptrType) => {
				var spec = specOf(receiver, field, null);
				return env.addApply(env.source, V3Op.newPtrAtObjectField(spec, ptrType), [target]);
			}
		}
	}
	def genReadModifyWrite(source: Source, lval: Expr, modify: (SsaInstr, VstSsaEnv) -> SsaInstr, env: VstSsaEnv) -> (SsaInstr, SsaInstr) {
		var pre: SsaInstr, post: SsaInstr;
		if (IndexExpr.?(lval)) {
			// read-modify-write of an index expression
			var expr = IndexExpr.!(lval);
			var leftType = elimTypeVars(expr.receiver.exactType);
			if (V3.isArrayOrRange(leftType)) {
				var array = env.genExpr(expr.receiver);
				var iexpr = expr.exprs.first();
				var index = env.genExpr(iexpr);
				var appSource = exprSource(expr);
				var indexType = IntType.!(elimTypeVars(iexpr.exactType));
				pre = env.at(appSource).opArrayGetElem(leftType, indexType, Facts.NONE, array, index);
				post = modify(pre, env);
				env.at(appSource).opArraySetElem(leftType, indexType, Facts.O_SAFE_BOUNDS, array, index, post);
			} else {
				var t = evalAppExprs(expr.receiver, expr.read, expr.exprs, null, env);
				var pre = genAppRead(expr.read, t.0, t.1, env.at(exprSource(expr)));
				post = modify(pre, env);
				genAppRead(expr.write, t.0, Arrays.append(post, t.1), env.at(source));
			}
		} else if (VarExpr.?(lval)) {
			// read-modify-write of a var expression
			var expr = VarExpr.!(lval);
			var receiver = genReceiver(expr.receiver, env);
			var varSource = exprSource(expr);
			pre = genVarRead(receiver, expr.varbind, env.at(varSource));
			post = modify(pre, env);
			genVarWrite(expr.varbind, varSource, receiver, post, true, env.at(source));
		} else {
			pre = error(lval, "invalid lvalue");
		}
		return (pre, post);
	}
	def newClassAllocOp(spec: IrSpec, funcType: Type, env: VstSsaEnv) -> Operator {
		if (spec.member == null) {
			// trivial constructor
			funcType = elimTypeVars(funcType);
			var paramTypes = Function.getParamTypeArray(funcType), classType = spec.receiver;
			return V3Op.newEmptyClassAllocP(classType, paramTypes);
		}
		return V3Op.newClassAlloc(spec);
	}
	def specOf(receiver: Type, member: VstMember, typeArgs: TypeArgs) -> IrSpec {
		return VstIr.specOf(ir, receiver, member, typeArgs);
	}
	def initOf(member: VstMember, block: SsaBuilder) -> SsaInstr {
		var decl = VstCompound.!(member.receiver);
		var ctype = decl.getDeclaredType();
		var constructor = decl.constructor;
		if (constructor.initIndex >= 0) {
			return block.opInit(ir.makeIrClass(ctype).methods[0]);
		}
		return block.graph.nullConst(ctype);
	}
	def genReceiver(expr: Expr, env: VstSsaEnv) -> SsaInstr {
		return if (expr == null, null, env.genExpr(expr));
	}
	def visitArray(expr: ArrayExpr, env: VstSsaEnv) -> SsaInstr {
		// generate code for an array initializer
		return env.at(exprSource(expr)).opArrayInit(expr.exactType, expr.exprs.mapArray(env.genExpr));
	}
	def visitVar(expr: VarExpr, env: VstSsaEnv) -> SsaInstr {
		var receiver = genReceiver(expr.receiver, env);
		return genVarRead(receiver, expr.varbind, env.at(exprSource(expr)));
	}
	def visitLiteral(expr: Literal, env: VstSsaEnv) -> SsaInstr {
		// generate a constant
		return env.addVal(expr.exactType, expr.val);
	}
	def visitString(expr: StringExpr, env: VstSsaEnv) -> SsaInstr {
		// generate a constant
		return env.addVal(V3.stringType, context.prog.getStringRecord(expr));
	}
	def visitApp(expr: AppExpr, env: VstSsaEnv) -> SsaInstr {
		var t = evalAppExprs(expr.target, expr.appbind, expr.args.exprs, expr.boundMap, env);
		return genAppRead(expr.appbind, t.0, t.1, env.at(exprSource(expr)));
	}
	def visitIndex(expr: IndexExpr, env: VstSsaEnv) -> SsaInstr {
		var leftType = elimTypeVars(expr.receiver.exactType);
		if (V3.isArray(leftType) || V3.isRange(leftType)) {
			var array = env.genExpr(expr.receiver);
			var iexpr = expr.exprs.first();
			var index = env.genExpr(iexpr);
			var indexType = IntType.!(elimTypeVars(iexpr.exactType));
			return env.at(exprSource(expr)).opArrayGetElem(leftType, indexType, Facts.NONE, array, index);
		} else {
			var t = evalAppExprs(expr.receiver, expr.read, expr.exprs, null, env);
			return genAppRead(expr.read, t.0, t.1, env.at(exprSource(expr)));
		}
	}
	def visitRange(expr: RangeExpr, env: VstSsaEnv) -> SsaInstr {
		var range = env.genExpr(expr.expr);
		var start = env.genExpr(expr.start);
		var end = if(expr.end != null, env.genExpr(expr.end));
		var rangeType = elimTypeVars(expr.exactType);
		var endType: Type;
		if (end == null) {
			var leftType = elimTypeVars(expr.expr.effectiveType());
			end = env.opArrayGetLength(leftType, range);
			endType = Int.TYPE;
		} else {
			endType = elimTypeVars(expr.end.exactType);
		}
		var startType = elimTypeVars(expr.start.exactType);
		var op = if(expr.plus, V3Op.newRangeFromPlus, V3Op.newRangeFromTo)(rangeType, startType, endType);
		return env.addApply(exprSource(expr), op, [range, start, end]);
	}
	def evalAppExprs(t: Expr, appbind: AppBinding, a: VstList<Expr>, boundMap: Array<int>, env: VstSsaEnv) -> (SsaInstr, Array<SsaInstr>) {
		var args = a.asArray();
		return evalAppExprs0(t, appbind, args, boundMap, env);
	}
	def evalAppExprs0(t: Expr, appbind: AppBinding, args: Array<Expr>, boundMap: Array<int>, env: VstSsaEnv) -> (SsaInstr, Array<SsaInstr>) {
		// flatten any nested tuple expressions
		while (args.length == 1 && TupleExpr.?(args[0])) {
			args = (TupleExpr.!(args[0])).exprs.asArray();
		}
		// evaluate target (either receiver or function)
		var target: SsaInstr;
		if (t != null) {
			target = env.genExpr(t);
			if (appbind.nullCheck()) {
				env.at(exprSource(t)).opNullCheck(target.getType(), target);
			}
		}
		// evaluate bound arguments
		var instrs: Array<SsaInstr>;
		if (boundMap != null) {
			instrs = Array<SsaInstr>.new(boundMap.length - 1);
			for (i < boundMap.length - 1) instrs[i] = env.genExpr(args[boundMap[i+1]-1]);
		} else {
			instrs = Array<SsaInstr>.new(args.length);
			for (i < args.length) instrs[i] = env.genExpr(args[i]);
		}
		// return the target and the arguments
		return (target, instrs);
	}
	def visitNot(expr: NotExpr, env: VstSsaEnv) -> SsaInstr {
		// generate a boolean inversion
		return env.at(exprSource(expr)).opBoolNot(env.genExpr(expr.expr));
	}
	def visitNeg(expr: NegExpr, env: VstSsaEnv) -> SsaInstr {
		// generate 0 - x
		var t = expr.exactType;
		var zero = graph.nullConst(t);
		return env.at(exprSource(expr)).pure(expr.op, [zero, env.genExpr(expr.expr)]);
	}
	def visitBitwiseNeg(expr: BitwiseNegExpr, env: VstSsaEnv) -> SsaInstr {
		// generate a bitwise not
		var val = env.genExpr(expr.expr);
		return env.at(exprSource(expr)).opBitwiseNeg(IntType.!(expr.exactType), val);
	}
	def visitAssign(expr: AssignExpr, env: VstSsaEnv) -> SsaInstr {
		var lval = expr.target, source = exprSource(expr), rval = expr.expr;
		if (expr.infix != null) {
			var t = genReadModifyWrite(source, lval, genBinop(expr.infix.op, _, expr.expr, _), env);
			return t.1;
		}
		if (VarExpr.?(lval)) {
			// assignment to a variable binding
			var varExpr = VarExpr.!(lval);
			var receiver = genReceiver(varExpr.receiver, env);
			var val = env.genExpr(rval);
			genVarWrite(varExpr.varbind, exprSource(varExpr), receiver, val, false, env.at(source));
			return val;
		}
		if (IndexExpr.?(lval)) {
			// assignment to an array or indexed element
			var indexExpr = IndexExpr.!(lval);
			var leftType = elimTypeVars(indexExpr.expr.exactType);
			if (V3.isArrayOrRange(leftType)) {
				var array = env.genExpr(indexExpr.receiver);
				var iexpr = indexExpr.exprs.first();
				var index = env.genExpr(iexpr);
				var val = env.genExpr(rval);
				var indexType = IntType.!(elimTypeVars(iexpr.exactType));
				env.at(exprSource(indexExpr)).opArraySetElem(leftType, indexType, Facts.NONE, array, index, val);
				return val;
			} else {
				var args = Arrays.append(rval, indexExpr.exprs.asArray());
				var t = evalAppExprs0(indexExpr.receiver, indexExpr.write, args, null, env);
				genAppRead(indexExpr.write, t.0, t.1, env.at(source));
				return t.1[t.1.length - 1];
			}
		}
		return error(expr, "invalid expression as target of assignment");
	}
	def visitBinOp(expr: BinOpExpr, env: VstSsaEnv) -> SsaInstr {
		var c = expr.op.op;
		if (c == null) return error(expr, "unknown binop");
		if (c == Bool.OROR) {
			// generate a lazy evaluation of the RHS
			return genLazyEval(false, expr.left, expr.right, env);
		} else if (c == Bool.ANDAND) {
			// generate a lazy evaluation of the RHS
			return genLazyEval(true, expr.left, expr.right, env);
		}
		var le = env.genExpr(expr.left), re = env.genExpr(expr.right);
		var source = exprSource(expr);
		return env.addApply(source, c.subst(elimTypeVars), [le, re]);
	}
	def genLazyEval(isAnd: bool, left: Expr, right: Expr, env: VstSsaEnv) -> SsaInstr {
		// isAnd  &&: if(left) right; else (); phi(left, right)
		// !isAnd ||: if(left) (); else right; phi(left, right)
		var le = env.genExpr(left);
		if (env.end) return graph.nullConst(le.getType());
		// fold (K && e) and (K || e)
		if (SsaConst.?(le)) return foldLazyEvalL(isAnd, le.unbox<bool>(), right, env);
		var merge = VstSsaMerge.new(this);
		var fenv = env.split();
		if (isAnd) {
			env.addIf(le, fenv.block, merge.block);
			merge.mergeIncoming(env);
		} else {
			env.addIf(le, merge.block, fenv.block);
			merge.mergeIncoming(env);
		}
		var re = fenv.genExpr(right), fend = fenv.end;
		merge.merge(fenv);
		// fold (e && K) and (e || K)
		if (SsaConst.?(re)) {
			merge.setEnv(env);
			return foldLazyEvalR(isAnd, le, re.unbox<bool>());
		}
		if (le == re) {
			// x [&&,||] x == x
			merge.setEnv(env);
			return le;
		} else {
			// if fenv.end, then the false branch is a dead end (e.g. a throw)
			var ce = graph.boolConst(!isAnd);
			var result = if(fend, ce, merge.newPhi2(Bool.TYPE, ce, re));
			merge.setEnv(env);
			return result;
		}
	}
	def foldLazyEvalL(isAnd: bool, left: bool, right: Expr, env: VstSsaEnv) -> SsaInstr {
		if (isAnd) {
			if (left) return env.genExpr(right);
			else return graph.falseConst();
		} else {
			if (left) return graph.trueConst();
			else return env.genExpr(right);
		}
	}
	def foldLazyEvalR(isAnd: bool, left: SsaInstr, right: bool) -> SsaInstr {
		if (isAnd) {
			if (right) return left;
			else return graph.falseConst();
		} else {
			if (right) return graph.trueConst();
			else return left;
		}
	}
	def visitIfExpr(expr: IfExpr, env: VstSsaEnv) -> SsaInstr {
		// generate control flow for an if expression
		var exprs = expr.exprs.asArray();
		var cond = env.genExpr(exprs[0]);
		if (context.compiler.VstBranchOpt && SsaConst.?(cond)) {
			if (cond.unbox<bool>()) {
				// condition is always true
				return env.genExpr(exprs[1]);
			} else {
				// condition is always false
				return if(exprs.length == 3, env.genExpr(exprs[2]), graph.nullConst(expr.exactType));
			}
		}
		var tenv = env.split(), fenv = env.split();
		env.addIf(cond, tenv.block, fenv.block);
		var trueVal = tenv.genExpr(exprs[1]);
		var falseVal = if(exprs.length == 3, fenv.genExpr(exprs[2]), graph.nullConst(expr.exactType));
		var merge = VstSsaMerge.new(this);
		var trueThru = !tenv.end, falseThru = !fenv.end;
		merge.merge(tenv);
		merge.merge(fenv);
		merge.setEnv(env);
		if (trueThru) {
			// did both fall through?
			var t = elimTypeVars(expr.exactType);
			if (falseThru) {
				if (trueVal == falseVal) return trueVal; // same in either case
				else return merge.newPhi2(t, trueVal, falseVal);
			}
			// only the true branch fell through
			return trueVal;
		}
		if (falseThru) {
			// only the false branch fell through
			return falseVal;
		}
		return graph.nop(); // neither fell through
	}
	def visitFuncExpr(expr: FuncExpr, env: VstSsaEnv) -> SsaInstr {
		context.fail("unimplemented in VstSsaGen.visitFuncExpr()");
		return graph.nullConst(expr.exactType);
	}

	// -- Utility methods ------------------------------------------------------
	def error(expr: Expr, msg: string) -> SsaInstr {
		context.fail(msg);
		return null;
	}
	def exprSource(e: Expr) -> Source {
		var point = e.point();
		var range = e.range();
		var source = Source.new(meth, point.beginLine, point.beginColumn, null, range);
		return source;
	}
	def tokenSource(point: FilePoint) -> Source {
		return Source.new(meth, point.beginLine, point.beginColumn, null, null);
	}
}
// An environment for generating code, including the current block and the current
// variable map, which maps locals to the SSA instructions that produced them
class VstSsaEnv extends SsaBuilder {
	def gen: VstSsaGen;
	def parent: VstSsaEnv;
	var varMap: Array<SsaInstr>;

	var loopStart: VstSsaMerge;
	var loopEnd: VstSsaMerge;

	new(size: int, gen, parent, block: SsaBlock) super(gen.context, gen.graph, block) {
		if (parent == null) varMap = Array.new(size);
		else varMap = parent.varMap;
	}
	def at(source: Source) -> this {
		if (source != null && isNewSourceLine(source)) addCheckpoint(source, varMap);
		this.source = source;
	}
	def isNewSourceLine(source: Source) -> bool {
		if (this.source == null || source.line > this.source.line) return true;
		return false;
	}
	def split() -> VstSsaEnv {
		var r = VstSsaEnv.new(varMap.length, gen, this, SsaBlock.new());
		r.source = source;
		return r;
	}
	def [ssa: VstSsaVar] -> SsaInstr {
		if (ssa.isWritten()) return varMap[ssa.index];
		return ssa.instr;
	}
	def [ssa: VstSsaVar] = i: SsaInstr {
		if (ssa.isWritten()) {
			// perform copy-on-write update of variable map
			if (parent != null && parent.varMap == varMap) varMap = Arrays.dup(varMap);
			if (varMap[ssa.index] != null) addUpdateVar(ssa.index, [i]);
			varMap[ssa.index] = i;
		} else {
			ssa.instr = i;
		}
	}
	def addVal(t: Type, val: Val) -> SsaInstr {
		return graph.valConst(t, val);
	}
	def addOp(op: Operator, facts: Fact.set) -> SsaInstr {
		// XXX: perform LVN and GVN
		var spec = gen.opBuilder.buildOpMethod(gen.context.compiler, op, facts);
		if (spec.isPolymorphic()) {
			return opCreateClosure(spec, graph.nullReceiver());
		}
		// return a closure value
		return graph.valConst(op.sig.funcType(), Closure.new(null, spec));
	}
	def addClosureCreate(comp: Operator, args: Array<SsaInstr>, indexMap: Array<int>) -> SsaInstr {
		var context = SsaContext.new(gen.context.compiler, gen.context.prog);
		return gen.opBuilder.buildOpClosure(context, this, comp, args, indexMap);
	}
	def genVarDecl(v: VarDecl) {
		if (v.ssa.index >= 0) gen.nonSsaVars[v.ssa.index] = v;
		if (!end) this[v.ssa] = if(v.init != null, genExpr(v.init), graph.nullConst(v.vtype));
		addNewVarDecl(v);
	}
	def addNewVarDecl(v: VarDecl) {
		addNewVar(v.name(), v.vtype, v.ssa.index, [this[v.ssa]]);
	}
	def genStmt(s: Stmt) {
		if (!end) s.accept(gen, this);
	}
	def genExpr(e: Expr) -> SsaInstr {
		if (!end) {
			var i = e.accept(gen, this);
			var it = e.implicitType, xt = e.exactType;
			if (it == null || it == xt) return i;
			it = elimTypeVars(it);
			xt = elimTypeVars(xt);
			if (it == xt) return i;
			// conversion is necessary
			return at(gen.exprSource(e)).opTypeSubsume(xt, it, i);
		}
		return graph.nop();
	}
	def recordDirectCall(spec: IrSpec) {
		if (!gen.recordDirectCalls) return;
		gen.directCallTargets = List.new(spec, gen.directCallTargets);
		if (gen.directCallBlocks == null || gen.directCallBlocks.head != block) {
			// record the block if not already recorded
			gen.directCallBlocks = List.new(block, gen.directCallBlocks);
		}
	}
}
// handles all merges in the control flow
class VstSsaMerge(gen: VstSsaGen) {
	def predValues = Vector<Array<SsaInstr>>.new();
	def block = SsaBlock.new();
	var varMap: Array<SsaInstr>;

	def startLoop(env: VstSsaEnv, loopNum: int) -> VstSsaEnv {
		// create the variable map with phis at the given positions
		var vm = env.varMap, ssa = gen.nonSsaVars;
		varMap = Array.new(vm.length);
		for (i < ssa.length) {
			var v = ssa[i];
			if (v != null && v.ssa.isWrittenInLoop(loopNum)) {
				varMap[v.ssa.index] = newPhi(v.vtype, Ssa.NO_INSTRS);
				var update = SsaUpdateVar.new(v.ssa.index, [varMap[v.ssa.index]]);
				block.append(update);
			} else {
				varMap[i] = vm[i];
			}
		}
		merge(env);
		var nenv = VstSsaEnv.new(varMap.length, gen, env, block);
		nenv.varMap = Arrays.dup(varMap);
		nenv.source = env.source;
		return nenv;
	}
	def merge(env: VstSsaEnv) {
		// merge with the given ssa environment if it falls through
		if (!env.end) {
			env.addGoto(block);
			mergeEdge(env, env.block.succ(0));
		}
	}
	def mergeEdge(env: VstSsaEnv, edge: SsaCfEdge) {
		if (edge.dest != block) return V3.fail(Strings.format3("mergeEdge B%d: edge B%d -> B%d doesn\'t go here", block.uid, edge.src.uid, edge.dest.uid));
		predValues.put(env.varMap);
		if (varMap == null) varMap = Arrays.dup(env.varMap);
		else mergeNewest();
	}
	def mergeIncoming(env: VstSsaEnv) {
		for (edge in env.block.succs()) {
			if (edge.dest == block) mergeEdge(env, edge);
		}
	}
	private def mergeNewest() {
		// merge newest predecessor map into current variable map
		var vm = predValues[predValues.length - 1], numVars = vm.length;
		var numPreds = predValues.length;
		for (v = 0; v < numVars; v = v + 1) {
			var x = varMap[v], y = vm[v];
			if (y == null && x != null) {
				// this variable is dead on this edge, remove it
				killVar(x, v);
				continue;
			}
			if (SsaPhi.?(x)) {
				var phi = SsaPhi.!(x);
				if (phi.block == block) {
					// there is already a phi at this position
					phi.inputs = Arrays.append(SsaDfEdge.new(phi, y), phi.inputs);
					continue;
				}
			}
			if (x != null && x != y) {
				// a new phi is required here
				var inputs = Array<SsaInstr>.new(numPreds);
				for (j < numPreds) {
					inputs[j] = predValues[j][v];
				}
				var t = gen.nonSsaVars[v].vtype;
				varMap[v] = newPhi(t, inputs);
				var update = SsaUpdateVar.new(v, [varMap[v]]);
				block.append(update);
			}
		}
	}
	private def killVar(x: SsaInstr, v: int) {
		if (SsaPhi.?(x)) {
			var phi = SsaPhi.!(x);
			if (phi.block == block) {
				// there is already a phi for this var for this block, kill it
				phi.kill();
				phi.remove();
			}
		}
		varMap[v] = null;
	}
	def setEnv(env: VstSsaEnv) {
		// set the environment to be this block, if reachable
		if (predValues.length > 0) {
			env.block = block;
			// XXX: transfer ownership instead of copying?
			env.varMap = Arrays.dup(varMap);
			env.end = false;
			// XXX: optimize phis at this point
		} else {
			env.block = null;
			env.varMap = null;
			env.end = true;
		}
	}
	def reachable() -> bool {
		return predValues.length > 0;
	}
	def toEnv(parent: VstSsaEnv) -> VstSsaEnv {
		var env = VstSsaEnv.new(varMap.length, gen, parent, block);
		env.varMap = Arrays.dup(varMap);
		env.source = parent.source;
		return env;
	}
	def newPhi(t: Type, args: Array<SsaInstr>) -> SsaPhi {
		var phi = SsaPhi.new(t, block, args);
		block.prepend(phi);
		return phi;
	}
	def newPhi2(t: Type, a: SsaInstr, b: SsaInstr) -> SsaPhi {
		var args = [a, b];
		var phi = newPhi(t, args);
		phi.facts = a.facts & b.facts;
		return phi;
	}
}
