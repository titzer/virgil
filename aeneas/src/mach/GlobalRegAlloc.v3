// Copyright 2023 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def verbose = false;
def colorVerbose = false;
def COALESCE = false;
// Implement global register allocation with graph coloring. Build an interference
// graph from liveness analysis.
class GlobalRegAlloc(regSet: MachRegSet, codegen: SsaMachGen) {
	def statistic = RegAllocStatistic.new();
	def regState = RegState.new(regSet, codegen);
	def regUsage = Array<int>.new(regSet.physRegs);
	def moves = GlobalMoveSet.new(regSet);
	def movesPrev = GlobalMoveSet.new(regSet);
	def parmoveDests = Vector<(VReg, List<Operand.Def>)>.new();
	def backupAllocate = LocalRegAlloc.new(regSet, codegen).allocate;
	def availableColor = regSet.regSets[regSet.regClasses[RegClass.REF.tag]].length - 2;
	def vars = codegen.vars;
	def loops = Vector<SsaLoopInfo>.new();
	def simplifyWorklist = Vector<int>.new();
	def freezeWorklist = Vector<int>.new();
	def spillWorklist = Vector<int>.new();
	def selectStack = Vector<int>.new();
	var movesWorklist = Vector<(int,int,int)>.new(); // var, var, weight
	var liveness: BitMatrix;
	var buf = ArchInstrBuffer.new(codegen, codegen.mach.prog, regSet);
	var prev: ArchInstr;
	var cur: ArchInstr;
	var next: ArchInstr;
	var graph: Graph;
	var coloring: Array<byte>;
	var actualSpill: bool;
	var blockWeight: Array<int>;
	var curWeight: int;
	var liveoutRow: int;
	var maskRow: int;
	var originVarsCnt: int;
	var blockReloads: Array<Vector<VReg>>;

	// 1. Insert move instruction before each use whose constraint is stack.
	// 2. Construct the interference graph.
	// 3. Color the graph with simplify, coalesce, freeze, spill and select phases.
	//    Iterate until the graph is colorable.
	// 4. Allocate register in the instructions. If there is constraint, move variable
	//    to match the constraint.
	def allocate() {
		reset();
		liveness = codegen.liveness;
		liveoutRow = liveness.numrows;
		maskRow = liveness.numrows + 1;
		liveness.grow(maskRow + 1);
		liveness.setRow(maskRow);
		blockReloads = Array<Vector<VReg>>.new(codegen.order.length);
		for (i < codegen.order.length) {
			blockReloads[i] = Vector<VReg>.new();
		}
		codegen.blocks.computeDominators();
		codegen.iterateInstructionsBackward(insertMovesToStack);
		blockWeight = Array<int>.new(codegen.order.length);
		computeBlockWeight(1, 0, codegen.order.length);
		initGraph();
		codegen.iterateInstructionsBackward(buildGraph);
		colorGraph();
		while (actualSpill) {
			statistic.iterate++;
			statistic.coalesce = 0;
			insertSpillInit();
			codegen.iterateInstructionsForward(insertSpill);
			insertSpillCleanup();
			initGraph();
			codegen.iterateInstructionsBackward(buildGraph);
			colorGraph();
		}
		if (colorVerbose) printColor();
		codegen.iterateInstructionsBackward(allocateAfterColoring);
		if (CLOptions.PRINT_REGALLOC.get()) statistic.print();
	}
	def computeLiveoutForBlock(block: SsaBlock) {
		liveness.clearRow(liveoutRow);
		for (e in block.succs()) {
			var succ = e.dest;
			// union the succesor's live-in set into this.
			liveness.or(liveoutRow, succ.mark);
		}
		liveness.and(liveoutRow, maskRow);
	}
	def allocateAfterColoring(block: SsaBlock, cur: ArchInstr) {
		cur = cur;
		prev = cur.prev;
		next = cur.next;
		if (verbose) Terminal.put(buf.putInstrV(cur).toString());
		regState.pos++;
		var opcode = cur.opcode();
		var operands = cur.operands;

		if (opcode == ArchInstrs.ARCH_BLOCK_END) {
			regState.release();
			computeLiveoutForBlock(block);
			for (i < vars.length) {
				if (liveness[liveoutRow, i]) updateRegState(vars[i]);
			}
			return;
		}
		moves.clear();
		movesPrev.clear();
		
		if (opcode == ArchInstrs.ARCH_PARMOVE) { // perform parallel move
			parmoveDests.resize(0);
			codegen.gatherParallelMoveDests(cur, parmoveDests);
			for (j < parmoveDests.length) recursivelyEmitMoves(j, next);
			for (i < operands.length) match (operands[i]) {
				Def(vreg, constraint) => {
					var gReg = coloring[vreg.varNum];
					regState.freeReg(gReg, true);
				}
				Use(vreg, assignment) => {
					if (!regSet.isStack(assignment)) {
						updateRegState(vreg);
					}
				}
				_ => ;
			}
			var half = operands.length / 2;
			for (i < half) {
				var dst = Operand.Def.!(operands[i]), src = Operand.Use.!(operands[i + half]);
				var dstReg = coloring[dst.vreg.varNum];
				if (regSet.isReg(dstReg) && regState.getVreg(dstReg) != src.vreg) {
					codegen.insertRestoreLocal(dst.vreg, dstReg, next);
				}
			}
			cur.remove();
			if (verbose) regState.dumpState("");
			return;
		}
		if (opcode == ArchInstrs.ARCH_RELOAD) {
			var dst = Operand.Def.!(cur.operands[0]).vreg;
			if (Operand.Use.!(cur.operands[1]).vreg != dst) statistic.reload ++;
			moves.reloads.put(dst, coloring[dst.varNum]);
			moves.emit(codegen, cur.next);
			regState.freeReg(coloring[dst.varNum], true);
			cur.remove();
			if (verbose) regState.dumpState("");
			return;
		}
			
		for (i < operands.length) match (operands[i]) {
			Def(vreg, constraint) => {
				// ignore `Def` introduced by previous spill or `insertLoadToStack`
				if (vreg == null || (regSet.isCallerStack(constraint) && !graph.nodes[vreg.varNum].use)) continue;
				var loc = allocDefReg(vreg, constraint);
				operands[i] = Operand.Def(vreg, loc);
			}
			Overwrite(vreg, use, constraint)    => {
				var loc = allocDefReg(vreg, constraint), newReg = byte.!(loc);
				var gReg = coloring[use.varNum];
				if (use.reloadFrom != null) {
					statistic.reload ++;
					movesPrev.reloads.put(use.reloadFrom, newReg);
				}
				else if (newReg != gReg) {
					if (regSet.isReg(gReg)) movesPrev.addRegMove(use, gReg, newReg);
					else movesPrev.reloads.put(use, newReg);
				}
				regUsage[loc] = regState.pos;
				operands[i] = Operand.Overwrite(vreg, use, loc);
			}
			Use(vreg, constraint) => {
				if (vreg == null || regSet.isStack(constraint)) continue;
				var loc = allocUseReg(vreg, constraint);
				operands[i] = Operand.Use(vreg, loc);
			}
			Kill(constraint) => {
				if (constraint < regSet.regSets.length) {
					for (reg in regSet.regSets[constraint]) {
						spillReg(reg);
						regState.freeReg(reg, true);
					}
				}
			}
			_ => ;
		}
		for (i < operands.length) match (operands[i]) {
			Overwrite(vreg, use, assignment)    => {
				if (use.reloadFrom != null) continue;
				updateRegState(use);
			}
			Use(vreg, assignment) => {
				if (vreg == null || regSet.isStack(assignment) || vreg.reloadFrom != null) continue;
				updateRegState(vreg);
			}
			_ => ;
		}
		if (verbose) regState.dumpState("");
		moves.emit(codegen, cur.next);
		movesPrev.emit(codegen, cur);
		if (opcode == ArchInstrs.ARCH_ENTRY) {
			for (j < regState.cursor) {
				var vreg = regState.allocated[j].0;
				if (vreg.isConst()) {
					codegen.insertMoveValLoc(vreg, (vreg, vreg.reg), vreg.regClass, next);
				}
			}
		}
	}
	def allocDefReg(vreg: VReg, constraint: int) -> int {
		var gReg = coloring[vreg.varNum], loc: int = gReg;
		var prevVreg = regState.getVreg(gReg);
		regState.freeReg(loc, true);
		if (!isOk(loc, constraint)) {
			loc = findBestLocUnderConstraint(vreg.regClass, loc, constraint);
			if (regSet.isReg(gReg) && prevVreg == vreg) moves.addRegMove(vreg, loc, gReg);
		}
		if (vreg.spill > 0) {
			statistic.store++;
			moves.saves.put(vreg, loc, vreg.spill);
		}
		return loc;
	}
	def allocUseReg(vreg: VReg, constraint: int) -> int {
		var gReg = coloring[vreg.varNum], loc: int = gReg;
		loc = findBestLocUnderConstraint(vreg.regClass, loc, constraint);
		var newReg = byte.!(loc);
		if (vreg.reloadFrom != null) {
			statistic.reload++;
			movesPrev.reloads.put(vreg.reloadFrom, newReg);
		} else if (newReg != gReg) {
			if (regSet.isReg(gReg)) movesPrev.addRegMove(vreg, gReg, newReg);
			else movesPrev.reloads.put(vreg, newReg);
		}
		regUsage[loc] = regState.pos;
		return loc;
	}
	def isOk(loc: int, constraint: int) -> bool {
		if (loc == 0) return false;
		if (constraint >= regSet.regSets.length) return false;
		if (constraint == 0) return true;
		return regSet.isInRegSet(loc, constraint);
	}
	def isUsedInThisInstr(reg: byte) -> bool {
		return regUsage[reg] == regState.pos;
	}
	def findBestLocUnderConstraint(regClass: RegClass, prefer: int, constraint: int) -> int {
		if (constraint >= regSet.regSets.length) return constraint;
		if (constraint == 0) constraint = regSet.regClasses[regClass.tag];
		if (prefer != 0 && regSet.isInRegSet(prefer, constraint) && 
			!isUsedInThisInstr(byte.!(prefer))) { // try prefer register first
			return prefer; // prefer register is unused
		}
		// Find a register from the constraint set; a free one, or the one used farthest in future
		var minpos = int.max, newReg: byte = 0;
		for (reg in regSet.regSets[constraint]) {
			var i = regState.regState[reg];
			if (i < 0 && !isUsedInThisInstr(reg)) return reg; // found a free register in the set
			if (i >= 0) {
				var a = regState.allocated[i];
				if (a.1 < minpos && !isUsedInThisInstr(reg)) {
					minpos = a.1;
					newReg = reg;
				}
			}
		}
		if (newReg == 0) codegen.context.fail("no registers available");
		return newReg;
	}
	def spillReg(reg: byte) {
		var i = regState.regState[reg];
		if (i < 0) return;
		var vreg = regState.allocated[i].0;
		allocSpill(vreg);
		moves.reloads.put(vreg, reg);
	}
	def allocSpill(vreg: VReg) {
		if (vreg.spill == 0) vreg.spill = codegen.frame.allocSpill(vreg.regClass);
	}
	def updateRegState(vreg: VReg) {
		var reg = coloring[vreg.varNum];
		if (!regSet.isReg(reg)) return;
		regState.reassignReg(vreg, reg);
		vreg.reg = reg;
	}
	def reset() {
		for (i < regUsage.length) regUsage[i] = 0;
		regState.clear();
		statistic.reset(vars.length);
		loops.resize(0);
	}
	def recursivelyEmitMoves(j: int, next: ArchInstr) {
		var t = parmoveDests[j], vreg = t.0, dest = t.1;
		if (vreg.parmoveState <= 0) return; // already done on or stack
		vreg.parmoveState = ON_STACK;
		for (l = dest; l != null; l = l.tail) {
			var o = l.head, dreg = o.vreg, index = dreg.parmoveState;
			allocSpill(dreg);
			if (index == ON_STACK) {
				// destination is already on stack; cycle; load to temp
				dreg.parmoveState = IN_CYCLE;
				codegen.insertRestoreLocal(dreg, getParallelMoveReg(dreg.regClass, 1), next);
			}
			if (index > 0) recursivelyEmitMoves(index - 1, next);
		}
		var loc: int;
		if (vreg.parmoveState == IN_CYCLE) {
			loc = getParallelMoveReg(vreg.regClass, 1);
		} else if (vreg.spill <= 0) {
			loc = coloring[vreg.varNum];
		} else {
			allocSpill(vreg);
			loc = getParallelMoveReg(vreg.regClass, 0);
			codegen.insertRestoreLocal(vreg, loc, next);
		}
		if (regSet.isReg(loc)) {
			for (l = dest; l != null; l = l.tail) {
				statistic.store++;
				codegen.insertSaveLocal(loc, l.head.vreg, next);
			}
		} else { // not spill and no global register assigned -> const
			for (l = dest; l != null; l = l.tail) {
				statistic.store++;
				codegen.insertMoveValLoc(vreg, (l.head.vreg, l.head.vreg.spill), vreg.regClass, next);
			}
		}
		vreg.parmoveState = 0;
	}
	def getParallelMoveReg(rcl: RegClass, which: int) -> int {
		var set = regSet.regClasses[rcl.tag];
		var loc = regSet.regSets[set][regSet.regSets[set].length - which - 1];
		return loc;
	}
	def removeFromWorklist(worklist: Vector<int>, x: int) -> bool {
		for (i < worklist.length) {
			if (worklist[i] == x) {
				var a = worklist[--worklist.length];
				if (worklist.length > 0) worklist[i] = a;
				return true;
			}
		}
		return false;
	}
	def movesWorklistCmp(x: (int, int, int), y: (int, int, int)) -> bool {
		return x.2 > y.2;
	}
	def mkWorklist() {
		simplifyWorklist.clear();
		freezeWorklist.clear();
		spillWorklist.clear();
		for (i = vars.length - 1; i > 0; i--) {
			if (vars[i] == null || (!graph.nodes[i].use && !graph.nodes[i].color)) continue;
			if (graph.nodes[i].interfereCnt >= availableColor) spillWorklist.put(i);
			else if (graph.nodes[i].movesCnt > 0) {
				if (!COALESCE) V3.fail<void>("coalesce should be turned off");
				freezeWorklist.put(i);
			}
			else simplifyWorklist.put(i);
		}
		movesWorklist.array = Arrays.sort(movesWorklist.array, 0, movesWorklist.length, movesWorklistCmp);
		statistic.move = movesWorklist.length;
	}
	def decrementDegree(n: int) {
		if (n < 0) return;
		// When a degree transit from availableColor, move the node to simplifyWorklist.
		if (!graph.nodes[n].removed && graph.nodes[n].interfereCnt == availableColor) {
			removeFromWorklist(spillWorklist, n);
			if (graph.nodes[n].movesCnt > 0) freezeWorklist.put(n);
			else simplifyWorklist.put(n);
		}
		graph.nodes[n].interfereCnt --;
	}
	def simplify() {
		var node = simplifyWorklist[--simplifyWorklist.length];
		graph.nodes[node].removed = true;
		selectStack.put(node);
		for (i < graph.nodes[node].interfere.length) {
			decrementDegree(graph.nodes[node].interfere[i]);
		}
	}
	def getAlias(n: int) -> int {
		while (n > 0 && graph.nodes[n].alias != n) {
			n = graph.nodes[n].alias;
		}
		return n;
	}
	def addWorklist(n: int) {
		if (n > 0 && graph.nodes[n].movesCnt == 0 && graph.nodes[n].interfereCnt < availableColor) {
			removeFromWorklist(freezeWorklist, n);
			simplifyWorklist.put(n);
		}
	}
	def coalesce() -> bool {
		var flag = false;
		var tmpMovesWorklist = Vector<(int,int,int)>.new();
		while (movesWorklist.length > 0) {
			var m = movesWorklist[--movesWorklist.length];
			var u = getAlias(m.0), v = getAlias(m.1);
			var x = if(v < 0, v, u), y = if(v < 0, u, v);
			if (y < 0) { // both vars are precolored
			} else if (x == y) {
				flag = true;
				graph.nodes[x].movesCnt --;
				addWorklist(x);
			} else if (!graph.isInterfere(x, y) && tryCoalesce(x, y)) {
				flag = true;
			} else {
				tmpMovesWorklist.put(m);
			}
		}
		movesWorklist = tmpMovesWorklist;
		return flag;
	}
	def precoloredCoalesceCheck(precolored: int, y: Node) -> bool{
		for (i < y.interfere.length) {
			if (y.interfere[i] < 0) continue;
			var t = y.interfere[i], tnode = graph.nodes[t];
			if (tnode.removed || tnode.interfereCnt < availableColor || graph.isInterfere(t, precolored)) continue;
			return false;
		}
		return true;
	}
	def tryCoalesce(x_: int, y_: int) -> bool {
		var coalesce = false;
		var y = graph.nodes[y_];
		if (x_ < 0) {
			if (precoloredCoalesceCheck(-x_, graph.nodes[y_])) {
				coalesce = true;
			}
		} else {
			var x = graph.nodes[x_];
			var combine = graph.combineInterfere(x_, y_);
			var cnt = 0, tmpInterfereCnt = 0;
			for (i < combine.length) {
				if (combine[i] < 0) {cnt++; tmpInterfereCnt ++; continue;}
				if (graph.nodes[combine[i]].interfereCnt >= availableColor) cnt ++;
				if (!graph.nodes[combine[i]].removed) tmpInterfereCnt ++;
			}
			if (cnt < availableColor) { // Briggs conservative coalescing heuristic
				coalesce = true;
				x.movesCnt --;
				graph.mergeMoves(x_, y_);
				if (tmpInterfereCnt >= availableColor && x.interfereCnt < availableColor) {
					removeFromWorklist(freezeWorklist, x_);
					spillWorklist.put(x_);
				} else if (tmpInterfereCnt < availableColor && x.movesCnt == 0) {
					removeFromWorklist(freezeWorklist, x_);
					simplifyWorklist.put(x_);
				}
				x.interfere = combine;
				x.interfereCnt = tmpInterfereCnt;
			}
		}
		if (coalesce) {
			statistic.coalesce++;
			y.removed = true;
			if (y.interfereCnt < availableColor) removeFromWorklist(freezeWorklist, y_);
			else removeFromWorklist(spillWorklist, y_);
			for (i < y.interfere.length) {
				if (y.interfere[i] < 0) continue;
				if (graph.nodes[y.interfere[i]].addInterfere(x_)) graph.nodes[y.interfere[i]].interfereCnt --;
				else decrementDegree(y.interfere[i]);
			}
			graph.nodes[y_].alias = x_;
		}
		return coalesce;
	}
	def freeze() {
		var node = freezeWorklist[--freezeWorklist.length];
		simplifyWorklist.put(node);
		freezeMoves(node);
	}
	def freezeMoves(node: int) {
		for (i < graph.nodes[node].moves.length) {
			var v = getAlias(graph.nodes[node].moves[i]);
			if (v > 0 && v != node) {
				graph.nodes[v].movesCnt --;
				if (!graph.nodes[v].removed && graph.nodes[v].movesCnt == 0 && graph.nodes[v].interfereCnt < availableColor) {
					simplifyWorklist.put(v);
					removeFromWorklist(freezeWorklist, v);
				}
			}
			for (j < movesWorklist.length) {
				var x = getAlias(movesWorklist[j].0), y = getAlias(movesWorklist[j].1);
				if ((x == node && y == v) || (x == v && y == node)) {
					var a = movesWorklist[--movesWorklist.length];
					if (movesWorklist.length > 0) movesWorklist[j] = a;
					break;
				}
			}
		}
	}
	def selectSpill() {
		var mincost: float = 1000000000000f, idx: int = -1;
		for (i < spillWorklist.length) {
			var node = graph.nodes[spillWorklist[i]];
			if (!node.removed && !vars[spillWorklist[i]].notSpillable) {
				var cost: float = float.roundi(node.spillCost) / float.roundi(node.interfereCnt);
				if (cost < mincost) {
					idx = i;
					mincost = cost;
				}
			}
		}
		if (idx == -1) return V3.fail("no registers available to spill");
		var node = spillWorklist[idx];
		graph.nodes[node].spill = true;
		simplifyWorklist.put(node);
		var a = spillWorklist[--spillWorklist.length];
		if (spillWorklist.length > 0) spillWorklist[idx] = a;
		freezeMoves(node);
	}
	// Color the graph by removing the nodes from graph and add them back in a
	// LIFO order. Select node with degree smaller than k or mark as spill if no
	// available node. Set `actualSpill` to true if require actual spill.
	def colorGraph() {
		mkWorklist();
		while (simplifyWorklist.length > 0 || freezeWorklist.length > 0 || spillWorklist.length > 0) {
			if (simplifyWorklist.length > 0) simplify();
			else if (!coalesce()) {
				if (freezeWorklist.length > 0) freeze();	
				else selectSpill();
			}
		}
		coloring = Array<byte>.new(vars.length);
		actualSpill = false;
		var allocatedColor: Array<bool> = Array.new(regSet.physRegs);
		while (selectStack.length > 0) {
			var node = selectStack[--selectStack.length];
			graph.nodes[node].removed = false;
			for (i < regSet.physRegs) allocatedColor[i] = false;
			for (i < graph.nodes[node].interfere.length) {
				var neighbor = graph.nodes[node].interfere[i];
				if (neighbor < 0) {
					allocatedColor[-neighbor] = true;
				} else {
					if (!graph.nodes[neighbor].removed) {
						allocatedColor[coloring[neighbor]] = true;
					}
				}
			}
			var vreg = vars[node];
			if (vreg.hint != 0 && !allocatedColor[vreg.hint]) {
				coloring[node] = vreg.hint;
				continue;
			}
			var set = regSet.regClasses[vreg.regClass.tag];
			for (i < regSet.regSets[set].length - 2) {
				var reg = regSet.regSets[set][i];
				if (!allocatedColor[reg]) {
					coloring[node] = reg;
					break;
				}
			}
			if (coloring[node] > 0) continue;
			if (!graph.nodes[node].spill) return V3.fail("no colors available");
			vreg.notSpillable = true;
			allocSpill(vreg);
			actualSpill = true;
		}
		for (i = vars.length - 1; i > 0; i--) {
			if (vars[i] == null || (!graph.nodes[i].use && !graph.nodes[i].color) || coloring[i] > 0) continue;
			var a = getAlias(i);
			coloring[i] = if(a > 0, coloring[a], byte.!(-a));
		}
	}
	def processSpillOnInstr(vreg: VReg, constraint: int) -> VReg {
		var newVreg = codegen.dupVReg(vreg);
		newVreg.notSpillable = true;
		newVreg.reloadFrom = vreg;
		if (constraint < regSet.physRegs) newVreg.hint = byte.view(constraint);
		return newVreg;
	}
	def findDominatorOutOfLoop(node: Node) -> SsaBlock {
		var vreg = node.newVreg;
		var blockinfo = codegen.order[node.commonDominator.mark];
		var defBlockinfo = codegen.order[node.defBlock.mark];
		for (p = blockinfo; p != null; p = p.dom_parent) {
			if (p.dom_parent != null && !codegen.blocks.isDominator(defBlockinfo, p.dom_parent)) break;
			if (p.loop != null && p.dom_parent != null && p.dom_parent != defBlockinfo && p.loop.contains(blockinfo)) {
				blockinfo = p.dom_parent;
				liveness[p.block.mark, vreg.varNum] = true;
			}
		}
		return blockinfo.block;
	}
	def insertReload(vreg: VReg, node: Node) {
		node.commonDominator = findDominatorOutOfLoop(node);
		codegen.insertReload(vreg, (node.newVreg, 0), codegen.instrs[node.commonDominator.mark].next);
		blockReloads[node.commonDominator.mark].put(node.newVreg);
	}
	def findCommonDominator(vreg: VReg, block: SsaBlock) -> SsaBlock {
		var node = graph.nodes[vreg.varNum];
		var order = codegen.order;
		var blockAInfo = codegen.blocks.commonDominator(order[node.commonDominator.mark], order[block.mark]);
		if (blockAInfo == null) return null;
		for (i < loops.length) {
			if (loops[i].contains(blockAInfo) && 
				(!loops[i].contains(order[node.commonDominator.mark]) || !loops[i].contains(order[block.mark]))) {
				return null;
			}
		}
		var blockA = blockAInfo.block;
		if (blockA == node.commonDominator) return blockA;
		if (blockA == node.defBlock) return null;
		for (e in blockA.succs()) {
			var succ = e.dest;
			if (!liveness[succ.mark, vreg.varNum]) return null;
		}
		return blockA;
	}
	// Try to insert reload in the common dominator.
	def processSpillOnBlock(vreg: VReg, block: SsaBlock) {
		var node = graph.nodes[vreg.varNum];
		if (node.commonDominator == null) {
			node.newVreg = codegen.dupVReg(vreg);
			node.newVreg.spill = vreg.spill;
			node.commonDominator = block;
		} else {
			var newCommonDominator = findCommonDominator(vreg, block);
			if (newCommonDominator == null) {
				// Insert reload for the past uses at the start of the common dominator.
				insertReload(vreg, node);
				node.newVreg = codegen.dupVReg(vreg);
				node.newVreg.spill = vreg.spill;
				node.commonDominator = block;
			} else {
				node.commonDominator = newCommonDominator;
			}
		}
		liveness[block.mark, node.newVreg.varNum] = true;
	}
	def processSpill(vreg: VReg, constraint: int, block: SsaBlock) {
		var node = graph.nodes[vreg.varNum];
		if (node.defBlock == block) node.newVreg = processSpillOnInstr(vreg, constraint);
		else processSpillOnBlock(vreg, block);
	}
	def insertSpill(block: SsaBlock, i: ArchInstr) {
		var opcode = i.opcode();
		var operands = i.operands;
		for (j = operands.length - 1; j >= 0; j--) {
			match (operands[j]) {
				Use(vreg, constraint) => {
					if (opcode == ArchInstrs.ARCH_RELOAD) continue;
					if (vreg != null && !regSet.isStack(constraint) && coloring[vreg.varNum] == 0) {
						var node = graph.nodes[vreg.varNum];
						if (opcode == ArchInstrs.ARCH_PARMOVE) {
							operands[j] = Operand.Use(vreg, regSet.spillStart); // Set the constraint to stack
							continue;
						}
						processSpill(vreg, constraint, block);
						operands[j] = Operand.Use(node.newVreg, constraint);
					}
				}
				Overwrite(vreg, use, constraint) => {
					if (!regSet.isStack(constraint) && coloring[use.varNum] == 0) {
						processSpill(use, constraint, block);
						operands[j] = Operand.Overwrite(vreg, graph.nodes[use.varNum].newVreg, constraint);
					} 
					if (vreg != null && coloring[vreg.varNum] == 0) {
						graph.nodes[vreg.varNum].defBlock = block;
					}
				}
				Def(vreg, constraint) => {
					if (vreg != null && coloring[vreg.varNum] == 0) {
						var node = graph.nodes[vreg.varNum];
						if (node.commonDominator != null) {
							insertReload(vreg, node);
							node.commonDominator = null;
						}
						node.defBlock = block;
						if (opcode == ArchInstrs.ARCH_RELOAD) {
							// vreg is spilled again, remove this reload
							i.remove();
							return;
						}
						if (opcode == ArchInstrs.ARCH_PARMOVE) {
							operands[j] = Operand.Def(vreg, vreg.spill);
						}
					}
				}
				_ => ;
			}
		}
	}
	def insertSpillInit() {
		originVarsCnt = vars.length;
		for (i = vars.length - 1; i > 0; i--) {
			if (vars[i] == null) originVarsCnt --;
			else break;
		}
		for (i < codegen.order.length) {
			blockReloads[i].resize(0);
		}
	}
	def insertSpillCleanup() {
		for (i = originVarsCnt; i < vars.length; i++) {
			liveness[maskRow, i] = true;
		}
		for (i < originVarsCnt) {
			if (coloring[i] == 0) {
				liveness[maskRow, i] = false; // spill vreg are not live accross blocks
				var node = graph.nodes[i];
				if (node.commonDominator != null) {
					insertReload(vars[i], node);
				}
 			}
		}
		for (i = codegen.order.length - 1; i >= 0; i--) {
			var info = codegen.order[i], block = info.block;
			for (e in block.succs()) {
				var succ = e.dest;
				for (j = originVarsCnt; j < vars.length; j++) {
					if (liveness[succ.mark, j]) liveness[block.mark, j] = true;
				}
			}
			for (j < blockReloads[i].length) {
				liveness[i, blockReloads[i][j].varNum] = false;
			}
			if (info.loop != null) {
				var end = info.loop.end;
				// Propagate the liveness to the blocks in this loop.
				for (j = info.block.mark + 1; j < end; j++) {
					liveness.or(j, info.block.mark);
				}
			}
		}
	}
	def insertMovesToStack(block: SsaBlock, cur: ArchInstr) {
		var opcode = cur.opcode();
		if (opcode == ArchInstrs.ARCH_BLOCK) {
			for (i < vars.length) if (liveness[liveoutRow, i]) {
				codegen.insertReload(vars[i], (vars[i], 0), cur.next);
				liveness[maskRow, i] = false;
			}
			liveness.clearRow(liveoutRow);
		}
		var operands = cur.operands;
		for (j < operands.length) {
			match (operands[j]) {
				Use(vreg, constraint) => {
					if (regSet.isStack(constraint)) {
						if (vreg.isConst()) codegen.insertMoveValLoc(vreg, (vreg, constraint), vreg.regClass, cur);
						else codegen.insertMoveLocLoc((vreg, 0), (null, constraint), vreg.regClass, cur);
					}
					else if (vreg.isConst()) liveness[liveoutRow, vreg.varNum] = true;
				}
				Overwrite(vreg, use, constraint) => {
					if (use.isConst()) liveness[liveoutRow, use.varNum] = true;
				}
				Kill(constraint) => {
					for (i < vars.length) if (liveness[liveoutRow, i]) {
						codegen.insertReload(vars[i], (vars[i], 0), cur.next);
						liveness[maskRow, i] = false;
					}
					liveness.clearRow(liveoutRow);
				}
				_ => ;
			}
		}
	}
	def printColor() {
		buf.reset();
		for (i = 1; i < coloring.length; i++) {
			if (regSet.isReg(coloring[i])) {
				buf.putc('v').putd(i).puts("->");
				buf.puts(regSet.identify(coloring[i])).putc(' ');
			}
		}
		Terminal.put(buf.ln().toString());
	}
	def computeBlockWeight(weight: int, start: int, end: int) -> int {
		var order = codegen.order;
		for (i = start; i < end; i++) {
			var info = order[i], block = info.block;
			if (info.loop != null) {
				blockWeight[i] = weight * 10;
				loops.put(info.loop);
				i = computeBlockWeight(weight * 10, i + 1, info.loop.end);
			} else {
				blockWeight[i] = weight;
			}
		}
		return end - 1;
	}
	def addInterferences(vreg: VReg) {
		var node = graph.nodes[vreg.varNum], old = node.interfere;
		node.interfere = Vector<int>.new();
		var i = 0, j = 0;
		while (i < old.length && old[i] < 0) {
			node.interfere.put(old[i]);
			i ++;
		}
		while (i < old.length && j < vars.length) {
			if (old[i] == j) {
				node.interfere.put(old[i]);
				i ++;
			} else if (liveness[liveoutRow, j] && j != vreg.varNum) {
				node.interfere.put(j);
				node.interfereCnt ++;
				graph.nodes[j].addInterfere(vreg.varNum);
			}
			j ++;
		}
		for (j = j; j < vars.length; j++) {
			if (liveness[liveoutRow, j] && j != vreg.varNum) {
				node.interfere.put(j);
				node.interfereCnt ++;
				graph.nodes[j].addInterfere(vreg.varNum);
			}
		}
	}
	def addInterfereRegfilter(reg: int, filter: VReg) {
		for (i < vars.length) {
			if (i != filter.varNum && liveness[liveoutRow, i]) graph.nodes[i].addInterfere(-reg);
		}
	}
	def processConstraint(vreg: VReg, constraint: int, weight: int) {
		if (vreg == null || constraint == 0 || regSet.isStack(constraint)) return;
		if (regSet.isReg(constraint)) {
			addInterfereRegfilter(constraint, vreg);
			if (graph.addMove(vreg.varNum, -constraint)) movesWorklist.put((-constraint, vreg.varNum, weight));
		} else {
			var constraintSet = regSet.regSets[constraint], j = 0;
			constraintSet = Arrays.sort(constraintSet, 0, constraintSet.length, byte.<);
			var set = regSet.regClasses[vreg.regClass.tag];
			for (i < regSet.regSets[set].length - 2) {
				var reg = regSet.regSets[set][i];
				if (j < constraintSet.length && reg == constraintSet[j]) j ++;
				else graph.nodes[vreg.varNum].addInterfere(-reg);
			}
		}
	}
	def initGraph() {
		graph = Graph.new(vars.length, regSet);
		for (i < vars.length) {
			graph.nodes[i] = Node.new(i, codegen.order[0].block);
		}
		curWeight = 0;
		movesWorklist.resize(0);
	}
	// Build interference graph via liveness analysis passing instructions backward.
	def buildGraph(block: SsaBlock, cur: ArchInstr) {
		var opcode = cur.opcode();
		var operands = cur.operands;
		if (opcode == ArchInstrs.ARCH_BLOCK_END) {
			computeLiveoutForBlock(block);
			// Variables may be interfered with uses in different succ of the block.
			for (i < vars.length) if (liveness[liveoutRow, i]) addInterferences(vars[i]);
			curWeight = blockWeight[block.mark];
			return;
		}
		if (opcode == ArchInstrs.ARCH_BLOCK) {
			liveness.copy(block.mark, liveoutRow);
		}
		if (opcode == ArchInstrs.ARCH_PARMOVE) {
			var half = operands.length / 2;
			for (i < half) {
				var def_ = Operand.Def.!(operands[i]), use = Operand.Use.!(operands[i + half]);
				var dst = def_.vreg.varNum, src = use.vreg.varNum;
				if (def_.constraint == 0 && use.constraint == 0 && dst != src && graph.addMove(dst, src)) {
					movesWorklist.put((dst, src, curWeight));
				}
			}
		}

		for (i < operands.length) match (operands[i]) {
			Def(vreg, constraint) => {
				// ignore `Def` introduced by previous spill or `insertLoadToStack`
				if (vreg == null || (regSet.isStack(constraint) && !graph.nodes[vreg.varNum].use)) continue;
				liveness[liveoutRow, vreg.varNum] = true;
				addInterferences(vreg);
				graph.nodes[vreg.varNum].color = true;
			}
			Overwrite(vreg, use, constraint)    => {
				liveness[liveoutRow, vreg.varNum] = true;
				addInterferences(vreg);
				graph.nodes[vreg.varNum].color = true;
			}
			_ => ;
		}
		// constraint
		for (i < operands.length) match (operands[i]) {
			Def(vreg, constraint) => {
				processConstraint(vreg, constraint, curWeight);
			}
			Overwrite(vreg, use, constraint) => {
				processConstraint(vreg, constraint, curWeight);
			}
			Use(vreg, constraint) => {
				processConstraint(vreg, constraint, curWeight);
			}
			_ => ;
		}
		for (i < operands.length) match (operands[i]) {
			Def(vreg, constraint) => {
				if (vreg == null || (regSet.isStack(constraint) && !graph.nodes[vreg.varNum].use)) continue;
				liveness[liveoutRow, vreg.varNum] = false;
				graph.nodes[vreg.varNum].spillCost += curWeight;
				if (opcode == ArchInstrs.ARCH_RELOAD) break;
			}
			Kill(constraint) => {
				if (regSet.names[constraint] == "all") {
					liveness.clearRow(liveoutRow);
				}
			}
			Overwrite(vreg, use, constraint)    => {
				liveness[liveoutRow, vreg.varNum] = false;
				liveness[liveoutRow, use.varNum] = true;
				addInterferences(use);
				graph.nodes[vreg.varNum].spillCost += curWeight;
				graph.nodes[use.varNum].spillCost += curWeight;
				graph.nodes[use.varNum].use = true;
			}
			Use(vreg, constraint) => {
				if (vreg == null || regSet.isStack(constraint)) continue;
				liveness[liveoutRow, vreg.varNum] = true;
				addInterferences(vreg);
				graph.nodes[vreg.varNum].spillCost += curWeight;
				graph.nodes[vreg.varNum].use = true;
			}
			_ => ;
		}
		for (i < operands.length) match (operands[i]) {
			Overwrite(vreg, use, constraint) => {
				if (use.reloadFrom != null) liveness[liveoutRow, use.varNum] = false;
			}
			Use(vreg, constraint) => {
				if (vreg != null && vreg.reloadFrom != null) liveness[liveoutRow, vreg.varNum] = false;
			}
			_ => ;
		}
	}
}

def LIVE: i8 = 0;
def ON_STACK: i8 = -1;
def IN_CYCLE: i8 = -2;
def DEAD: i8 = -3;

class Graph(varsCnt: int, regSet: MachRegSet) {
	def nodes = Array<Node>.new(varsCnt);

	def addMove(x: int, y: int) -> bool {
		if (!COALESCE) return false;
		for (i < nodes[x].moves.length) {
			if (nodes[x].moves[i] == y) return false;
		}
		nodes[x].moves.put(y);
		nodes[x].movesCnt ++;
		if (y > 0) {
			nodes[y].moves.put(x);	
			nodes[y].movesCnt ++;
		}
		return true;
	}
	def mergeMoves(dst: int, src: int) {
		if (dst < 0) return;
		nodes[dst].moves.putv(nodes[src].moves);
		nodes[dst].movesCnt += nodes[src].movesCnt;
	}
	def isInterfere(x: int, y: int) -> bool {
		if (x < 0 && y < 0) return true;
		var u = x, v = y;
		if (x < 0) {u = y; v = x;}
		var interfere = nodes[u].interfere;
		var low = 0, high = interfere.length - 1;
		while (low <= high) {
			var mid = low + (high - low) / 2;
			if (interfere[mid] == v) return true;
			if (interfere[mid] < v) low = mid + 1;
			else high = mid - 1;
		}
		return false;
	}
	def combineInterfere(x_: int, y_: int) -> Vector<int> {
		var x = nodes[x_], y = nodes[y_];
		var combine = Vector<int>.new();
		var i = 0, j = 0;
		while (i < x.interfere.length && j < y.interfere.length) {
			if (x.interfere[i] == y.interfere[j]) {
				combine.put(x.interfere[i]);
				i ++; j++;
			} else if (x.interfere[i] < y.interfere[j]) {
				combine.put(x.interfere[i]);
				i ++;
			} else {
				combine.put(y.interfere[j]);
				j ++;
			}
		}
		while (i < x.interfere.length) {
			combine.put(x.interfere[i]);
			i ++;
		}
		while (j < y.interfere.length) {
			combine.put(y.interfere[j]);
			j ++;
		}
		return combine;
	}
	def print() {
		for (i < nodes.length) {
			Terminal.put1("v%d:", i);
			for (j < nodes[i].interfere.length) {
				if (nodes[i].interfere[j] < 0) Terminal.put1(" %s", regSet.identify(-nodes[i].interfere[j]));
				else Terminal.put1(" v%d", nodes[i].interfere[j]);
			}
			Terminal.put("\n");
		}
	}
}

class Node(var alias: int, var defBlock: SsaBlock) {
	var interfere = Vector<int>.new();
	var interfereCnt: int = 0;
	var moves = Vector<int>.new();
	var movesCnt: int = 0;
	var removed: bool = false;
	var spillCost = 0;
	var spill: bool = false;
	var use: bool = false;
	var color: bool = false; // whether a node requires a color even without use
	//  -- state for inserting spill ---------------------------
	var newVreg: VReg;
	var commonDominator: SsaBlock;

	def addInterfere(n: int) -> bool {
		var stop = interfere.length;
		for (i < interfere.length) {
			if (interfere[i] == n) {
				return false;
			} else if (interfere[i] > n) {
				stop = i;
				break;
			}
		}
		interfere.put(0);
		for (i = interfere.length - 1; i > stop; i--) {
			interfere[i] = interfere[i-1];
		}
		interfere[stop] = n;
		interfereCnt ++;
		return true;
	}
}

class GlobalMoveSet(regSet: MachRegSet) {
	def regindex = Array<int>.new(regSet.physRegs);     // where each register occurs, if all, in regmoves
	def regmoves = Vector<(i8, VReg, int, List<byte>)>.new();   // (state, VReg, src, reg)
	def saves = Vector<(VReg, int, int)>.new();     // (VReg, src, dst)
	def reloads = Vector<(VReg, int)>.new();        // (VReg, dst)

	def addRegMove(vreg: VReg, src: int, dst: byte) {
		if (src == dst) return;
		if (regSet.isReg(src)) {
			if (regindex[src] < 0) {
				var index = regmoves.length;
				regindex[src] = index;
				regmoves.put(LIVE, vreg, src, List.new(dst, null));
			} else {
				var index = regindex[src];
				var prev = regmoves[index].3;
				regmoves[index] = (LIVE, vreg, src, List.new(dst, prev));
			}
		} else {
			regmoves.put(LIVE, vreg, src, List.new(dst, null));
		}
	}
	def emit(codegen: SsaMachGen, next: ArchInstr) {
		for (j < saves.length) {
			var s = saves[j], vreg = s.0, src = s.1, dst = s.2;
			if (src != dst) codegen.insertMoveLocLoc((vreg, src), (vreg, dst), vreg.regClass, next);
		}
		for (j < regmoves.length) emit0(codegen, j, next);
		for (j < reloads.length) {
			var t = reloads[j], vreg = t.0;
			if (vreg.isConst()) codegen.insertMoveValLoc(vreg, (vreg, t.1), vreg.regClass, next);
			else codegen.insertMoveLocLoc((vreg, vreg.spill), (vreg, t.1), vreg.regClass, next);
		}
	}
	def emit0(codegen: SsaMachGen, j: int, next: ArchInstr) {
		var t = regmoves[j], state = t.0, vreg = t.1, src = t.2, dst = t.3;
		if (state < LIVE) return; // already done on or stack
		regmoves[j] = (ON_STACK, vreg, src, dst);
		for (l = dst; l != null; l = l.tail) {
			var dreg = l.head, d = regindex[dreg];
			if (d >= 0) { // is the source of some regmove
				var u = regmoves[d];
				if (u.0 == ON_STACK) {
					var regClass = u.1.regClass;
					var scratch = regSet.scratch[regClass.tag];
					regmoves[d] = (IN_CYCLE, u.1, scratch, u.3);
					codegen.insertMoveLocLoc((u.1, dreg), (u.1, scratch), regClass, next);
				} else if (u.0 == LIVE) {
					emit0(codegen, d, next);
				}
			}
		}
		// reload entry after recursion
		t = regmoves[j];
		if (t.0 == IN_CYCLE) src = t.2; // use scratch of entry
		for (l = dst; l != null; l = l.tail) {
			codegen.insertMoveLocLoc((vreg, src), (vreg, l.head), vreg.regClass, next);
		}
		regmoves[j] = (DEAD, null, 0, null);
	}
	def clear() {
		for (i < regindex.length) regindex[i] = -1;
		regmoves.resize(0);
		saves.resize(0);
		reloads.resize(0);
	}
}
class RegAllocStatistic {
	var varslen: int;
	var iterate: int;
	var store: int;
	var reload: int;
	var coalesce: int;
	var move: int;

	def reset(len: int) {
		varslen = len;
		iterate = 0;
		store = 0;
		reload = 0;
	}
	def print() {
		Terminal.put1("Statistic: iterate=%d\n", iterate);
		Terminal.put3("           varslen=%d, store=%d, reload=%d\n", varslen, store, reload);
		if (COALESCE) Terminal.put2("           coalesce=%d/%d\n", coalesce, move);
	}
}