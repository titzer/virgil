// Copyright 2023 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def COALESCE = false;
def COLOR_RESERVE = 2;

// Implements global register allocation via graph coloring, including spilling, splitting,
// and coalescing.
class GlobalRegAlloc(regSet: MachRegSet, codegen: SsaMachGen) {
	def statistic = RegAllocStatistic.new();
	def vars = codegen.vars;
	var liveness = BitMatrix.new(0, 0);
	def constRow = 0;
	var finalizeRow: int;
	var buf = codegen.getOutput();
	var graph: InterferenceGraph;
	var coloring: Array<byte>;
	var verbose = false;
	var stackMoves = false;
	// --- graph coloring ------------------
	def availableColor = regSet.regSets[regSet.regClasses[RegClass.REF.tag]].length - COLOR_RESERVE;
	def simplifyWorklist = Vector<int>.new();
	def freezeWorklist = Vector<int>.new();
	def spillWorklist = Vector<int>.new();
	def selectStack = Vector<int>.new();
	var movesWorklist = Vector<(int,int,int)>.new(); // var, var, weight
	var actualSpill: bool;
	var spillChange: bool;
	var spillRound = 1;
	// --- insert split -------------------
	var blockWeight: Array<int>;
	var curWeight: int;
	var originVarsCnt: int;
	// --- allocate after coloring ----------
	def regState = RegState.new(regSet, codegen);
	def regUsage = Array<int>.new(regSet.physRegs);
	def movesNext = MoveSet.new(regSet);
	def movesPrev = MoveSet.new(regSet);
	def regindex = Array<(int, VReg)>.new(regSet.physRegs);

	def allocate() {
		// Reset internal state.
		verbose = CLOptions.PRINT_REGALLOC.val && codegen.context.shouldPrintMach();
		statistic.reset(vars.length);
		regState.clear();
		stackMoves = false;
		for (i < regUsage.length) regUsage[i] = 0;

		if (verbose) Terminal.putln("Begin global register allocation:");

		// 1. Preprocess constants and uses whose constraint is stack.
		if (verbose) Terminal.put1("Round %d: insert stack moves and constants\n", spillRound);
		stackMoves = false;
		insertStackMovesAndConstants();
		if (stackMoves) codegen.print("after inserting stack moves");

		// 2. Pre-spill variables live across calls and other kills.
		if (verbose) Terminal.put1("Round %d: run shadow stack spiller\n", spillRound);
		codegen.blocks.computeDominators();
		var changed = ShadowStackSpiller.new().run(codegen);
		if (changed) codegen.print("after shadow stack spilling");

		blockWeight = Array<int>.new(codegen.order.length);
		computeBlockWeight(1, 0, codegen.order.length);
		// 2. Construct the interference graph and try to color it.
		spillRound = 1;
		buildAndColorGraph();
		while (actualSpill) {
			// While any actual spills, insert them and rebuild.
			statistic.iterate++;
			statistic.coalesce = 0;
			buildAndColorGraph();
		}
		if (verbose) printColor();

		// 4. Finalize the assignment in instructions and deal with constraints.
		if (verbose) Terminal.put1("Round %d: finalize assignments\n", spillRound);
		codegen.iterateInstructionsBackward(finalizeAssignments);
		if (CLOptions.PRINT_REGALLOC.get()) statistic.print();
	}
	// Compute block weight by giving more weight in loops, {weight = 10^depth}.
	def computeBlockWeight(weight: int, start: int, end: int) -> int {
		var order = codegen.order;
		for (i = start; i < end; i++) { // XXX: use ranges here
			var block = order[i], info = block.info;
			if (info.loop != null) {
				blockWeight[i] = weight * 10;
				i = computeBlockWeight(weight * 10, i + 1, info.loop.end);
			} else {
				blockWeight[i] = weight;
			}
		}
		return end - 1;
	}
	def insertStackMovesAndConstants() {
		liveness.reset(1, vars.length, false); // Track live constants in a block.
		codegen.iterateInstructionsBackward(insertStackMovesAndConstDefs);
	}
	def insertStackMovesAndConstDefs(block: SsaBlock, cur: ArchInstr) {
		codegen.context.block = block;
		var opcode = cur.opcode();
		if (opcode == ArchInstrs.ARCH_BLOCK) {
			// Reached the top of a block while iterating backwards, define all constants.
			insertDefsForLiveConsts(cur.next);
		}
		var operands = cur.operands;
		for (j < operands.length) {
			match (operands[j]) {
				Def(vreg, constraint) => {
					if (vreg != null) {
						if (regSet.isCallerStack(constraint) && vreg.spill == constraint) {
							operands[j] = Operand.DefSlot(vreg.regClass, vreg.spill); // already written by caller
							codegen.insertRestore(vreg, 0, cur.next);
						} else if (regSet.isStack(constraint)) {
							operands[j] = Operand.DefSlot(vreg.regClass, constraint);
							var set = regSet.regClasses[vreg.regClass.tag];
							codegen.insertMoveLocLoc(Operand.Use(null, constraint), Operand.Def(vreg, set), vreg.regClass, cur.next);
						}
					}
				}
				Use(vreg, constraint) => {
					if (regSet.isStack(constraint)) {
						insertStackWrite(constraint, vreg, cur);
						operands[j] = Operand.Use(null, constraint); // TODO: UseSlot
					}
					if (vreg != null && vreg.isConst()) markConstLive(vreg, constraint);
				}
				Overwrite(dreg, vreg, constraint) => {
					if (regSet.isStack(constraint)) {
						// TODO: this seems to never happen.
						insertStackWrite(constraint, vreg, cur);
						operands[j] = Operand.Overwrite(dreg, null, constraint); // TODO: UseSlot
					}
					if (vreg != null && vreg.isConst()) markConstLive(vreg, constraint);
				}
				Kill(constraint) => {
					// Reached a kill, define all constants after the kill.
					insertDefsForLiveConsts(cur.next); // XXX: only kill constants if it kills all regs.
				}
				_ => ;
			}
		}
	}
	def markConstLive(vreg: VReg, constraint: int) {
		liveness.set(constRow, vreg.varNum);
		if (vreg.hint == 0 && regSet.isReg(constraint)) vreg.hint = byte.!(constraint);
	}
	def insertStackWrite(constraint: int, vreg: VReg, cur: ArchInstr) {
		if (vreg.isConst()) {
			codegen.insertMoveConstLoc(SsaConst.!(vreg.ssa), Operand.Def(vreg, constraint), vreg.regClass, cur);
		} else {
			var set = regSet.regClasses[vreg.regClass.tag];
			codegen.insertMoveLocLoc(Operand.Use(vreg, set), Operand.Def(null, constraint), vreg.regClass, cur);
		}
		stackMoves = true;
	}
	def insertDefsForLiveConsts(next: ArchInstr) {
		liveness.apply(constRow, insertDefForLiveConst, next);
		liveness.clearRow(constRow);
	}
	def insertDefForLiveConst(index: int, next: ArchInstr) {
		var vreg = vars[index], val = SsaConst.!(vreg.ssa);
		codegen.insertMoveConstLoc(val, Operand.Def(vreg, 0), vreg.regClass, next);
		stackMoves = true;
	}
	// =====================
	// Build interference graph via liveness analysis, iterating instructions backward.
	// =====================
	def buildAndColorGraph() {
		curWeight = 0;
		spillChange = false;
		movesWorklist.resize(0);
		// Compute liveness for each block and insert spills from this round.
		liveness.reset(codegen.blocks.order.length + 1, vars.length, false);
		if (verbose) Terminal.put2("Round %d: computing liveness %s\n", spillRound, if(spillRound > 1, "and inserting spills", ""));
		codegen.iterateInstructionsBackward(computeLivenessAndInsertSpills);
		if (verbose) {
			if (spillChange) codegen.print(Strings.format1("after inserting spills in round %d", spillRound));
			printLiveness();
		}
		graph = InterferenceGraph.new(vars.length, regSet);
		// Build interference graph using local liveness.
		if (verbose) Terminal.put1("Round %d: building interference graph\n", spillRound);
		codegen.iterateInstructionsBackward(addInterferenceForInstr);
		if (verbose) {
			printGraph();
			Terminal.put1("Round %d: coloring graph\n", spillRound);
		}
		colorGraph();
	}
	// Visit each instruction in backwards order, computing liveness and inserting spill code
	// for variables spilled in the last round.
	def computeLivenessAndInsertSpills(block: SsaBlock, cur: ArchInstr) {
		codegen.context.block = block;
		var opcode = cur.opcode();
		var operands = cur.operands;
		var liveoutRow = block.info.srpo_num;
		var overwrites = false;

		// 1. Gather liveness from successor blocks.
		if (opcode == ArchInstrs.ARCH_BLOCK_END) {
			liveness.clearRow(liveoutRow);
			for (e in block.succs()) {
				liveness.or(liveoutRow, e.dest.info.srpo_num); // union successor's live-in set
			}
		} else if (opcode == ArchInstrs.ARCH_SAVE) {
			var u = Operand.Use.!(operands[0]);
			if (u.vreg.spillRound == spillRound) {
				// Previous saves of a variable that is spilled in this round can be removed,
				// since the variable's definition will have a save inserted immediately after it.
				cur.remove();
				spillChange = true;
				return;
			}
		}

		// 2. Remove all defined variables from liveness.
		for (o in operands) match (o) {
			Def(vreg, constraint) => if(vreg != null) liveness.clear(liveoutRow, vreg.varNum);
			Overwrite(vreg, use, constraint) => if(vreg != null) liveness.clear(liveoutRow, vreg.varNum);
			_ => ;
		}

		// 3. Insert saves for any def in this spillRound and restores (into new vregs) for uses spilled this round.
		for (i < operands.length) match (operands[i]) {
			Def(vreg, constraint) => {
				if (vreg == null || vreg.spillRound != spillRound) continue;
				if (cur.opcode() == ArchInstrs.ARCH_RESTORE) {
					// spilling a variable used in a restore means the restore should be removed.
					cur.remove();
					spillChange = true;
					continue;
				}
				if ((constraint == 0 || constraint == vreg.spill) && vreg.spill > 0) {
					// Unconstrained definition can write directly to spill slot.
					operands[i] = Operand.DefSlot(vreg.regClass, vreg.spill);
				} else {
					// Definition needs a save (if not a constant).
					insertSaveIfNotConst(vreg, constraint, cur.next);
				}
			}
			Overwrite(vreg, use, constraint) => {
				if (vreg != null && vreg.spillRound == spillRound) insertSaveIfNotConst(vreg, constraint, cur.next);
				if (use != null) {
					if (use.spillRound == spillRound) {
						// Use is spilled in this round. Insert restore before. Don't add to liveness.
						var newUse = insertRestoreBeforeUse(use, constraint, cur);
						operands[i] = Operand.Overwrite(vreg, newUse, constraint);
					} else {
						// Use is not spilled in this round; add to liveness.
						liveness.set(liveoutRow, use.varNum);
					}
				}
			}
			Use(vreg, constraint) => {
				if (vreg == null) continue;
				if (vreg.spillRound == spillRound) {
					if ((constraint == 0 || constraint == vreg.spill) && vreg.spill > 0) {
						// Use can read directly from spill slot
						operands[i] = Operand.Use(null, vreg.spill);
					} else {
						// Use is spilled in this round. Insert restore before. Don't add to liveness.
						var newVreg = insertRestoreBeforeUse(vreg, constraint, cur);
						operands[i] = Operand.Use(newVreg, constraint);
					}
				} else {
					// Use is not spilled in this round; add to liveness.
					liveness.set(liveoutRow, vreg.varNum);
				}
			}
			_ => ;
		}

		// 4. Propagate liveness for variables live-in to loop headers to all blocks in the loop.
		var loop = block.info.loop;
		if (opcode == ArchInstrs.ARCH_BLOCK && loop != null) {
			for (i = liveoutRow + 1; i < loop.end; i++) liveness.or(i, liveoutRow);
		}
	}
	def insertSaveIfNotConst(vreg: VReg, constraint: int, next: ArchInstr) {
		if (!vreg.isConst()) {
			codegen.insertSave(vreg, next);
			spillChange = true;
		}
	}
	def insertRestoreBeforeUse(vreg: VReg, constraint: int, next: ArchInstr) -> VReg {
		var newVreg = codegen.dupVReg(vreg);
		newVreg.spillRound = 1;
		liveness.widen(vars.length);
		if (verbose) Terminal.put2(" insertRestoreBeforeUse v%d <- v%d\n", newVreg.varNum, vreg.varNum);
		if (regSet.isReg(constraint)) newVreg.hint = byte.view(constraint);
		if (vreg.spill > 0) newVreg.spill = vreg.spill;
		codegen.insertRestore(newVreg, 0, next);
		spillChange = true;
		return newVreg;
	}
	// Visit each instruction in backwards order, adding edges to the interference graph
	// for interference with other variables and handling constraints. Add move edges for coalescing.
	def addInterferenceForInstr(block: SsaBlock, cur: ArchInstr) {
		codegen.context.block = block;
		var opcode = cur.opcode();
		var operands = cur.operands;
		var currentRow = liveness.numrows - 1;
		
		if (opcode == ArchInstrs.ARCH_BLOCK_END) {
			curWeight = blockWeight[block.info.srpo_num];
			computeLiveoutFromSuccessors(currentRow, block);
			// All variables interfere with each other.
			liveness.apply(currentRow, addInterferenceEdgesByIndex, currentRow);
			return;
		}

		// 0. Handle definitions of vregs that are not live-out as if they were.
		// XXX: this is suboptimal; introduce a new "dead" vreg which interferes only with currentRow
		for (i < operands.length) match (operands[i]) {
			Def(vreg, constraint) => if(vreg != null) setLiveAndAddInterference(currentRow, vreg);
			Overwrite(vreg, use, constraint) => if(vreg != null) setLiveAndAddInterference(currentRow, vreg);
			_ => ;
		}

		// 1. Process constraint interferences for definitions.
		for (i < operands.length) match (operands[i]) {
			Def(vreg, constraint) => addInterferencesFromConstraints(currentRow, vreg, constraint);
			Overwrite(vreg, use, constraint) => addInterferencesFromConstraints(currentRow, vreg, constraint);
			_ => ;
		}

		// 2. Remove all defined variables from liveness.
		for (o in operands) match (o) {
			Def(vreg, constraint) => if(vreg != null) liveness.clear(currentRow, vreg.varNum);
			Overwrite(vreg, use, constraint) => if (vreg != null) liveness.clear(currentRow, vreg.varNum);
			_ => ;
		}

		// 3. Add interferences for kills.
		for (o in operands) match (o) {
			Kill(constraint) => {
				liveness.apply(currentRow, addInterferencesRegSet, regSet.regSets[constraint]);
			}
			_ => ;
		}

		// 4. Mark all uses live.
		for (o in operands) match (o) {
			Overwrite(vreg, use, constraint) => if (use != null) setLiveAndAddInterference(currentRow, use);
			Use(vreg, constraint) => if (vreg != null) setLiveAndAddInterference(currentRow, vreg);
			_ => ;
		}

		// 5. Process constraint interferences for uses.
		for (i < operands.length) match (operands[i]) {
			Overwrite(vreg, use, constraint) => {
				if (COALESCE) tryCoalescing(vreg, 0, use, constraint);
				addInterferencesFromConstraints(currentRow, use, constraint);
			}
			Use(vreg, constraint) => {
				addInterferencesFromConstraints(currentRow, vreg, constraint);
			}
			_ => ;
		}

		// 6. If coalescing is turned on, remember possible coalescing opportunities.
		if (COALESCE && opcode == ArchInstrs.ARCH_PARMOVE) {
			var half = operands.length >> 1;
			for (i < half) {
				match (operands[i]) {
					Def(vreg, constraint) => {
						var u = Operand.Use.!(operands[i + half]);
						tryCoalescing(vreg, constraint, u.vreg, u.constraint);
					}
					_ => ;
				}
			}
		}
	}
	def computeLiveoutFromSuccessors(currentRow: int, block: SsaBlock) {
		var s = block.succs();
		if (s.length == 0) return liveness.clearRow(currentRow);
		// Start with live in of successor blocks.
		liveness.copy(currentRow, s[0].dest.info.srpo_num);
		for (i = 1; i < s.length; i++) {
			liveness.or(currentRow, s[i].dest.info.srpo_num);
		}
	}
	def setLiveAndAddInterference(currentRow: int, vreg: VReg) {
		if (!liveness.set(currentRow, vreg.varNum)) {
			var node = graph.nodes[vreg.varNum];
			node.use = true;
			node.spillCost += curWeight;
			liveness.apply(currentRow, graph.addInterference, vreg.varNum);
		}
	}
	def tryCoalescing(dst: VReg, dconstraint: int, src: VReg, sconstraint: int) {
		// XXX: also consider !live[src] && !live[dst]
		if (dconstraint == 0 && sconstraint == 0 && dst != src && graph.addMove(dst.varNum, src.varNum)) {
			movesWorklist.put((dst.varNum, src.varNum, curWeight));
		}
	}
	def addInterferenceEdgesByIndex(index: int, currentRow: int) {
		var vreg = vars[index];
		var node = graph.nodes[index];
		addInterferenceEdges(currentRow, vreg, node);
	}
	def addInterferenceEdges(currentRow: int, vreg: VReg, node: Node) {
		var vec = node.interfere;
		var old = vec.extract();
		var i = 0, j = 0;
		while (i < old.length && old[i] < 0) {
			vec.put(old[i]);
			i++;
		}
		while (i < old.length && j < vars.length) {
			if (old[i] == j) {
				vec.put(old[i]);
				i++;
			} else if (liveness[currentRow, j] && j != vreg.varNum) {
				vec.put(j);
				graph.nodes[j].addInterfere(vreg.varNum);
			}
			j++;
		}
		for (j = j; j < vars.length; j++) {
			if (liveness[currentRow, j] && j != vreg.varNum) {
				vec.put(j);
				graph.nodes[j].addInterfere(vreg.varNum);
			}
		}
	}
	// Process constraint in two cases:
	// 1. If constraint is a single register, add a move for this constraint.
	// 2. If constraint is a set of registers, add interference with registers not in the set.
	def addInterferencesFromConstraints(currentRow: int, vreg: VReg, constraint: int) {
		if (constraint <= 0 || regSet.isStack(constraint)) return;
		if (regSet.isReg(constraint)) {
			// All live variables interfere with this register now.
			liveness.apply(currentRow, addInterferencesReg, (vreg, constraint));
			if (vreg != null && graph.addMove(vreg.varNum, -constraint)) movesWorklist.put((-constraint, vreg.varNum, curWeight));
		} else {
			var constraintSet = regSet.regSets[constraint], j = 0;
			constraintSet = Arrays.sort(constraintSet, 0, constraintSet.length, byte.<); // XXX: ensure constraint sets are sorted statically
			var set = regSet.regClasses[vreg.regClass.tag];
			var rset = regSet.regSets[set];
			for (i < rset.length - COLOR_RESERVE) {
				var reg = rset[i];
				if (j < constraintSet.length && reg == constraintSet[j]) j++;
				else graph.nodes[vreg.varNum].addInterfere(-reg);
			}
		}
	}
	def addInterferencesReg(index: int, t: (VReg, int)) {
		var vreg = t.0, constraint = t.1;
		if (vreg == null || vreg.varNum != index) graph.nodes[index].addInterfere(-constraint);
	}
	def addInterferencesRegSet(index: int, rset: Array<byte>) {
		for (reg in rset) addInterferencesReg(index, (null, reg)); // XXX: more efficient bulk-add of interferences.
	}
	// =====================
	// Color the graph by removing the nodes from graph and add them back in a LIFO order,
	// selecting nodes with degree smaller than k or mark as spill if no available node.
	// Set actualSpill to true if any node requires an actual spill.
	// =====================
	def colorGraph() {
		// Initialize the worklists.
		simplifyWorklist.resize(0);
		freezeWorklist.resize(0);
		spillWorklist.resize(0);
		selectStack.resize(0);

		for (i = vars.length - 1; i >= 0; i--) {
			if (vars[i] == null) continue;
			var node = graph.nodes[i];
			node.interfereCnt = node.interfere.length;
			if (node.interfereCnt >= availableColor) {
				spillWorklist.put(i);
			} else if (node.movesCnt > 0) {
				if (!COALESCE) codegen.context.fail("coalesce should be turned off");
				freezeWorklist.put(i);
			} else {
				simplifyWorklist.put(i);
			}
		}
		if (COALESCE) {
			Ranges.quicksort(movesWorklist.array[0 ... movesWorklist.length], movesWorklistCmp);
			statistic.move = movesWorklist.length;
		}
		// Simplify, coalesce, and freeze.
		while (simplifyWorklist.length > 0 || freezeWorklist.length > 0 || spillWorklist.length > 0) {
			if (verbose) Terminal.put3(" simplify: %d, freeze: %d, spill: %d\n", simplifyWorklist.length, freezeWorklist.length, spillWorklist.length);
			if (simplifyWorklist.length > 0) {
				simplify();
			} else if (!coalesce()) {
				if (freezeWorklist.length > 0) freeze();
				else selectSpill();
			}
		}
		// Assign coloring by popping from the select stack.
		coloring = Array<byte>.new(vars.length);
		actualSpill = false;
		var allocatedColor: Array<bool> = Array.new(regSet.physRegs);
		while (selectStack.length > 0) {
			var nid = selectStack[--selectStack.length];
			if (verbose) Terminal.put1("select v%d\n", nid);
			var node = graph.nodes[nid];
			node.removed = false;
			for (i < regSet.physRegs) allocatedColor[i] = false;
			for (i < node.interfere.length) {
				var neighbor = node.interfere[i];
				// Mark neighbors' color as allocated
				if (neighbor < 0) {
					allocatedColor[-neighbor] = true;
				} else {
					if (!graph.nodes[neighbor].removed) {
						allocatedColor[coloring[neighbor]] = true;
					}
				}
			}
			var vreg = vars[nid];
			if (vreg.hint != 0 && !allocatedColor[vreg.hint]) { // try hint first
				coloring[nid] = vreg.hint;
				continue;
			}
			// Find a free one and pick a register from the appropriate register class.
			var set = regSet.regClasses[vreg.regClass.tag];
			for (i < regSet.regSets[set].length - COLOR_RESERVE) {
				var reg = regSet.regSets[set][i];
				if (!allocatedColor[reg]) {
					coloring[nid] = reg;
					break;
				}
			}
			if (coloring[nid] > 0) continue;
			if (!node.spill) return codegen.context.fail1("no colors available for v%d", nid);
			if (!actualSpill) {
				// A new spill round will be required.
				spillRound++;
				actualSpill = true;
			}
			vreg.spillRound = spillRound; // mark for spilling this round
			codegen.allocSpill(vreg);
			if (verbose) Terminal.put2(" spill v%d = %d\n", vreg.varNum, vreg.spill);
		}
		// Finalize colorings for nodes.
		for (i = vars.length - 1; i >= 0; i--) {
			if (vars[i] == null || coloring[i] > 0) continue;
			var a = getAlias(i);
			coloring[i] = if(a > 0, coloring[a], byte.!(-a));
		}
	}
	// Sort movesWorklist against the weight in descending order
	def movesWorklistCmp(x: (int, int, int), y: (int, int, int)) -> bool {
		return x.2 > y.2;
	}
	def removeFromWorklist(worklist: Vector<int>, nid: int) -> bool {
		for (i < worklist.length) {
			if (worklist[i] == nid) {
				var a = worklist[--worklist.length];
				if (worklist.length > 0) worklist[i] = a;
				return true;
			}
		}
		return false;
	}
	def getAlias(nid: int) -> int {
		var alias: int;
		while (nid > 0 && (alias = graph.nodes[nid].alias) != nid) {
			nid = alias;
		}
		return nid;
	}
	// Simplify the last node in the worklist.
	def simplify() {
		var nid = simplifyWorklist[--simplifyWorklist.length];
		if (verbose) Terminal.put1("  simplify v%d\n", nid);
		var node = graph.nodes[nid];
		node.removed = true;
		selectStack.put(nid);
		var interfere = node.interfere;
		for (i < interfere.length) {
			decrementDegree(interfere[i]);
		}
	}
	// Decrements the degree of node {n} and moves the node to the right worklist.
	def decrementDegree(nid: int) {
		if (nid < 0) return;
		var node = graph.nodes[nid];
		// When a degree transit from availableColor, move the node to simplifyWorklist.
		if (!node.removed && node.interfereCnt == availableColor) {
			removeFromWorklist(spillWorklist, nid);
			if (node.movesCnt > 0) freezeWorklist.put(nid);
			else simplifyWorklist.put(nid);
		}
		node.interfereCnt--;
	}
	// Coalesces all possible moves in the movelist.
	def coalesce() -> bool {
		if (verbose) Terminal.put(" coalesce\n");
		var any = false; // if any nodes were coalesced
		var tmpMovesWorklist = Vector<(int, int, int)>.new();
		while (movesWorklist.length > 0) {
			var m = movesWorklist[--movesWorklist.length];
			var u = getAlias(m.0), v = getAlias(m.1);
			var x = if(v < 0, v, u), y = if(v < 0, u, v);
			if (y < 0) {
				// both vars are precolored
			} else if (x == y) {
				any = true;
				graph.nodes[x].movesCnt--;
				addWorklist(x);
			} else if (!graph.interfere(x, y) && tryCoalesce(x, y)) {
				any = true;
			} else { // cannot coalesce
				tmpMovesWorklist.put(m);
			}
		}
		movesWorklist = tmpMovesWorklist;
		if (verbose) Terminal.put1(" coalesced: %z\n", any);
		return any;
	}
	def addWorklist(nid: int) {
		if (nid <= 0) return;
		var node = graph.nodes[nid];
		if (node.movesCnt == 0 && node.interfereCnt < availableColor) {
			removeFromWorklist(freezeWorklist, nid);
			simplifyWorklist.put(nid);
		}
	}
	// Try to coalesce, and if success, merge node y into node x.
	def tryCoalesce(x_: int, y_: int) -> bool {
		var coalesce = false;
		var y = graph.nodes[y_];
		if (x_ < 0) {
			if (precoloredCoalesceCheck(-x_, y)) {
				coalesce = true;
			}
		} else {
			var x = graph.nodes[x_];
			var combine = graph.combineInterfere(x_, y_);
			var cnt = 0, tmpInterfereCnt = 0;
			for (i < combine.length) {
				if (combine[i] < 0) { cnt++; tmpInterfereCnt++; continue; }
				if (graph.nodes[combine[i]].interfereCnt >= availableColor) cnt++;
				if (!graph.nodes[combine[i]].removed) tmpInterfereCnt++;
			}
			if (cnt < availableColor) {
				// Briggs conservative coalescing heuristic.
				coalesce = true;
				x.movesCnt--;
				graph.mergeMoves(x_, y_);
				if (tmpInterfereCnt >= availableColor && x.interfereCnt < availableColor) {
					removeFromWorklist(freezeWorklist, x_);
					spillWorklist.put(x_);
				} else if (tmpInterfereCnt < availableColor && x.movesCnt == 0) {
					removeFromWorklist(freezeWorklist, x_);
					simplifyWorklist.put(x_);
				}
				x.interfere = combine;
				x.interfereCnt = tmpInterfereCnt;
			}
		}
		if (coalesce) {
			// Remove y and updates its neighbors.
			statistic.coalesce++;
			y.removed = true;
			if (y.interfereCnt < availableColor) removeFromWorklist(freezeWorklist, y_);
			else removeFromWorklist(spillWorklist, y_);
			for (i < y.interfere.length) {
				if (y.interfere[i] < 0) continue;
				if (graph.nodes[y.interfere[i]].addInterfere(x_)) graph.nodes[y.interfere[i]].interfereCnt--;
				else decrementDegree(y.interfere[i]);
			}
			y.alias = x_;
		}
		return coalesce;
	}
	// Heuristic used for coalescing a precolored register:
	// For any t in y's neighbor, t is precolored || degree[t] < K || (t, r) interfere
	def precoloredCoalesceCheck(precolored: int, y: Node) -> bool{
		for (i < y.interfere.length) {
			if (y.interfere[i] < 0) continue;
			var t = y.interfere[i], tnode = graph.nodes[t];
			if (tnode.removed || tnode.interfereCnt < availableColor || graph.interfere(t, precolored)) continue;
			return false;
		}
		return true;
	}
	// Freeze the last node in the worklist.
	def freeze() {
		var node = freezeWorklist[--freezeWorklist.length];
		simplifyWorklist.put(node);
		freezeMoves(node);
	}
	def freezeMoves(n: int) {
		var moves = graph.nodes[n].moves;
		for (i < moves.length) {
			var v = getAlias(moves[i]);
			if (v > 0 && v != n) {
				graph.nodes[v].movesCnt--;
				if (!graph.nodes[v].removed && graph.nodes[v].movesCnt == 0
					&& graph.nodes[v].interfereCnt < availableColor) {
					simplifyWorklist.put(v);
					removeFromWorklist(freezeWorklist, v);
				}
			}
			// Remove from movesWorklist
			for (j < movesWorklist.length) {
				var x = getAlias(movesWorklist[j].0), y = getAlias(movesWorklist[j].1);
				if ((x == n && y == v) || (x == v && y == n)) {
					var a = movesWorklist[--movesWorklist.length];
					if (movesWorklist.length > 0) movesWorklist[j] = a;
					break;
				}
			}
		}
	}
	// Select a node in spillWorklist with minimum cost and push it to simplifyWorklist.
	def selectSpill() {
		var mincost: float = 1000000000000f, idx: int = -1;
		for (i < spillWorklist.length) {
			var nid = spillWorklist[i];
			var node = graph.nodes[nid];
			if (verbose) Terminal.put3(" considerSpill v%d (spillRound=%d, interfereCnt=%d)\n", nid, vars[nid].spillRound, node.interfereCnt);
			if (!node.removed && vars[nid].spillRound == 0) {
				// TODO: used fixed point calculation instead of float.
				var cost: float = float.roundi(node.spillCost) / float.roundi(node.interfereCnt);
				if (verbose) {
					var buf = "                                ";
					var len = Floats.renderFloat(cost, buf, 0);
					Terminal.put1("  cost = %s\n", Arrays.range(buf, 0, len));
				}
				if (cost < mincost) {
					idx = i;
					mincost = cost;
				}
			}
		}
		if (idx == -1) {
			spillWorklist.resize(0);
			return codegen.context.fail("nothing available to spill");
		}
		var nid = spillWorklist[idx];
		if (verbose) Terminal.put1("  spill v%d\n", nid);
		graph.nodes[nid].spill = true;
		simplifyWorklist.put(nid);
		var a = spillWorklist[--spillWorklist.length];
		if (spillWorklist.length > 0) spillWorklist[idx] = a;
		freezeMoves(nid);
	}
	// Finalize assignment of registers in uses and defs after coloring.
	def finalizeAssignments(block: SsaBlock, cur: ArchInstr) {
		codegen.context.block = block;
		var prev = cur.prev;
		var next = cur.next;
		if (verbose) Terminal.put(buf.putInstrV(cur).toString());
		regState.pos++;
		var opcode = cur.opcode();
		var operands = cur.operands;

		if (opcode == ArchInstrs.ARCH_BLOCK_END) {
			regState.release();
			computeLiveoutFromSuccessors(finalizeRow, block);
			liveness.apply(finalizeRow, updateRegStateIndex, ());
			return;
		}
		movesNext.clear();
		movesPrev.clear();

		if (opcode == ArchInstrs.ARCH_PARMOVE) { // perform parallel move
			emitParMoves(cur, next);
			for (i < operands.length) match (operands[i]) {
				Def(vreg, constraint) => {
					if (vreg != null) regState.freeReg(coloring[vreg.varNum], true);
				}
				Use(vreg, assignment) => {
					if (vreg != null && !regSet.isStack(assignment)) updateRegState(vreg);
				}
				_ => ;
			}
			cur.remove();
			if (verbose) regState.dumpState("");
			return;
		}

		for (i < operands.length) match (operands[i]) {
			DefSlot(regClass, constraint) => {
				operands[i] = Operand.Def(null, constraint);
			}
			Def(vreg, constraint) => {
				// Ignore Def introduced by previous spill or preprocess
				if (vreg == null || (regSet.isCallerStack(constraint) && !graph.nodes[vreg.varNum].use)) continue;
				var loc = allocDefReg(vreg, constraint);
				operands[i] = Operand.Def(vreg, loc);
			}
			Overwrite(vreg, use, constraint) => {
				var loc = allocDefReg(vreg, constraint), newReg = byte.!(loc);
				var gReg = coloring[use.varNum];
				if (newReg != gReg) {
					if (regSet.isReg(gReg)) movesPrev.addRegMove(use, gReg, newReg);
					else movesPrev.reloads.put(use, newReg);
				}
				regUsage[loc] = regState.pos;
				operands[i] = Operand.Overwrite(vreg, use, loc);
			}
			Use(vreg, constraint) => {
				if (vreg == null || regSet.isStack(constraint)) continue;
				var loc = allocUseReg(vreg, constraint);
				operands[i] = Operand.Use(vreg, loc);
			}
			Kill(constraint) => {
				if (constraint < regSet.regSets.length) {
					for (reg in regSet.regSets[constraint]) {
						regState.freeReg(reg, true);
					}
				}
			}
			_ => ;
		}
		// Second pass to update regstate for uses
		for (i < operands.length) match (operands[i]) {
			Overwrite(vreg, use, assignment)    => {
				updateRegState(use);
			}
			Use(vreg, assignment) => {
				if (vreg == null || regSet.isStack(assignment)) continue;
				updateRegState(vreg);
			}
			_ => ;
		}
		if (verbose) regState.dumpState("");
		movesNext.emit(codegen, next);
		movesPrev.emit(codegen, cur);
	}
	def updateRegStateIndex(index: int, v_: void) {
		updateRegState(vars[index]);
	}
	def updateRegState(vreg: VReg) {
		var reg = coloring[vreg.varNum];
		if (!regSet.isReg(reg)) return;
		regState.reassignReg(vreg, reg);
		vreg.reg = reg;
	}
	def allocDefReg(vreg: VReg, constraint: int) -> int {
		var gReg = coloring[vreg.varNum], loc: int = gReg;
		var prevVreg = regState.getVreg(gReg);
		regState.freeReg(loc, true);
		if (!isOk(loc, constraint)) {
			loc = findBestLocUnderConstraint(vreg.regClass, loc, constraint);
			if (regSet.isReg(gReg) && prevVreg == vreg) movesNext.addRegMove(vreg, loc, gReg);
		}
		return loc;
	}
	def allocUseReg(vreg: VReg, constraint: int) -> int {
		var gReg = coloring[vreg.varNum], loc: int = gReg;
		loc = findBestLocUnderConstraint(vreg.regClass, loc, constraint);
		var newReg = byte.!(loc);
		if (newReg != gReg) {
			if (regSet.isReg(gReg)) movesPrev.addRegMove(vreg, gReg, newReg);
			else movesPrev.reloads.put(vreg, newReg);
		}
		regUsage[loc] = regState.pos;
		return loc;
	}
	def isOk(loc: int, constraint: int) -> bool {
		if (loc == 0) return false;
		if (constraint >= regSet.regSets.length) return false;
		if (constraint == 0) return true;
		return regSet.isInRegSet(loc, constraint);
	}
	def findBestLocUnderConstraint(regClass: RegClass, prefer: int, constraint: int) -> int { // XXX: could move to RegState
		if (constraint >= regSet.regSets.length) return constraint;
		if (constraint == 0) constraint = regSet.regClasses[regClass.tag];
		if (prefer != 0 && regSet.isInRegSet(prefer, constraint) &&
			!isUsedInThisInstr(byte.!(prefer))) { // try prefer register first
			return prefer; // prefer register is unused
		}
		// Find a register from the constraint set; a free one, or the one used farthest in future
		var minpos = int.max, newReg: byte = 0;
		for (reg in regSet.regSets[constraint]) {
			var i = regState.regState[reg];
			if (i < 0 && !isUsedInThisInstr(reg)) return reg; // found a free register in the set
			if (i >= 0) {
				var a = regState.allocated[i];
				if (a.1 < minpos && !isUsedInThisInstr(reg)) {
					minpos = a.1;
					newReg = reg;
				}
			}
		}
		if (newReg == 0) codegen.context.fail("no registers available");
		return newReg;
	}
	def isUsedInThisInstr(reg: byte) -> bool {
		return regUsage[reg] == regState.pos;
	}
	// Gather move destination list and source registers, and recursively emit moves
	// to solve potential cycle.
	def emitParMoves(cur: ArchInstr, next: ArchInstr) {
		var mr = MoveResolver.new(codegen.context.prog.ERROR);
		var operands = cur.operands;
		var half = operands.length >> 1;
		for (i < half) {
			var d = operands[i], dreg: VReg, u = Operand.Use.!(operands[i + half]);
			var dst: int, regClass: RegClass;
			match (operands[i]) {
				DefSlot(r, constraint) => {
					dst = constraint;
					regClass = r;
				}
				Def(vreg, constraint) => {
					if (vreg != null) {
						dreg = vreg;
						dst = coloring[vreg.varNum];
						regClass = vreg.regClass;
					} else {
						dst = constraint;
						regClass = u.vreg.regClass;
					}
				}
				_ => ;
			}

			var src = if(u.constraint == 0, coloring[u.vreg.varNum], u.constraint);
			if (verbose) {
				Terminal.put2("addMove v%d:%s ", if(dreg != null, dreg.varNum), regSet.identify(dst));
				Terminal.put3("<- v%d:%s regClass=%s\n", if(u.vreg != null, u.vreg.varNum), regSet.identify(src), regClass.name);
			}
			mr.addMove(src, dst, regClass);
		}
		cur.remove();
		mr.genMoves(allocMoveTmp, addMove(_, _, _, next));
	}
	def addMove(src: int, dst: int, regClass: RegClass, next: ArchInstr) {
		if (verbose) Terminal.put3("  insertMove %s <- %s regClass=%s\n", regSet.identify(dst), regSet.identify(src), regClass.name);
		if (src < 0) {
			var vreg = codegen.getConst(src), ssa = SsaConst.!(vreg.ssa);
			codegen.insertMoveConstLoc(ssa, Operand.Def(null, dst), regClass, next);
		} else {
			codegen.insertMoveLocLoc(Operand.Use(null, src), Operand.Def(null, dst), regClass, next);
		}
	}
	def allocMoveTmp(regClass: RegClass) -> int { // XXX: move to codegen
		return regSet.scratch[regClass.tag];
	}
	def printGraph() {
		Terminal.put("Interference graph:");
		Terminal.ln();
		for (nid < graph.nodes.length) {
			Terminal.put1("v%d ", nid);
			var node = graph.nodes[nid];
			Terminal.put1("(interfere: %d) ", node.interfereCnt);
			if (!node.use) Terminal.put("(unused) ");
			var vreg = vars[nid];
			if (vreg != null) {
				if (vreg.spillRound > 0) Terminal.put1("(spillRound: %d) ", vreg.spillRound);
				if (vreg.hint != 0) Terminal.put1("(hint %s) ", regSet.identify(vreg.hint));
			}
			var a = getAlias(nid);
			if (a >= 0 && nid != a) Terminal.put1("(alias v%d) ", a);
			var e = node.interfere;
			for (j < e.length) {
				var other = e[j];
				if (other < 0) Terminal.put1("%s ", regSet.identify(-other));
				else Terminal.put1("v%d ", e[j]);
			}
			Terminal.ln();
		}
	}
	def printLiveness() {
		Terminal.put("Live-in sets:\n");
		def blocks = codegen.blocks.order;
		for (i < blocks.length) {
			var b = blocks[i], row = b.info.srpo_num;
			buf.puts("  block ").putSsaBlock(b).puts(":");
			for (j < vars.length) {
				if (liveness[row, j]) buf.put1(" v%d", j);
			}
			buf.outln();
		}
	}
	def printColor() {
		buf.reset();
		buf.puts("After coloring:\n");
		for (i < coloring.length) {
			buf.putc('v').putd(i).puts(" -> ");
			buf.puts(regSet.identify(coloring[i])).ln();
		}
		buf.outt();
	}
}

class InterferenceGraph(varsCnt: int, regSet: MachRegSet) {
	def nodes = Array<Node>.new(varsCnt);

	new() {
		for (i < nodes.length) nodes[i] = Node.new(i);
	}

	def addInterference(x_: int, y_: int) {
		if (x_ == y_) return;
		nodes[x_].addInterfere(y_);
		nodes[y_].addInterfere(x_);
	}
	def addMove(x_: int, y: int) -> bool {
		if (!COALESCE) return false;
		var x = nodes[x_];
		for (i < x.moves.length) {
			if (x.moves[i] == y) return false;
		}
		x.moves.put(y);
		x.movesCnt++;
		if (y > 0) {
			nodes[y].moves.put(x_);
			nodes[y].movesCnt++;
		}
		return true;
	}
	def mergeMoves(dst: int, src: int) {
		if (dst < 0) return;
		nodes[dst].moves.putv(nodes[src].moves);
		nodes[dst].movesCnt += nodes[src].movesCnt;
	}
	def interfere(x: int, y: int) -> bool {
		if (x < 0 && y < 0) return true;
		var u = x, v = y;
		if (x < 0) { u = y; v = x; }
		var interfere = nodes[u].interfere;
		var low = 0, high = interfere.length - 1; // XXX: use Ranges.binarySearch
		while (low <= high) {
			var mid = low + (high - low) / 2;
			if (interfere[mid] == v) return true;
			if (interfere[mid] < v) low = mid + 1;
			else high = mid - 1;
		}
		return false;
	}
	def combineInterfere(x_: int, y_: int) -> Vector<int> {
		var x = nodes[x_], y = nodes[y_];
		var combine = Vector<int>.new();
		var i = 0, j = 0;
		while (i < x.interfere.length && j < y.interfere.length) {
			if (x.interfere[i] == y.interfere[j]) {
				combine.put(x.interfere[i]);
				i++; j++;
			} else if (x.interfere[i] < y.interfere[j]) {
				combine.put(x.interfere[i]);
				i++;
			} else {
				combine.put(y.interfere[j]);
				j++;
			}
		}
		while (i < x.interfere.length) {
			combine.put(x.interfere[i]);
			i++;
		}
		while (j < y.interfere.length) {
			combine.put(y.interfere[j]);
			j++;
		}
		return combine;
	}
	def print() {
		for (i < nodes.length) {
			Terminal.put1("v%d:", i);
			for (j < nodes[i].interfere.length) {
				if (nodes[i].interfere[j] < 0) Terminal.put1(" %s", regSet.identify(-nodes[i].interfere[j]));
				else Terminal.put1(" v%d", nodes[i].interfere[j]);
			}
			Terminal.put("\n");
		}
	}
}

class Node(var alias: int) {
	var defBlock: SsaBlock;
	var interfere = Vector<int>.new(); // sorted
	var interfereCnt: int = 0;
	var moves = Vector<int>.new();
	var movesCnt: int = 0;
	var spillCost = 0;
	var removed: bool = false;
	var spill: bool = false;
	var use: bool = false;

	def addInterfere(n: int) -> bool {
		var stop = interfere.length;
		for (i < interfere.length) { // XXX: binary search
			if (interfere[i] == n) {
				return false;
			} else if (interfere[i] > n) {
				stop = i;
				break;
			}
		}
		interfere.put(0);
		for (i = interfere.length - 1; i > stop; i--) {
			interfere[i] = interfere[i-1];
		}
		interfere[stop] = n;
		interfereCnt = interfere.length;
		return true;
	}
}

class RegAllocStatistic {
	var varslen: int;
	var iterate: int;
	var store: int;
	var reload: int;
	var coalesce: int;
	var move: int;

	def reset(len: int) {
		varslen = len;
		iterate = 0;
		store = 0;
		reload = 0;
	}
	def print() {
		Terminal.put1("Statistic: iterate=%d\n", iterate);
		Terminal.put3("           varslen=%d, store=%d, reload=%d\n", varslen, store, reload);
		if (COALESCE) Terminal.put2("           coalesce=%d/%d\n", coalesce, move);
	}
}
