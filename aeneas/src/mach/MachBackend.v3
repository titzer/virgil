// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A machine-independent representation of an instruction.
class MachInstr(name: string) {
	var live: bool;		// used for marking dead code
	var useStart: int;	// index into code describing use/def info
	var useEnd: int;	// end index into code describing use/def info
	var moves: MachMoves;	// moves to be inserted before instruction

	def render(buf: StringBuilder) -> StringBuilder;
	def emit();
}
// Moves inserted before/after an instruction, either due to SSA deconstruction,
// spilling, register moves, calling conventions, etc
class MachMoves {
	var before: MoveResolver;	// phys -> phys moves, before
	var varMoves: List<(int, int)>; // usepos -> defpos moves, before
	var valMoves: List<(Val, int)>; // value -> usepos moves, before
	var after: MoveResolver;	// phys -> phys moves, after
}
// Machine-independent representation of virtual register classes
enum RegClass {
	REF,
	I32,
	I64,
	F32,
	F64
}
enum Usage { NONE, ONCE, MULTIPLE }
// Machine-independent representation of a virtual register.
class VReg {
	// -- state for code gen --------------------------------
	def ssa: SsaInstr;		// corresponding ssa instruction (if any)
	def varNum: int;		// virtual register number
	def varSize: int;		// number of virtual registers this var represents
	var start: int = -1;		// start position of code that defines this var
	var end: int = -1;		// end position of code that defines this var
	var live: bool;			// true if live
	// -- state for register allocation ---------------------
	var hint: byte;			// physical register hint
	var regClass: RegClass;		// required register type
	var reg: byte;			// assigned physical register
	var block: SsaBlock;
	var prev: VReg;			// prev link for list management
	var next: VReg;			// next link for list management
	var spill: int;			// assigned spill slot (< 0 indicates a constant)
	var endPos: int;		// last live position
	var notSpillable: bool;		// true if this var cannot be spill anymore
	var reloadFrom: VReg;			// var that this var is spilled from
	// -- state for stackifier -----------------------------
	var usage = Usage.NONE;
	var parmoveState: int;
	var stackIndex = -2;

	new(ssa, varNum, varSize, isConst: bool) {
		if (isConst) spill = -2 - varNum; // constants have invalid spill slots
	}
	def loc() -> int {
		return if(reg != 0, reg, spill);
	}
	def isConst() -> bool {
		return spill < 0;
	}
}
// Representation of a machine frame, including spill slots and space for outgoing params
class MachFrame(conv: MachCallConv, align: Alignment, refSize: int) {
	var spillVars: int;		// spilled variables
	var spillArgs: int;		// space for outgoing spilled arguments
	var frameSize: int = -1;	// architecture-specific total frame size
	var tmpSpill: int = -1;		// temporary spill slot
	def IS_64: int = 0x40000000;	// flags a 64-bit spill slot (TODO: only for MoveResolver)

	def allocSpill(regClass: RegClass) -> int {
		var count: int, is64: int;
		match (regClass) {
			I32, F32 => count = 1;
			I64, F64 => { count = align.alignUp(8) >> align.shift; is64 = IS_64; }
			REF => { count = align.alignUp(refSize) >> align.shift; is64 = if(refSize > 4, IS_64); }
		}
		var spill = conv.regSet.spillStart + spillVars;
		spillVars += count;
		return spill | is64;
	}
	def getTmpSpill(regClass: RegClass) -> int {
		var is64 = if(regClass == RegClass.I64 || regClass == RegClass.F64, IS_64);
		if (tmpSpill < 0) {
			tmpSpill = conv.regSet.spillStart + spillVars;
			spillVars += 2; // always use two slots
		}
		return tmpSpill | is64;
	}
	def allocCallerSpace(conv: MachCallConv) -> MachCallConv {
		allocOverflow(conv.overflow);
		return conv;
	}
	def allocOverflow(overflow: int) {
		if (overflow > spillArgs) spillArgs = overflow;
	}
	def slots() -> int {
		return spillVars + spillArgs;
	}
	def size() -> int {
		return if(frameSize >= 0, frameSize, V3.fail("frame size not set"));
	}
	def is64(loc: int) -> bool {
		return (loc & IS_64) != 0;
	}
	def un64(loc: int) -> int {
		return loc & ~IS_64;
	}
	def toSlot(loc: int) -> int {
		loc &= ~IS_64;						// mask out is64
		if (loc >= conv.regSet.callerStart) return -1;		// on caller stack
		// TODO: relies on stack growing downward and spillArgs being first.
		if (loc < conv.regSet.spillStart) return -1;
		return loc - conv.regSet.spillStart + spillArgs;
	}
}
// Defines physical locations (registers, register sets, and stack locations).
// 1. 0 means an unassigned location.
// 2. Physical registers have low numbers in the range [1 ... physregs].
// 3. Sets of registers have numbers in the range (physregs ... spillStart).
// 4. Spill locations have numbers [spillStart ... callerStart).
// 5. Caller locations have numbers [callerStart ... calleeStart).
// 6. Callee locations have numbers [calleeStart ... MAX_INT).
class MachRegSet {
	def physRegs: int;			// number of physical registers
	def regSets: Array<Array<byte>>;	// registers in each set
	def names: Array<string>;		// names of each register and set
	def regClasses: Array<byte>;		// registers in each class
	def scratch: Array<byte>;		// scratch registers by register class
	def spillStart: int = regSets.length;
	def callerStart: int;
	def calleeStart: int;
	def matrix = BitMatrix.new(physRegs + 1, regSets.length);
	def IS_64: int = 0x40000000;
	new(physRegs, regSets, names, regClasses, scratch, callerStart, calleeStart) {
		// compute the matrix of physical register / register set membership
		for (i < regSets.length) {
			var rs = regSets[i];
			if (rs == null) continue;
			for (r in rs) matrix[r, i] = true;
		}
	}
	def isInRegSet(loc: int, snum: int) -> bool {
		if (loc < 1 || loc >= regSets.length) return false;
		return matrix[loc, snum];
	}
	def isReg(loc: int) -> bool {
		return loc > 0 && loc <= physRegs;
	}
	def isRegSet(loc: int) -> bool {
		return loc > 0 && loc <= regSets.length;
	}
	def isStack(loc: int) -> bool {
		return loc >= spillStart;
	}
	def isCallerStack(loc: int) -> bool {
		loc &= ~(IS_64);
		return loc >= callerStart && loc < calleeStart;
	}
	def isMultiple(loc: int) -> bool {
		if (loc == 0) return true;
		if (loc <= physRegs) return false;
		return loc < spillStart;
	}
	def identify(loc: int) -> string {
		loc &= ~(IS_64);
		if (loc < 0) return Strings.format1("invalid#%d", loc);
		if (loc == 0) return "unassigned";
		if (loc < spillStart) {
			var name = names[loc];
			if (name != null) return name;
			if (loc <= physRegs) return Strings.format1("r#%d", loc);
			else return Strings.format1("set#%d", loc);
		}
		if (loc < callerStart) return Strings.format1("spill#%d", loc - spillStart);
		if (loc < calleeStart) return Strings.format1("caller#%d", loc - callerStart);
		return Strings.format1("callee#%d", loc - calleeStart);
	}
}
// Machine-independent representation of the calling convention for a specific call.
class MachCallConv {
	def regSet: MachRegSet;		// associated register set
	def paramTypes: Array<Type>;	// parameter types
	def paramLocs: Array<int>;	// locations of parameters
	def returnTypes: Array<Type>;	// return types
	def retLocs: Array<int>;	// locations of return value(s)
	def overflow: int;		// number of overflow stack arguments
	new(regSet, paramTypes, paramLocs, returnTypes, retLocs, overflow) { }
	def callerParam(i: int) -> int {
		return adjust(paramLocs[i], regSet.callerStart);
	}
	def callerRet(i: int) -> int {
		return adjust(retLocs[i], regSet.callerStart);
	}
	def calleeParam(i: int) -> int {
		return adjust(paramLocs[i], regSet.calleeStart);
	}
	def calleeRet(i: int) -> int {
		return adjust(retLocs[i], regSet.calleeStart);
	}
	private def adjust(loc: int, adjust: int) -> int {
		if (loc <= regSet.physRegs) return loc;
		return loc - regSet.spillStart + adjust;
	}
}

type Operand {
	case Scratch(regClass: RegClass);
	case Immediate(val: Val);
	case Use(vreg: VReg, constraint: int);
	case Def(vreg: VReg, constraint: int);
	case Kill(constraint: int);
	case RefMap(livepoint: int, outgoing: MachCallConv);
	case Overwrite(dst: VReg, src: VReg, constraint: int);
	case Label(block: SsaBlock, label: Label);
	case ExSource(ex: string, source: Source);
	case NewVar(vname: string, vtype: Type);

	def isImm() -> bool { return tag == 1; }
}

class ArchInstr(op: int, operands: Array<Operand>) {
	var prev: ArchInstr;
	var next: ArchInstr;
	def opcode() -> i28 { return i28.view(op); }
	def remove() {
		if (prev != null) prev.next = next;
		if (next != null) next.prev = prev;
		prev = next = null;
	}
}

// Constants for Arch instructions.
component ArchInstrs {
	// flags for all arch instructions reordering and register allocation
	def FLAG_NO_GAP = 0x80000000;	// cannot insert instructions before this instruction
	def FLAG_REMAT	= 0x40000000;	// instruction can be copied for rematerialization
	def FLAG_LOAD	= 0x20000000;	// instruction reads mutable state
	def FLAG_STORE	= 0x10000000;	// instruction writes mutable state

	def NUM_FLAGS: u5 = 4;

	// block and SSA resolution instructions
	def ARCH_UPDATEVAR = -17;
	def ARCH_DELETEVAR = -16;
	def ARCH_NEWVAR = -15;
	def ARCH_SOURCELINE = -14;
	def ARCH_GETSHADOWSTACKPTR = -13;
	def ARCH_ALLOCSHADOWSTACK = -12;
	def ARCH_SETSHADOWSTACKPTR = -11;
	def ARCH_SAVE = -10;
	def ARCH_RESTORE = -9;
	def ARCH_RELOAD = -8;
	def ARCH_BLOCK_END = -7;
	def ARCH_NOP	 = -6;
	def ARCH_BLOCK	 = -5;
	def ARCH_ENTRY	 = -4;
	def ARCH_PARMOVE = -3;
	def ARCH_END	 = -2;
	def ARCH_RET	 = -1;

	def NO_OPERANDS: Array<Operand> = [];
}

def CACHED_INT_IMMEDIATES = [
	Operand.Immediate(Box<int>.new(-1)),
	Operand.Immediate(Box<int>.new(0)),
	Operand.Immediate(Box<int>.new(1)),
	Operand.Immediate(Box<int>.new(2)),
	Operand.Immediate(Box<int>.new(3)),
	Operand.Immediate(Box<int>.new(4)),
	Operand.Immediate(Box<int>.new(5)),
	Operand.Immediate(Box<int>.new(6)),
	Operand.Immediate(Box<int>.new(7)),
	Operand.Immediate(Box<int>.new(8))
];

// Basic algorithm for code generation.
class SsaMachGen(context: SsaContext, mach: MachProgram, regSet: MachRegSet, w: MachDataWriter) {
	def operands = Vector<Operand>.new();
	def vars = Vector<VReg>.new();
	var lowestMark: int;
	var blocks: SsaBlockOrder;
	var order: Vector<SsaBlockInfo>;
	def instrs = Vector<ArchInstr>.new();
	var liveness: BitMatrix;
	var numLivepoints = 0;
	def livepoints = Vector<(SsaBlock, ArchInstr, Operand.RefMap)>.new();
	var first: ArchInstr;
	var last: ArchInstr;
	var cursor: ArchInstr;
	var blockEnd: ArchInstr;
	var frame: MachFrame;
	var curBlock: SsaBlock;
	var computingLiveness: bool;
	var firstSourceLine: bool; // used by SsaX86_64Gen in assemble
	var out: ArchInstrBuffer;
	var rtsrc = if(mach.runtime != null, mach.runtime.src);

	def reset(graph: SsaGraph, blocks: SsaBlockOrder, frame: MachFrame) {
		this.operands.length = 0;
		this.vars.length = 0;
		this.context.graph = graph;
		this.context.block = null;
		this.lowestMark = graph.markGen++;
		this.blocks = blocks;
		this.order = if(blocks != null, blocks.order);
		this.instrs.resize(if(order != null, order.length, 0));
		this.liveness = BitMatrix.new(if(order != null, order.length, 1), 32); // XXX: reuse?
		this.numLivepoints = 0;
		this.livepoints.length = 0;
		this.first = null;
		this.cursor = null;
		this.frame = frame;
		this.curBlock = null;
		this.computingLiveness = true;
		this.firstSourceLine = true;
	}
	def generate(m: IrMethod, frame: MachFrame) {
		context.enterMethod(m);
		var blocks = SsaBlockOrder.new(m.ssa);
		reset(m.ssa, blocks, frame);
		if (CLOptions.PRINT_CFG.get()) {
			var buf = TerminalBuffer.new();
			context.method.renderLong(buf);
			buf.puts(": ").putd(blocks.order.length);
			buf.outln();
			blocks.print();
		}
		selectInstructionsForGraph();
		print();
	}
	def print() {
		if (!context.shouldPrintMach()) return;
		// print header
		var out = getOutput();
		out.puts("Arch instructions for: ");
		var render: StringBuilder -> StringBuilder;
		if (context.spec != null) context.spec.render(out);
		else if (context.method != null) context.method.renderLong(out);
		if (CLOptions.PRINT_PATCH.val) out.put1(" @ 0x%x", w.posAddr());
		out.outln();
		// print instructions
		var indent = 1;
		for (i = first; i != null; i = i.next) {
			indent = out.putInstr(indent, i);
		}
		out.outln();
	}
	def selectInstructionsForGraph() {
		cursor = last = ArchInstr.new(ArchInstrs.ARCH_END, []);
		// Process blocks in reverse order.
		for (i = order.length - 1; i >= 0; i--) {
			var info = order[i], block = info.block;
			context.block = block;
			gatherLivenessForBlock(block);
			selectInstructionsForBlock(block);
			if (info.loop != null) finishLoopLiveness(info);
			instrs[i] = cursor;
		}
		// emit the entry instruction.
		visitEntry(context.graph.params);
		first = cursor;
		cursor = null;
	}
	def finishLoopLiveness(info: SsaBlockInfo) {
		// Propagate liveness from the loop header to all live points
		// contained in the loop.
		var end = info.loop.end;
		for (i = livepoints.length - 1; i >= 0; i--) {	// process newest first
			var t = livepoints[i], block = t.0;
			if (block.mark >= end) break;  // rely on backwards codegen order
			liveness.or(order.length + t.2.livepoint, info.block.mark);
		}
		// Propagate the liveness to the blocks in this loop.
		for (i = info.block.mark + 1; i < end; i++) {
			liveness.or(i, info.block.mark);
		}
	}
	def gatherLivenessForBlock(block: SsaBlock) {
		for (e in block.succs()) {
			var succ = e.dest;
			// union the succesor's live-in set into this.
			liveness.or(block.mark, succ.mark);
		}
	}
	def selectInstructionsForBlock(block: SsaBlock) {
		curBlock = block;
		blockEnd = cursor;
		// Pre-process instructions in forward order.
		// Mark instructions in this block.
		for (i = block.next; i != block; i = i.next) {
			if (!SsaInstr.?(i)) break;
			var instr = SsaInstr.!(i);
			var vreg = getVReg(instr);
			vreg.block = block;
		}
		emit1(ArchInstrs.ARCH_BLOCK_END, useLabel(block));
		advanceCursor();
		// Select instructions in reverse order.
		for (i = block.prev; i != block; i = i.prev) {
			// Skip instructions that are not live.
			if (SsaPhi.?(i)) break;
			if (!isLive(i, block) && i.facts.O_PURE) continue;
			selectInstructions(block, i);
			advanceCursor();
		}
		// Cap the top of the block with a special instruction.
		emit1(ArchInstrs.ARCH_BLOCK, useLabel(block));
		advanceCursor();
	}
	def advanceCursor() {
		while (cursor.prev != null) cursor = cursor.prev;
	}
	def selectInstructions(block: SsaBlock, i: SsaLink) {
		// Dispatch to appropriate architecture-specific routine.
		match (i) {
			x: SsaApplyOp => visitApply(block, x);
			x: SsaGoto => {
				// Emit SSA-resolution moves for the successor if necessary.
				emitPhiResolutionMoves(block, x.succs[0]);
				visitGoto(block, x);
			}
			x: SsaIf => visitIf(block, x);
			x: SsaReturn => visitReturn(block, x);
			x: SsaSwitch => visitSwitch(block, x);
			x: SsaThrow => visitThrow(block, x);
			x: SsaCheckpoint => visitCheckpoint(x);
			x: SsaNewVar => visitNewVar(x);
			x: SsaDeleteVar => visitDeleteVar(x);
			x: SsaUpdateVar => visitUpdateVar(x);
			x: SsaProbe => ; // do nothing
			_ => context.fail("invalid instruction type");
		}
	}
	def visitCheckpoint(x: SsaCheckpoint) {
		var label = Label.new();
		emit2(ArchInstrs.ARCH_SOURCELINE, op(Operand.Label(null, label)), op(Operand.ExSource(null, x.source)));
	}
	def visitNewVar(x: SsaNewVar) {
		op(Operand.NewVar(x.name, x.vtype));
		if (x.index != -1) useInt(x.index);
		for (input in x.inputs) use(input.dest);
		emitN(ArchInstrs.ARCH_NEWVAR);
	}
	def visitDeleteVar(x: SsaDeleteVar) {
		emit1(ArchInstrs.ARCH_DELETEVAR, useInt(x.n));
	}
	def visitUpdateVar(x: SsaUpdateVar) {
		useInt(x.index);
		for (input in x.inputs) use(input.dest);
		emitN(ArchInstrs.ARCH_UPDATEVAR);
	}
	def emitPhiResolutionMoves(block: SsaBlock, edge: SsaCfEdge) {
		var index = edge.desti;
		// Add definitions of all phis.
		for (i = edge.dest.next; SsaPhi.?(i); i = i.next) {
			var phi = SsaPhi.!(i);
			dfn(phi);
		}
		// Add uses of all phi inputs.
		for (i = edge.dest.next; SsaPhi.?(i); i = i.next) {
			var phi = SsaPhi.!(i);
			use(phi.inputs[index].dest);
		}
		emitN(ArchInstrs.ARCH_PARMOVE);
	}
	// Check if {i} is live in {block}
	def isLive(i: SsaLink, block: SsaBlock) -> bool {
		if (i.mark >= context.graph.markGen) {
			context.fail1("mark @%d invalid", i.uid);
			return false;
		}
		if (i.mark <= lowestMark) return false;
		return liveness[block.mark, i.mark - lowestMark];
	}

	def getVReg(i: SsaInstr) -> VReg {
		if (i.mark >= context.graph.markGen) {
			context.fail1("mark @%d invalid", i.uid);
			return null;
		}
		if (i.mark <= lowestMark) {
			return newVReg(i);
		}
		return vars[i.mark - lowestMark];
	}
	def newVReg(i: SsaInstr) -> VReg {
		var next = context.graph.markGen++;
		var width = 1, rcl: RegClass;
		if (i != null) {
			width = numVars(i);
			i.mark = next;
			rcl = mach.toRegClass(i.getType());
		}
		var id = next - lowestMark;
		var length = id + width + 1;
		liveness.widen(length);
		vars.grow(length);
		vars.length = length;
		var n = VReg.new(i, id, width, SsaConst.?(i));
		n.regClass = rcl;
		vars[id] = n;
		return n;
	}
	def dupVReg(vreg: VReg) -> VReg {
		var next = context.graph.markGen++;
		var width = vreg.varSize;
		var id = next - lowestMark;
		var length = id + width + 1;
		liveness.widen(length);
		vars.grow(length);
		vars.length = length;
		var n = VReg.new(vreg.ssa, id, width, vreg.isConst());
		n.regClass = vreg.regClass;
		vars[id] = n;
		return n;
	}
	def nextId() -> int {
		return context.graph.markGen - lowestMark;
	}
	def newLivepoint() -> int {
		return numLivepoints++;
	}
	def numVars(i: SsaInstr) -> int {
		return Tuple.length(i.getType());
	}
	def updateLiveness(i: ArchInstr) {
		def DEFS = 0, KILLS = 1, REFMAP = 2, OVW = 3, USES = 4;
		var state = DEFS;
		var row = if(context.block != null, context.block.mark);
		for (o in i.operands) match (o) {
			Def(vreg, constraint) => {
				if (state > DEFS) context.fail("out of order def");
				liveness[row, vreg.varNum] = false;
				state = DEFS;
			}
			Overwrite(dst, use, constraint) => {
				if (state > OVW) context.fail("out of order ovw");
				liveness[row, dst.varNum] = false;
				liveness[row, use.varNum] = true;
				state = OVW;
			}
			Kill(constraint) => {
				if (state > KILLS) context.fail("out of order kill");
				state = KILLS;
			}
			RefMap(livepoint, outgoing) => {
				if (state > REFMAP) context.fail("out of order refmap");
				if (livepoint >= 0) {
					var index = order.length + livepoint;
					liveness.grow(index + 1);
					liveness.or(index, row);
					if (CLOptions.PRINT_STACKMAP.val) {
						var buf = TerminalBuffer.new().put1("livepoint %d = \n", livepoint);
						liveness.renderRow(index, buf);
						buf.outt();
					}
					livepoints.put((context.block, i, Operand.RefMap.!(o)));
				}
				state = REFMAP;
			}
			Use(vreg, constraint) => {
				liveness[row, vreg.varNum] = true;
				state = USES;
			}
			_ => ;
		}
	}
	def isRef(v: VReg) -> bool {
		if (v == null || v.ssa == null) return false;
		if (SsaConst.?(v.ssa)) return false;
		return mach.isRefType(v.ssa.getType());
	}
	def runInsertion<T>(f: T -> void, arg: T, next: ArchInstr) {
		var prevCursor = cursor, prevL = computingLiveness;
		computingLiveness = false;
		cursor = next;
		f(arg);
		computingLiveness = prevL;
		cursor = prevCursor;
	}
	// Reorganizes a parallel move of (dest1, dest2..., src1, src2) operands into
	// a vector of (src, destination list) pairs.
	// XXX: reorganize parallel moves to make this unnecessary?
	def gatherParallelMoveDests(i: ArchInstr, dests: Vector<(VReg, List<Operand.Def>)>) {
		dests.length = 0;
		var operands = i.operands;
                var max = operands.length / 2;
		for (i < max) {
			var d = Operand.Def.!(operands[i]), u = Operand.Use.!(operands[i + max]);
			var v = u.vreg;
			if (v.parmoveState <= 0) {
				var index = dests.length;
				v.parmoveState = 1 + index;
				dests.put(v, List.new(d, null));
			} else {
				var index = v.parmoveState - 1;
				var prev = dests[index].1;
				dests[index] = (v, List.new(d, prev));
			}
		}
	}
	def buildStackMap(codeOffset: int, outgoing: MachCallConv, lp: int) -> int {
		var slots = frame.slots();
		if (slots == 0) return mach.runtime.gc.emptyRefMap(20);
		var builder = mach.runtime.gc.beginRefMap(slots, 20);
		if (outgoing != null && outgoing.overflow > 0) {
			// record any outgoing overflow parameters that are references
			var pt = outgoing.paramTypes;
			for (i < pt.length) {
				var ploc = outgoing.calleeParam(i);
				if (regSet.isStack(ploc) && mach.isRefType(pt[i])) {
					builder.setRefMap(ploc - regSet.calleeStart);
				}
			}
		}
		// lazily compute the reference slot index for each live VReg
		var index = order.length + lp;
		if (CLOptions.PRINT_STACKMAP.val) Terminal.put1("buildRefMap lp=%d\n", lp);
		liveness.row(index).apply(setRefMapSlot, builder);
		return builder.finishRefMap();
	}
	def setRefMapSlot(vnum: int, builder: MachRefMapBuilder) {
		var vreg = vars[vnum];
		if (CLOptions.PRINT_STACKMAP.val) {
			Terminal.put3("  v%d %s spill=%d\n", vnum, vreg.regClass.name, vreg.spill);
		}
		if (vreg.regClass == RegClass.REF) {
			var slot = frame.toSlot(vreg.spill);
			if (slot >= 0) {
				if (CLOptions.PRINT_STACKMAP.val) Terminal.put1(" ref in slot %d\n", slot);
				builder.setRefMap(slot);
			}
		}
	}
	def iterateInstructionsForward(func: (SsaBlock, ArchInstr) -> void) {
		var i = first;
		var block: SsaBlock = order[0].block;
		while (i != null) {
			var next = i.next;
			var opcode = i.opcode();
			if (opcode == ArchInstrs.ARCH_BLOCK) {
				block = Operand.Label.!(i.operands[0]).block;
			}
			func(block, i);  // call user callback
			i = next;
		}
	}
	def iterateInstructionsBackward(func: (SsaBlock, ArchInstr) -> void) {
		var i = last;
		var block: SsaBlock = order[order.length - 1].block;
		while (i != null) {
			var prev = i.prev;
			var opcode = i.opcode();
			if (opcode == ArchInstrs.ARCH_BLOCK_END) {
				block = Operand.Label.!(i.operands[0]).block;
			}
			func(block, i);  // call user callback
			i = prev;
		}
	}
	//======================================================================
	// MachStackifier uses these codegen methods to insert loads, stores,
	// etc. Only relevant targets implement the gen*() methods.
	//======================================================================
	def insertLoadLocal(v: VReg, next: ArchInstr) {
		runInsertion(genLoadLocal, v, next);
	}
	def insertStoreLocal(v: VReg, pop: bool, next: ArchInstr) {
		runInsertion(genStoreLocal, (v, pop), next);
	}
	def insertPop(v: VReg, next: ArchInstr) {
		runInsertion(genPop, v, next);
	}
	def insertLoadConst(t: Type, val: Val, next: ArchInstr) {
		runInsertion(genLoadConst, (t, val), next);
	}
	def genLoadLocal(v: VReg);		// arch-specific
	def genStoreLocal(v: VReg, pop: bool);	// arch-specific
	def genPop(v: VReg);			// arch-specific
	def genLoadConst(t: Type, val: Val);	// arch-specific

	//======================================================================
	// ShadowStackSpiller uses these codegen methods to insert saves,
	// restores, etc. Only relevant targets implement the gen*() methods.
	//======================================================================
	def insertShadowStackAlloc(shadow_sp: VReg, slots: int, next: ArchInstr) {
		runInsertion(genShadowStackAlloc, (shadow_sp, slots), next);
	}
	def insertShadowStackFree(shadow_sp: VReg, slots: int, next: ArchInstr) {
		runInsertion(genShadowStackFree, (shadow_sp, slots), next);
	}
	def insertShadowStackSave(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {
		runInsertion(genShadowStackSave, (shadow_sp, v, slot), next);
	}
	def insertShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {
		runInsertion(genShadowStackRestore, (shadow_sp, v, slot), next);
	}
	def insertRestore(dst: (VReg, int), slot: int, next: ArchInstr) {
		runInsertion(genRestore, (dst, slot), next);
	}
	def newShadowSpTmp() -> VReg;					// arch-specific
	def genShadowStackAlloc(shadow_sp: VReg, slots: int) {
		emit2(ArchInstrs.ARCH_GETSHADOWSTACKPTR, dfnv0(shadow_sp), useAddrConst(CiRuntimeModule.SHADOW_STACK_CUR_PTR));
		emit3(ArchInstrs.ARCH_ALLOCSHADOWSTACK, useAddrConst(CiRuntimeModule.SHADOW_STACK_CUR_PTR), useIntConst(slots * mach.data.addressSize), usev0(shadow_sp));
	}
	def genShadowStackFree(shadow_sp: VReg, slots: int) {
		emit2(ArchInstrs.ARCH_SETSHADOWSTACKPTR, useAddrConst(CiRuntimeModule.SHADOW_STACK_CUR_PTR), usev0(shadow_sp));
	}
	def genShadowStackSave(shadow_sp: VReg, v: VReg, slot: int) {
		emit3(ArchInstrs.ARCH_SAVE, useInt(slot), usev0(shadow_sp), usev0(v));
	}
	def genShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int) {
		emit3(ArchInstrs.ARCH_RESTORE, dfnv0(v), useInt(slot), usev0(shadow_sp));
	}
	def genRestore(dst: (VReg, int), slot: int) {
		emit2(ArchInstrs.ARCH_RESTORE, op(Operand.Def(dst)), op(Operand.Use(null, slot)));
	}

	//======================================================================
	// SimpleRegAlloc uses these codegen methods to insert saves and restore
	// of vregs from registers
	//======================================================================
	def insertSaveLocal(reg: int, v: VReg, next: ArchInstr) {
		runInsertion(genSaveLocal, (reg, v), next);
	}
	def insertRestoreLocal(v: VReg, reg: int, next: ArchInstr) {
		runInsertion(genRestoreLocal, (v, reg), next);
	}
	def insertMoveLocLoc(src: (VReg, int), dst: (VReg, int), regClass: RegClass, next: ArchInstr) {
		runInsertion(genMoveLocLoc, (src, dst, regClass), next);
	}
	def insertMoveValLoc(src: VReg, dst: (VReg, int), regClass: RegClass, next: ArchInstr) {
		runInsertion(genMoveValLoc, (src, dst, regClass), next);
	}

	def genSaveLocal(reg: int, v: VReg);
	def genRestoreLocal(v: VReg, reg: int);
	def genMoveLocLoc(src: (VReg, int), dst: (VReg, int), regClass: RegClass);
	def genMoveValLoc(vreg: VReg, dst: (VReg, int), regClass: RegClass);

	def insertReload(src: VReg, dst: (VReg, int), next: ArchInstr) {
		runInsertion(genReload, (src, dst), next);
	}
	def genReload(src: VReg, dst: (VReg, int)) {
		emit2(ArchInstrs.ARCH_RELOAD, op(Operand.Def(dst)), op(Operand.Use(src, 0)));
	}

	//======================================================================
	// Helper routines for emitting instructions.
	//======================================================================
	def matchAddImm(i: SsaInstr, disp: Val) -> (SsaInstr, Val) {
		// TODO: check covering condition: in same block and single use
		if (!SsaApplyOp.?(i)) return (i, disp);
		var apply = SsaApplyOp.!(i);
		if (Opcode.IntAdd.?(apply.op.opcode) || Opcode.PtrAdd.?(apply.op.opcode)) {
			var x = apply.input0(), y = apply.input1();
			if (SsaConst.?(x)) {
				var disp2 = tryAddConsts(disp, SsaConst.!(x).val);
				if (disp2 != null) return matchAddImm(y, disp2);
			}
			if (SsaConst.?(y)) {
				var disp2 = tryAddConsts(disp, SsaConst.!(y).val);
				if (disp2 != null) return matchAddImm(x, disp2);
			}
		}
		return (i, disp);
	}
	def tryAddConsts(k1: Val, k2: Val) -> Val {
		if (k1 == null) return k2;
		if (k2 == null) return k1;
		match (k1) {
			x: Box<int> => match (k2) {
				y: Box<int> => return Box<int>.new(x.val + y.val);
				y: Addr => return y.add(x.val);
			}
			x: Addr => match (k2) {
				y: Box<int> => return x.add(y.val);
			}
		}
		return null;
	}
	def canCover(i: SsaInstr) -> bool {
		if (!inSameBlock(i)) return false;
		if (i.useList.next != null) return false;
		return true;
	}
	def cover(optag: u8, i: SsaInstr) -> SsaApplyOp {
		if (!SsaApplyOp.?(i)) return null;
		if (!inSameBlock(i)) return null;
		var apply = SsaApplyOp.!(i);
		if (apply.op.opcode.tag != optag) return null;
		return apply;
	}
	def emit0(opcode: int) {
		if (operands.length != 0) return context.fail("expected 0 operands");
		emitN(opcode);
	}
	def emit1(opcode: int, a: void) {
		if (operands.length != 1) return context.fail("expected 1 operand");
		emitN(opcode);
	}
	def emit2(opcode: int, a: void, b: void) {
		if (operands.length != 2) return context.fail("expected 2 operands");
		emitN(opcode);
	}
	def emit3(opcode: int, a: void, b: void, c: void) {
		if (operands.length != 3) return context.fail("expected 3 operands");
		emitN(opcode);
	}
	def emitN(opcode: int) {
		var x = operands.extract();
		var i = ArchInstr.new(opcode, x);
		// insert {i} between {cursor.prev} and {cursor}
		i.next = cursor;
		var prev = cursor.prev;
		if (prev != null) {
			prev.next = i;
			i.prev = prev;
		}
		cursor.prev = i;
		if (computingLiveness) updateLiveness(i);
	}
	def useLabel(block: SsaBlock) {
		operands.put(Operand.Label(block, order[block.mark].label));
	}
	def dfnAll(i: SsaInstr) {
		var rv = getVReg(i);
		match (rv.varSize) {
			0 => ;
			1 => dfn(i);
			_ => {
				var proj = Array<SsaInstr>.new(rv.varSize);
				for (l: Edge<SsaInstr> = i.useList; l != null; l = l.next) {
					var u = l.src;
					if (SsaApplyOp.?(u)) {
						match (SsaApplyOp.!(u).op.opcode) {
							TupleGetElem(index) => proj[index] = u;
							_ => ;
						}
					}
				}
				for (j < rv.varSize) {
					operands.put(Operand.Def(vars[rv.varNum + j], 0));
				}
			}
		}
	}
	def dfn(i: SsaInstr) {
		operands.put(Operand.Def(getVReg(i), 0));
	}
	def dfnv(vreg: VReg, constraint: int) {
		if (vreg != null) vreg.hint = if(regSet != null && constraint < regSet.physRegs, byte.view(constraint));
		operands.put(Operand.Def(vreg, constraint));
	}
	def dfnv0(vreg: VReg) {
		operands.put(Operand.Def(vreg, 0));
	}
	def kill(constraint: int) {
		operands.put(Operand.Kill(constraint));
	}
	def refmap(conv: MachCallConv) {
		operands.put(Operand.RefMap(newLivepoint(), conv));
	}
	def useAll(array: Array<SsaDfEdge>, start: int) {
		for (j = start; j < array.length; j++) use(array[j].dest);
	}
	private def upref(vreg: VReg) -> VReg {
		if (vreg.isConst()) return vreg;
		if (vreg.usage == Usage.NONE) vreg.usage = Usage.ONCE;
		else vreg.usage = Usage.MULTIPLE;
		return vreg;
	}
	def use(i: SsaInstr) {
		operands.put(Operand.Use(upref(getVReg(i)), 0));
	}
	def usev(vreg: VReg, constraint: int) {
		operands.put(Operand.Use(upref(vreg), constraint));
	}
	def usev0(vreg: VReg) {
		operands.put(Operand.Use(upref(vreg), 0));
	}
	def op(op: Operand) {
		operands.put(op);
	}
	def useReg(i: SsaInstr) {
		var vreg = getVReg(i);
		operands.put(Operand.Use(upref(vreg), anyReg(vreg)));
	}
	def useImm(val: Val) {
		operands.put(Operand.Immediate(val));
	}
	def useInt(val: int) {
		var x = val + 1;
		if (u32.view(x) < u32.view(CACHED_INT_IMMEDIATES.length)) {
			operands.put(CACHED_INT_IMMEDIATES[x]);
			return;
		}
		operands.put(Operand.Immediate(Int.box(val)));
	}
	def useIntConst(val: int) {
		use(context.graph.intConst(val));
	}
	def useAddrConst(addr: Addr) {
		use(context.graph.valConst(mach.data.ptrType, addr));
	}
	def useLongConst(val: int) {
		use(context.graph.valConst(Long.TYPE, Long.box(val)));
	}
	def useFixed(i: SsaInstr, constraint: int) {
		operands.put(Operand.Use(upref(getVReg(i)), constraint));
	}
	def dfnFixed(i: SsaInstr, constraint: int) {
		var vreg = getVReg(i);
		vreg.hint = if(regSet != null && constraint < regSet.physRegs, byte.view(constraint));
		operands.put(Operand.Def(vreg, constraint));
	}
	def dfnReg(i: SsaInstr) {
		var vreg = getVReg(i);
		operands.put(Operand.Def(vreg, anyReg(vreg)));
	}
	def ovwReg(d: SsaInstr, u: SsaInstr) {
		var dreg = getVReg(d);
		operands.put(Operand.Overwrite(dreg, upref(getVReg(u)), anyReg(dreg)));
	}
	def ovwRegFixed(d: SsaInstr, u: SsaInstr, constraint: int) {
		var dreg = getVReg(d);
		operands.put(Operand.Overwrite(dreg, upref(getVReg(u)), constraint));
	}
	def ovwv(d: VReg, u: VReg, constraint: int) {
		operands.put(Operand.Overwrite(d, upref(u), constraint));
	}
	def anyReg(vreg: VReg) -> int {
		return regSet.regClasses[vreg.regClass.tag];
	}
	def useScratch(regClass: RegClass) {
		operands.put(Operand.Scratch(regClass));
	}
	def newTmp(t: Type) -> VReg {
		var vreg = newVReg(null);
		vreg.regClass = mach.toRegClass(t);
		return vreg;
	}
	def id(i: SsaInstr, vreg: VReg) -> VReg {
		i.mark = vreg.varNum;
		return vreg;
	}
	def useExSource(ex: string, source: Source) {
		operands.put(Operand.ExSource(ex, source));
	}

	def toLabel(o: Operand) -> Label {
		match (o) {
			Label(block, label) => return label;
			_ => context.fail("expected label");
		}
		return null;
	}
	def toBlock(o: Operand) -> SsaBlock {
		match (o) {
			Label(block, label) => return block;
			_ => context.fail("expected block");
		}
		return null;
	}
	def toInt(o: Operand) -> int {
		return Int.unbox(toImm(o));
	}
	def toImm(o: Operand) -> Val {
		match (o) {
			Immediate(val) => return val;
			_ => context.fail("expected immediate");
		}
		return null;
	}
	def toVar(o: Operand) -> VReg {
		match (o) {
			Use(vreg, constraint) => return vreg;
			Def(vreg, constraint) => return vreg;
			_ => context.fail("expected immediate");
		}
		return null;
	}
	def toExSource(o: Operand) -> (string, Source) {
		match (o) {
			ExSource(ex, source) => return (ex, source);
			_ => context.fail("expected exception + source");
		}
		return (null, null);
	}
	def toNewVar(o: Operand) -> (string, Type) {
		match (o) {
			NewVar(vname, vtype) => return (vname, vtype);
			_ => context.fail("expected vardecl");
		}
		return (null, null);
	}
	def inSameBlock(i: SsaInstr) -> bool {
		if (order.length == 1) return true;
		return getVReg(i).block == curBlock;
	}
	def isSigned(op: Operator) -> bool {
		return IntType.!(op.typeArgs[0]).signed;
	}

	//======================================================================
	// Architecture-specific routines.
	//======================================================================

	// Instruction selection.
	def visitEntry(params: Array<SsaParam>) {
		for (i < params.length) {
			var p = params[i];
			if (!isLive(p, context.block)) continue;
			if (frame == null) dfn(p);
			else {
				var vreg = getVReg(p), loc = frame.conv.callerParam(i);
				dfnFixed(p, loc);
				if (regSet.isStack(loc)) vreg.spill = loc;
			}
		}
		emitN(ArchInstrs.ARCH_ENTRY);
		advanceCursor();
	}
	def visitApply(block: SsaBlock, i: SsaApplyOp);
	def visitThrow(block: SsaBlock, i: SsaThrow);
	def visitIf(block: SsaBlock, i: SsaIf);
	def visitSwitch(block: SsaBlock, i: SsaSwitch);
	def visitGoto(block: SsaBlock, target: SsaGoto);
	def visitReturn(block: SsaBlock, i: SsaReturn) {
		for (j < i.inputs.length) useFixed(i.inputs[j].dest, frame.conv.callerRet(j));
		emitN(ArchInstrs.ARCH_RET);
	}

	def getProjections(i: SsaApplyOp) -> Array<SsaInstr> {
		var t = i.op.sig.returnType();
		match (t.typeCon.kind) {
			VOID => return Ssa.NO_INSTRS;
			TUPLE => ; // fall through to below
			_ => return [i];
		}
		var r = Array<SsaInstr>.new(Lists.length(t.nested));
		for (l: Edge<SsaInstr> = i.useList; l != null; l = l.next) {
			if (!SsaApplyOp.?(l.src)) continue;
			var apply = SsaApplyOp.!(l.src);
			match (apply.op.opcode) {
				TupleGetElem(index) => r[index] = apply;
				_ => ;
			}
		}
		return r;
	}

	def assembleInstrs() {
		var out = if (context.shouldPrintMach(), getOutput()), indent = 1;
		if (out != null) out.puts("After register allocation: ").outln();
		var prevL = computingLiveness;
		computingLiveness = false;
		for (i = first; i != null; i = i.next) {
			if (out != null) {
				indent = out.putInstr(indent, i);
				out.outt();
			}
			cursor = i.next;
			assemble(i.opcode(), i.operands);
		}
		computingLiveness = prevL;
	}

	// Code generation.
	def assemble(opcode: int, x: Array<Operand>);
	// Rendering.
	// Override this method to add architecture-specific rendering of instructions.
	def getOutput() -> ArchInstrBuffer {
		if (out != null) return out;
		return out = ArchInstrBuffer.new(this, context.prog, regSet);
	}
}
// Helper class for rendering architecture-specific machine instructions.
class ArchInstrBuffer(codegen: SsaMachGen, prog: Program, regSet: MachRegSet) extends TerminalBuffer {
	def putBlock(indent: int, i: ArchInstr) -> int {
		while (i != null) {
			indent = putInstr(indent, i);
			i = i.next;
			if (i != null && i.opcode() == ArchInstrs.ARCH_BLOCK) break;
		}
		return indent;
	}
	def putInstrV(i: ArchInstr) -> this {
		putInstr(2, i);
	}
	def putInstr(indent: int, i: ArchInstr) -> int {
		var a = i.operands;
		match (int.!(i.opcode())) {
			ArchInstrs.ARCH_NOP => {
				putIndent(indent + 1);
				puts("nop ");
				putOperands(a);
			}
			ArchInstrs.ARCH_ENTRY => {
				putIndent(indent);
				puts("entry ");
				putOperands(a);
			}
			ArchInstrs.ARCH_BLOCK => {
				putIndent(indent);
				puts("block ");
				putSsaBlock(Operand.Label.!(a[0]).block);
			}
			ArchInstrs.ARCH_BLOCK_END => {
				putIndent(indent);
				puts("end ");
				putSsaBlock(Operand.Label.!(a[0]).block);
			}
			ArchInstrs.ARCH_PARMOVE => {
				putIndent(indent + 1);
				puts("parallel-move");
				var half = a.length / 2;
				for (i < half) {
					var dst = a[i], src = a[i + half];
					ln();
					putIndent(indent+4);
					putOperand(dst);
					puts(" <- ");
					putOperand(src);
				}
			}
			ArchInstrs.ARCH_RET => {
				putIndent(indent + 1);
				puts("ret ");
				putOperands(a);
			}
			ArchInstrs.ARCH_END => {
				putIndent(indent);
				puts("end");
			}
			ArchInstrs.ARCH_RELOAD => {
				putIndent(indent + 1);
				puts("reload ");
				putOperands(a);
			}
			ArchInstrs.ARCH_GETSHADOWSTACKPTR => {
				putNamedInstr(indent + 1, "get_shadowstack_ptr", a);
			}
			ArchInstrs.ARCH_ALLOCSHADOWSTACK => {
				putNamedInstr(indent + 1, "alloc_shadowstack", a);
			}
			ArchInstrs.ARCH_SETSHADOWSTACKPTR => {
				putNamedInstr(indent + 1, "set_shadowstack_ptr", a);
			}
			ArchInstrs.ARCH_SAVE => {
				putNamedInstr(indent + 1, "save", a);
			}
			ArchInstrs.ARCH_RESTORE => {
				putNamedInstr(indent + 1, "restore", a);
			}
			ArchInstrs.ARCH_SOURCELINE => {
				putIndent(indent + 1);
				puts("sourceline ");
				putOperand(a[1]); // ExSource
				for (j = 2; j < a.length; j++) {
					csp();
					putOperand(a[j]);
				}
			}
			ArchInstrs.ARCH_NEWVAR => {
				putIndent(indent + 1);
				puts("newvar ");
				putOperands(a);
			}
			ArchInstrs.ARCH_DELETEVAR => {
				putNamedInstr(indent + 1, "deletevar", a);
			}
			ArchInstrs.ARCH_UPDATEVAR => {
				putNamedInstr(indent + 1, "updateVar", a);
			}
			_ => {
				indent = putArchInstr(indent + 1, i) - 1;
			}
		}
		ln();
		return indent;
	}
	// Override this method to add architecture-specific rendering of instructions.
	def putArchInstr(indent: int, i: ArchInstr) -> int {
		return putSimpleInstr(indent, i);
	}
	def putSimpleInstr(indent: int, i: ArchInstr) -> int {
		putIndent(indent);
		puts("opcode: ").putx(int.view(i.opcode())).sp();
		putOperands(i.operands);
		return indent;
	}
	def putIndent(indent: int) {
		if (indent-- > 0) tab(); // the first two indent levels are tabs
		if (indent-- > 0) tab();
		while (indent-- > 0) sp().sp(); // two spaces for each afterwards
	}
	def putSsaBlock(block: SsaBlock) {
		blockColor().putc('#').putd(block.uid).end();
	}
	def putSsa(i: SsaInstr) -> this {
		instrColor().putc('@').putd(i.uid).end();
		if (SsaConst.?(i)) puthashv(SsaConst.!(i).val, SsaConst.!(i).getType());
	}
	def putArchWithI(name: string, x: Array<Operand>) -> this {
		var y = x[x.length - 1];
		puts(name);
		if (y.isImm()) putc('i');
		sp();
		putOperands(x);
	}
	def putNamedInstr(indent: int, name: string, x: Array<Operand>) -> int {
		putIndent(indent);
		puts(name).sp();
		putOperands(x);
		return indent;
	}
	def putOperands(x: Array<Operand>) -> this {
		for (j < x.length) {
			if (j > 0) csp();
			putOperand(x[j]);
		}
	}
	def putConstraint(constraint: int) -> this {
		if (constraint != 0) putc(':').yellow().puts(regSet.identify(constraint)).end();
	}
	def putVReg(mode: string, vreg: VReg) -> this {
		blue().puts(mode).end();
		if (vreg != null && vreg.ssa != null) putSsa(vreg.ssa);
		if (vreg != null) putc('v').putd(vreg.varNum);
	}
	def putOperand(o: Operand) -> this {
		match (o) {
			Scratch => puts("<scratch>");
			Immediate(val) => {
				blue().puts("imm").puthashv(val, null).end();
			}
			Use(vreg, constraint) => {
				putVReg("use", vreg);
				putConstraint(constraint);
			}
			Def(vreg, constraint) => {
				putVReg("def", vreg);
				putConstraint(constraint);
			}
			Kill(constraint) => {
				blue().puts("kill").end();
				putConstraint(constraint);
			}
			RefMap(livepoint, outgoing) => {
				blue().puts("refmap").end();
				if (livepoint >= 0) putd(livepoint);
			}
			Overwrite(dst, src, constraint) => {
				putVReg("ovr", dst);
				sp();
				putVReg("with", src);
				putConstraint(constraint);
			}
			Label(block, label) => {
				puts("block=");
				putSsaBlock(block);
			}
			ExSource(ex, source) => {
				if (ex != null) {
					puts("ex=");
					red().puts(ex).end();
					sp();
				}
				if (source != null) {
					puts("src=");
					purple();
					source.render(this);
					this.end();
				}
			}
			NewVar(vname, vtype) => {
				put1("\"%s\" ", vname);
				yellow();
				vtype.render(this);
				this.end();
			}
		}
	}
	def putLiveness(liveness: BitMatrix, index: int) {
		put1("{livepoint=%d", index);
		for (j < liveness.numcols) {
			if (liveness[index, j]) {
				put1(" v%d", j);
			}
		}
		puts("}\n");
	}
}
// Generates machine code for all aspects of the program, including the main
// stub, fatal stubs, and SSA methods.
class MachBackend(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter) {
	def alwaysGc: bool = CLOptions.RT_TEST_GC.get();
	var ri_gc: IrMethod;
	var ri_signal: IrMethod;
	def context = SsaContext.new(compiler, prog);
	new() {
		if (CLOptions.RT_GC.get()) {
			mach.allocStub = Addr.new(mach.codeRegion, null, 0);
			ri_gc = mach.runtime.getRiGc();
		}
		if (ri_gc == null && alwaysGc) return prog.ERROR.fail("RiRuntime.gc method needed for gc test mode");
		ri_signal = mach.runtime.getRiSignal();
		if (ri_signal != null) mach.signalStub = Addr.new(mach.codeRegion, null, 0);
	}
	// Generate all code, beginning with the entrypoint
	def genAllCode() {
		w.atEnd();
		w.startPos = w.pos;
		// Generate main entrypoint
		w.bind(mach.entryStub);
		genEntryStub();
		w.bindSize(mach.entryStub);
		// Generate memory allocation stub
		if (!CLOptions.IR_ALLOC.get() && mach.allocStub != null) {
			w.bind(mach.allocStub);
			genAllocStub();
			w.bindSize(mach.allocStub);
		}

		// Generate code for SSA methods
		var methods = prog.ir.methods;
		var code = mach.code;
		var rtsrc = mach.runtime.src;
		for (i < methods.length) {
			var m = methods[i];
			w.atEnd().align(code.addrAlign.size);
			var start = w.pos;
			var methodStart = w.endAddr();
			var addr = mach.addrOfMethod(m);
			addr.absolute = methodStart;
			context.enterMethod(m);
			genCodeFromSsa();
			addr.size = w.atEnd().pos - start;
			if (CLOptions.PRINT_BIN.get()) {
				mach.printBin(m, methodStart, w);
			} else if (CLOptions.PRINT_SIZE.get()) {
				Terminal.put2("%q: %d\n", m.renderLong, w.endAddr() - methodStart);
			}
		}

		// Generate code for stubs
		mach.stubMap.apply(genStub);
		// Generate signal handler stub
		if (mach.signalStub != null) {
			w.bind(mach.signalStub);
			genSignalHandlerStub();
			w.bindSize(mach.signalStub);
		}
	}
	// Generate a stub, such as a fatal stub or other shared routine
	def genStub(name: string, t: (Addr, (Addr, MachDataWriter) -> void)) {
		w.align(mach.code.addrAlign.size); // XXX: skip align for stubs?
		var addr = t.0, func = t.1;
		addr.absolute = w.endAddr();
		if (CLOptions.PRINT_MACH.val != VstMatcher.None) {
			TerminalBuffer.new()
				.put1("genStub[%s] @ ", name)
				.putv(addr, null)
				.put1(" = %x", addr.absolute)
				.outln();
		}
		if (func != null) func(addr, w);
		else genFatalStub(name, addr);
	}
	// Overridden in target-specific code generators
	def genEntryStub();
	def genAllocStub();
	def genCodeFromSsa();
	def genSignalHandlerStub();
	def genFatalStub(ex: string, addr: Addr);
	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int);
	def patchCodeAddrArm64(w: DataWriter, a: Addr, kind: Arm64PatchKind, posAddr: int);
}
