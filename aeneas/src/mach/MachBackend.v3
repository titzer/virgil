// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A machine-independent representation of an instruction.
class MachInstr(name: string) {
	var live: bool;		// used for marking dead code
	var useStart: int;	// index into code describing use/def info
	var useEnd: int;	// end index into code describing use/def info
	var moves: MachMoves;	// moves to be inserted before instruction

	def render(buf: StringBuilder) -> StringBuilder;
	def emit();
}
// Moves inserted before/after an instruction, either due to SSA deconstruction,
// spilling, register moves, calling conventions, etc
class MachMoves {
	var before: MoveResolver;	// phys -> phys moves, before
	var varMoves: List<(int, int)>; // usepos -> defpos moves, before
	var valMoves: List<(Val, int)>; // value -> usepos moves, before
	var after: MoveResolver;	// phys -> phys moves, after
}
// Machine-independent representation of virtual register classes
enum RegClass {
	REF,
	I32,
	I64,
	F32,
	F64
}
// Conversion functions from V3 Types to RegClasses
component Regs {
	def toRegClass(t: Type) -> RegClass {
		match (t.typeCon.kind) {
			V3Kind.INT => return toRegIntClass(IntType.!(t));
			V3Kind.FLOAT => {
				var ftc = Float_TypeCon.!(t.typeCon);
				return if(ftc.is64, RegClass.F64, RegClass.F32);
			}
			V3Kind.ENUM => return toRegIntClass(V3.getVariantTagType(t));
			V3Kind.ENUM_SET => return toRegIntClass(V3.getEnumSetType(t));
			_ => return RegClass.REF;
		}
	}

	def toRegIntClass(t: IntType) -> RegClass {
		return if(t.width <= 32, RegClass.I32, RegClass.I64);
	}
}
enum Usage { NONE, ONCE, MULTIPLE }
// Machine-independent representation of a virtual register.
class VReg {
	// -- state for code gen --------------------------------
	def ssa: SsaInstr;		// corresponding ssa instruction (if any)
	def varNum: int;		// virtual register number
	def varSize: int;		// number of virtual registers this var represents
	var start: int = -1;		// start position of code that defines this var
	var end: int = -1;		// end position of code that defines this var
	var live: bool;			// true if live
	// -- state for register allocation ---------------------
	var hint: byte;			// physical register hint
	var regClass: RegClass;		// required register type
	var reg: byte;			// assigned physical register
	var block: SsaBlock;
	var prev: VReg;			// prev link for list management
	var next: VReg;			// next link for list management
	var spill: int;			// assigned spill slot (< 0 indicates a constant)
	var endPos: int;		// last live position
	// -- state for stackifier -----------------------------
	var usage = Usage.NONE;
	var consumedFromStack: bool;
	var parmoveState: int;
	var stackIndex = -2;

	new(ssa, varNum, varSize, isConst: bool) {
		if (isConst) spill = -2 - varNum; // constants have invalid spill slots
	}
	def loc() -> int {
		return if(reg != 0, reg, spill);
	}
	def isConst() -> bool {
		return spill < 0;
	}
}
// Representation of a machine frame, including spill slots and space for outgoing params
class MachFrame(conv: MachCallConv) {
	var spillVars: int;		// spilled variables
	var spillArgs: int;		// space for outgoing spilled arguments
	var frameSize: int = -1;	// architecture-specific total frame size
	def IS_64: int = 0x40000000;	// if the spilled value is 64 bits

	def allocSpill(regClass: RegClass) -> int {
		match (regClass) {
			I64, F64 => {
				var spill = conv.regSet.spillStart + spillVars;
				spillVars += 2; // XXX: wasteful on 64-bit
				return spill | IS_64;
			}
			_ => return conv.regSet.spillStart + spillVars++;
		}
	}
	def allocCallerSpace(conv: MachCallConv) -> MachCallConv {
		allocOverflow(conv.overflow);
		return conv;
	}
	def allocOverflow(overflow: int) {
		if (overflow > spillArgs) spillArgs = overflow;
	}
	def slots() -> int {
		return spillVars + spillArgs;
	}
	def size() -> int {
		return if(frameSize >= 0, frameSize, V3.fail("frame size not set"));
	}
	def is64(loc: int) -> bool {
		return (loc & IS_64) != 0;
	}
}
// Defines physical locations (registers, register sets, and stack locations).
// 1. 0 means an unassigned location.
// 2. Physical registers have low numbers in the range [1 ... physregs].
// 3. Sets of registers have numbers in the range (physregs ... spillStart).
// 4. Spill locations have numbers [spillStart ... callerStart).
// 5. Caller locations have numbers [callerStart ... calleeStart).
// 6. Callee locations have numbers [calleeStart ... MAX_INT).
class MachRegSet {
	def physRegs: int;			// number of physical registers
	def regSets: Array<Array<byte>>;	// registers in each set
	def names: Array<string>;		// names of each register and set
	def regClasses: Array<byte>;	// registers in each class
	def scratch: int;
	def fpScratch: int;
	def spillStart: int = regSets.length;
	def callerStart: int;
	def calleeStart: int;
	def matrix = BitMatrix.new(physRegs + 1, regSets.length);
	def IS_64: int = 0x40000000;
	new(physRegs, regSets, names, regClasses, scratch, fpScratch, callerStart, calleeStart) {
		// compute the matrix of physical register / register set membership
		for (i < regSets.length) {
			var rs = regSets[i];
			if (rs == null) continue;
			for (r in rs) matrix[r, i] = true;
		}
	}
	def isInRegSet(loc: int, snum: int) -> bool {
		if (loc < 1 || loc >= regSets.length) return false;
		return matrix[loc, snum];
	}
	def isReg(loc: int) -> bool {
		return loc > 0 && loc <= physRegs;
	}
	def isRegSet(loc: int) -> bool {
		return loc > 0 && loc <= regSets.length;
	}
	def isStack(loc: int) -> bool {
		return loc >= spillStart;
	}
	def isCallerStack(loc: int) -> bool {
		loc &= ~(IS_64);
		return loc >= callerStart && loc < calleeStart;
	}
	def isMultiple(loc: int) -> bool {
		if (loc == 0) return true;
		if (loc <= physRegs) return false;
		return loc < spillStart;
	}
	def identify(loc: int) -> string {
		loc &= ~(IS_64);
		if (loc < 0) return Strings.format1("invalid#%d", loc);
		if (loc == 0) return "unassigned";
		if (loc < spillStart) {
			var name = names[loc];
			if (name != null) return name;
			if (loc <= physRegs) return Strings.format1("r#%d", loc);
			else return Strings.format1("set#%d", loc);
		}
		if (loc < callerStart) return Strings.format1("spill#%d", loc - spillStart);
		if (loc < calleeStart) return Strings.format1("caller#%d", loc - callerStart);
		return Strings.format1("callee#%d", loc - calleeStart);
	}
}
// Machine-independent representation of the calling convention for a specific call.
class MachCallConv {
	def regSet: MachRegSet;		// associated register set
	def paramTypes: Array<Type>;	// parameter types
	def paramLocs: Array<int>;	// locations of parameters
	def returnTypes: Array<Type>;	// return types
	def retLocs: Array<int>;	// locations of return value(s)
	def overflow: int;		// number of overflow stack arguments
	new(regSet, paramTypes, paramLocs, returnTypes, retLocs, overflow) { }
	def callerParam(i: int) -> int {
		return adjust(paramLocs[i], regSet.callerStart);
	}
	def callerRet(i: int) -> int {
		return adjust(retLocs[i], regSet.callerStart);
	}
	def calleeParam(i: int) -> int {
		return adjust(paramLocs[i], regSet.calleeStart);
	}
	def calleeRet(i: int) -> int {
		return adjust(retLocs[i], regSet.calleeStart);
	}
	private def adjust(loc: int, adjust: int) -> int {
		if (loc <= regSet.physRegs) return loc;
		return loc - regSet.spillStart + adjust;
	}
}

type Operand {
	case Scratch;
	case Immediate(val: Val);
	case Use(ssa: SsaInstr, vreg: VReg, constraint: int);
	case Def(ssa: SsaInstr, vreg: VReg, constraint: int);
	case Kill(livepoint: int, constraint: int);
	case Overwrite(ssa: SsaInstr, dst: VReg, src: VReg, constraint: int);
	case Label(block: SsaBlock, label: Label);
	case ExSource(ex: string, source: Source);

	def isImm() -> bool { return tag == 1; }
}

class ArchInstr(op: int, operands: Array<Operand>) {
	var prev: ArchInstr;
	var next: ArchInstr;
	def opcode() -> i28 { return i28.view(op); }
	def remove() {
		if (prev != null) prev.next = next;
		if (next != null) next.prev = prev;
		prev = next = null;
	}
}

// Constants for Arch instructions.
component ArchInstrs {
	// flags for all arch instructions reordering and register allocation
	def FLAG_NO_GAP = 0x80000000;	// cannot insert instructions before this instruction
	def FLAG_REMAT	= 0x40000000;	// instruction can be copied for rematerialization
	def FLAG_LOAD	= 0x20000000;	// instruction reads mutable state
	def FLAG_STORE	= 0x10000000;	// instruction writes mutable state

	def NUM_FLAGS: u5 = 4;

	// block and SSA resolution instructions
	def ARCH_NOP	 = -6;
	def ARCH_BLOCK	 = -5;
	def ARCH_ENTRY	 = -4;
	def ARCH_PARMOVE = -3;
	def ARCH_END	 = -2;
	def ARCH_RET	 = -1;

	def NO_OPERANDS: Array<Operand> = [];
}

def CACHED_INT_IMMEDIATES = [
	Operand.Immediate(Box<int>.new(-1)),
	Operand.Immediate(Box<int>.new(0)),
	Operand.Immediate(Box<int>.new(1)),
	Operand.Immediate(Box<int>.new(2)),
	Operand.Immediate(Box<int>.new(3)),
	Operand.Immediate(Box<int>.new(4)),
	Operand.Immediate(Box<int>.new(5)),
	Operand.Immediate(Box<int>.new(6)),
	Operand.Immediate(Box<int>.new(7)),
	Operand.Immediate(Box<int>.new(8))
];

// Basic algorithm for code generation.
class SsaMachGen(context: SsaContext, mach: MachProgram, regSet: MachRegSet, w: MachDataWriter) {
	def operands = Vector<Operand>.new();
	def vars = Vector<VReg>.new();
	var lowestMark: int;
	var blocks: SsaBlockOrder;
	var order: Vector<SsaBlockInfo>;
	var liveness: BitMatrix;
	var numLivepoints = 0;
	def livepoints = Vector<(SsaBlock, ArchInstr, Operand.Kill)>.new();
	var anyReg: int;
	var first: ArchInstr;
	var cursor: ArchInstr;
	var blockEnd: ArchInstr;
	var frame: MachFrame;
	var curBlock: SsaBlock;
	var computingLiveness: bool;
	var out: ArchInstrBuffer;

	def reset(graph: SsaGraph, blocks: SsaBlockOrder, frame: MachFrame) {
		this.operands.length = 0;
		this.vars.length = 0;
		this.context.graph = graph;
		this.context.block = null;
		this.lowestMark = graph.markGen++;
		this.blocks = blocks;
		this.order = if(blocks != null, blocks.order);
		this.liveness = BitMatrix.new(if(order != null, order.length, 1), 32); // XXX: reuse?
		this.numLivepoints = 0;
		this.livepoints.length = 0;
		this.first = null;
		this.cursor = null;
		this.frame = frame;
		this.curBlock = null;
		this.computingLiveness = true;
	}
	def generate(m: IrMethod, frame: MachFrame) {
		context.enterMethod(m);
		var blocks = SsaBlockOrder.new(m.ssa);
		reset(m.ssa, blocks, frame);
		selectInstructionsForGraph();
		print();
	}
	def print() {
		if (!context.shouldPrintMach()) return;
		// print header
		var out = getOutput();
		out.puts("Arch instructions for: ");
		var render: StringBuilder -> StringBuilder;
		if (context.spec != null) context.spec.render(out);
		else if (context.method != null) context.method.renderLong(out);
		out.outln();
		// print instructions
		var indent = 1;
		for (i = first; i != null; i = i.next) {
			indent = out.putInstr(indent, i);
		}
		out.outln();
	}
	def selectInstructionsForGraph() {
		cursor = ArchInstr.new(ArchInstrs.ARCH_END, []);
		// Process blocks in reverse order.
		for (i = order.length - 1; i >= 0; i--) {
			var info = order[i], block = info.block;
			context.block = block;
			gatherLivenessForBlock(block);
			selectInstructionsForBlock(block);
			if (info.loop != null) finishLoopLiveness(info);
		}
		// emit the entry instruction.
		visitEntry(context.graph.params);
		first = cursor;
		cursor = null;
	}
	def finishLoopLiveness(info: SsaBlockInfo) {
		// Propagate liveness from the loop header to all live points
		// contained in the loop.
		var end = info.loop.end;
		for (i = livepoints.length - 1; i >= 0; i--) {	// process newest first
			var t = livepoints[i], block = t.0;
			if (block.mark > end) break;  // rely on backwards codegen order
			liveness.or(order.length + t.2.livepoint, block.mark);
		}
	}
	def gatherLivenessForBlock(block: SsaBlock) {
		for (e in block.succs()) {
			var succ = e.dest;
			// union the succesor's live-in set into this.
			liveness.or(block.mark, succ.mark);
		}
	}
	def selectInstructionsForBlock(block: SsaBlock) {
		curBlock = block;
		blockEnd = cursor;
		// Pre-process instructions in forward order.
		// Mark instructions in this block.
		for (i = block.next; i != block; i = i.next) {
			if (!SsaInstr.?(i)) break;
			var instr = SsaInstr.!(i);
			var vreg = getVReg(instr);
			vreg.block = block;
		}
		// Select instructions in reverse order.
		for (i = block.prev; i != block; i = i.prev) {
			// Skip instructions that are not live.
			if (SsaPhi.?(i)) break;
			if (!isLive(i, block) && i.facts.O_PURE) continue;
			selectInstructions(block, i);
			advanceCursor();
		}
		// Cap the top of the block with a special instruction.
		emit1(ArchInstrs.ARCH_BLOCK, useLabel(block));
		advanceCursor();
	}
	def advanceCursor() {
		while (cursor.prev != null) cursor = cursor.prev;
	}
	def selectInstructions(block: SsaBlock, i: SsaLink) {
		// Dispatch to appropriate architecture-specific routine.
		match (i) {
			x: SsaApplyOp => visitApply(block, x);
			x: SsaGoto => {
				// Emit SSA-resolution moves for the successor if necessary.
				emitPhiResolutionMoves(block, x.succs[0]);
				visitGoto(block, x);
			}
			x: SsaIf => visitIf(block, x);
			x: SsaReturn => visitReturn(block, x);
			x: SsaSwitch => visitSwitch(block, x);
			x: SsaThrow => visitThrow(block, x);
			_ => context.fail("invalid instruction type");
		}
	}
	def emitPhiResolutionMoves(block: SsaBlock, edge: SsaCfEdge) {
		var index = edge.desti;
		// Add definitions of all phis.
		for (i = edge.dest.next; SsaPhi.?(i); i = i.next) {
			var phi = SsaPhi.!(i);
			dfn(phi);
		}
		// Add uses of all phi inputs.
		for (i = edge.dest.next; SsaPhi.?(i); i = i.next) {
			var phi = SsaPhi.!(i);
			use(phi.inputs[index].dest);
		}
		emitN(ArchInstrs.ARCH_PARMOVE);
	}
	// Mark {i} as live in {block}
	def setLive(i: SsaInstr, block: SsaBlock) {
		liveness[block.mark, getVReg(i).varNum] = true;
	}
	// Check if {i} is live in {block}
	def isLive(i: SsaLink, block: SsaBlock) -> bool {
		if (i.mark >= context.graph.markGen) {
			context.fail1("mark @%d invalid", i.uid);
			return false;
		}
		if (i.mark <= lowestMark) return false;
		return liveness[block.mark, i.mark - lowestMark];
	}

	def getVReg(i: SsaInstr) -> VReg {
		// TODO: handle multiple return values
		if (i.mark >= context.graph.markGen) {
			context.fail1("mark @%d invalid", i.uid);
			return null;
		}
		if (i.mark <= lowestMark) {
			return newVReg(i);
		}
		return vars[i.mark - lowestMark];
	}
	def newVReg(i: SsaInstr) -> VReg {
		var next = context.graph.markGen++;
		var width = 1;
		if (i != null) {
			width = numVars(i);
			i.mark = next;
		}
		var id = next - lowestMark;
		var length = id + width + 1;
		liveness.widen(length);
		vars.grow(length);
		vars.length = length;
		var n = VReg.new(i, id, width, SsaConst.?(i));
		vars[id] = n;
		return n;
	}
	def newLivepoint() -> int {
		return numLivepoints++;
	}
	def numVars(i: SsaInstr) -> int {
		return Tuple.length(i.getType());
	}
	def updateLiveness(i: ArchInstr) {
		def DEFS = 0, KILLS = 1, OVW = 2, USES = 3;
		var state = DEFS;
		var row = if(context.block != null, context.block.mark);
		for (o in i.operands) match (o) {
			Def(i, vreg, constraint) => {
				if (state > DEFS) context.fail("out of order def");
				liveness[row, vreg.varNum] = false;
				state = DEFS;
			}
			Overwrite(i, dst, use, constraint) => {
				if (state > OVW) context.fail("out of order ovw");
				liveness[row, dst.varNum] = false;
				liveness[row, use.varNum] = true;
				state = OVW;
			}
			Kill(livepoint, constraint) => {
				if (state > KILLS) context.fail("out of order kill");
				if (livepoint >= 0) {
					var index = order.length + livepoint;
					liveness.grow(index + 1);
					liveness.or(index, row);
					livepoints.put((context.block, i, Operand.Kill.!(o)));
				}
				state = KILLS;
			}
			Use(i, vreg, constraint) => {
				liveness[row, vreg.varNum] = true;
				state = USES;
			}
			_ => ;
		}
	}
	def isRef(v: VReg) -> bool {
		if (v == null || v.ssa == null) return false;
		if (SsaConst.?(v.ssa)) return false;
		return mach.isRefType(v.ssa.getType());
	}
	def runInsertion<T>(f: T -> void, arg: T, next: ArchInstr) {
		var prevCursor = cursor, prevL = computingLiveness;
		computingLiveness = false;
		cursor = next;
		f(arg);
		computingLiveness = prevL;
		cursor = prevCursor;
	}
	//======================================================================
	// MachStackifier uses these codegen methods to insert loads, stores,
	// etc. Only relevant targets implement the gen*() methods.
	//======================================================================
	def insertLoadLocal(v: VReg, next: ArchInstr) {
		runInsertion(genLoadLocal, v, next);
	}
	def insertStoreLocal(v: VReg, pop: bool, next: ArchInstr) {
		runInsertion(genStoreLocal, (v, pop), next);
	}
	def insertPop(v: VReg, next: ArchInstr) {
		runInsertion(genPop, v, next);
	}
	def insertLoadConst(t: Type, val: Val, next: ArchInstr) {
		runInsertion(genLoadConst, (t, val), next);
	}
	def genLoadLocal(v: VReg);		// arch-specific
	def genStoreLocal(v: VReg, pop: bool);	// arch-specific
	def genPop(v: VReg);			// arch-specific
	def genLoadConst(t: Type, val: Val);	// arch-specific

	//======================================================================
	// ShadowStackSpiller uses these codegen methods to insert saves,
	// restores, etc. Only relevant targets implement the gen*() methods.
	//======================================================================
	def insertShadowStackAlloc(shadow_sp: VReg, slots: int, next: ArchInstr) {
		runInsertion(genShadowStackAlloc, (shadow_sp, slots), next);
	}
	def insertShadowStackFree(shadow_sp: VReg, slots: int, next: ArchInstr) {
		runInsertion(genShadowStackFree, (shadow_sp, slots), next);
	}
	def insertShadowStackSave(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {
		runInsertion(genShadowStackSave, (shadow_sp, v, slot), next);
	}
	def insertShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int, next: ArchInstr) {
		runInsertion(genShadowStackRestore, (shadow_sp, v, slot), next);
	}
	def newShadowSpTmp() -> VReg;					// arch-specific
	def genShadowStackAlloc(shadow_sp: VReg, slots: int);		// arch-specific
	def genShadowStackFree(shadow_sp: VReg, slots: int);		// arch-specific
	def genShadowStackSave(shadow_sp: VReg, v: VReg, slot: int);	// arch-specific
	def genShadowStackRestore(shadow_sp: VReg, v: VReg, slot: int);	// arch-specific

	//======================================================================
	// SimpleRegAlloc uses these codegen methods to insert saves and restore
	// of vregs from registers
	//======================================================================
	def insertSaveLocal(reg: int, v: VReg, next: ArchInstr) {
		runInsertion(genSaveLocal, (reg, v), next);
	}
	def insertRestoreLocal(v: VReg, reg: int, next: ArchInstr) {
		runInsertion(genRestoreLocal, (v, reg), next);
	}
	def genSaveLocal(reg: int, v: VReg);
	def genRestoreLocal(v: VReg, reg: int);

	//======================================================================
	// Helper routines for emitting instructions.
	//======================================================================
	def matchAddImm(i: SsaInstr) -> (SsaInstr, Val) {
		// TODO: check covering condition: in same block and single use
		if (!SsaApplyOp.?(i)) return (i, null);
		var apply = SsaApplyOp.!(i);
		if (Opcode.IntAdd.?(apply.op.opcode) || Opcode.PtrAdd.?(apply.op.opcode)) {
			var x = apply.input0(), y = apply.input1();
			if (SsaConst.?(y)) return (x, SsaConst.!(y).val);
			if (SsaConst.?(x)) return (y, SsaConst.!(x).val);
		}
		return (i, null);
	}
	def canCover(i: SsaInstr) -> bool {
		if (!inSameBlock(i)) return false;
		if (i.useList.next != null) return false;
		return true;
	}
	def cover(optag: u8, i: SsaInstr) -> SsaApplyOp {
		if (!SsaApplyOp.?(i)) return null;
		if (!inSameBlock(i)) return null;
		var apply = SsaApplyOp.!(i);
		if (apply.op.opcode.tag != optag) return null;
		return apply;
	}
	def emit0(opcode: int) {
		if (operands.length != 0) return context.fail("expected 0 operands");
		emitN(opcode);
	}
	def emit1(opcode: int, a: void) {
		if (operands.length != 1) return context.fail("expected 1 operand");
		emitN(opcode);
	}
	def emit2(opcode: int, a: void, b: void) {
		if (operands.length != 2) return context.fail("expected 2 operands");
		emitN(opcode);
	}
	def emit3(opcode: int, a: void, b: void, c: void) {
		if (operands.length != 3) return context.fail("expected 3 operands");
		emitN(opcode);
	}
	def emitN(opcode: int) {
		var x = operands.extract();
		var i = ArchInstr.new(opcode, x);
		// insert {i} between {cursor.prev} and {cursor}
		i.next = cursor;
		var prev = cursor.prev;
		if (prev != null) {
			prev.next = i;
			i.prev = prev;
		}
		cursor.prev = i;
		if (computingLiveness) updateLiveness(i);
	}
	def useLabel(block: SsaBlock) {
		operands.put(Operand.Label(block, order[block.mark].label));
	}
	def dfnAll(i: SsaInstr) {
		var rv = getVReg(i);
		match (rv.varSize) {
			0 => ;
			1 => dfn(i);
			_ => {
				var proj = Array<SsaInstr>.new(rv.varSize);
				for (l: Edge<SsaInstr> = i.useList; l != null; l = l.next) {
					var u = l.src;
					if (SsaApplyOp.?(u)) {
						match (SsaApplyOp.!(u).op.opcode) {
							TupleGetElem(index) => proj[index] = u;
							_ => ;
						}
					}
				}
				for (j < rv.varSize) {
					operands.put(Operand.Def(proj[j], vars[rv.varNum + j], 0));
				}
			}
		}
	}
	def dfn(i: SsaInstr) {
		operands.put(Operand.Def(i, getVReg(i), 0));
	}
	def dfnv(vreg: VReg) {
		operands.put(Operand.Def(vreg.ssa, vreg, 0));
	}
	def kill(livepoint: int, constraint: int) {
		operands.put(Operand.Kill(livepoint, constraint));
	}
	def useAll(array: Array<SsaDfEdge>, start: int) {
		for (j = start; j < array.length; j++) use(array[j].dest);
	}
	def upref(vreg: VReg) -> VReg {
		if (vreg.usage == Usage.NONE) vreg.usage = Usage.ONCE;
		else vreg.usage = Usage.MULTIPLE;
		return vreg;
	}
	def use(i: SsaInstr) {
		operands.put(Operand.Use(i, upref(getVReg(i)), 0));
	}
	def usev(vreg: VReg) {
		operands.put(Operand.Use(vreg.ssa, upref(vreg), 0));
	}
	def op(op: Operand) {
		operands.put(op);
	}
	def useReg(i: SsaInstr) {
		operands.put(Operand.Use(i, upref(getVReg(i)), anyReg));
	}
	def useImm(val: Val) {
		operands.put(Operand.Immediate(val));
	}
	def useInt(val: int) {
		var x = val + 1;
		if (x >= 0 && x < CACHED_INT_IMMEDIATES.length) {
			operands.put(CACHED_INT_IMMEDIATES[x]);
			return;
		}
		operands.put(Operand.Immediate(Int.box(val)));
	}
	def useIntConst(val: int) {
		useConstant(context.graph.intConst(val), 0);
	}
	def useAddrConst(addr: Addr) {
		useConstant(context.graph.valConst(mach.data.ptrType, addr), 0);
	}
	def useLongConst(val: int) {
		useConstant(context.graph.valConst(Long.TYPE, Long.box(val)), 0);
	}
	def useFixed(i: SsaInstr, constraint: int) {
		operands.put(Operand.Use(i, upref(getVReg(i)), constraint));
	}
	def useConstant(i: SsaConst, constraint: int) {
		operands.put(Operand.Use(i, getVReg(i), constraint));
	}
	def dfnFixed(i: SsaInstr, constraint: int) {
		operands.put(Operand.Def(i, getVReg(i), constraint));
	}
	def dfnReg(i: SsaInstr) {
		operands.put(Operand.Def(i, getVReg(i), anyReg));
	}
	def ovwReg(d: SsaInstr, u: SsaInstr) {
		operands.put(Operand.Overwrite(d, getVReg(d), upref(getVReg(u)), anyReg));
	}
	def useScratch() {
		operands.put(Operand.Scratch);
	}
	def newTmp(t: Type) -> SsaInstr {
		return SsaParam.new(-1, t);
	}
	def id(i: SsaInstr, vreg: VReg) -> VReg {
		i.mark = vreg.varNum;
		return vreg;
	}
	def useExSource(ex: string, source: Source) {
		operands.put(Operand.ExSource(ex, source));
	}

	def toLabel(o: Operand) -> Label {
		match (o) {
			Label(block, label) => return label;
			_ => context.fail("expected label");
		}
		return null;
	}
	def toBlock(o: Operand) -> SsaBlock {
		match (o) {
			Label(block, label) => return block;
			_ => context.fail("expected block");
		}
		return null;
	}
	def toInt(o: Operand) -> int {
		return Int.unbox(toImm(o));
	}
	def toImm(o: Operand) -> Val {
		match (o) {
			Immediate(val) => return val;
			_ => context.fail("expected immediate");
		}
		return null;
	}
	def toVar(o: Operand) -> VReg {
		match (o) {
			Use(i, vreg, constraint) => return vreg;
			Def(i, vreg, constraint) => return vreg;
			_ => context.fail("expected immediate");
		}
		return null;
	}
	def toExSource(o: Operand) -> (string, Source) {
		match (o) {
			ExSource(ex, source) => return (ex, source);
			_ => context.fail("expected exception + source");
		}
		return (null, null);
	}
	def inSameBlock(i: SsaInstr) -> bool {
		if (order.length == 1) return true;
		return getVReg(i).block == curBlock;
	}
	def isSigned(op: Operator) -> bool {
		return IntType.!(op.typeArgs[0]).signed;
	}

	//======================================================================
	// Architecture-specific routines.
	//======================================================================

	// Instruction selection.
	def visitEntry(params: Array<SsaParam>) {
		for (i < params.length) {
			var p = params[i];
			if (!isLive(p, context.block)) continue;
			if (frame == null) dfn(p);
			else {
				var vreg = getVReg(p), loc = frame.conv.callerParam(i);
				dfnFixed(p, loc);
				if (frame.conv.regSet.isStack(loc)) vreg.spill = loc;
			}
		}
		emitN(ArchInstrs.ARCH_ENTRY);
		advanceCursor();
	}
	def visitApply(block: SsaBlock, i: SsaApplyOp);
	def visitThrow(block: SsaBlock, i: SsaThrow);
	def visitIf(block: SsaBlock, i: SsaIf);
	def visitSwitch(block: SsaBlock, i: SsaSwitch);
	def visitGoto(block: SsaBlock, target: SsaGoto);
	def visitReturn(block: SsaBlock, i: SsaReturn) {
		for (j < i.inputs.length) useFixed(i.inputs[j].dest, frame.conv.callerRet(j));
		emitN(ArchInstrs.ARCH_RET);
	}

	def getProjections(i: SsaApplyOp) -> Array<SsaInstr> {
		var t = i.op.sig.returnTypes;
		if (t.length == 0) return Ssa.NO_INSTRS;
		if (t.length == 1) return [i];
		var r = Array<SsaInstr>.new(t.length);
		for (l: Edge<SsaInstr> = i.useList; l != null; l = l.next) {
			if (!SsaApplyOp.?(l.dest)) continue;
			var apply = SsaApplyOp.!(l.dest);
			match (apply.op.opcode) {
				TupleGetElem(index) => r[index] = apply;
				_ => ;
			}
		}
		return r;
	}

	def assembleInstrs() {
		var out = if (context.shouldPrintMach(), getOutput()), indent = 1;
		if (out != null) out.puts("After register allocation: ").outln();
		for (i = first; i != null; i = i.next) {
			if (out != null) {
				indent = out.putInstr(indent, i);
				out.outt();
			}
			assemble(i.opcode(), i.operands);
		}
	}

	// Code generation.
	def assemble(opcode: int, x: Array<Operand>);
	// Rendering.
	// Override this method to add architecture-specific rendering of instructions.
	def getOutput() -> ArchInstrBuffer {
		if (out != null) return out;
		return out = ArchInstrBuffer.new(this, context.prog, regSet);
	}
}
// Helper class for rendering architecture-specific machine instructions.
class ArchInstrBuffer(codegen: SsaMachGen, prog: Program, regSet: MachRegSet) extends TerminalBuffer {
	def putBlock(indent: int, i: ArchInstr) -> int {
		while (i != null) {
			indent = putInstr(indent, i);
			i = i.next;
			if (i != null && i.opcode() == ArchInstrs.ARCH_BLOCK) break;
		}
		return indent;
	}
	def putInstrV(i: ArchInstr) {
		putInstr(1, i);
	}
	def putInstr(indent: int, i: ArchInstr) -> int {
		var a = i.operands;
		match (int.!(i.opcode())) {
			ArchInstrs.ARCH_NOP => {
				putIndent(indent);
				puts("nop ");
				putOperands(a);
			}
			ArchInstrs.ARCH_ENTRY => {
				putIndent(1);
				puts("entry ");
				putOperands(a);
			}
			ArchInstrs.ARCH_BLOCK => {
				putIndent(1);
				puts("block ");
				putSsaBlock(Operand.Label.!(a[0]).block);
			}
			ArchInstrs.ARCH_PARMOVE => {
				putIndent(indent);
				puts("parallel-move");
				var half = a.length / 2;
				for (i < half) {
					var dst = a[i], src = a[i + half];
					ln();
					putIndent(indent+4);
					putOperand(dst);
					puts(" <- ");
					putOperand(src);
				}
			}
			ArchInstrs.ARCH_RET => {
				putIndent(indent);
				puts("ret ");
				putOperands(a);
			}
			ArchInstrs.ARCH_END => {
				putIndent(1);
				puts("end");
			}
			_ => {
				indent = putArchInstr(indent, i);
			}
		}
		ln();
		return indent;
	}
	// Override this method to add architecture-specific rendering of instructions.
	def putArchInstr(indent: int, i: ArchInstr) -> int {
		return putSimpleInstr(indent, i);
	}
	def putSimpleInstr(indent: int, i: ArchInstr) -> int {
		putIndent(indent);
		puts("opcode: ").putx(int.view(i.opcode())).sp();
		putOperands(i.operands);
		return indent;
	}
	def putIndent(indent: int) {
		if (indent-- > 0) tab();
		while (indent-- > 0) sp().sp();
	}
	def putSsaBlock(block: SsaBlock) {
		blue().putc('#').putd(block.uid).end();
	}
	def putSsa(i: SsaInstr) -> this {
		cyan().putc('@').putd(i.uid).end();
		if (SsaConst.?(i)) {
			V3.renderResult(SsaConst.!(i).val, null, green().putc('#'));
			end();
		}
	}
	def putArchWithI(name: string, x: Array<Operand>) -> this {
		var y = x[x.length - 1];
		puts(name);
		if (y.isImm()) putc('i');
		sp();
		putOperands(x);
	}
	def putNamedInstr(indent: int, name: string, x: Array<Operand>) -> int {
		putIndent(indent);
		puts(name).sp();
		putOperands(x);
		return indent;
	}
	def putOperands(x: Array<Operand>) -> this {
		for (j < x.length) {
			if (j > 0) csp();
			putOperand(x[j]);
		}
	}
	def putConstraint(constraint: int) -> this {
		if (constraint != 0) putc(':').yellow().puts(regSet.identify(constraint)).end();
	}
	def putVReg(mode: byte, vreg: VReg) -> this {
		putc(mode);
		if (vreg != null) putd(vreg.varNum);
	}
	def putOperand(o: Operand) -> this {
		match (o) {
			Scratch => puts("<scratch>");
			Immediate(val) => {
				puts("imm=");
				green();
				V3.renderResult(val, null, this);
				end();
			}
			Use(i, vreg, constraint) => {
				if (i != null) putSsa(i);
				putVReg('u', vreg);
				putConstraint(constraint);
			}
			Def(i, vreg, constraint) => {
				if (i != null) putSsa(i);
				putVReg('d', vreg);
				putConstraint(constraint);
			}
			Kill(livepoint, constraint) => {
				putc('k');
				if (livepoint >= 0) putd(livepoint);
				putConstraint(constraint);
			}
			Overwrite(i, dst, src, constraint) => {
				putSsa(i);
				putVReg('v', dst);
				putVReg('u', src);
				putConstraint(constraint);
			}
			Label(block, label) => {
				puts("lbl=");
				putSsaBlock(block);
			}
			ExSource(ex, source) => {
				if (ex != null) {
					puts("ex=");
					green().puts(ex).end();
					sp();
				}
				if (source != null) {
					puts("src=");
					green();
					source.render(this);
					this.end();
				}
			}
		}
	}
	def putLiveness(liveness: BitMatrix, index: int) {
		put1("{livepoint=%d", index);
		for (j < liveness.numcols) {
			if (liveness[index, j]) {
				put1(" v%d", j);
			}
		}
		puts("}\n");
	}
}
// Generates machine code for all aspects of the program, including the main
// stub, fatal stubs, and SSA methods.
class MachBackend(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter) {
	def context = SsaContext.new(compiler, prog);
	// Generate all code, beginning with the entrypoint
	def genAllCode() {
		w.atEnd();
		// Generate main entrypoint
		genMainEntry();
		// Generate memory allocation stub
		genAllocStub();

		// Generate code for SSA methods
		var methods = prog.ir.methods;
		var code = mach.code;
		for (i < methods.length) {
			var m = methods[i];
			w.atEnd().align(code.addrAlign.size);
			var start = w.pos;
			var methodStart = w.endAddr();
			var addr = mach.addrOfMethod(m);
			addr.absolute = methodStart;
			context.enterMethod(m);
			genCodeFromSsa();
			addr.size = w.atEnd().pos - start;
			if (Aeneas.PRINT_BIN.get()) {
				mach.printBin(m, methodStart, w);
			} else if (Aeneas.PRINT_SIZE.get()) {
				Terminal.put2("%q: %d\n", m.renderLong, w.endAddr() - methodStart);
			}
		}

		// Generate code for stubs
		mach.stubMap.apply(genStub);
		// Generate signal handler stub
		genSignalHandlerStub();
	}
	// Generate a stub, such as a fatal stub or other shared routine
	def genStub(name: string, t: (Addr, (Addr, MachDataWriter) -> void)) {
		w.align(mach.code.addrAlign.size); // XXX: skip align for stubs?
		var addr = t.0, func = t.1;
		addr.absolute = w.endAddr();
		if (Aeneas.PRINT_MACH.val != VstMatcher.None) {
			Terminal.put3("genStub[%s] @ %q = %x\n", name,
				V3.renderResult(addr, null, _), addr.absolute);
		}
		if (func != null) func(addr, w);
		else genFatalStub(name, addr);
	}
	// Overridden in target-specific code generators
	def genMainEntry();
	def genAllocStub();
	def genCodeFromSsa();
	def genSignalHandlerStub();
	def genFatalStub(ex: string, addr: Addr);
	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int);
}
