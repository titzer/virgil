// Copyright 2022-2026 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum ParMoveState(val: i8) {
	LIVE(0), ON_STACK(-1), IN_CYCLE(-2), DEAD(-3)
}

// Used to resolve parallel moves.
class MoveSet(regSet: MachRegSet) { // XXX: refactor and combine with MoveResolver?
	def regindex = Array<int>.new(regSet.physRegs); // where each register occurs, if all, in regmoves
	def regmoves = Vector<(ParMoveState, VReg, int, List<byte>)>.new();   // (state, VReg, src, reg)
	def saves = Vector<(VReg, int, int)>.new();     // (VReg, src, dst)
	def reloads = Vector<(VReg, int)>.new();        // (VReg, dst)

	def addRegMove(vreg: VReg, src: int, dst: byte) {
		if (src == dst) return;
		if (regSet.isReg(src)) {
			if (regindex[src] < 0) {
				var index = regmoves.length;
				regindex[src] = index;
				regmoves.put(ParMoveState.LIVE, vreg, src, List.new(dst, null));
			} else {
				var index = regindex[src];
				var prev = regmoves[index].3;
				regmoves[index] = (ParMoveState.LIVE, vreg, src, List.new(dst, prev));
			}
		} else {
			regmoves.put(ParMoveState.LIVE, vreg, src, List.new(dst, null));
		}
	}
	def emit(codegen: SsaMachGen, next: ArchInstr) {
		for (j < saves.length) {
			var s = saves[j], vreg = s.0, src = s.1, dst = s.2;
			if (src != dst) codegen.insertMoveLocLoc((vreg, src), (vreg, dst), vreg.regClass, next);
		}
		for (j < regmoves.length) emit0(codegen, j, next);
		for (j < reloads.length) {
			var t = reloads[j], vreg = t.0;
			if (vreg.isConst()) codegen.insertMoveValLoc(vreg, (vreg, t.1), vreg.regClass, next);
			else codegen.insertMoveLocLoc((vreg, vreg.spill), (vreg, t.1), vreg.regClass, next);
		}
	}
	def emit0(codegen: SsaMachGen, j: int, next: ArchInstr) {
		var t = regmoves[j], state = t.0.val, vreg = t.1, src = t.2, dst = t.3;
		if (state < ParMoveState.LIVE.val) return; // already done on or stack
		regmoves[j] = (ParMoveState.ON_STACK, vreg, src, dst);
		for (l = dst; l != null; l = l.tail) {
			var dreg = l.head, d = regindex[dreg];
			if (d >= 0) { // is the source of some regmove
				var u = regmoves[d];
				if (u.0 == ParMoveState.ON_STACK) {
					var regClass = u.1.regClass;
					var scratch = regSet.scratch[regClass.tag];
					regmoves[d] = (ParMoveState.IN_CYCLE, u.1, scratch, u.3);
					codegen.insertMoveLocLoc((u.1, dreg), (u.1, scratch), regClass, next);
				} else if (u.0 == ParMoveState.LIVE) {
					emit0(codegen, d, next);
				}
			}
		}
		// reload entry after recursion
		t = regmoves[j];
		if (t.0 == ParMoveState.IN_CYCLE) src = t.2; // use scratch of entry
		for (l = dst; l != null; l = l.tail) {
			codegen.insertMoveLocLoc((vreg, src), (vreg, l.head), vreg.regClass, next);
		}
		regmoves[j] = (ParMoveState.DEAD, null, 0, null);
	}
	def clear() {
		for (i < regindex.length) regindex[i] = -1;
		regmoves.resize(0);
		saves.resize(0);
		reloads.resize(0);
	}
}
