// Copyright 2022-2026 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum ParMoveState(val: i8) {
	LIVE(0), ON_STACK(-1), IN_CYCLE(-2), DEAD(-3)
}

// Used to emit sets of moves in a proper order.
class MoveSet(regSet: MachRegSet) {
	def regindex = Array<int>.new(regSet.physRegs); // where each register occurs, if all, in regmoves
	def regmoves = Vector<(ParMoveState, VReg, int, List<byte>)>.new();   // (state, VReg, src, reg)
	def saves = Vector<(VReg, int, int)>.new();     // (VReg, src, dst)
	def reloads = Vector<(VReg, int)>.new();        // (VReg, dst)

	def addRegMove(vreg: VReg, src: int, dst: byte) {
		if (src == dst) return;
		if (regSet.isReg(src)) {
			if (regindex[src] < 0) {
				var index = regmoves.length;
				regindex[src] = index;
				regmoves.put(ParMoveState.LIVE, vreg, src, List.new(dst, null));
			} else {
				var index = regindex[src];
				var prev = regmoves[index].3;
				regmoves[index] = (ParMoveState.LIVE, vreg, src, List.new(dst, prev));
			}
		} else {
			regmoves.put(ParMoveState.LIVE, vreg, src, List.new(dst, null));
		}
	}
	def emit(codegen: SsaMachGen, next: ArchInstr) {
		for (j < saves.length) {
			var s = saves[j], vreg = s.0, src = s.1, dst = s.2;
			if (src != dst) codegen.insertMoveLocLoc((vreg, src), (vreg, dst), vreg.regClass, next);
		}
		for (j < regmoves.length) emit0(codegen, j, next);
		for (j < reloads.length) {
			var t = reloads[j], vreg = t.0;
			if (vreg.isConst()) codegen.insertMoveValLoc(vreg, (vreg, t.1), vreg.regClass, next);
			else codegen.insertMoveLocLoc((vreg, vreg.spill), (vreg, t.1), vreg.regClass, next);
		}
	}
	def emit0(codegen: SsaMachGen, j: int, next: ArchInstr) {
		var t = regmoves[j], state = t.0.val, vreg = t.1, src = t.2, dst = t.3;
		if (state < ParMoveState.LIVE.val) return; // already done on or stack
		regmoves[j] = (ParMoveState.ON_STACK, vreg, src, dst);
		for (l = dst; l != null; l = l.tail) {
			var dreg = l.head, d = regindex[dreg];
			if (d >= 0) { // is the source of some regmove
				var u = regmoves[d];
				if (u.0 == ParMoveState.ON_STACK) {
					var regClass = u.1.regClass;
					var scratch = regSet.scratch[regClass.tag];
					regmoves[d] = (ParMoveState.IN_CYCLE, u.1, scratch, u.3);
					codegen.insertMoveLocLoc((u.1, dreg), (u.1, scratch), regClass, next);
				} else if (u.0 == ParMoveState.LIVE) {
					emit0(codegen, d, next);
				}
			}
		}
		// reload entry after recursion
		t = regmoves[j];
		if (t.0 == ParMoveState.IN_CYCLE) src = t.2; // use scratch of entry
		for (l = dst; l != null; l = l.tail) {
			codegen.insertMoveLocLoc((vreg, src), (vreg, l.head), vreg.regClass, next);
		}
		regmoves[j] = (ParMoveState.DEAD, null, 0, null);
	}
	def clear() {
		for (i < regindex.length) regindex[i] = -1;
		regmoves.resize(0);
		saves.resize(0);
		reloads.resize(0);
	}
}
// Used to collect and process parallel moves.
class ParMoveDests {
	def entries = Vector<(VReg, List<Operand.Def>)>.new();

	def emitMoves(codegen: SsaMachGen, j: int, next: ArchInstr) {
		var t = entries[j], vreg = t.0, dest = t.1;
		if (vreg.parmoveState <= 0) return; // already done on or stack
		vreg.parmoveState = ParMoveState.ON_STACK.val;
		for (l = dest; l != null; l = l.tail) {
			var o = l.head, dreg = o.vreg, index = dreg.parmoveState;
			codegen.allocSpill(dreg);
			if (index == ParMoveState.ON_STACK.val) {
				// destination is already on stack; cycle; load to temp
				dreg.parmoveState = ParMoveState.IN_CYCLE.val;
				codegen.insertRestoreLocal(dreg, getParallelMoveReg(codegen.frame.conv.regSet, dreg.regClass, 1), next);
			}
			if (index > 0) emitMoves(codegen, index - 1, next);
		}
		codegen.allocSpill(vreg);
		var loc: int;
		if (vreg.parmoveState == ParMoveState.IN_CYCLE.val) {
			loc = getParallelMoveReg(codegen.frame.conv.regSet, vreg.regClass, 1);
		} else {
			loc = getParallelMoveReg(codegen.frame.conv.regSet, vreg.regClass, 0);
			codegen.insertRestoreLocal(vreg, loc, next);
		}
		for (l = dest; l != null; l = l.tail) {
			codegen.insertSaveLocal(loc, l.head.vreg, next);
		}
		vreg.parmoveState = 0;
	}
	def getParallelMoveReg(regSet: MachRegSet, rcl: RegClass, which: int) -> int {
		var set = regSet.regClasses[rcl.tag];
		var loc = regSet.regSets[set][which];
		return loc;
	}
}