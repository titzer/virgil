// Copyright 2019 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def EVERYUSE = false;
def EVERYKILL = false;

// Responsible for transforming Arch code containing livepoints (i.e. kills
// of VRegs across potential GC points) to use a shadow stack. To do this,
// it computes good locations for the allocation and deallocation of the stack frame,
// saves and restores of VRegs, and inserts code into the instruction stream
// to accomplish this. Code after this transformation is no longer in SSA form,
// since multiple new definitions of a VReg may be introduced. The code is, however,
// safe to run through the MachStackifier, since all live ranges will be split so
// that no VReg originally live across a livepoint is live across any livepoint after
// transformation.
class ShadowStackSpiller() {
	var codegen: SsaMachGen;
	var order: SsaBlockOrder;
	var matrix: BitMatrix;
	var lpPassStart: int;
	var reloadStart: int;
	var allLive: int;
	var tmpRow: int;
	var lps: Vector<(SsaBlock, ArchInstr, Operand.RefMap)>;
	var useShadowStack: bool;
	var shadow_sp: VReg;
	def shadowVarMap = Vector<int>.new();
	def lastLivepoint = Vector<ArchInstr>.new();
	def deallocate = Vector<bool>.new();

	def reset(codegen: SsaMachGen, order: SsaBlockOrder) {
		this.codegen = codegen;
		this.order = order;
		useShadowStack = if(WasmCodeGen.?(codegen), WasmCodeGen.!(codegen).useShadowStack, false);
	}
	// Run the algorithm, inserting save and restore code.
	def run() {
		lps = codegen.livepoints;
		if (lps.length == 0) return;  // nothing to do
		matrix = codegen.liveness;
		matrix.grow(matrix.numrows + 2);
		allLive = matrix.numrows - 2;
		tmpRow = matrix.numrows - 1;
		matrix.copy(allLive, lps[0].0.mark);
		for (i < lps.length) {
			var t = lps[i], lp = order.order.length + t.2.livepoint;
			matrix.or(allLive, lp); // union all livepoint sets
		}
		var numSlots = allocSpillSlot();
		if (numSlots == 0) return; // no live references at any livepoint
		if (useShadowStack) {
			allocateShadowStack(numSlots);
			save();
		}
		if (!EVERYKILL) restore();
	}
	def allocSpillSlot() -> int {
		var numVars = codegen.vars.length;
		var numSlots = 0;
		if (useShadowStack) {
			// Allocate a temporary for a shadow stack pointer.
			shadow_sp = codegen.newShadowSpTmp();
			// Initialize the shadow variable map, which maps (reference) variables to shadow
			// spill slots.
			shadowVarMap.grow(numVars);
			shadowVarMap.length = numVars;
		}
		for (i < numVars) {
			if (matrix[allLive, i]) {
				var vreg = codegen.vars[i];
				if (!vreg.isConst() && (!useShadowStack || codegen.isRef(vreg))) {
					if (useShadowStack) shadowVarMap[i] = numSlots;
					else allocSpill(codegen.vars[i]);
					numSlots++;
					continue;
				}
			}
			if (useShadowStack) shadowVarMap[i] = -1;
			matrix[allLive, i] = false; // filter out non-ref vars and consts
		}
		return numSlots;
	}
	def allocSpill(vreg: VReg) {
		if (vreg.spill == 0) vreg.spill = codegen.frame.allocSpill(vreg.regClass);
	}
	def allocateShadowStack(numShadowSlots: int) {
		// Make a first pass over all livepoints.
		lastLivepoint.resize(codegen.order.length);
		deallocate.resize(codegen.order.length);
		for (i < lastLivepoint.length) {
			lastLivepoint[i] = null;
			deallocate[i] = false;
		}

		// Compute the allocation block A, where the shadow stack pointer will be adjusted.
		// Find the common dominator A of all blocks that contain livepoints.
		var blockA_i = lps[0].0.mark, blockA = order.order[blockA_i];
		for (i < lps.length) {
			var t = lps[i], bm = t.0.mark, info = order.order[bm];
			if (lastLivepoint[bm] == null) lastLivepoint[bm] = t.1;
			if (info == blockA) continue;
			blockA = order.commonDominator(blockA, info);
		}

		// Pull the allocation out of any loops; the lowest non-loop dominator of A.
		for (p = blockA; p != null; p = p.dom_parent) {
			if (p.loop != null) blockA = p.dom_parent;
		}
		if (blockA == null) blockA = order.order[0];  // TODO: first block was a loop

		// Compute deallocation points D, which are either blocks with throws/returns or
		// on the dominance frontier of A (i.e. not dominated by A, but the destination of
		// an edge from A).
		var range = (blockA.block.mark, blockA.dom_max);
		for (i = range.0; i < range.1; i++) {
			var bi = order.order[i], end = bi.block.end();
			match (end.succs.length) {
				0 => deallocate[i] = true;
				1 => {
					var ti = end.succs[0].dest.mark;
					if (ti < range.0 || ti >= range.1) deallocate[i] = true; // target not dominated
				}
				_ => {
					if (Debug.PARANOID) for (s in end.succs) { // check for non-dominated blocks
						var ti = s.dest.mark;
						if (ti < range.0 || ti >= range.1) {
							codegen.context.fail(Strings.format2("unsplit critical edge at #%d -> #%d", bi.block.uid, s.dest.uid));
						}
					}
				}
			}
		}

		// Insert shadow stack allocation and deallocations. Iterate instructions from top
		// to bottom because blocks don't know their first instruction.
		for (i = codegen.first; i != null; i = i.next) {
			if (i.opcode() != ArchInstrs.ARCH_BLOCK) continue; // only need block starts
			var label = Operand.Label.!(i.operands[0]);
			if (label.block == blockA.block) { // allocation block
				var startOfBlock = i.next;
				codegen.insertShadowStackAlloc(shadow_sp, numShadowSlots, startOfBlock);
			}
			if (deallocate[label.block.mark]) { // deallocation block
				var point = lastLivepoint[label.block.mark]; // insert after last livepoint
				if (point == null) point = i;  // no livepoint, using block start is ok
				codegen.insertShadowStackFree(shadow_sp, numShadowSlots, point.next);
			}
		}
	}
	def insertSaveVarNum(varNum: int, t: (ArchInstr, ArchInstr)) {
		var vreg = codegen.vars[varNum], slot = shadowVarMap[varNum];
		codegen.insertShadowStackSave(shadow_sp, vreg, slot, t.0);
		if (EVERYKILL) codegen.insertShadowStackRestore(shadow_sp, vreg, slot, t.1);
	}
	def save() {
		// For every livepoint, for every live variable, add a save before and a restore after.
		// XXX: improve spilling to the shadow stack with better splitting heuristics.
		var start = tmpRow * matrix.width, end = start + matrix.width;
		for (j < lps.length) {
			var t = lps[j], i = t.1, lp = order.order.length + t.2.livepoint;
			matrix.copy(tmpRow, lp);
			matrix.and(tmpRow, allLive);  // filter non-refs and constants
			var before = i, after = i.next;
			matrix.apply(tmpRow, insertSaveVarNum, (before, after));
		}
	}
	def restore() {
		if (lps.length == 0) return;
		matrix = codegen.liveness;
		lpPassStart = matrix.numrows;
		reloadStart = matrix.numrows + codegen.order.length;
		matrix.grow(matrix.numrows + codegen.order.length * 2);
		codegen.iterateInstructionsForward(markRestore);
		pushRestoreUp();
	}
	def iterateloop(loop: SsaLoopInfo, endinstr: ArchInstr) {
		var cur = codegen.instrs[loop.start];
		var block: SsaBlock;
		while (cur != endinstr) {
			var next = cur.next;
			var opcode = cur.opcode();
			if (opcode == ArchInstrs.ARCH_BLOCK) {
				block = Operand.Label.!(cur.operands[0]).block;
				matrix.clearRow(lpPassStart + block.mark);
				for (e in block.preds) {
					var pred = e.src.block();
					matrix.or(lpPassStart + block.mark, lpPassStart + pred.mark);
				}
				matrix.and(lpPassStart + block.mark, allLive);
			}
			var operands = cur.operands;
			for (j = operands.length-1; j >= 0; j--) {
				match (operands[j]) {
					Def(vreg, constraint) => {
						if (vreg != null) matrix[lpPassStart + block.mark, vreg.varNum] = false;
					}
					Use(vreg, constraint) => {
						if (vreg != null && matrix[lpPassStart + block.mark, vreg.varNum]) {
							if (EVERYUSE) insertRestore(vreg, cur);
							else matrix[reloadStart + block.mark, vreg.varNum] = true;
							matrix[lpPassStart + block.mark, vreg.varNum] = false;
						}
					}
					Overwrite(vreg, use, constraint) => {
						if (matrix[lpPassStart + block.mark, use.varNum]) {
							if (EVERYUSE) insertRestore(vreg, cur);
							else matrix[reloadStart + block.mark, use.varNum] = true;
							matrix[lpPassStart + block.mark, use.varNum] = false;
						}
					}
					RefMap(livepoint, outgoing) => {
						matrix.or(lpPassStart + block.mark, codegen.order.length + livepoint);
						matrix.and(lpPassStart + block.mark, allLive);
					}
					_ => ;
				}
			}
			cur = next;
		}
	}
	def insertRestore(vreg: VReg, next: ArchInstr) {
		if (!useShadowStack) codegen.insertRestore((vreg, 0), vreg.spill, next);
		else codegen.insertShadowStackRestore(shadow_sp, vreg, shadowVarMap[vreg.varNum], next);
	}
	def markRestoreVreg(block: SsaBlock, cur: ArchInstr, vreg: VReg) {
		if (matrix[lpPassStart + block.mark, vreg.varNum]) { // kills in this block
			insertRestore(vreg, cur);
			matrix[tmpRow, vreg.varNum] = false;
			matrix[lpPassStart + block.mark, vreg.varNum] = false;
		} else if (matrix[tmpRow, vreg.varNum]) { // kills from predecessor
			if (EVERYUSE) insertRestore(vreg, cur);
			else matrix[reloadStart + block.mark, vreg.varNum] = true;
			matrix[tmpRow, vreg.varNum] = false;
		}
	}
	def markRestore(block: SsaBlock, cur: ArchInstr) {
		var opcode = cur.opcode();
		if (opcode == ArchInstrs.ARCH_BLOCK) {
			matrix.clearRow(tmpRow);
			for (e in block.preds) {
				var pred = e.src.block();
				matrix.or(tmpRow, lpPassStart + pred.mark); // kills from predecessor
			}
			matrix.and(tmpRow, allLive);
		} else if (opcode == ArchInstrs.ARCH_BLOCK_END) {
			matrix.or(lpPassStart + block.mark, tmpRow);
			if (order.loops != null) for (i < order.loops.length) {
				if (block.mark == order.loops[i].end-1) {
					iterateloop(order.loops[i], cur);
					break;
				}
			}
		}
		var operands = cur.operands;
		for (j = operands.length-1; j >= 0; j--) {
			match (operands[j]) {
				Use(vreg, constraint) => {
					if (vreg != null) markRestoreVreg(block, cur, vreg);
				}
				Overwrite(vreg, use, constraint) => {
					markRestoreVreg(block, cur, use);
				}
				RefMap(livepoint, outgoing) => { // kills in this block
					matrix.or(lpPassStart + block.mark, codegen.order.length + livepoint);
					matrix.and(lpPassStart + block.mark, allLive);
				}
				_ => ;
			}
		}
	}
	def isSucc(block: SsaBlock, succs: Array<SsaCfEdge>) -> bool {
		for (e in succs) {
			if (e.dest == block) return true;
		}
		return false;
	}
	def succsHasKill(succs: Array<SsaCfEdge>) -> bool {
		for (e in succs) {
			if (hasKill(e.dest)) return true;
		}
		return false;
	}
	def hasKill(block: SsaBlock) -> bool {
		var livepoints = codegen.livepoints;
		for (i < livepoints.length) {
			if (livepoints[i].0 == block) return true;
		}
		return false;
	}
	def insertRestoreVarNum(varNum: int, t: (ArchInstr, SsaBlock)) {
		insertRestore(codegen.vars[varNum], t.0);
		matrix[t.1.mark, varNum] = false;
	}
	def pushRestoreUp() {
		if (EVERYUSE) return;
		for (i = codegen.order.length - 1; i >= 0; i--) {
			var info = codegen.order[i], block = info.block;
			var succs = block.succs();
			var child = info.dom_child;
			if (child != null) {
				if (child.dom_sibling == null || hasKill(block) || succsHasKill(succs)) {
					while (child != null) {
						var next = codegen.instrs[child.block.mark].next;
						matrix.apply(reloadStart + child.block.mark, insertRestoreVarNum, (next, child.block));
						child = child.dom_sibling;
					}
				} else {
					matrix.setRow(tmpRow);
					// Mark reload if all successors require reload
					for (e in succs) {
						matrix.and(tmpRow, reloadStart + e.dest.mark);
					}
					matrix.or(reloadStart + block.mark, tmpRow);
					// Mark reload if some succs and dom_child that is not a successor require reload
					matrix.clearRow(tmpRow);
					for (e in succs) {
						matrix.or(tmpRow, reloadStart + e.dest.mark);
					}
					while (child != null) {
						if (!isSucc(child.block, succs)) {
							matrix.and(tmpRow, reloadStart + child.block.mark);
							matrix.or(reloadStart + block.mark, tmpRow);
							break;
						}
						child = child.dom_sibling;
					}
					child = info.dom_child;
					while (child != null) {
						// Reload at child if child requires reload but current block doesn't.
						var next = codegen.instrs[child.block.mark].next;
						matrix.copy(tmpRow, reloadStart + block.mark);
						matrix.flipRow(tmpRow);
						matrix.and(tmpRow, reloadStart + child.block.mark);
						matrix.apply(tmpRow, insertRestoreVarNum, (next, child.block));
						child = child.dom_sibling;
					}
				}
			}
		}
	}
	def print() {
		var out = codegen.getOutput(), indent = 1;
		for (i = codegen.first; i != null; i = i.next) {
			indent = out.putInstr(indent, i);
			for (o in i.operands) match (o) {
				RefMap(livepoint, outgoing) => {
					out.putLiveness(codegen.liveness, livepoint + codegen.order.length);
				}
				_ => ;
			}
		}
	}
}
