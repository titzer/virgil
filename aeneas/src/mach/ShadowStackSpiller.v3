// Copyright 2019 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def EVERYUSE = false;

// Responsible for transforming Arch code containing livepoints (i.e. kills
// of VRegs across potential GC points) to use a shadow stack. To do this,
// it computes good locations for the allocation and deallocation of the stack frame,
// saves and restores of VRegs, and inserts code into the instruction stream
// to accomplish this. Code after this transformation is no longer in SSA form,
// since multiple new definitions of a VReg may be introduced. The code is, however,
// safe to run through the MachStackifier, since all live ranges will be split so
// that no VReg originally live across a livepoint is live across any livepoint after
// transformation.
class ShadowStackSpiller() {
	var codegen: SsaMachGen;
	var order: SsaBlockOrder;
	var matrix: BitMatrix;
	var maskRow: int;
	var lpPassStart: int;
	var reloadStart: int;
	var tmpRow: int;
	def shadowVarMap = Vector<int>.new();
	def lastLivepoint = Vector<ArchInstr>.new();
	def deallocate = Vector<bool>.new();

	def reset(codegen: SsaMachGen, order: SsaBlockOrder) {
		this.codegen = codegen;
		this.order = order;
	}
	// Run the algorithm, inserting save and restore code.
	def run() {
		var lps = codegen.livepoints;
		if (lps.length == 0) return;  // nothing to do

		// Make a first pass over all livepoints.
		lastLivepoint.resize(codegen.order.length);
		deallocate.resize(codegen.order.length);
		for (i < lastLivepoint.length) {
			lastLivepoint[i] = null;
			deallocate[i] = false;
		}

		// Compute the allocation block A, where the shadow stack pointer will be adjusted.
		// Find the common dominator A of all blocks that contain livepoints. Along the way,
		// compute the union of all variables used in all livepoints.
		var matrix = codegen.liveness;
		matrix.grow(matrix.numrows + 2);
		var allLive = matrix.numrows - 2;
		var tmpLive = matrix.numrows - 1;
		var blockA_i = lps[0].0.mark, blockA = order.order[blockA_i];
		matrix.copy(allLive, blockA_i);
		for (i < lps.length) {
			var t = lps[i], bm = t.0.mark, info = order.order[bm], lp = order.order.length + t.2.livepoint;
			matrix.or(allLive, lp); // union all livepoint sets
			if (lastLivepoint[bm] == null) lastLivepoint[bm] = t.1;
			if (info == blockA) continue;
			blockA = order.commonDominator(blockA, info);
		}

		// Pull the allocation out of any loops; the lowest non-loop dominator of A.
		for (p = blockA; p != null; p = p.dom_parent) {
			if (p.loop != null) blockA = p.dom_parent;
		}
		if (blockA == null) blockA = order.order[0];  // TODO: first block was a loop

		// Compute deallocation points D, which are either blocks with throws/returns or
		// on the dominance frontier of A (i.e. not dominated by A, but the destination of
		// an edge from A).
		var range = (blockA.block.mark, blockA.dom_max);
		for (i = range.0; i < range.1; i++) {
			var bi = order.order[i], end = bi.block.end();
			match (end.succs.length) {
				0 => deallocate[i] = true;
				1 => {
					var ti = end.succs[0].dest.mark;
					if (ti < range.0 || ti >= range.1) deallocate[i] = true; // target not dominated
				}
				_ => {
					if (Debug.PARANOID) for (s in end.succs) { // check for non-dominated blocks
						var ti = s.dest.mark;
						if (ti < range.0 || ti >= range.1) {
							codegen.context.fail(Strings.format2("unsplit critical edge at #%d -> #%d", bi.block.uid, s.dest.uid));
						}
					}
				}
			}
		}
		// Allocate a temporary for a shadow stack pointer.
		var shadow_sp = codegen.newShadowSpTmp();

		// Initialize the shadow variable map, which maps (reference) variables to shadow
		// spill slots. XXX: improve shadow spill slot allocation with graph coloring.
		var numVars = codegen.vars.length;
		shadowVarMap.grow(numVars);
		shadowVarMap.length = numVars;
		var numShadowSlots = 0;
		for (i < numVars) {
			if (matrix[allLive, i]) {
				var vreg = codegen.vars[i];
				if (!vreg.isConst() && codegen.isRef(vreg)) {
					shadowVarMap[i] = numShadowSlots++;
					continue;
				}
			}
			shadowVarMap[i] = -1;
			matrix[allLive, i] = false; // filter out non-ref vars and consts
		}
		if (numShadowSlots == 0) return;  // no live references at any livepoint

		// Insert shadow stack allocation and deallocations. Iterate instructions from top
		// to bottom because blocks don't know their first instruction.
		for (i = codegen.first; i != null; i = i.next) {
			if (i.opcode() != ArchInstrs.ARCH_BLOCK) continue; // only need block starts
			var label = Operand.Label.!(i.operands[0]);
			if (label.block == blockA.block) { // allocation block
				var startOfBlock = i.next;
				codegen.insertShadowStackAlloc(shadow_sp, numShadowSlots, startOfBlock);
			}
			if (deallocate[label.block.mark]) { // deallocation block
				var point = lastLivepoint[label.block.mark]; // insert after last livepoint
				if (point == null) point = i;  // no livepoint, using block start is ok
				codegen.insertShadowStackFree(shadow_sp, numShadowSlots, point.next);
			}
		}

		// For every livepoint, for every live variable, add a save before and a restore after.
		// XXX: improve spilling to the shadow stack with better splitting heuristics.
		var start = tmpLive * matrix.width, end = start + matrix.width;
		for (j < lps.length) {
			var t = lps[j], i = t.1, lp = order.order.length + t.2.livepoint;
			matrix.copy(tmpLive, lp);
			matrix.and(tmpLive, allLive);  // filter non-refs and constants
			var before = i, after = i.next;

			for (j = start; j < end; j++) {
				var bits = matrix.bits[j];
				var varNum = (j - start) * 32;
				while (bits != 0) {
					if ((bits & 1) == 1) {
						// spill and restore varNum
						var vreg = codegen.vars[varNum], slot = shadowVarMap[varNum];
						codegen.insertShadowStackSave(shadow_sp, vreg, slot, before);
						codegen.insertShadowStackRestore(shadow_sp, vreg, slot, after);
					}
					bits = bits >>> 1;
					varNum++;
				}
			}
		}
	}
	def restore() {
		if (codegen.livepoints.length == 0) return;
		matrix = codegen.liveness;
		maskRow = matrix.numrows - 1;
		lpPassStart = matrix.numrows;
		reloadStart = matrix.numrows + codegen.order.length;
		matrix.grow(matrix.numrows + codegen.order.length * 2 + 1);
		tmpRow = matrix.numrows - 1;
		codegen.iterateInstructionsForward(markRestore);
		pushRestoreUp();
	}
	def iterateloop(loop: SsaLoopInfo, endinstr: ArchInstr) {
		var cur = codegen.instrs[loop.start];
		var block: SsaBlock;
		while (cur != endinstr) {
			var next = cur.next;
			var opcode = cur.opcode();
			if (opcode == ArchInstrs.ARCH_BLOCK) {
				block = Operand.Label.!(cur.operands[0]).block;
				matrix.clearRow(lpPassStart + block.mark);
				for (e in block.preds) {
					var pred = e.src.block();
					matrix.or(lpPassStart + block.mark, lpPassStart + pred.mark);
				}
				matrix.and(lpPassStart + block.mark, maskRow);
			}
			var operands = cur.operands;
			for (j = operands.length-1; j >= 0; j--) {
				match (operands[j]) {
					Def(vreg, constraint) => {
						if (vreg != null) matrix[lpPassStart + block.mark, vreg.varNum] = false;
					}
					Use(vreg, constraint) => {
						if (matrix[lpPassStart + block.mark, vreg.varNum]) {
							if (EVERYUSE) codegen.insertReload(vreg, (vreg, 0), cur);
							else matrix[reloadStart + block.mark, vreg.varNum] = true;
							matrix[lpPassStart + block.mark, vreg.varNum] = false;
						}
					}
					Overwrite(vreg, use, constraint) => {
						if (matrix[lpPassStart + block.mark, use.varNum]) {
							if (EVERYUSE) codegen.insertReload(use, (use, 0), cur);
							else matrix[reloadStart + block.mark, use.varNum] = true;
							matrix[lpPassStart + block.mark, use.varNum] = false;
						}
					}
					RefMap(livepoint, outgoing) => {
						matrix.or(lpPassStart + block.mark, codegen.order.length + livepoint);
						matrix.and(lpPassStart + block.mark, maskRow);
					}
					_ => ;
				}
			}
			cur = next;
		}
	}
	def markRestoreVreg(block: SsaBlock, cur: ArchInstr, vreg: VReg) {
		if (matrix[lpPassStart + block.mark, vreg.varNum]) { // kills in this block
			codegen.insertReload(vreg, (vreg, 0), cur);
			matrix[tmpRow, vreg.varNum] = false;
			matrix[lpPassStart + block.mark, vreg.varNum] = false;
		} else if (matrix[tmpRow, vreg.varNum]) { // kills from predecessor
			if (EVERYUSE) codegen.insertReload(vreg, (vreg, 0), cur);
			else matrix[reloadStart + block.mark, vreg.varNum] = true;
			matrix[tmpRow, vreg.varNum] = false;
		}
	}
	def markRestore(block: SsaBlock, cur: ArchInstr) {
		var opcode = cur.opcode();
		if (opcode == ArchInstrs.ARCH_BLOCK) {
			matrix.clearRow(tmpRow);
			for (e in block.preds) {
				var pred = e.src.block();
				matrix.or(tmpRow, lpPassStart + pred.mark); // kills from predecessor
			}
			matrix.and(tmpRow, maskRow);
		} else if (opcode == ArchInstrs.ARCH_BLOCK_END) {
			matrix.or(lpPassStart + block.mark, tmpRow);
			if (order.loops != null) for (i < order.loops.length) {
				if (block.mark == order.loops[i].end-1) {
					iterateloop(order.loops[i], cur);
					break;
				}
			}
		}
		var operands = cur.operands;
		for (j = operands.length-1; j >= 0; j--) {
			match (operands[j]) {
				Use(vreg, constraint) => {
					if (vreg != null) markRestoreVreg(block, cur, vreg);
				}
				Overwrite(vreg, use, constraint) => {
					markRestoreVreg(block, cur, use);
				}
				RefMap(livepoint, outgoing) => { // kills in this block
					matrix.or(lpPassStart + block.mark, codegen.order.length + livepoint);
					matrix.and(lpPassStart + block.mark, maskRow);
				}
				_ => ;
			}
		}
	}
	def isSucc(block: SsaBlock, succs: Array<SsaCfEdge>) -> bool {
		for (e in succs) {
			if (e.dest == block) return true;
		}
		return false;
	}
	def succsHasKill(succs: Array<SsaCfEdge>) -> bool {
		for (e in succs) {
			if (hasKill(e.dest)) return true;
		}
		return false;
	}
	def hasKill(block: SsaBlock) -> bool {
		var livepoints = codegen.livepoints;
		for (i < livepoints.length) {
			if (livepoints[i].0 == block) return true;
		}
		return false;
	}
	def insertReload(col: int, t: (ArchInstr, SsaBlock)) {
		codegen.insertReload(codegen.vars[col], (codegen.vars[col], 0), t.0);
		matrix[t.1.mark, col] = false;
	}
	def pushRestoreUp() {
		if (EVERYUSE) return;
		for (i = codegen.order.length - 1; i >= 0; i--) {
			var info = codegen.order[i], block = info.block;
			var succs = block.succs();
			var child = info.dom_child;
			if (child != null) {
				if (child.dom_sibling == null || hasKill(block) || succsHasKill(succs)) {
					while (child != null) {
						var next = codegen.instrs[child.block.mark].next;
						matrix.apply(reloadStart + child.block.mark, insertReload, (next, child.block));
						child = child.dom_sibling;
					}
				} else {
					matrix.setRow(tmpRow);
					// Mark reload if all successors require reload
					for (e in succs) {
						matrix.and(tmpRow, reloadStart + e.dest.mark);
					}
					matrix.or(reloadStart + block.mark, tmpRow);
					// Mark reload if some succs and dom_child that is not a successor require reload
					matrix.clearRow(tmpRow);
					for (e in succs) {
						matrix.or(tmpRow, reloadStart + e.dest.mark);
					}
					while (child != null) {
						if (!isSucc(child.block, succs)) {
							matrix.and(tmpRow, reloadStart + child.block.mark);
							matrix.or(reloadStart + block.mark, tmpRow);
							break;
						}
						child = child.dom_sibling;
					}
					child = info.dom_child;
					while (child != null) {
						// Reload at child if child requires reload but current block doesn't.
						var next = codegen.instrs[child.block.mark].next;
						matrix.copy(tmpRow, reloadStart + block.mark);
						matrix.flipRow(tmpRow);
						matrix.and(tmpRow, reloadStart + child.block.mark);
						matrix.apply(tmpRow, insertReload, (next, child.block));
						child = child.dom_sibling;
					}
				}
			}
		}
	}
	def print() {
		var out = codegen.getOutput(), indent = 1;
		for (i = codegen.first; i != null; i = i.next) {
			indent = out.putInstr(indent, i);
			for (o in i.operands) match (o) {
				RefMap(livepoint, outgoing) => {
					out.putLiveness(codegen.liveness, livepoint + codegen.order.length);
				}
				_ => ;
			}
		}
	}
}
