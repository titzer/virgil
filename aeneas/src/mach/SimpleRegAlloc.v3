// Copyright 2021 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Simple register allocator that spills everything to the stack between
// instructions.
class SimpleRegAlloc(regSet: MachRegSet, codegen: SsaMachGen) {
	def curVreg = Array<VReg>.new(regSet.physRegs);
	def allocated = Array<byte>.new(regSet.physRegs);
	def parmoves = ParMoveDests.new();
	var cursor: int;

	def allocate() {
		var i = codegen.first;
		while (i != null) {
			var next = i.next;
			release();
			if (i.opcode() == ArchInstrs.ARCH_PARMOVE) {
				i.remove();
				doParallelMove(i, next);
				i = next;
				continue;
			}
			var operands = i.operands;
			var first_def = true;
			for (j = operands.length - 1; j >= 0; j--) {
				match (operands[j]) {
					Use(vreg, constraint) => {
						codegen.allocSpill(vreg);
						var loc = loadUse(vreg, constraint, i);
						operands[j] = Operand.Use(vreg, loc);
					}
					Overwrite(dst, use, constraint) => {
						var loc = loadUse(use, constraint, i);
						operands[j] = Operand.Overwrite(dst, use, loc);
						codegen.allocSpill(dst);
						codegen.insertMoveLocLoc(Operand.Use(null, loc),
							Operand.Def(dst, dst.spill), dst.regClass, next);
					}
					Def(vreg, constraint) => {
						if (first_def) {
							release();
							first_def = false;
						}
						codegen.allocSpill(vreg);
						var loc = vreg.spill;
						if (constraint != 0) loc = alloc(vreg, constraint);
						operands[j] = Operand.Def(vreg, loc);
						if (constraint != 0) {
							codegen.insertMoveLocLoc(Operand.Use(null, loc),
								Operand.Def(vreg, vreg.spill), vreg.regClass, next);
						}
					}
					_ => ;
				}
			}
			i = next;
		}
	}
	def loadUse(vreg: VReg, constraint: int, cur: ArchInstr) -> int {
		codegen.allocSpill(vreg);
		if (constraint == 0) {
			if (vreg.isConst()) {
				var reg = allocReg(vreg, regSet.regClasses[vreg.regClass.tag]);
				codegen.insertMoveConstLoc(SsaConst.!(vreg.ssa), Operand.Def(null, reg), vreg.regClass, cur);
				return reg;
			}
			return vreg.spill;
		}
		if (regSet.isStack(constraint)) {
			if (vreg.isConst()) {
				codegen.insertMoveConstLoc(SsaConst.!(vreg.ssa), Operand.Def(null, constraint), vreg.regClass, cur);
				return constraint;
			}
			codegen.insertMoveLocLoc(Operand.Use(null, vreg.spill), Operand.Def(null, constraint), vreg.regClass, cur);
			return constraint;
		}
		var reg = allocReg(vreg, constraint);
		codegen.insertRestore(vreg, reg, cur);
		return reg;
	}
	def alloc(vreg: VReg, constraint: int) -> int {
		if (constraint == 0) {
			// no constraint: use register class
			constraint = regSet.regClasses[vreg.regClass.tag];
		} else if (constraint >= regSet.regSets.length) {
			// constraint is for a spill slot
			return constraint;
		}
		return allocReg(vreg, constraint);
	}
	def allocReg(vreg: VReg, constraint: int) -> byte {
		var set = regSet.regSets[constraint];
		// Check if existing register (if any) is in the constraint set
		if (vreg.reg != 0) {
			for (reg in set) if (reg == vreg.reg) return reg;
		}
		// Allocate a register from the constraint set
		for (reg in set) {
			if (curVreg[reg] == null) {
				curVreg[reg] = vreg;
				allocated[cursor++] = reg;
				if (vreg.reg == 0) vreg.reg = reg;
				return reg;
			}
		}
		return V3.fail1("out of registers in set %s", regSet.identify(constraint));
	}
	def release() {
		for (i < cursor) { // Release all registers.
			var num = allocated[i];
			var vreg = curVreg[num];
			curVreg[num] = null;
			vreg.reg = 0;
		}
		cursor = 0;
	}
	def doParallelMove(i: ArchInstr, next: ArchInstr) {
		parmoves.entries.resize(0);
		codegen.gatherParallelMoveDests(i, parmoves.entries);
		for (j < parmoves.entries.length) parmoves.emitMoves(codegen, j, next);
	}
}
