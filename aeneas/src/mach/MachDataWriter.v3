// Copyright 2011 Google Inc. All rights reserved.
// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum PatchKind {
	REL_32,
	RELA_32,
	ABS_32,
	ABS_64,
	ABS_LEB32,
	ARM64_REL_IMM19,
	ARM64_ABS_IMM16,
	ARM64_REL_IMM26
}

// A specialized DataWriter with machine-level properties, such as a start address
// and the ability to encode an address that is tracked for later patching.
class MachDataWriter extends DataWriter {
	def pageAlign: Alignment;
	var startPos: int; // start position from which offset() is calculated
	var patches: List<(PatchKind, Addr, /*posAddr:*/int, /*pos:*/int)>;

	new(pageAlign, startAddr: int, initialSize: int) {
		this.startAddr = u64.!(startAddr);
		grow(initialSize);
	}

	def recordPatch(kind: PatchKind, addr: Addr, pos: int) {
		patches = List.new((kind, addr, addr_of(pos), pos), patches);
	}
	def patch(f: (MachDataWriter, PatchKind, Addr, int) -> void) {
		// patch address locations with user function
		for (l = patches; l != null; l = l.tail) {
			var t = l.head, kind = t.0, addr = t.1, posAddr = t.2, pos = t.3;
			f(at(pos), kind, addr, posAddr);
		}
	}
	def abs4(addr: Addr, encoding: int) {
		recordPatch(PatchKind.ABS_32, addr, pos);
		put_b32(encoding);
	}
	def skipPage() {
		skipAddr(pageAlign.size);
	}
	def endPageAddr() -> int {
		return pageAlign.alignDown_i32(addr_end());
	}
	def putmd(w: MachDataWriter) {
		var p = this.pos;
		putr(w.alias());
		for (l = w.patches; l != null; l = l.tail) {
			var t = l.head;
			patches = List.new((t.0, t.1, t.2 + p, t.3 + p), patches);
		}
		w.patches = null;
	}
	def offset() -> int {
		return pos - startPos;
	}
	def endOffset() -> int {
		return end() - startPos;
	}
	def bind(addr: Addr) {
		addr.absolute = this.addr();
	}
	def bindSize(addr: Addr) {
		addr.size = this.addr() - addr.absolute;
	}
}
