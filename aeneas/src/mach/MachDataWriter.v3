// Copyright 2011 Google Inc. All rights reserved.
// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum PatchKind {
	REL_32,
	RELA_32,
	ABS_32,
	ABS_64,
	ABS_SLEB32,
	ARM64_REL_IMM19,
	ARM64_ABS_IMM16,
	ARM64_REL_IMM26
}

// A specialized DataWriter with machine-level properties, such as a start address
// and the ability to encode an address that is tracked for later patching.
class MachDataWriter extends DataWriter {
	def pageAlign: Alignment;
	var startPos: int; // start position from which offset() is calculated
	var patches: List<(PatchKind, Addr, /*posAddr:*/long, /*pos:*/int)>;

	new(pageAlign, startAddr: long, initialSize: int) {
		this.startAddr = u64.!(startAddr);
		grow(initialSize);
	}

	def recordPatch(kind: PatchKind, addr: Addr, pos: int) {
		patches = List.new((kind, addr, addr_of(pos), pos), patches);
	}
	def patch(mach: MachProgram) {
		for (l = patches; l != null; l = l.tail) {
			var t = l.head, kind = t.0, addr = t.1, posAddr = t.2, pos = t.3;
			if (CLOptions.PRINT_PATCH.val) {
				TerminalBuffer.new()
					.puts("patch-code @0x")
					.putx(posAddr)
					.puts(" <- ")
					.putcv(addr, null)
					.outt();
			}
			var absAddr = mach.absolute(addr);
			if (CLOptions.PRINT_PATCH.val) {
				TerminalBuffer.new()
					.puts(" = 0x")
					.putx(absAddr)
					.outln();
			}
			at(pos);
			match (t.0) {
				REL_32 => {
					put_b32(int.!(absAddr - posAddr));
				}
				RELA_32 => {
					var delta = i8.view(data[pos + 1]);
					put_b32(int.!(absAddr - (posAddr + delta)));
				}
				ABS_32 => {
					put_b32(int.!(absAddr));
				}
				ABS_64 => {
					put_b64(absAddr);

				}
				ABS_SLEB32 => {
					overwrite_sleb32(int.!(absAddr));
				}
				_ => mach.prog.ERROR.fail1("unimplemented patch code: %s", kind.name);
			}
		}
	}
	def abs4(addr: Addr, encoding: int) {
		recordPatch(PatchKind.ABS_32, addr, pos);
		put_b32(encoding);
	}
	def skipPage() {
		skipAddr(pageAlign.size);
	}
	def endPageAddr() -> long {
		return pageAlign.alignDown_i64(addr_end());
	}
	def putmd(w: MachDataWriter) {
		var p = this.pos;
		putr(w.alias());
		for (l = w.patches; l != null; l = l.tail) {
			var t = l.head;
			patches = List.new((t.0, t.1, t.2 + p, t.3 + p), patches);
		}
		w.patches = null;
	}
	def offset() -> int {
		return pos - startPos;
	}
	def endOffset() -> int {
		return end() - startPos;
	}
	def bind(addr: Addr) {
		addr.absolute = this.addr();
	}
	def bindSize(addr: Addr) {
		addr.size = this.addr() - addr.absolute;
	}
}
