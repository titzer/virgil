// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class Operator2(opcode: Opcode2) {
	private var openness: Open;			// lazily computed open / closed
	private var paramType: Type;
	private var paramTypes: Array<Type>;
	private var resultType: Type;
	private var resultTypes: Array<Type>;

	def getParamType() -> Type {
		if (paramType != null) return paramType;
		return computeTypes().paramType;
	}
	def getParamTypes() -> Array<Type> {
		if (paramTypes != null) return paramTypes;
		return computeTypes().paramTypes;
	}
	def getResultType() -> Type {
		if (resultType != null) return resultType;
		return computeTypes().resultType;
	}
	def getResultTypes() -> Array<Type> {
		if (resultTypes != null) return resultTypes;
		return computeTypes().resultTypes;
	}
	def subst(func: Type -> Type) -> Operator2 {
		if (checkOpenness() == Open.CLOSED) return this;
		return Operator2.new(Opcodes2.subst(opcode, func));
	}
	def checkOpenness() -> Open {
		if (openness != Open.UNKNOWN) return openness;
		return openness = Opcodes2.checkOpenness(opcode);
	}
	private def substArray(func: Type -> Type, args: Array<Type>) -> Array<Type> {
		for (i < args.length) {
			var t = args[i], nt = func(t);
			if (t != nt) {
				var nargs = Array<Type>.new(args.length);
				for (j < i) nargs[j] = args[j];
				nargs[i] = nt;
				for (j = i + 1; j < args.length; j++) nargs[j] = func(args[j]);
				return nargs;
			}
		}
		return args;
	}
	private def computeTypes() -> this {
		match (opcode) {
			// Boolean operators
			BoolEq =>			set(TYPE_zz, arr_zz, TYPE_z, arr_z);
			BoolAnd =>			set(TYPE_zz, arr_zz, TYPE_z, arr_z);
			BoolOr =>			set(TYPE_zz, arr_zz, TYPE_z, arr_z);
			BoolNot =>			set(TYPE_z, arr_z, TYPE_z, arr_z);
			// Integer arithmetic and conversions
			IntEq(t) =>			set_xx_z(t);
			IntAdd(t) =>			set_xx_x(t);
			IntSub(t) =>			set_xx_x(t);
			IntMul(t) =>			set_xx_x(t);
			IntDiv(t) =>			set_xx_x(t);
			IntMod(t) =>			set_xx_x(t);
			IntAnd(t) =>			set_xx_x(t);
			IntOr(t) =>			set_xx_x(t);
			IntXor(t) =>			set_xx_x(t);
			IntShl(t) =>			set_xx_x(t);
			IntSar(t) =>			set_xx_x(t);
			IntShr(t) =>			set_xx_x(t);
			IntLt(t) =>			set_xx_z(t);
			IntLteq(t) =>			set_xx_z(t);
			IntWide(op, p, r) =>		set_arr(p, r);
			// Floating point arithmetic
			FloatAdd(t) =>			set_xx_x(t);
			FloatSub(t) =>			set_xx_x(t);
			FloatMul(t) =>			set_xx_x(t);
			FloatDiv(t) =>			set_xx_x(t);
			FloatBitEq(t) =>		set_xx_z(t);
			FloatEq(t) =>			set_xx_z(t);
			FloatNe(t) =>			set_xx_z(t);
			FloatLt(t) =>			set_xx_z(t);
			FloatLteq(t) =>			set_xx_z(t);
			FloatAbs(t) =>			set_x_x(t);
			FloatCeil(t) =>			set_x_x(t);
			FloatFloor(t) =>		set_x_x(t);
			FloatSqrt(t) =>			set_x_x(t);
			// Integer casts and conversions
			IntCastF(to, from) =>		set_x_y(from, to);
			IntQueryF(to, from) =>		set_x_z(from);
			IntViewI(to, from) =>		set_x_y(from, to);
			IntViewF(to, from) =>		set_x_y(from, to);
			IntTruncF(to, from) =>		set_x_y(from, to);
			// Floating point casts and conversions
			FloatCastI(to, from) =>		set_x_y(from, to);
			FloatCastD(to, from) =>		set_x_y(from, to);
			FloatQueryI(to, from) =>	set_x_z(from);
			FloatQueryD(to, from) =>	set_x_z(from);
			FloatPromoteI(to, from) =>	set_x_y(from, to);
			FloatPromoteF(to, from) =>	set_x_y(from, to);
			FloatViewI(to, from) =>		set_x_y(from, to);
			FloatRoundI(to, from) =>	set_x_y(from, to);
			FloatRound(t) =>		set_x_y(t, t);
			FloatRoundD(to, from) =>	set_x_y(from, to);
			// Reference equality
			RefEq(t) =>			set_xx_z(t);
			// Default value operator
			DefaultValue(t) =>		set(TYPE_v, arr_v, t, [t]);
			IntRepCreate(to, from) => 	set_x_y(from, to);
			IntRepView(to, from) => 	set_x_y(from, to);
			// Tuple operations
			TupleCreate(t) => {
				var paramTypes = Lists.toArray(t.nested);
				set(t, paramTypes, t, [t]);
			}
			TupleGetElem(t, index) => {
				var e = Lists.get(t.nested, index);
				set(t, [t], e, [e]);
			}
			// Array operations
			ArrayAlloc(t) =>			set_x_y(Int.TYPE, t);
			ArrayInit(t, length) =>	{
				var elemType = t.elementType();
				var paramTypes = Array<Type>.new(length);
				for (i < paramTypes.length) paramTypes[i] = elemType;
				set(Tuple.fromTypeArray(paramTypes), paramTypes, t, [t]);
			}
			ArrayFill(t) =>	{
				var elemType = t.elementType();
				var paramTypes = [t, elemType];
				set(Tuple.fromTypeArray(paramTypes), paramTypes, t, [t]);
			}
			ArrayTupleInit(t, elems, length) => {
				var elemType = t.elementType();
				var paramTypes = Array<Type>.new(elems * length);
				var tuple = Tuple.toTypeArray(elemType);
				var i = 0;
				for (j < length) {
					for (k < tuple.length) {
						paramTypes[i++] = tuple[k];
					}
				}
				set(Tuple.fromTypeArray(paramTypes), paramTypes, t, [t]);
			}
			ArrayGetElem(t, it) =>			set_arr([t, it], [t.elementType()]);
			ArraySetElem(t, it) =>			set_arr([t, it, t.elementType()], arr_v);
			ArrayGetElemElem(t, it, index) => {
				var etype = Tuple.elementType(t.elementType(), index);
				var paramTypes = [t, it];
				set(Tuple.fromTypeArray(paramTypes), paramTypes, etype, [etype]);
			}
			ArraySetElemElem(t, it, index) => {
				var etype = Tuple.elementType(t.elementType(), index);
				var tt = [t, it, etype];
				set(Tuple.fromTypeArray(tt), tt, TYPE_v, arr_v);
			}
			ArrayGetLength(t) =>			set_x_y(t, Int.TYPE);
			// Range operations
			RangeFromTo(t, st, et) =>		set_arr([t, st, et], [t]);
			RangeFromPlus(t, st, lt) =>		set_arr([t, st, lt], [t]);
			RangeGetElem(t, it) =>			set_arr([t, it], [t.elementType()]);
			RangeSetElem(t, it) =>			set_arr([t, it, t.elementType()], arr_v);
			RangeGetLength(t) =>			set_x_y(t, Int.TYPE);
			RangeStartPlusIndex(t, it) =>		set_arr([t, it], arr_rs);
			RangeStartFromPointer(t, pt) =>		set_arr([t, pt], [pt]);
			// Normalized Range operations
			NormRangeGetElem(t, it) =>		set_arr([t, TYPE_rs, it], [t.elementType()]);
			NormRangeGetElemElem(t, index, it) =>	set_arr([t, TYPE_rs, it], [Tuple.elementType(t.elementType(), index)]);
			NormRangeSetElem(t, it) =>		set_arr([t, TYPE_rs, it, t.elementType()], arr_v);
			NormRangeSetElemElem(t, index, it) =>	set_arr([t, TYPE_rs, it, Tuple.elementType(t.elementType(), index)], arr_v);
			// Component operations
			Init(method) =>				set(TYPE_v, arr_v, TYPE_v, arr_v);
			ComponentGetField(field) =>		set(TYPE_v, arr_v, field.fieldType, [field.fieldType]);
			ComponentSetField(field) =>		set(field.fieldType, [field.fieldType], TYPE_v, arr_v);
			// Class operations
			ClassAlloc(spec) => {
				var ftype = spec.getBoundType(), p = Function.getParamType(ftype);
				set(p, Tuple.toTypeArray(p), spec.receiver, [spec.receiver]);
			}
			ClassEmptyAlloc(classType, paramTypes) => {
				set(Tuple.fromTypeArray(paramTypes), paramTypes, classType, [classType]);
			}
			ClassGetField(spec) => {
				var r = spec.receiver, f = spec.getFieldType();
				set(r, [r], f, Tuple.toTypeArray(f));
			}
			ClassInitField(spec) =>	{
				var r = spec.receiver, f = spec.getFieldType(), arr = [r, f];
				set(Tuple.fromTypeArray(arr), arr, TYPE_v, arr_v);
			}
			ClassSetField(spec) => {
				var r = spec.receiver, f = spec.getFieldType(), arr = [r, f];
				set(Tuple.fromTypeArray(arr), arr, TYPE_v, arr_v);
			}
			ClassGetMethod(spec) =>	{
				var r = spec.receiver, f = spec.getBoundType();
				set_x_y(r, f);
			}
			ClassGetVirtual(spec) => {
				var r = spec.receiver, f = spec.getBoundType();
				set_x_y(r, f);
			}
			ClassGetSelector(spec) => {
				var r = spec.receiver, f = spec.getFuncType();
				set_x_y(r, f);
			}
			// Variant operations
			VariantEq(t) =>				set_xx_z(t);
			VariantGetTag(t) =>			set_x_y(t, V3.getVariantTagType(t));
			VariantGetField(spec) => {
				var r = spec.receiver, f = spec.getFieldType();
				set(r, [r], f, Tuple.toTypeArray(f));
			}
			VariantGetMethod(spec) => {
				var r = spec.receiver, f = spec.getBoundType();
				set_x_y(r, f);
			}
			VariantGetVirtual(spec) => {
				var r = spec.receiver, f = spec.getBoundType();
				set_x_y(r, f);
			}
			VariantGetSelector(spec) => {
				var r = spec.receiver, f = spec.getFuncType();
				set_x_y(r, f);
			}
			// Safety checks
			NullCheck(t) =>				set(t, [t], TYPE_v, arr_v);
			BoundsCheck(t) =>			set_arr([t, TYPE_i], arr_v);
			ConditionalThrow(exception) =>		set(TYPE_z, arr_z, TYPE_v, arr_v);
			// Overloaded, polymorphic casts
			OverloadedEq(t) =>			set_xx_z(t);
			TypeCast(cast, to, from) =>		set_x_y(from, to);
			TypeQuery(query, to, from) =>		set_x_z(from);
			TypeSubsume(to, from) =>		set_x_y(from, to);
			// Closure and call operations
			CallMethod(spec) => {
				var ftype = FuncType.!(spec.getUnboundType());
				set_ftype(ftype);
			}
			CallClassMethod(spec) => {
				var ftype = FuncType.!(spec.getUnboundType());
				set_ftype(ftype);
			}
			CallClassVirtual(spec) => {
				var ftype = FuncType.!(spec.getUnboundType());
				set_ftype(ftype);
			}
			CallClassSelector(spec) => {
				var ftype = FuncType.!(spec.getUnboundType());
				set_ftype(ftype);
			}
			CallVariantVirtual(spec) => {
				var ftype = FuncType.!(spec.getUnboundType());
				set_ftype(ftype);
			}
			CallVariantSelector(spec) => {
				var ftype = FuncType.!(spec.getUnboundType());
				set_ftype(ftype);
			}
			CallClosure(t) => {
				var sig = t.sig();
				set_arr(Arrays.prepend(t, sig.paramTypes), sig.returnTypes);
			}
			CallFunction(t) => {
				var sig = t.sig(), ftype = t.prependParam(AnyRef.TYPE);
				set_arr(Arrays.prepend(ftype, sig.paramTypes), sig.returnTypes);
			}
			CreateClosure(obj, method) => {
				set_x_y(obj, method.getBoundType());
			}
			ForgeClosure(ptrType, closureType, paramType, resultType) => {
				var funcType = Function.newType(paramType, resultType);
				set_arr([ptrType, closureType], [funcType]);
			}
			UnpackClosure(ptrType, closureType, paramType, resultType) => {
				var funcType = Function.newType(paramType, resultType);
				set_arr([funcType], [ptrType, closureType]);
			}
			// RefLayout operations
			RefLayoutAt(t) =>					set_arr([V3.arrayByteType, Int.TYPE], [t]);
			RefLayoutOf(t) =>					set_arr([V3.rangeByteType], [t]);
			RefLayoutIn(t, offset, rt) => 				set_x_y(t, rt);
			RefLayoutGetField(t, offset, ft) =>			set_x_y(t, ft);
			RefLayoutSetField(t, offset, ft) =>			set_arr([t, ft], arr_v);
			RefLayoutAtRepeatedField(t, offset, scale, max, rt) =>	set_arr([t, TYPE_i], [rt]);
			RefLayoutGetRepeatedField(t, offset, scale, max, ft) =>	set_arr([t, TYPE_i], [ft]);
			RefLayoutSetRepeatedField(t, offset, scale, max, ft) =>	set_arr([t, TYPE_i], [ft]);
			ByteArrayGetField(st, offset, ft) =>			set_arr([TYPE_ab, st], [ft]);
			ByteArraySetField(st, offset, ft) =>			set_arr([TYPE_ab, st], [ft]);
			ForgeRange(ptrType, t) => 				set_arr([ptrType, TYPE_i], [t]);
			// System operations
			SystemCall(syscall, paramType, resultType) =>		set_ftype(FuncType.!(Function.newType(paramType, resultType)));
			// Container for VST operations
			VstSugar(op, paramType, resultType) =>			set_ftype(FuncType.!(Function.newType(paramType, resultType)));
			// Pointer operations
			PtrAdd(t, it) =>				set_arr([t, it], [t]);
			PtrSub(t, it) =>				set_arr([t, t], [it]);
			PtrLt(t) =>					set_xx_z(t);
			PtrLteq(t) =>					set_xx_z(t);
			PtrAtContents(t, at) =>				set_x_y(at, t);
			PtrAtLength(t, arrayType) =>			set_x_y(arrayType, t);
			PtrAtObject(t, objType) =>			set_x_y(objType, t);
			PtrAtRangeElem(t, rangeType, it) =>		set_arr([rangeType, it], [t]);
			PtrAtArrayElem(t, arrayType, it) =>		set_arr([arrayType, it], [t]);
			PtrAtEnd(t, objType) =>				set_x_y(objType, t);
			PtrAtRef(t, refType) =>				set_x_y(refType, t);
			PtrAtComponentField(t, field) =>		set(TYPE_v, arr_v, t, [t]);
			PtrAtObjectField(t, field) =>			set_x_y(field.receiver, t);
			PtrAtRefLayoutField(refType, t, offset) =>	set_x_y(refType, t);
			PtrCmpSwp(t, valType) =>			set_arr([t, valType, valType], arr_z);
			PtrLoad(t, valType) =>				set_x_y(t, valType);
			PtrStore(t, valType) =>				set_arr([t, valType], arr_v);
			PtrAddRangeStart(t) =>				set_arr([t, TYPE_rs], [t]);
			// Get caller instruction pointer or stack pointer
			CallerIp(t) =>				set(TYPE_v, arr_v, t, [t]);
			CallerSp(t) =>				set(TYPE_v, arr_v, t, [t]);
			// Allocate raw memory
			Alloc(t) =>				set(TYPE_v, arr_v, t, [t]);
			// Call
			CallAddress(p, rep) => {
				var funcType = rep.machType.nested.head;
				set_arr(rep.paramTypes, [Function.getReturnType(funcType)]);
			}
			CallKernel(kernel, paramType, resultType) => {
				set(paramType, Tuple.toTypeArray(paramType), resultType, Tuple.toTypeArray(resultType));
			}
		}
	}
	def isPolymorphic() -> bool {
		return checkOpenness() == Open.OPEN;
	}
	private def set_x_x(x: Type) {
		var arr_x = [x];
		set(x, arr_x, x, arr_x);
	}
	private def set_x_y(x: Type, y: Type) {
		set(x, [x], y, [y]);
	}
	private def set_x_z(x: Type) {
		set(x, [x], TYPE_z, arr_z);
	}
	private def set_xx_x(x: Type) {
		set(Tuple.newType(Lists.cons2(x, x)), [x, x], x, [x]);
	}
	private def set_xx_z(x: Type) {
		set(Tuple.newType(Lists.cons2(x, x)), [x, x], TYPE_z, arr_z);
	}
	private def set_ftype(f: FuncType) {
		var paramTypes = Function.getParamTypeArray(f);
		var returnType = Function.getReturnType(f);
		set(Tuple.fromTypeArray(paramTypes), paramTypes, returnType, Tuple.toTypeArray(returnType));
	}
	private def set_arr(p: Array<Type>, r: Array<Type>) {
		paramType = if(p.length == 1, p[0], Tuple.fromTypeArray(p));
		paramTypes = p;
		resultType = if(r.length == 1, r[0], Tuple.fromTypeArray(r));
		resultTypes = r;
	}
	private def set(p: Type, pa: Array<Type>, r: Type, ra: Array<Type>) {
		paramType = p;
		paramTypes = pa;
		resultType = r;
		resultTypes = ra;
	}
}

def TYPE_v = Void.TYPE;
def TYPE_z = Bool.TYPE;
def TYPE_i = Int.TYPE;
def arr_v: Array<Type> = [];
def arr_z: Array<Type> = [TYPE_z];
def arr_zz: Array<Type> = [TYPE_z, TYPE_z];
def TYPE_zz = Tuple.fromTypeArray(arr_zz);
def TYPE_rs = V3Range.START_TYPE;
def arr_rs: Array<Type> = [TYPE_rs];
def TYPE_ab = V3.arrayByteType;
