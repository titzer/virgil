// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.
enum InitState { Uninit, Running, Done }
// A collection of all the entities in a program, including the parsed files,
// the syntax tree (vst), the intermediate representation (ir), and dynamic portion
// (initialized state).
class Program(compiler: Compiler) {
	// file and argument portions of the program
	def ERROR = ErrorGen.new(15);		// error generator
	var files: Array<string>;		// the input files
	var inputs: Array<Array<byte>>;		// the input data
	var args: Array<string>;		// input arguments
	var opBuilder: IrOpMethodBuilder;
	// static parts of the program
	def typeCache = TypeCache.new();
	def typeEnv = TypeEnv.new(null, null, V3.lookupToplevelType);
	var layouts: HashMap<string, VstLayout>;
	var packings: HashMap<string, VstPacking>;
	var vst: VstModule;
	var ir: IrModule;
	var global: Type;
	var mainRootIndex = -1;
	var explicitName: string;
	var tprog: TargetProgram;

	// Function subsumption wrapping / mapping tables
	//   When a function type F1 id a subtype of function type F2, but not the
	//   same type, F2 subsumes F1.  Some targets do not allow treating F1 instances
	//   as F2 instances in their run-times, because of stricter type rules.  In
	//   this case f of type F1 requires a wrapper, e.g., wf, of type F2 that just
	//   turns around and calls f.  Example: class B extends class A, F1 is void -> A
	//   and F2 is void -> B.  Let f: void -> B in a context that wants a function
	//   of type void -> A.  We can create internally a wrapper equivalent to:
	//   def wf() -> A { return f(); }.  This generalizes, with some care to handle
	//   nested subsmptions when argument / result types are themselves function
	//   types.
	//
	//   In the case where var v: F1, that is, an unknown function, we require a
	//   *mapper* that takes in a *function* of type F1 and returns a wrapped
	//   version of type F2.  This requires generating a wrapper for *every* function
	//   of type F1, and generating the mapper as well.
	//
	//   If function values are compared (== or !=) other than against null, we need
	//   to ensure that we compare a canonical version of the functions as opposed to
	//   possibly different wrappers for the same underlying function.  In this case,
	//   if required, we generate an *unmapper* that takes in a function are returns
	//   its (fully) unwrapped version.  Those may then me compared.
	//

	// (wrappee func type, wrapper func type) => (wrappee => wrapper)
	//   used to find wrapper for a given wrappee subsumption
	//   requires normalization
	var wrappedFunctionWrapper = TypeUtil.newTypePairMap<HashMap<IrSpec,IrSpec>>();

	// Vector of (wrappee func type, wrapper func type, wrappee, wrapper)
	//   used to iterate and build mappers
	//   requires normalization
	var wrappedFunctionWrapperVec = Vector<(Type, Type, IrSpec, IrSpec)>.new();

	// (wrappee func type, wrapper func type) => mapper method
	//   used to find mapper for a given func type subsumption
	//   requires normalization
	var wrappedFunctionTypeMapper = TypeUtil.newTypePairMap<IrSpec>();

	// Vector of (wrappee func type, wrapper func type, mapper method)
	//   used to iterate over mappers
	//   requires normalization
	var wrappedFunctionTypeMapperVec = Vector<(Type, Type, IrSpec)>.new();

	// Hash set of (wrappee func type, wrapper func type)
	//   used (during reachability analysis) to indicate that a mapper is required
	//   does not require normalization
	def functionTypeMapperRequests = TypeUtil.newTypePairMap<void>();

	// Vector of (wrappee func type, wrapper func type)
	//   used to iterate over mapper requests
	//   does not require normalization
	def functionTypeMapperRequestsVec = Vector<(Type, Type)>.new();

	// Set of (wrapped func type)
	//   used (during reachability analysis) to indicate possible need for an unmapper
	//   does not require normalization
	var unmapperRequests = TypeUtil.newTypeMap<void>();

	// Vector of (wrapped func type)
	//   used to iterate over unmapper requests
	//   does not require normalization
	var unmapperRequestsVec = Vector<Type>.new();

	// Func type => unmapper for that type
	//   used to find unmapper in normalization
	//   requires normalization
	var unmapper = TypeUtil.newTypeMap<IrSpec>();

	// Vector of (func type, unmapper for that type)
	//   used to iterate over unmappers
	//   requires normalization
	var unmapperVec = Vector<(Type, IrSpec)>.new();

	// Type -> List of wrappers that have that type
	//   used to build unmappers
	//   requires normalization
	var wrappers = TypeUtil.newTypeMap<List<IrSpec>>();

	// wrapper => wrappee
	//   used to build unmappers
	//   requires normalization
	var wrappeeForWrapper = HashMap<IrSpec, IrSpec>.new(IrSpec.hash, IrSpec.equals);

	// End of wrapping / mapping tables


	// dynamic portion of the program, including initialized state
	var initState: Array<InitState>;
	var compRecords: Array<Record>;
	var strRecords: Array<Record>;
	var recordCount: int;
	var system: SystemCallState;

	new() {
		opBuilder = IrOpMethodBuilder.new(this);
	}
	def setInput(fname: string, input: Array<byte>) {
		files = [fname];
		inputs = [input];
	}
	def reportErrors() -> bool {
		if (ERROR.noErrors) return true;
		else ERROR.report();
		return false;
	}
	def getMain() -> IrSpec {
		return if (mainRootIndex >= 0, ir.roots[mainRootIndex].spec);
	}
	def name() -> string {
		if (explicitName != null) return explicitName;
		if (mainRootIndex >= 0) return getMain().asMethod().source.receiver.name();
		for (i < ir.roots.length) {
			var r = ir.roots[i];
			if (r == null || !r.spec.isMethod()) continue;
			var s = r.spec.asMethod().source;
			if (s != null) return s.receiver.name();
		}
		return "program";
	}
	def globalType() -> Type {
		if (global == null) {
			var name = Arrays.concat(name(), "$global");
			var decl = VstComponent.new(false, false, null, Token.new("<generated>", name, 0, 0), null);
			var typeCon = V3Component_TypeCon.new(decl, typeCache);
			decl.memberMap = Strings.newMap();
			global = typeCon.create0();
			decl.recordIndex = vst.numComponents++;
		}
		return global;
	}
	def getComponentRecord(comp: VstComponent) -> Record {
		if (compRecords == null) return null;
		var index = comp.recordIndex;
		if (index >= compRecords.length) return null;
		return compRecords[index];
	}
	def setComponentRecord(comp: VstComponent, record: Record) {
		var index = comp.recordIndex;
		if (compRecords == null) {
			compRecords = Array.new(index + 1);
		} else if (index >= compRecords.length) {
			compRecords = Arrays.grow(compRecords, index + 1);
		}
		compRecords[index] = record;
	}
	def getStringRecord(sexpr: StringExpr) -> Record {
		var record = strRecords[sexpr.recordIndex];
		if (record == null) {
			var image = sexpr.array;
			record = newRecord(sexpr.exactType, image.length);
			Arrays.mapInto(image, Byte.box, record.values);
			strRecords[sexpr.recordIndex] = record;
		}
		return record;
	}
	def newRecord(rtype: Type, size: int) -> Record {
		return Record.new(recordCount++, rtype, Array<Val>.new(size));
	}
	def getDefaultValue(t: Type) -> Val {
		match (t.typeCon.kind) {
			VOID, BOOL, INT, FLOAT, ARRAY, COMPONENT, CLASS,
			CLOSURE, FUNCREF, ANYFUNC, ENUM, ENUM_SET, POINTER, REF, RANGE, RANGE_START => return Values.BOTTOM;
			VARIANT => {
				var prev = ir.getDefaultVal(t);
				if (prev != null) return prev;
				var ct = ClassType.!(t);
				var decl = ct.classDecl;
				if (decl.superclass == null) {
					if (decl.cases.length > 0) t = decl.cases[0].decl.typeCon.create(t.nested);
				}
				var ic = ir.makeIrClass(t);
				var record = newRecord(t, ic.fields.length);
				record.h0 = 0;
				ir.defaultValues[ct] = record;
				ir.defaultValues[t] = record;
				var typeArgs = ct.getTypeArgs();
				for (i < ic.fields.length) {
					var ft = ic.fields[i].fieldType;
					if (typeArgs != null) ft = ft.substitute(typeArgs);
					record.values[i] = getDefaultValue(ft);
				}
				return record;
			}
			TUPLE => {
				var prev = ir.getDefaultVal(t);
				if (prev != null) return prev;
				var at = Tuple.toTypeArray(t);
				var tv = BoxVal.new(null, Array<Val>.new(at.length));	
				ir.defaultValues[t] = tv;
				for (i < at.length) tv.values[i] = getDefaultValue(at[i]);
				return tv;
			}
			TYPE_PARAM,
			TYPE_VAR => return V3.fail1("cannot get default value for type %q", t.render);
		}
	}
	def hasTrivialDefaultValue(t: Type) -> bool {
		if (t == null) return true;
		match (t.typeCon.kind) {
			TUPLE => {
				for (l = t.nested; l != null; l = l.tail) if(!hasTrivialDefaultValue(l.head)) return false;
			}
			VARIANT,
			TYPE_PARAM,
			TYPE_VAR => return false;
			_ => ;
		}
		return true;
	}
	def genWrappedFunction(ft: Type, tt: Type, spec: IrSpec, ra: ReachabilityAnalyzer) -> IrSpec {
		// ra may be null, but if non-null can be used to request any needed mapper
		var nspec = getWrappedFunction(ft, tt, spec);
		if (nspec != null) return nspec;
		var ftCanon = Function.funcRefType(ft);
		var ttCanon = Function.funcRefType(tt);

		if (!wrappedFunctionWrapper.has((ftCanon, ttCanon))) {
			wrappedFunctionWrapper[(ftCanon, ttCanon)] = HashMap<IrSpec,IrSpec>.new(IrSpec.hash,IrSpec.equals);
		}
		var ht = wrappedFunctionWrapper[(ftCanon, ttCanon)];
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.green().puts("genWrappedFunction:").end()
				.put3(" a FuncVal of %q{%d/%d}", spec.asMethod().render,
					spec.asMethod().index, spec.asMethod().uid).outln();
		}

		// build SSA params and types
		def orig = spec.asMethod();
//		def receiver = orig.receiver;
		var receiver = spec.receiver;
		if (receiver.open()) receiver = spec.instantiateType(spec.receiver);
//		def ftype = FuncType.!(spec.instantiateType(ft));
//		def ttype = FuncType.!(spec.instantiateType(tt));
		def ftype = FuncType.!(ft);
		def ttype = FuncType.!(tt);
		def fsig = ftype.sig();
		var tsig = ttype.sig();
		def mtype = spec.getBoundType();
		if (mtype.typeCon.kind == Kind.CLOSURE) {
			tsig = Signature.new(null, tsig.paramTypes, tsig.returnTypes);
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.green().puts("genWrappedFunction:").end()
					.put1(" bound type %q is a closure", mtype.render)
					.outln();
			}
		}

		// We create the method here
//		var typeArgs = spec.getTypes().methodTypeArgs;
		var typeArgs = orig.typeArgs;
		var ntypeArgs = if (typeArgs == null, null, TypeArgs.new(typeArgs.typeEnv, [receiver]));
//		var meth = opBuilder.createIrMethod(receiver, typeArgs, tsig);
		var meth = opBuilder.createIrMethod(receiver, ntypeArgs, tsig);
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.green().puts("genWrappedFunction:").end()
				.put2(" ft %q tt %q", ftype.render, ttype.render)
				.put1(" bound type %q", spec.getBoundType().render)
				.put1(" method type %q", spec.asMethod().getMethodType().render)
				.outln();
			Terminal.buf.put1("wrappee is %q", receiver.render)
				.put3(".%q{%d/%d}", spec.render, orig.index, orig.uid)
				.put1(" with type %q", spec.getBoundType().render).outln();
			Terminal.buf.put1("wrapper is %q", meth.receiver.render)
				.put3(".%q{%d/%d}", meth.render, meth.index, meth.uid)
				.put3(" with type %q (tsig %q fsig %q)", meth.getMethodType().render, tsig.funcType().render, fsig.funcType().render).outln();
			if (typeArgs == null) {
				Terminal.buf.puts("orig typeArgs is null").outln();
			} else {
				Terminal.buf.put1("orig typeArgs %q", orig.typeArgs.render).outln();
			}
			if (meth.typeArgs == null) {
				Terminal.buf.puts("meth typeArgs is null").outln();
			} else {
				Terminal.buf.put1("meth typeArgs %q", meth.typeArgs.render).outln();
			}
		}

		meth.setFact(Fact.M_WRAPPER);
		var inner = SsaContext.new(compiler, this);
		inner.enterMethod(meth);
		var block = opBuilder.createSsa(inner, receiver, meth);
		// build block
		var args = Arrays.map(meth.ssa.params, SsaInstr.!<SsaParam>);
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.put1("args[0]: %q", args[0].getType().render).outln();
		}
		for (i = 1; i < args.length; ++i) {
			if (tsig.paramTypes[i-1] != fsig.paramTypes[i-1]) {
				args[i] = block.opTypeSubsume(tsig.paramTypes[i-1], fsig.paramTypes[i-1], args[i]);
				var op: SsaApplyOp;
				if (ra != null &&
				    SsaApplyOp.?(args[i]) &&
				    (op = SsaApplyOp.!(args[i])).op.opcode == Opcode.TypeSubsume) {
					ra.analyzeOp(op, null);  // may request a mapper
				}
			}
		}
		var apply: SsaInstr;
		var op: Operator;
		if (V3.isComponent(receiver)) {
			op = V3Op.newCallMethod(spec);
			args[0] = inner.graph.nullReceiver();
//			args[0] = inner.graph.nullConst(AnyRef.TYPE);
		} else {
			op = V3Op.newCallClassMethod(spec);
		}
		apply = block.addApply(null, op, args);
		if (ftype.returnType() != ttype.returnType()) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.puts("wrapper includes return subsume").outln();
			}
			apply = block.opTypeSubsume(ftype.returnType(), ttype.returnType(), apply);
			var op: SsaApplyOp;
			if (false && ra != null &&
			    SsaApplyOp.?(apply) &&
			    (op = SsaApplyOp.!(apply)).op.opcode == Opcode.TypeSubsume) {
				ra.analyzeOp(op, null);  // may request a mapper
			}
		}
		block.addReturn([apply]);
		inner.printSsa("Generated wrapper");

		// create the IrSpec
		var wrapper = IrSpec.new(receiver, spec.typeArgs, meth);

		ht[spec] = wrapper;
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.put1("Wrapper stored under spec %q", spec.render).outln();
		}
		wrappedFunctionWrapperVec.put((ftCanon, ttCanon, spec, wrapper));
		wrappers[ttCanon] = List.new(wrapper, wrappers[ttCanon]);
		wrappeeForWrapper[wrapper] = spec;
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.green().puts("genWrappedFunction:").end().outln()
				.cyan().puts("    from type ").end().put1("%q", ft.render)
				.cyan().puts("  to type ").end().put1("%q", tt.render).outln()
				.cyan().puts("    from canoncial type ").end().put1("%q", ftCanon.render)
				.cyan().puts("  to canonical type ").end().put1("%q", ttCanon.render).outln()
				.cyan().puts("    wrappee ").end().put3("%q{%d/%d}", spec.render, spec.asMethod().index, spec.asMethod().uid)
				.cyan().puts("  wrapper ").end().put3("%q{%d/%d}", wrapper.render, wrapper.asMethod().index, wrapper.asMethod().uid).outln()
				.cyan().puts("    wrappee rcvr ").end().put1("%q", spec.receiver.render)
				.cyan().puts(" type ").end().put1("%q", spec.asMethod().sig.funcType().render).outln()
				.cyan().puts("    wrapper rcvr ").end().put1("%q", wrapper.receiver.render)
				.cyan().puts(" type ").end().put1("%q", wrapper.asMethod().sig.funcType().render).outln();
		}
		return wrapper;
	}
	def genWrappedFunctionRA(ra: ReachabilityAnalyzer, ft: Type, tt: Type, spec: IrSpec) -> IrSpec {
		if (CLOptions.PRINT_RA.get()) {
			var m = spec.asMethod();
			Terminal.buf.green().puts("genWrappedFunctionRA:").end()
				.put3(" method %q{%d/%d} not found", spec.render,
					m.index, m.uid).outln();
		}
		var nspec = getWrappedFunction(ft, tt, spec);
		if (nspec != null) return nspec;
		nspec = genWrappedFunction(ft, tt, spec, ra);
// EBM adding specs
		var rm = ra.makeMethod(nspec.typeArgs, nspec.asMethod(), nspec);
		ra.getMethod(null, rm);
		var raSpec = rm.getSpec();
		if (CLOptions.PRINT_RA.get()) {
			var m = spec.asMethod();
			Terminal.buf.green().puts("genWrappedFunctionRA:").end()
				.put3(" returning %q{%d/%d", raSpec.render, raSpec.asMethod().index, raSpec.asMethod().uid)
				.put1("/%d}", rm.uid)
				.put3(" nspec %q{%d/%d}", nspec.render,
					nspec.asMethod().index, nspec.asMethod().uid).outln();
		}
		return raSpec;
	}
	def getWrappedFunction(ft: Type, tt: Type, spec: IrSpec) -> IrSpec {
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.green().puts("getWrappedFunction:").end()
				.put2(" input types ft %q (open %z)", ft.render, ft.open())
				.put2("  tt %q (open %z)", tt.render, tt.open()).outln();
			Terminal.buf.green().puts("getWrappedFunction:").end()
				.put3(" spec %q  method receiver %q  open %z",
				      spec.render, spec.asMethod().receiver.render, spec.asMethod().receiver.open()).outln();
		}
		var ftCanon = Function.funcRefType(ft);
		var ttCanon = Function.funcRefType(tt);
		var m = spec.asMethod();
		if (!wrappedFunctionWrapper.has((ftCanon, ttCanon))) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.green().puts("getWrappedFunction:").end()
					.put3(" a FuncVal of %q{%d/%d} not found", m.render,
						m.index, m.uid)
					.put3("; ft %q  tt %q  M_NORM %z", ftCanon.render, ttCanon.render, m.facts.M_NORM).outln();
			}
			return null;
		}
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.green().puts("getWrappedFunction:").end()
				.put1(" lookup spec is %q; ", spec.render)
				.put3("method %q{%d/%d}", m.render,
					m.index, m.uid).outln();
		}
		var nspec = wrappedFunctionWrapper[(ftCanon, ttCanon)][spec];
		if (nspec == null) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.green().puts("getWrappedFunction(2):").end()
					.put3(" a FuncVal of %q{%d/%d} not found", spec.asMethod().render,
						spec.asMethod().index, spec.asMethod().uid).outln();
			}
			return null;
		}
		if (CLOptions.PRINT_RA.get()) {
			var nm = nspec.asMethod();
			Terminal.buf.green().puts("getWrappedFunction:").end()
				.put3(" looked up %q{%d/%d}, ", m.render, m.index, m.uid)
				.put3("returning %q{%d/%d}", nm.render, nm.index, nm.uid).outln();
		}
		return nspec;
	}
	def getMapper(ft: Type, tt: Type) -> IrSpec {
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("getMapper:").end()
				.put2(" ft %q  tt %q", ft.render, tt.render).outln();
		}
		var ftCanon = Function.funcRefType(ft);
		var ttCanon = Function.funcRefType(tt);
		if (!wrappedFunctionTypeMapper.has((ftCanon, ttCanon))) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.purple().puts("getMapper: not found").end().outln();
			}
			return null;
		}
		return wrappedFunctionTypeMapper[(ftCanon, ttCanon)];
	}
	def requestMapper(ft: Type, tt: Type) {
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("requestMapper:").end()
				.put2(" ft %q  tt %q", ft.render, tt.render).outln();
		}
		var ftCanon = Function.funcRefType(ft);
		var ttCanon = Function.funcRefType(tt);
		if (!functionTypeMapperRequests.has((ftCanon, ttCanon))) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.purple().puts("requestMapper: adding request for").end()
					.put2(" ft %q  tt %q", ftCanon.render, ttCanon.render).outln();
			}
			functionTypeMapperRequests[(ftCanon, ttCanon)] = ();
			functionTypeMapperRequestsVec.put((ftCanon, ttCanon));
		}

		// check for nested subsumptions
		var fsig = FuncType.!(Function.funcRefType(ft)).sig();
		var tsig = FuncType.!(Function.funcRefType(tt)).sig();
		for (i = 0; i < fsig.paramTypes.length && i < tsig.paramTypes.length; ++i) {
			var tpt = tsig.paramTypes[i];
			if (!Function_TypeCon.?(tpt.typeCon)) continue;
			var fpt = fsig.paramTypes[i];
			if (tpt != fpt) requestMapper(tpt, fpt);  // args are contravariant
		}
		for (i = 0; i < fsig.returnTypes.length && i < tsig.returnTypes.length; ++i) {
			var trt = tsig.returnTypes[i];
			if (!Function_TypeCon.?(trt.typeCon)) continue;
			var frt = fsig.returnTypes[i];
			if (trt != frt) requestMapper(frt, trt);  // results are covariant
		}
	}
	def getUnmapper(t: Type) -> IrSpec {
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("getUnmapper:").end()
				.put1(" t %q", t.render).outln();
		}
		var canon = Function.funcRefType(t);
		if (!unmapper.has(canon)) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.purple().puts("getUnmapper: not found").end().outln();
			}
			return null;
		}
		return unmapper[canon];
	}
	def requestUnmapper(t: Type) {
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("requestUnmapper:").end()
				.put1(" t %q", t.render).outln();
		}
		var canon = Function.funcRefType(t);
		if (!unmapperRequests.has(canon)) {
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.purple().puts("requestUnmapper: adding request for").end()
					.put1(" t %q", canon.render).outln();
			}
			unmapperRequests[canon] = ();
			unmapperRequestsVec.put(canon);
		}
	}
	def normWrappingTables(rn: ReachabilityNormalizer) {
		// maps contents of wrapping, mapping, and unmapping tables to normed keys and values
		{
			var newWrappers = Vector<(Type, Type, IrSpec, IrSpec)>.new().grow(wrappedFunctionWrapperVec.length);
			var newWrapperMap = TypeUtil.newTypePairMap<HashMap<IrSpec,IrSpec>>();
			for (i < wrappedFunctionWrapperVec.length) {
				var entry = wrappedFunctionWrapperVec[i];
				var ft = entry.0, tt = entry.1, wrappee = entry.2, wrapper = entry.3;
				var nft = rn.norm(ft).newType;
				var ntt = rn.norm(tt).newType;
				if (nft.typeCon.kind == Kind.TUPLE) nft = Tuple.elementType(nft, 0);
				if (ntt.typeCon.kind == Kind.TUPLE) ntt = Tuple.elementType(ntt, 0);
				var nwrappee = rn.normalizeMethodRef(wrappee).1;
				var nwrapper = rn.normalizeMethodRef(wrapper).1;
				if (CLOptions.PRINT_RA.get()) {
					Terminal.buf.put2("normWrappingTables: old ft %q tt %q", ft.render, tt.render)
						.put3(" wrappee %q{%d/%d}", wrappee.render, wrappee.asMethod().index, wrappee.asMethod().uid)
						.put3(" wrapper %q{%d/%d}", wrapper.render, wrapper.asMethod().index, wrapper.asMethod().uid).outln();
					Terminal.buf.put2("normWrappingTables: new ft %q tt %q", nft.render, ntt.render)
						.put3(" wrappee %q{%d/%d}", nwrappee.render, nwrappee.asMethod().index, nwrappee.asMethod().uid)
						.put3(" wrapper %q{%d/%d}", nwrapper.render, nwrapper.asMethod().index, nwrapper.asMethod().uid).outln();
				}
				newWrappers.put((nft, ntt, nwrappee, nwrapper));
				var ht = newWrapperMap[(nft, ntt)];
				if (ht == null) {
					newWrapperMap[(nft, ntt)] = ht = HashMap<IrSpec,IrSpec>.new(IrSpec.hash, IrSpec.equals);
				}
				ht[nwrappee] = nwrapper;
			}
			var newMapperMap = TypeUtil.newTypePairMap<IrSpec>();
			var newMappers = Vector<(Type, Type, IrSpec)>.new().grow(wrappedFunctionTypeMapperVec.length);
			for (i < wrappedFunctionTypeMapperVec.length) {
				var entry = wrappedFunctionTypeMapperVec[i];
				var ft = entry.0, tt = entry.1, spec = entry.2;
				var nft = rn.norm(ft).newType;
				var ntt = rn.norm(tt).newType;
				if (nft.typeCon.kind == Kind.TUPLE) nft = Tuple.elementType(nft, 0);
				if (ntt.typeCon.kind == Kind.TUPLE) ntt = Tuple.elementType(ntt, 0);
				var nspec = rn.normalizeMethodRef(spec).1;
				if (CLOptions.PRINT_RA.get()) {
					Terminal.buf.put2("normWrappingTables: old mapper ft %q tt %q", ft.render, tt.render)
						.put3(" spec %q{%d/%d}", spec.render, spec.asMethod().index, spec.asMethod().uid)
						.outln();
					Terminal.buf.put2("normWrappingTables: new mapper ft %q tt %q", nft.render, ntt.render)
						.put3(" spec %q{%d/%d}", nspec.render, nspec.asMethod().index, nspec.asMethod().uid)
						.outln();
				}
				newMappers.put((nft, ntt, nspec));
				newMapperMap[(nft, ntt)] = nspec;
			}
			wrappedFunctionWrapper = newWrapperMap;
			wrappedFunctionWrapperVec = newWrappers;
			wrappedFunctionTypeMapper = newMapperMap;
			wrappedFunctionTypeMapperVec = newMappers;
		}

		{
			var unmapperTypes = Maps.keyList(unmapper);
			var newUnmapper = TypeUtil.newTypeMap<IrSpec>();
			var newUnmapperVec = Vector<(Type, IrSpec)>.new();
			for (node = unmapperTypes; node != null; node = node.tail) {
				var typ = node.head;
				var ntyp = rn.norm(typ).newType;
				if (ntyp.typeCon.kind == Kind.TUPLE) ntyp = Tuple.elementType(ntyp, 0);
				var unmapperSpec = unmapper[typ];
				var nspec = rn.normalizeMethodRef(unmapperSpec).1;
				newUnmapper[typ] = nspec;
				newUnmapperVec.put((typ, nspec));
			}
			unmapper = newUnmapper;
			unmapperVec = newUnmapperVec;
		}

		{
			var wrapperTypes = Maps.keyList(wrappers);
			var newWrappers = TypeUtil.newTypeMap<List<IrSpec>>();
			for (node = wrapperTypes; node != null; node = node.tail) {
				var wrapperType = node.head;
				var ntyp = rn.norm(wrapperType).newType;
				if (ntyp.typeCon.kind == Kind.TUPLE) ntyp = Tuple.elementType(ntyp, 0);
				var wrappees = wrappers[wrapperType];
				var nwrappees: List<IrSpec>;
				for (wnode = wrappees; wnode != null; wnode = wnode.tail) {
					var spec = wnode.head;
					var nspec = rn.normalizeMethodRef(spec).1;
					nwrappees = List.new(nspec, nwrappees);
				}
				newWrappers[ntyp] = nwrappees;
			}
			wrappers = newWrappers;
		}

		{
			var nwrappeeForWrapper = HashMap<IrSpec, IrSpec>.new(IrSpec.hash, IrSpec.equals);
			for (wnode = Maps.keyList(wrappeeForWrapper); wnode != null; wnode = wnode.tail) {
				var wrapper = wnode.head;
				var wrappee = wrappeeForWrapper[wrapper];
				var nwrapper = rn.normalizeMethodRef(wrapper).1;
				var nwrappee = rn.normalizeMethodRef(wrappee).1;
				if (CLOptions.PRINT_RA.get()) {
					Terminal.buf.put3("normWrappingTables: wrapper %q{%d/%d}", wrapper.render, wrapper.asMethod().index, wrapper.asMethod().uid)
						.put3(" => wrappee %q{%d/%d}", wrappee.render, wrappee.asMethod().index, wrappee.asMethod().uid).outln();
					Terminal.buf.put3("normWrappingTables: norm wrapper %q{%d/%d}", nwrapper.render, nwrapper.asMethod().index, nwrapper.asMethod().uid)
						.put3(" => norm wrappee %q{%d/%d}", nwrappee.render, nwrappee.asMethod().index, nwrappee.asMethod().uid).outln();
				}
				nwrappeeForWrapper[nwrapper] = nwrappee;
			}
			wrappeeForWrapper = nwrappeeForWrapper;
		}
	}
/*
	def genMapper(ft: Type, tt: Type) {
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("genMapper:").end()
				.put2(" ft %q  tt %q", ft.render, tt.render).outln();
		}
		def receiver = opBuilder.createGlobalIrClass();
//		if (!wrappedFunctionTypeMapper.has((ft, tt))) {

		var inner = SsaContext.new(context.compiler, context.prog);
		if (!FuncType.?(ft)) Terminal.buf.put1("mapFunctionToWrapper: not a FuncType: %q", ft.render).outln();
		def ftype = FuncType.!(ft);
		def ttype = FuncType.!(tt);
		def mapperType = FuncType.!(Function.newType(ftype, ttype));
		var meth = opBuilder.createIrMethod(receiver, null, mapperType.sig());

		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("mapFuncToWrapper:").end().puts(" ").outt();
			SsaPrinter.new().printInstrLn(x).flush();
		}
//			var typeArgs: TypeArgs;
//			var op = SsaApplyOp.!(x).op;
//			if (op.isPolymorphic()) {
//				var abstracter = TypeParamAbstracter.new(context.prog);
//				op = op.subst(abstracter.substitute);
//				typeArgs = abstracter.getTypeArgs();
//			}
//			var ta: Array<Type> = [receiver, x.getType()];
		var ta: Array<Type> = [receiver];
		var spec = IrSpec.new(receiver, ta, meth);
		wrappedFunctionTypeMapper[(ft, tt)] = spec;
		wrappedFunctionTypeMapperVec.put(ft, tt, spec);
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("mapFuncToWrapper:").end()
				.put3(" created %q.%q{%d}", receiver.render, meth.render, meth.index)
				.put1("  with type %q", mapperType.render).outln();
		}
	}
*/

	def mapFunctionToWrapper(context: SsaContext, block: SsaBuilder, ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
		if (CLOptions.PRINT_RA.get()) {
			Terminal.buf.purple().puts("mapFuncToWrapper:").end()
				.put2(" ft %q  tt %q", ft.render, tt.render).outln();
		}
		def receiver = opBuilder.createGlobalIrClass();
		if (false && !wrappedFunctionTypeMapper.has((ft, tt))) {
			// We *create* the method, but will fill it in only at the end, when we know
			// all the functions that may need wrapping
			var inner = SsaContext.new(context.compiler, context.prog);
			if (!FuncType.?(ft)) Terminal.buf.put1("mapFunctionToWrapper: not a FuncType: %q", ft.render).outln();
			def ftype = FuncType.!(ft);
			def ttype = FuncType.!(tt);
			def mapperType = FuncType.!(Function.newType(ftype, ttype));
			var meth = opBuilder.createIrMethod(receiver, null, mapperType.sig());

			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.purple().puts("mapFuncToWrapper:").end().puts(" ").outt();
				SsaPrinter.new().printInstrLn(x).flush();
			}
//			var typeArgs: TypeArgs;
//			var op = SsaApplyOp.!(x).op;
//			if (op.isPolymorphic()) {
//				var abstracter = TypeParamAbstracter.new(context.prog);
//				op = op.subst(abstracter.substitute);
//				typeArgs = abstracter.getTypeArgs();
//			}
//			var ta: Array<Type> = [receiver, x.getType()];
			var ta: Array<Type> = [receiver];
			var spec = IrSpec.new(receiver, ta, meth);
			wrappedFunctionTypeMapper[(ft, tt)] = spec;
			wrappedFunctionTypeMapperVec.put(ft, tt, spec);
			if (CLOptions.PRINT_RA.get()) {
				Terminal.buf.purple().puts("mapFuncToWrapper:").end()
					.put3(" created %q.%q{%d}", receiver.render, meth.render, meth.index)
					.put1("  with type %q", mapperType.render).outln();
			}
		}
		var spec = wrappedFunctionTypeMapper[(ft, tt)];
		var op = V3Op.newCallMethod(spec);
		var args = [block.graph.nullReceiver(), x];

		return block.addApply(null, op, args);
	}
}
// Representation of the program appropriate for the target, e.g. a machine.
class TargetProgram(prog: Program) {
}
def EMPTY_HASH = -1;
def RECURSIVE_HASH = -2;
// Represents an object or an array in the program
class Record(id: int, rtype: Type, values: Array<Val>) extends Val {
	new() {
//		var sb = StringBuilder.new().put2("new Record for id %d %q\n", id, rtype.render);
//		System.puts(sb.extract());
//		ERROR.addError(null, null, "======>", sb.extract());
	}
	private var h0: int = EMPTY_HASH;
	
	def equals(other: Val) -> bool {
		if (other == this) return true;
		if (!V3.isVariant(rtype)) return false;
		match (other) {
			that: Record => {
				if (this.rtype != that.rtype) return false;
				if (this.hash() != that.hash()) return false;
				return Values.deepEqual(this.values, that.values);
			}
		}
		return false;
	}
	def hash() -> int {
		if (h0 >= 0) return h0;
		if (h0 == RECURSIVE_HASH) return h0 = 0;
		if (!V3.isVariant(rtype)) return h0 = id;
		var c = 0;
		h0 = RECURSIVE_HASH;
		for (i < values.length) {
			var v = values[i];
			if (v != null) c += v.hash() * (33 + i);
		}
		if (c != 0) c += rtype.hash;
		return h0 = int.max & c;
	}
}
