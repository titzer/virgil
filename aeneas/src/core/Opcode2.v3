// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Represents the statically-known part of an operation, not including the types.
type Opcode2 {
	// Boolean operators
	case BoolEq			{ def accept<P, R>(v: Opcode2Visitor, p: P) -> R { return v.visitBoolEq(this, p); } }
	case BoolAnd;
	case BoolOr;
	case BoolNot;
	// Integer arithmetic and conversions
	case IntEq(t: IntType);
	case IntAdd(t: IntType);
	case IntSub(t: IntType);
	case IntMul(t: IntType);
	case IntDiv(t: IntType);
	case IntMod(t: IntType);
	case IntAnd(t: IntType);
	case IntOr(t: IntType);
	case IntXor(t: IntType);
	case IntShl(t: IntType);
	case IntSar(t: IntType);
	case IntShr(t: IntType);
	case IntLt(t: IntType);
	case IntLteq(t: IntType);
	case IntWide(op: Operator, paramTypes: Array<Type>, resultTypes: Array<Type>);
	// Floating point arithmetic
	case FloatAdd(t: FloatType);
	case FloatSub(t: FloatType);
	case FloatMul(t: FloatType);
	case FloatDiv(t: FloatType);
	case FloatBitEq(t: FloatType);
	case FloatEq(t: FloatType);
	case FloatNe(t: FloatType);
	case FloatLt(t: FloatType);
	case FloatLteq(t: FloatType);
	case FloatAbs(t: FloatType);
	case FloatCeil(t: FloatType);
	case FloatFloor(t: FloatType);
	case FloatSqrt(t: FloatType);
	// Integer casts and conversions
	case IntCastF(to: IntType, from: FloatType);
	case IntQueryF(to: IntType, from: FloatType);
	case IntViewI(to: IntType, from: Type); // TODO: sharpen "from"
	case IntViewF(to: IntType, from: Type); // TODO: sharpen "from"
	case IntTruncF(to: IntType, from: FloatType);
	// Floating point casts and conversions
	case FloatCastI(to: FloatType, from: IntType);
	case FloatCastD(to: FloatType, from: FloatType);
	case FloatQueryI(to: FloatType, from: IntType);
	case FloatQueryD(to: FloatType, from: FloatType);
	case FloatPromoteI(to: FloatType, from: IntType);
	case FloatPromoteF(to: FloatType, from: FloatType);
	case FloatViewI(to: FloatType, from: Type); // TODO: sharpen "from"
	case FloatRoundI(to: FloatType, from: Type); // TODO: sharpen "from"
	case FloatRound(t: FloatType);
	case FloatRoundD(to: FloatType, from: FloatType);
	// Reference equality
	case RefEq(t: Type);
	// Default value operator
	case DefaultValue(t: Type);
	// Int representation for other types
	case IntRepCreate(to: IntRepType, from: Type);
	case IntRepView(to: Type, from: IntRepType);
	// Tuple operations
	case TupleCreate(t: TupleType);
	case TupleGetElem(t: TupleType, index: int);
	// Array operations
	case ArrayAlloc(t: ArrayType);
	case ArrayFill(t: ArrayType);
	case ArrayInit(t: ArrayType, length: int);
	case ArrayTupleInit(t: ArrayType, elems: int, length: int);
	case ArrayGetElem(t: ArrayType, it: IntType);
	case ArraySetElem(t: ArrayType, it: IntType);
	case ArrayGetElemElem(t: ArrayType, it: IntType, index: int);
	case ArraySetElemElem(t: ArrayType, it: IntType, index: int);
	case ArrayGetLength(t: ArrayType);
	// Range operations
	case RangeFromTo(t: RangeType, startType: IntType, lengthType: IntType);
	case RangeFromPlus(t: RangeType, startType: IntType, endType: IntType);
	case RangeGetElem(t: RangeType, it: IntType);
	case RangeSetElem(t: RangeType, it: IntType);
	case RangeGetLength(t: RangeType);
	case RangeStartPlusIndex(t: RangeType, it: IntType);
	case RangeStartFromPointer(t: RangeType, pt: PointerType);
	// Normalized Range operations
	case NormRangeGetElem(t: ArrayType, it: IntType);
	case NormRangeGetElemElem(t: ArrayType, index: int, it: IntType);
	case NormRangeSetElem(t: ArrayType, it: IntType);
	case NormRangeSetElemElem(t: ArrayType, index: int, it: IntType);
	// Component operations
	case Init(method: IrMethod);
	case ComponentGetField(field: IrField);
	case ComponentSetField(field: IrField);
	// Class operations
	case ClassAlloc(spec: IrSpec); // TODO: ClassNew/ClassAlloc
	case ClassEmptyAlloc(t: ClassType, paramTypes: Array<Type>);
	case ClassGetField(spec: IrSpec);
	case ClassInitField(spec: IrSpec);
	case ClassSetField(spec: IrSpec);
	case ClassGetMethod(spec: IrSpec);
	case ClassGetVirtual(spec: IrSpec);
	case ClassGetSelector(spec: IrSpec);
	// Variant operations
	case VariantEq(t: ClassType);
	case VariantGetTag(t: ClassType);
	case VariantAlloc(t: ClassType, paramTypes: Array<Type>);
	case VariantGetField(spec: IrSpec);
	case VariantGetMethod(spec: IrSpec);
	case VariantGetVirtual(spec: IrSpec);
	case VariantGetSelector(spec: IrSpec);
	// Safety checks
	case NullCheck(t: Type);
	case BoundsCheck(t: Type);
	case ConditionalThrow(exception: string);
	// Overloaded, polymorphic casts
	case OverloadedEq(t: Type);
	case TypeCast(cast: TypeCast, to: Type, from: Type);
	case TypeQuery(query: TypeQuery, to: Type, from: Type);
	case TypeSubsume(to: Type, from: Type);
	// Closure and call operations
	case CallMethod(spec: IrSpec);
	case CallClassMethod(spec: IrSpec);
	case CallClassVirtual(spec: IrSpec);
	case CallClassSelector(spec: IrSpec);
	case CallVariantVirtual(spec: IrSpec);
	case CallVariantSelector(spec: IrSpec);
	case CallClosure(t: FuncType);
	case CallFunction(t: FuncType);
	case CreateClosure(obj: Type, method: IrSpec);
	case ForgeClosure(ptrType: PointerType, closureType: Type, paramType: Type, resultType: Type);
	case UnpackClosure(ptrType: PointerType, closureType: Type, paramType: Type, resultType: Type);
	// RefLayout operations
	case RefLayoutAt(t: RefType);
	case RefLayoutOf(t: RefType);
	case RefLayoutIn(t: RefType, offset: int, rt: RefType);
	case RefLayoutGetField(t: RefType, offset: int, ft: Type);
	case RefLayoutSetField(t: RefType, offset: int, ft: Type);
	case RefLayoutAtRepeatedField(t: RefType, offset: int, scale: int, max: int, rt: RefType);
	case RefLayoutGetRepeatedField(t: RefType, offset: int, scale: int, max: int, ft: Type);
	case RefLayoutSetRepeatedField(t: RefType, offset: int, scale: int, max: int, ft: Type);
	case ByteArrayGetField(st: Type, offset: int, ft: Type);
	case ByteArraySetField(st: Type, offset: int, ft: Type);
	case ForgeRange(ptrType: PointerType, t: RangeType);
	// System operations
	case SystemCall(syscall: SystemCall, paramType: Type, resultType: Type); // TODO: paramTypes
	// Container for VST operations
	case VstSugar(op: VstOperator, paramTypes: Array<Type>, resultType: Type);

// ------- Machine-level operations ---------------------------------------------
	// Pointer operations
	case PtrAdd(t: Type, it: IntType);
	case PtrSub(t: Type, it: IntType);
	case PtrLt(t: PointerType);
	case PtrLteq(t: PointerType);
	case PtrAtContents(t: PointerType, at: Type);
	case PtrAtLength(t: PointerType, arrayType: ArrayType);
	case PtrAtObject(t: PointerType, objType: Type);
	case PtrAtRangeElem(t: PointerType, rangeType: RangeType, it: IntType);
	case PtrAtArrayElem(t: PointerType, arrayType: ArrayType, it: IntType);
	case PtrAtEnd(t: PointerType, objType: Type);
	case PtrAtRef(t: PointerType, refType: Type); // TODO: refType: RefType
	case PtrAtComponentField(t: PointerType, spec: IrSpec);
	case PtrAtObjectField(t: PointerType, spec: IrSpec);
	case PtrAtRefLayoutField(refType: RefType, t: PointerType, offset: int);
	case PtrAtUnboxedObjectField(specs: List<IrSpec>, t: PointerType);
	case PtrAtUnboxedComponentField(specs: List<IrSpec>, t: PointerType);
	case PtrCmpSwp(t: PointerType, valType: Type);
	case PtrLoad(t: Type, valType: Type);
	case PtrStore(t: Type, valType: Type);
	case PtrAddRangeStart(t: PointerType);
	// Get caller instruction pointer or stack pointer
	case CallerIp(t: PointerType);
	case CallerSp(t: PointerType);
	// Allocate raw memory
	case Alloc(t: Type);
	// Call
	case CallAddress(p: PointerType, rep: Mach_FuncRep);
	case CallKernel(kernel: Kernel, paramTypes: Array<Type>, resultType: Type);

	def accept<P, R>(v: Opcode2Visitor, p: P) -> R;
}

class Opcode2Visitor {
	def visitOp<P, R>(op: Opcode2, p: P) -> R;
	
	def visitBoolEq<P, R>(op: Opcode2.BoolEq, p: P) -> R 		{ return visitOp(op, p); }
	def visitBoolAnd<P, R>(op: Opcode2.BoolAnd, p: P) -> R 		{ return visitOp(op, p); }
	def visitBoolOr<P, R>(op: Opcode2.BoolOr, p: P) -> R 		{ return visitOp(op, p); }
	def visitBoolNot<P, R>(op: Opcode2.BoolNot, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntEq<P, R>(op: Opcode2.IntEq, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntAdd<P, R>(op: Opcode2.IntAdd, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntSub<P, R>(op: Opcode2.IntSub, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntMul<P, R>(op: Opcode2.IntMul, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntDiv<P, R>(op: Opcode2.IntDiv, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntMod<P, R>(op: Opcode2.IntMod, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntAnd<P, R>(op: Opcode2.IntAnd, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntOr<P, R>(op: Opcode2.IntOr, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntXor<P, R>(op: Opcode2.IntXor, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntShl<P, R>(op: Opcode2.IntShl, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntSar<P, R>(op: Opcode2.IntSar, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntShr<P, R>(op: Opcode2.IntShr, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntLt<P, R>(op: Opcode2.IntLt, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntLteq<P, R>(op: Opcode2.IntLteq, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntWide<P, R>(op: Opcode2.IntWide, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatAdd<P, R>(op: Opcode2.FloatAdd, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatSub<P, R>(op: Opcode2.FloatSub, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatMul<P, R>(op: Opcode2.FloatMul, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatDiv<P, R>(op: Opcode2.FloatDiv, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatBitEq<P, R>(op: Opcode2.FloatBitEq, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatEq<P, R>(op: Opcode2.FloatEq, p: P) -> R 			{ return visitOp(op, p); }
	def visitFloatNe<P, R>(op: Opcode2.FloatNe, p: P) -> R 			{ return visitOp(op, p); }
	def visitFloatLt<P, R>(op: Opcode2.FloatLt, p: P) -> R 			{ return visitOp(op, p); }
	def visitFloatLteq<P, R>(op: Opcode2.FloatLteq, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatAbs<P, R>(op: Opcode2.FloatAbs, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatCeil<P, R>(op: Opcode2.FloatCeil, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatFloor<P, R>(op: Opcode2.FloatFloor, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatSqrt<P, R>(op: Opcode2.FloatSqrt, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntCastF<P, R>(op: Opcode2.IntCastF, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntQueryF<P, R>(op: Opcode2.IntQueryF, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntViewI<P, R>(op: Opcode2.IntViewI, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntViewF<P, R>(op: Opcode2.IntViewF, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntTruncF<P, R>(op: Opcode2.IntTruncF, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatCastI<P, R>(op: Opcode2.FloatCastI, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatCastD<P, R>(op: Opcode2.FloatCastD, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatQueryI<P, R>(op: Opcode2.FloatQueryI, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatQueryD<P, R>(op: Opcode2.FloatQueryD, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatPromoteI<P, R>(op: Opcode2.FloatPromoteI, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatPromoteF<P, R>(op: Opcode2.FloatPromoteF, p: P) -> R 		{ return visitOp(op, p); }
	def visitFloatViewI<P, R>(op: Opcode2.FloatViewI, p: P) -> R 			{ return visitOp(op, p); }
	def visitFloatRoundI<P, R>(op: Opcode2.FloatRoundI, p: P) -> R 			{ return visitOp(op, p); }
	def visitFloatRound<P, R>(op: Opcode2.FloatRound, p: P) -> R 			{ return visitOp(op, p); }
	def visitFloatRoundD<P, R>(op: Opcode2.FloatRoundD, p: P) -> R 			{ return visitOp(op, p); }
	def visitRefEq<P, R>(op: Opcode2.RefEq, p: P) -> R 				{ return visitOp(op, p); }
	def visitDefaultValue<P, R>(op: Opcode2.DefaultValue, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntRepCreate<P, R>(op: Opcode2.IntRepCreate, p: P) -> R 		{ return visitOp(op, p); }
	def visitIntRepView<P, R>(op: Opcode2.IntRepView, p: P) -> R 			{ return visitOp(op, p); }
	def visitTupleCreate<P, R>(op: Opcode2.TupleCreate, p: P) -> R 			{ return visitOp(op, p); }
	def visitTupleGetElem<P, R>(op: Opcode2.TupleGetElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitArrayAlloc<P, R>(op: Opcode2.ArrayAlloc, p: P) -> R 			{ return visitOp(op, p); }
	def visitArrayFill<P, R>(op: Opcode2.ArrayFill, p: P) -> R 			{ return visitOp(op, p); }
	def visitArrayInit<P, R>(op: Opcode2.ArrayInit, p: P) -> R 			{ return visitOp(op, p); }
	def visitArrayTupleInit<P, R>(op: Opcode2.ArrayTupleInit, p: P) -> R 		{ return visitOp(op, p); }
	def visitArrayGetElem<P, R>(op: Opcode2.ArrayGetElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitArraySetElem<P, R>(op: Opcode2.ArraySetElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitArrayGetElemElem<P, R>(op: Opcode2.ArrayGetElemElem, p: P) -> R 	{ return visitOp(op, p); }
	def visitArraySetElemElem<P, R>(op: Opcode2.ArraySetElemElem, p: P) -> R 	{ return visitOp(op, p); }
	def visitArrayGetLength<P, R>(op: Opcode2.ArrayGetLength, p: P) -> R 		{ return visitOp(op, p); }
	def visitRangeFromTo<P, R>(op: Opcode2.RangeFromTo, p: P) -> R 			{ return visitOp(op, p); }
	def visitRangeFromPlus<P, R>(op: Opcode2.RangeFromPlus, p: P) -> R 		{ return visitOp(op, p); }
	def visitRangeGetElem<P, R>(op: Opcode2.RangeGetElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitRangeSetElem<P, R>(op: Opcode2.RangeSetElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitRangeGetLength<P, R>(op: Opcode2.RangeGetLength, p: P) -> R 		{ return visitOp(op, p); }
	def visitRangeStartPlusIndex<P, R>(op: Opcode2.RangeStartPlusIndex, p: P) -> R 		{ return visitOp(op, p); }
	def visitRangeStartFromPointer<P, R>(op: Opcode2.RangeStartFromPointer, p: P) -> R 	{ return visitOp(op, p); }
	def visitNormRangeGetElem<P, R>(op: Opcode2.NormRangeGetElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitNormRangeGetElemElem<P, R>(op: Opcode2.NormRangeGetElemElem, p: P) -> R 	{ return visitOp(op, p); }
	def visitNormRangeSetElem<P, R>(op: Opcode2.NormRangeSetElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitNormRangeSetElemElem<P, R>(op: Opcode2.NormRangeSetElemElem, p: P) -> R 	{ return visitOp(op, p); }
	def visitInit<P, R>(op: Opcode2.Init, p: P) -> R 				{ return visitOp(op, p); }
	def visitComponentGetField<P, R>(op: Opcode2.ComponentGetField, p: P) -> R 	{ return visitOp(op, p); }
	def visitComponentSetField<P, R>(op: Opcode2.ComponentSetField, p: P) -> R 	{ return visitOp(op, p); }
	def visitClassAlloc<P, R>(op: Opcode2.ClassAlloc, p: P) -> R 			{ return visitOp(op, p); }
	def visitClassEmptyAlloc<P, R>(op: Opcode2.ClassEmptyAlloc, p: P) -> R 		{ return visitOp(op, p); }
	def visitClassGetField<P, R>(op: Opcode2.ClassGetField, p: P) -> R 		{ return visitOp(op, p); }
	def visitClassInitField<P, R>(op: Opcode2.ClassInitField, p: P) -> R 		{ return visitOp(op, p); }
	def visitClassSetField<P, R>(op: Opcode2.ClassSetField, p: P) -> R 		{ return visitOp(op, p); }
	def visitClassGetMethod<P, R>(op: Opcode2.ClassGetMethod, p: P) -> R 		{ return visitOp(op, p); }
	def visitClassGetVirtual<P, R>(op: Opcode2.ClassGetVirtual, p: P) -> R 		{ return visitOp(op, p); }
	def visitClassGetSelector<P, R>(op: Opcode2.ClassGetSelector, p: P) -> R 	{ return visitOp(op, p); }
	def visitVariantEq<P, R>(op: Opcode2.VariantEq, p: P) -> R 			{ return visitOp(op, p); }
	def visitVariantGetTag<P, R>(op: Opcode2.VariantGetTag, p: P) -> R 		{ return visitOp(op, p); }
	def visitVariantAlloc<P, R>(op: Opcode2.VariantAlloc, p: P) -> R 		{ return visitOp(op, p); }
	def visitVariantGetField<P, R>(op: Opcode2.VariantGetField, p: P) -> R 		{ return visitOp(op, p); }
	def visitVariantGetMethod<P, R>(op: Opcode2.VariantGetMethod, p: P) -> R 	{ return visitOp(op, p); }
	def visitVariantGetVirtual<P, R>(op: Opcode2.VariantGetVirtual, p: P) -> R 	{ return visitOp(op, p); }
	def visitVariantGetSelector<P, R>(op: Opcode2.VariantGetSelector, p: P) -> R 	{ return visitOp(op, p); }
	def visitNullCheck<P, R>(op: Opcode2.NullCheck, p: P) -> R 			{ return visitOp(op, p); }
	def visitBoundsCheck<P, R>(op: Opcode2.BoundsCheck, p: P) -> R 			{ return visitOp(op, p); }
	def visitConditionalThrow<P, R>(op: Opcode2.ConditionalThrow, p: P) -> R 	{ return visitOp(op, p); }
	def visitOverloadedEq<P, R>(op: Opcode2.OverloadedEq, p: P) -> R 		{ return visitOp(op, p); }
	def visitTypeCast<P, R>(op: Opcode2.TypeCast, p: P) -> R 			{ return visitOp(op, p); }
	def visitTypeQuery<P, R>(op: Opcode2.TypeQuery, p: P) -> R 			{ return visitOp(op, p); }
	def visitTypeSubsume<P, R>(op: Opcode2.TypeSubsume, p: P) -> R 			{ return visitOp(op, p); }
	def visitCallMethod<P, R>(op: Opcode2.CallMethod, p: P) -> R 			{ return visitOp(op, p); }
	def visitCallClassMethod<P, R>(op: Opcode2.CallClassMethod, p: P) -> R 		{ return visitOp(op, p); }
	def visitCallClassVirtual<P, R>(op: Opcode2.CallClassVirtual, p: P) -> R 		{ return visitOp(op, p); }
	def visitCallClassSelector<P, R>(op: Opcode2.CallClassSelector, p: P) -> R 		{ return visitOp(op, p); }
	def visitCallVariantVirtual<P, R>(op: Opcode2.CallVariantVirtual, p: P) -> R 		{ return visitOp(op, p); }
	def visitCallVariantSelector<P, R>(op: Opcode2.CallVariantSelector, p: P) -> R 		{ return visitOp(op, p); }
	def visitCallClosure<P, R>(op: Opcode2.CallClosure, p: P) -> R 			{ return visitOp(op, p); }
	def visitCallFunction<P, R>(op: Opcode2.CallFunction, p: P) -> R 		{ return visitOp(op, p); }
	def visitCreateClosure<P, R>(op: Opcode2.CreateClosure, p: P) -> R 		{ return visitOp(op, p); }
	def visitForgeClosure<P, R>(op: Opcode2.ForgeClosure, p: P) -> R 		{ return visitOp(op, p); }
	def visitUnpackClosure<P, R>(op: Opcode2.UnpackClosure, p: P) -> R 		{ return visitOp(op, p); }
	def visitRefLayoutAt<P, R>(op: Opcode2.RefLayoutAt, p: P) -> R 			{ return visitOp(op, p); }
	def visitRefLayoutOf<P, R>(op: Opcode2.RefLayoutOf, p: P) -> R 			{ return visitOp(op, p); }
	def visitRefLayoutIn<P, R>(op: Opcode2.RefLayoutIn, p: P) -> R 			{ return visitOp(op, p); }
	def visitRefLayoutGetField<P, R>(op: Opcode2.RefLayoutGetField, p: P) -> R 		{ return visitOp(op, p); }
	def visitRefLayoutSetField<P, R>(op: Opcode2.RefLayoutSetField, p: P) -> R 		{ return visitOp(op, p); }
	def visitRefLayoutAtRepeatedField<P, R>(op: Opcode2.RefLayoutAtRepeatedField, p: P) -> R 		{ return visitOp(op, p); }
	def visitRefLayoutGetRepeatedField<P, R>(op: Opcode2.RefLayoutGetRepeatedField, p: P) -> R 		{ return visitOp(op, p); }
	def visitRefLayoutSetRepeatedField<P, R>(op: Opcode2.RefLayoutSetRepeatedField, p: P) -> R 		{ return visitOp(op, p); }
	def visitByteArrayGetField<P, R>(op: Opcode2.ByteArrayGetField, p: P) -> R 		{ return visitOp(op, p); }
	def visitByteArraySetField<P, R>(op: Opcode2.ByteArraySetField, p: P) -> R 		{ return visitOp(op, p); }
	def visitForgeRange<P, R>(op: Opcode2.ForgeRange, p: P) -> R 			{ return visitOp(op, p); }
	def visitSystemCall<P, R>(op: Opcode2.SystemCall, p: P) -> R 			{ return visitOp(op, p); }
	def visitVstSugar<P, R>(op: Opcode2.VstSugar, p: P) -> R 			{ return visitOp(op, p); }
	def visitPtrAdd<P, R>(op: Opcode2.PtrAdd, p: P) -> R 				{ return visitOp(op, p); }
	def visitPtrSub<P, R>(op: Opcode2.PtrSub, p: P) -> R 				{ return visitOp(op, p); }
	def visitPtrLt<P, R>(op: Opcode2.PtrLt, p: P) -> R 				{ return visitOp(op, p); }
	def visitPtrLteq<P, R>(op: Opcode2.PtrLteq, p: P) -> R 				{ return visitOp(op, p); }
	def visitPtrAtContents<P, R>(op: Opcode2.PtrAtContents, p: P) -> R 		{ return visitOp(op, p); }
	def visitPtrAtLength<P, R>(op: Opcode2.PtrAtLength, p: P) -> R 			{ return visitOp(op, p); }
	def visitPtrAtObject<P, R>(op: Opcode2.PtrAtObject, p: P) -> R 			{ return visitOp(op, p); }
	def visitPtrAtRangeElem<P, R>(op: Opcode2.PtrAtRangeElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitPtrAtArrayElem<P, R>(op: Opcode2.PtrAtArrayElem, p: P) -> R 		{ return visitOp(op, p); }
	def visitPtrAtEnd<P, R>(op: Opcode2.PtrAtEnd, p: P) -> R 			{ return visitOp(op, p); }
	def visitPtrAtRef<P, R>(op: Opcode2.PtrAtRef, p: P) -> R 			{ return visitOp(op, p); }
	def visitPtrAtComponentField<P, R>(op: Opcode2.PtrAtComponentField, p: P) -> R 		{ return visitOp(op, p); }
	def visitPtrAtObjectField<P, R>(op: Opcode2.PtrAtObjectField, p: P) -> R 		{ return visitOp(op, p); }
	def visitPtrAtRefLayoutField<P, R>(op: Opcode2.PtrAtRefLayoutField, p: P) -> R 		{ return visitOp(op, p); }
	def visitPtrAtUnboxedObjectField<P, R>(op: Opcode2.PtrAtUnboxedObjectField, p: P) -> R 		{ return visitOp(op, p); }
	def visitPtrAtUnboxedComponentField<P, R>(op: Opcode2.PtrAtUnboxedComponentField, p: P) -> R 	{ return visitOp(op, p); }
	def visitPtrCmpSwp<P, R>(op: Opcode2.PtrCmpSwp, p: P) -> R 					{ return visitOp(op, p); }
	def visitPtrLoad<P, R>(op: Opcode2.PtrLoad, p: P) -> R 				{ return visitOp(op, p); }
	def visitPtrStore<P, R>(op: Opcode2.PtrStore, p: P) -> R 			{ return visitOp(op, p); }
	def visitPtrAddRangeStart<P, R>(op: Opcode2.PtrAddRangeStart, p: P) -> R 	{ return visitOp(op, p); }
	def visitCallerIp<P, R>(op: Opcode2.CallerIp, p: P) -> R 			{ return visitOp(op, p); }
	def visitCallerSp<P, R>(op: Opcode2.CallerSp, p: P) -> R 			{ return visitOp(op, p); }
	def visitAlloc<P, R>(op: Opcode2.Alloc, p: P) -> R 				{ return visitOp(op, p); }
	def visitCallAddress<P, R>(op: Opcode2.CallAddress, p: P) -> R 			{ return visitOp(op, p); }
	def visitCallKernel<P, R>(op: Opcode2.CallKernel, p: P) -> R 			{ return visitOp(op, p); }
}

component Opcodes2 {
	def table = Array<Fact.set>.new(Opcode2.CallKernel.tag + 1); // XXX: Opcode2.count
	new() {
		// shorthand for SSA optimization facts
		var F = Fact.O_FOLDABLE;
		var M: Fact; // TODO = Fact.O_MONOMORPHIC;
		var P = Fact.O_PURE | Fact.O_FOLDABLE; // pure => foldable
		var C = Fact.O_COMMUTATIVE;
		var A: Fact; // TODO = Fact.O_ASSOCIATIVE;
		var NZ   = Fact.V_NON_ZERO;
		var NNEG = Fact.V_NON_NEGATIVE;
		var NNC = Fact.O_NO_NULL_CHECK;
                var NONE = Facts.NONE;

		def t = table; // for code shortitude

		// register all operators and their optimization facts
		t[Opcode2.BoolEq.tag] =			P  |M|C;
		t[Opcode2.BoolAnd.tag] = 		P|A|M|C;
		t[Opcode2.BoolOr.tag] = 		P|A|M|C;
		t[Opcode2.BoolNot.tag] = 		P|M;

		t[Opcode2.IntEq.tag] =			P  |M|C;
		t[Opcode2.IntAdd.tag] = 		P|A|M|C;
		t[Opcode2.IntSub.tag] = 		P|M;
		t[Opcode2.IntMul.tag] = 		P|A|M|C;
		t[Opcode2.IntDiv.tag] = 		F|M;
		t[Opcode2.IntMod.tag] = 		F|M;
		t[Opcode2.IntAnd.tag] = 		P|A|M|C;
		t[Opcode2.IntOr.tag] = 			P|A|M|C;
		t[Opcode2.IntXor.tag] = 		P|A|M|C;
		t[Opcode2.IntShl.tag] = 		P|M;
		t[Opcode2.IntSar.tag] = 		P|M;
		t[Opcode2.IntShr.tag] = 		P|M;
		t[Opcode2.IntLt.tag] = 			P|M;
		t[Opcode2.IntLteq.tag] = 		P|M;
		t[Opcode2.IntWide.tag] = 		P|M;

		t[Opcode2.FloatAdd.tag] =		P|A|M|C;
		t[Opcode2.FloatSub.tag] =		P|M;
		t[Opcode2.FloatMul.tag] =		P|A|M|C;
		t[Opcode2.FloatDiv.tag] =		P|M;
		t[Opcode2.FloatBitEq.tag] =		P  |M|C;
		t[Opcode2.FloatEq.tag] =		P  |M|C;
		t[Opcode2.FloatNe.tag] =		P  |M|C;
		t[Opcode2.FloatLt.tag] =		P|M;
		t[Opcode2.FloatLteq.tag] =		P|M;
		t[Opcode2.FloatAbs.tag] =		P|M;
		t[Opcode2.FloatCeil.tag] =		P|M;
		t[Opcode2.FloatFloor.tag] =		P|M;
		t[Opcode2.FloatSqrt.tag] =		P|M;

		t[Opcode2.IntCastF.tag] =		F|M;
		t[Opcode2.IntQueryF.tag] =		P|M;
		t[Opcode2.IntViewI.tag] = 		P|M;
		t[Opcode2.IntViewI.tag] =		P|M;
		t[Opcode2.IntViewF.tag] =		P|M;
		t[Opcode2.IntTruncF.tag] =		P|M;

		t[Opcode2.FloatCastI.tag] =		F|M;
		t[Opcode2.FloatCastD.tag] =		F|M;
		t[Opcode2.FloatQueryI.tag] =		P|M;
		t[Opcode2.FloatQueryD.tag] =		P|M;
		t[Opcode2.FloatPromoteI.tag] =		P|M;
		t[Opcode2.FloatPromoteF.tag] =		P|M;
		t[Opcode2.FloatViewI.tag] =		P|M;
		t[Opcode2.FloatRoundI.tag] =		P|M;
		t[Opcode2.FloatRound.tag] =		P|M;
		t[Opcode2.FloatRoundD.tag] =		P|M;

		t[Opcode2.RefEq.tag] =			P  |C;
		t[Opcode2.IntRepCreate.tag] =		P  |F;
		t[Opcode2.IntRepView.tag] =		P  |F;

		t[Opcode2.TupleCreate.tag] = 		P;
		t[Opcode2.TupleGetElem.tag] = 		P;

		t[Opcode2.ArrayAlloc.tag] = 		NZ;
		t[Opcode2.ArrayInit.tag] = 		NZ;
		t[Opcode2.ArrayGetElem.tag] = 		NONE;
		t[Opcode2.ArraySetElem.tag] = 		NONE;
		t[Opcode2.ArrayGetLength.tag] = 	F|NNEG;

		t[Opcode2.RangeFromTo.tag] = 		F;
		t[Opcode2.RangeFromPlus.tag] = 		F;
		t[Opcode2.RangeGetLength.tag] = 	P;

		t[Opcode2.RangeStartPlusIndex.tag] =	P;
		t[Opcode2.RangeStartFromPointer.tag] =	P;
		t[Opcode2.NormRangeGetElem.tag] = 	F;
		t[Opcode2.NormRangeGetElemElem.tag] = 	F;
		t[Opcode2.NormRangeSetElem.tag] = 	NONE;
		t[Opcode2.NormRangeSetElemElem.tag] = 	NONE;
		t[Opcode2.PtrAddRangeStart.tag] =	P;
		t[Opcode2.ForgeRange.tag] =		P;

		t[Opcode2.Init.tag] = 			M;
		t[Opcode2.ComponentGetField.tag] = 	NNC|M;
		t[Opcode2.ComponentSetField.tag] = 	NNC|M;

		t[Opcode2.ClassAlloc.tag] = 		NZ;
		t[Opcode2.ClassEmptyAlloc.tag] =	NZ; // TODO: dead-code elimination
		t[Opcode2.ClassGetField.tag] = 		NONE;
		t[Opcode2.ClassSetField.tag] = 		NONE;
		t[Opcode2.ClassInitField.tag] = 	Fact.O_NO_NULL_CHECK;
		t[Opcode2.ClassGetMethod.tag] = 	NZ|F;
		t[Opcode2.ClassGetVirtual.tag] = 	NZ|F;
		t[Opcode2.ClassGetSelector.tag] = 	NZ|F;

		t[Opcode2.VariantEq.tag] =		P  |C;
		t[Opcode2.VariantGetTag.tag] =		P|NNEG;
		t[Opcode2.VariantAlloc.tag] =		P;
		t[Opcode2.VariantGetField.tag] = 	P;
		t[Opcode2.VariantGetMethod.tag] = 	NZ|P;
		t[Opcode2.VariantGetVirtual.tag] = 	NZ|P;
		t[Opcode2.VariantGetSelector.tag] = 	NZ|P;

		t[Opcode2.NullCheck.tag] = 		F|NZ;
		t[Opcode2.BoundsCheck.tag] = 		F;
		t[Opcode2.ConditionalThrow.tag] = 	F|M;

		t[Opcode2.OverloadedEq.tag] =		P  |C;
		t[Opcode2.TypeCast.tag] = 		F;
		t[Opcode2.TypeQuery.tag] = 		P;
		t[Opcode2.TypeSubsume.tag] = 		P;

		t[Opcode2.CallMethod.tag] = 		NONE;
		t[Opcode2.CallClassVirtual.tag] = 	NONE;
		t[Opcode2.CallClassSelector.tag] = 	NONE;
		t[Opcode2.CallClosure.tag] = 		NONE;
		t[Opcode2.CallFunction.tag] = 		NONE;
		t[Opcode2.CreateClosure.tag] = 		NZ|P|NNC;
		t[Opcode2.ForgeClosure.tag] = 		P|NNC;
		t[Opcode2.UnpackClosure.tag] = 		P|NNC;

		t[Opcode2.SystemCall.tag] = 		NONE;

		t[Opcode2.PtrAdd.tag] =			P|M; // XXX: could be foldable with offset
		t[Opcode2.PtrSub.tag] =			P|M;
		t[Opcode2.PtrLt.tag] =			P|M;
		t[Opcode2.PtrLteq.tag] =		P|M;
		t[Opcode2.PtrAtContents.tag] =		P;
		t[Opcode2.PtrAtLength.tag] =		P;
		t[Opcode2.PtrAtObject.tag] =		P;
		t[Opcode2.PtrAtRangeElem.tag] =		F|M;
		t[Opcode2.PtrAtArrayElem.tag] =		F|M;
		t[Opcode2.PtrAtComponentField.tag] =	P|M;
		t[Opcode2.PtrAtObjectField.tag] =	F;
		t[Opcode2.PtrLoad.tag] =		NONE;
		t[Opcode2.PtrStore.tag] =		NONE;

		t[Opcode2.CallerIp.tag] =		P|M;
		t[Opcode2.CallerSp.tag] =		P|M;

		t[Opcode2.Alloc.tag] =			NONE;

		t[Opcode2.RefLayoutAt.tag] = 		NZ|F|M;
		t[Opcode2.RefLayoutIn.tag] = 		P|F|M;
		t[Opcode2.RefLayoutGetField.tag] =	NONE;
		t[Opcode2.RefLayoutAtRepeatedField.tag] = P|M;
	}
	def facts(opcode: Opcode2) -> Fact.set {
		return table[opcode.tag];
	}
	def checkOpenness(opcode: Opcode2) -> Open {
//TODO		if (table[opcode.tag].O_MONOMORPHIC) return Open.CLOSED;
		var open = Open.OPEN;
		match (opcode) {
			RefEq(t) =>				open = isOpenType(t);
			IntRepCreate(t, f) =>			open = isOpenType(f);
			IntRepView(t, f) =>			open = isOpenType(t);
			IntViewF(t, f) =>			open = isOpenType(f);
			FloatViewI(t, f) =>			open = isOpenType(f);
			FloatRoundI(t, f) =>			open = isOpenType(f);
			TupleCreate(t) => 			open = isOpenType(t);
			TupleGetElem(t, index) => 		open = isOpenType(t);
			ArrayAlloc(t) =>			open = isOpenType(t);
			ArrayInit(t, length) =>			open = isOpenType(t);
			ArrayTupleInit(t, elems, length) => 	open = isOpenType(t);
			ArrayGetElem(t, it) =>			open = isOpenType(t);
			ArraySetElem(t, it) =>			open = isOpenType(t);
			ArrayGetElemElem(t, it, index) => 	open = isOpenType(t);
			ArraySetElemElem(t, it, index) => 	open = isOpenType(t);
			ArrayGetLength(t) =>			open = isOpenType(t);
			RangeFromTo(t, st, lt) =>		open = isOpenType(t);
			RangeFromPlus(t, st, et) =>		open = isOpenType(t);
			RangeGetElem(t, it) =>			open = isOpenType(t);
			RangeSetElem(t, it) =>			open = isOpenType(t);
			RangeGetLength(t) =>			open = isOpenType(t);
			RangeStartPlusIndex(t, it) =>		open = isOpenType(t);
			RangeStartFromPointer(t, pt) =>		open = isOpenType(t);
			NormRangeGetElem(t, it) =>		open = isOpenType(t);
			NormRangeGetElemElem(t, index, it) =>	open = isOpenType(t);
			NormRangeSetElem(t, it) =>		open = isOpenType(t);
			NormRangeSetElemElem(t, index, it) =>	open = isOpenType(t);
			ClassAlloc(spec) => 			open = isOpenSpec(spec);
			ClassEmptyAlloc(t, paramTypes) =>	open = isOpenTypeOrTypes(t, paramTypes);
			ClassGetField(spec) => 			open = isOpenSpec(spec);
			ClassInitField(spec) =>			open = isOpenSpec(spec);
			ClassSetField(spec) => 			open = isOpenSpec(spec);
			ClassGetMethod(spec) =>			open = isOpenSpec(spec);
			ClassGetVirtual(spec) => 		open = isOpenSpec(spec);
			ClassGetSelector(spec) => 		open = isOpenSpec(spec);
			VariantEq(t) =>				open = isOpenType(t);
			VariantGetTag(t) =>			open = isOpenType(t);
			VariantAlloc(t, paramTypes) =>		open = isOpenTypeOrTypes(t, paramTypes);
			VariantGetField(spec) => 		open = isOpenSpec(spec);
			VariantGetMethod(spec) => 		open = isOpenSpec(spec);
			VariantGetVirtual(spec) => 		open = isOpenSpec(spec);
			VariantGetSelector(spec) => 		open = isOpenSpec(spec);
			NullCheck(t) =>				open = isOpenType(t);
			BoundsCheck(t) =>			open = isOpenType(t);
			OverloadedEq(t) =>			open = isOpenType(t);
			TypeCast(cast, to, from) =>		open = isOpenType2(to, from);
			TypeQuery(query, to, from) =>		open = isOpenType2(to, from);
			TypeSubsume(to, from) =>		open = isOpenType2(to, from);
			CallMethod(spec) => 			open = isOpenSpec(spec);
			CallClassMethod(spec) => 		open = isOpenSpec(spec);
			CallClassVirtual(spec) => 		open = isOpenSpec(spec);
			CallClassSelector(spec) => 		open = isOpenSpec(spec);
			CallVariantVirtual(spec) => 		open = isOpenSpec(spec);
			CallVariantSelector(spec) => 		open = isOpenSpec(spec);
			CallClosure(t) => 			open = isOpenType(t);
			CallFunction(t) => 			open = isOpenType(t);
			CreateClosure(obj, method) => 		open = isOpenTypeOrSpec(obj, method);
			ForgeClosure(ptrType, closureType, paramType, resultType) => 	open = isOpenTypes([closureType, paramType, resultType]);
			UnpackClosure(ptrType, closureType, paramType, resultType) => 	open = isOpenTypes([closureType, paramType, resultType]);
			RefLayoutGetField(t, offset, ft) =>				open = isOpenType(ft);
			RefLayoutSetField(t, offset, ft) =>				open = isOpenType(ft);
			RefLayoutGetRepeatedField(t, offset, scale, max, ft) =>		open = isOpenType(ft);
			RefLayoutSetRepeatedField(t, offset, scale, max, ft) =>		open = isOpenType(ft);
			ByteArrayGetField(st, offset, ft) =>				open = isOpenType(ft);
			ByteArraySetField(st, offset, ft) =>				open = isOpenType(ft);
			ForgeRange(ptrType, t) => 					open = isOpenType(t);
			SystemCall(syscall, paramType, resultType) =>			open = isOpenType2(paramType, resultType);
			VstSugar(op, paramTypes, resultType) =>				open = isOpenTypeOrTypes(resultType, paramTypes);
			PtrAtContents(t, at) =>						open = isOpenType(at);
			PtrAtLength(t, arrayType) =>					open = isOpenType(arrayType);
			PtrAtObject(t, objType) =>					open = isOpenType(objType);
			PtrAtRangeElem(t, at, it) =>					open = isOpenType(at);
			PtrAtArrayElem(t, at, it) =>					open = isOpenType(at);
			PtrAtRef(t, refType) =>						open = isOpenType(refType);
			PtrAtEnd(t, objType) =>						open = isOpenType(objType);
			PtrAtObjectField(t, spec) =>					open = isOpenType(t);
			PtrAtRefLayoutField(refType, t, offset) =>			open = isOpenType(t);
			PtrAtUnboxedObjectField(specs, ptrType) =>			open = isOpenSpecs(specs);
			PtrAtUnboxedComponentField(specs, ptrType) =>			open = isOpenSpecs(specs);
			PtrCmpSwp(t, valType) =>					open = isOpenType(valType);
			PtrLoad(t, valType) =>						open = isOpenType(valType);
			PtrStore(t, valType) =>						open = isOpenType(valType);
			Alloc(t) =>							open = isOpenType(t);
			CallAddress(p, rep) => {
				if (isOpenTypes(rep.paramTypes) != Open.CLOSED) return Open.OPEN;
				if (isOpenTypes(rep.returnTypes) != Open.CLOSED) return Open.OPEN;
				open = Open.CLOSED;
			}
			CallKernel(kernel, paramTypes, resultType) => 			open = isOpenTypeOrTypes(resultType, paramTypes);
			_ => ;
		}
		return open;
	}
	def subst(opcode: Opcode2, func: Type -> Type) -> Opcode2 {
		match (opcode) {
			RefEq(t) =>				return Opcode2.RefEq(func(t));
			IntViewF(t, f) =>			return Opcode2.IntViewF(t, func(f));
			FloatViewI(t, f) =>			return Opcode2.FloatViewI(t, func(f));
			FloatRoundI(t, f) =>			return Opcode2.FloatRoundI(t, func(f));
			TupleCreate(t) => 			return Opcode2.TupleCreate(TupleType.!(func(t)));
			TupleGetElem(t, index) => 		return Opcode2.TupleGetElem(TupleType.!(func(t)), index);
			ArrayAlloc(t) =>			return Opcode2.ArrayAlloc(substArrayType(t, func));
			ArrayFill(t) =>				return Opcode2.ArrayFill(substArrayType(t, func));
			ArrayInit(t, length) =>			return Opcode2.ArrayInit(substArrayType(t, func), length);
			ArrayTupleInit(t, elems, length) => 	return Opcode2.ArrayTupleInit(substArrayType(t, func), elems, length);
			ArrayGetElem(t, it) =>			return Opcode2.ArrayGetElem(substArrayType(t, func), it);
			ArraySetElem(t, it) =>			return Opcode2.ArraySetElem(substArrayType(t, func), it);
			ArrayGetElemElem(t, it, index) => 	return Opcode2.ArrayGetElemElem(substArrayType(t, func), it, index);
			ArraySetElemElem(t, it, index) => 	return Opcode2.ArraySetElemElem(substArrayType(t, func), it, index);
			ArrayGetLength(t) =>			return Opcode2.ArrayGetLength(substArrayType(t, func));
			RangeFromTo(t, st, et) =>		return Opcode2.RangeFromTo(substRangeType(t, func), st, et);
			RangeFromPlus(t, st, lt) =>		return Opcode2.RangeFromPlus(substRangeType(t, func), st, lt);
			RangeGetElem(t, it) =>			return Opcode2.RangeGetElem(substRangeType(t, func), it);
			RangeSetElem(t, it) =>			return Opcode2.RangeSetElem(substRangeType(t, func), it);
			RangeGetLength(t) =>			return Opcode2.RangeGetLength(substRangeType(t, func));
			RangeStartPlusIndex(t, it) =>		return Opcode2.RangeStartPlusIndex(substRangeType(t, func), it);
			RangeStartFromPointer(t, pt) =>		return Opcode2.RangeStartFromPointer(substRangeType(t, func), pt);
			NormRangeGetElem(t, it) =>		return Opcode2.NormRangeGetElem(substArrayType(t, func), it);
			NormRangeGetElemElem(t, index, it) =>	return Opcode2.NormRangeGetElemElem(substArrayType(t, func), index, it);
			NormRangeSetElem(t, it) =>		return Opcode2.NormRangeSetElem(substArrayType(t, func), it);
			NormRangeSetElemElem(t, index, it) =>	return Opcode2.NormRangeSetElemElem(substArrayType(t, func), index, it);
			ClassAlloc(spec) => 			return Opcode2.ClassAlloc(substSpec(spec, func));
			ClassEmptyAlloc(classType, paramTypes) => return Opcode2.ClassEmptyAlloc(ClassType.!(func(classType)), substArray(paramTypes, func));
			ClassGetField(spec) => 			return Opcode2.ClassGetField(substSpec(spec, func));
			ClassInitField(spec) =>			return Opcode2.ClassInitField(substSpec(spec, func));
			ClassSetField(spec) => 			return Opcode2.ClassSetField(substSpec(spec, func));
			ClassGetMethod(spec) =>			return Opcode2.ClassGetMethod(substSpec(spec, func));
			ClassGetVirtual(spec) => 		return Opcode2.ClassGetVirtual(substSpec(spec, func));
			ClassGetSelector(spec) => 		return Opcode2.ClassGetSelector(substSpec(spec, func));
			VariantEq(t) =>				return Opcode2.VariantEq(ClassType.!(func(t)));
			VariantGetTag(t) =>			return Opcode2.VariantGetTag(ClassType.!(func(t)));
			VariantAlloc(classType, paramTypes) =>	return Opcode2.VariantAlloc(ClassType.!(func(classType)), substArray(paramTypes, func));
			VariantGetField(spec) => 		return Opcode2.VariantGetField(substSpec(spec, func));
			VariantGetMethod(spec) => 		return Opcode2.VariantGetMethod(substSpec(spec, func));
			VariantGetVirtual(spec) => 		return Opcode2.VariantGetVirtual(substSpec(spec, func));
			VariantGetSelector(spec) => 		return Opcode2.VariantGetSelector(substSpec(spec, func));
			NullCheck(t) =>				return Opcode2.NullCheck(func(t));
			BoundsCheck(t) =>			return Opcode2.BoundsCheck(func(t));
			OverloadedEq(t) =>			return Opcode2.OverloadedEq(func(t));
			TypeCast(cast, to, from) =>		return Opcode2.TypeCast(cast, func(to), func(from));
			TypeQuery(query, to, from) =>		return Opcode2.TypeQuery(query, func(to), func(from));
			TypeSubsume(to, from) =>		return Opcode2.TypeSubsume(func(to), func(from));
			CallMethod(spec) => 			return Opcode2.CallMethod(substSpec(spec, func));
			CallClassMethod(spec) => 		return Opcode2.CallClassMethod(substSpec(spec, func));
			CallClassVirtual(spec) => 		return Opcode2.CallClassVirtual(substSpec(spec, func));
			CallClassSelector(spec) => 		return Opcode2.CallClassSelector(substSpec(spec, func));
			CallVariantVirtual(spec) => 		return Opcode2.CallVariantVirtual(substSpec(spec, func));
			CallVariantSelector(spec) => 		return Opcode2.CallVariantSelector(substSpec(spec, func));
			CallClosure(t) => 			return Opcode2.CallClosure(FuncType.!(func(t)));
			CallFunction(t) => 			return Opcode2.CallFunction(FuncType.!(func(t)));
			CreateClosure(obj, method) => 		return Opcode2.CreateClosure(func(obj), substSpec(method, func));
			ForgeClosure(ptrType, closureType, paramType, resultType) => 	return Opcode2.ForgeClosure(ptrType, func(closureType), func(paramType), func(resultType));
			UnpackClosure(ptrType, closureType, paramType, resultType) => 	return Opcode2.UnpackClosure(ptrType, func(closureType), func(paramType), func(resultType));
			RefLayoutGetField(t, offset, ft) =>				return Opcode2.RefLayoutGetField(t, offset, func(ft));
			RefLayoutSetField(t, offset, ft) =>				return Opcode2.RefLayoutSetField(t, offset, func(ft));
			RefLayoutGetRepeatedField(t, offset, scale, max, ft) =>		return Opcode2.RefLayoutGetRepeatedField(t, offset, scale, max, func(ft));
			RefLayoutSetRepeatedField(t, offset, scale, max, ft) =>		return Opcode2.RefLayoutSetRepeatedField(t, offset, scale, max, func(ft));
			ByteArrayGetField(st, offset, ft) =>				return Opcode2.ByteArrayGetField(st, offset, func(ft));
			ByteArraySetField(st, offset, ft) =>				return Opcode2.ByteArraySetField(st, offset, func(ft));
			ForgeRange(ptrType, t) => 					return Opcode2.ForgeRange(ptrType, substRangeType(t, func));
			SystemCall(syscall, paramType, resultType) =>			return Opcode2.SystemCall(syscall, func(paramType), func(resultType));
			VstSugar(op, paramTypes, resultType) =>				return Opcode2.VstSugar(op, substArray(paramTypes, func), func(resultType));
			PtrAtContents(t, at) =>						return Opcode2.PtrAtContents(t, func(at));
			PtrAtLength(t, arrayType) =>					return Opcode2.PtrAtLength(t, ArrayType.!(func(arrayType)));
			PtrAtObject(t, objType) =>					return Opcode2.PtrAtObject(t, func(objType));
			PtrAtRangeElem(t, at, it) =>					return Opcode2.PtrAtRangeElem(t, substRangeType(at, func), it);
			PtrAtArrayElem(t, at, it) =>					return Opcode2.PtrAtArrayElem(t, substArrayType(at, func), it);
			PtrAtRef(t, refType) =>						return Opcode2.PtrAtRef(t, func(refType));
			PtrAtEnd(t, objType) =>						return Opcode2.PtrAtEnd(t, func(objType));
			PtrAtObjectField(t, spec) =>					return Opcode2.PtrAtObjectField(t, substSpec(spec, func));
			PtrAtRefLayoutField(refType, t, offset) =>			return Opcode2.PtrAtRefLayoutField(substRefType(refType, func), t, offset);
			PtrAtUnboxedObjectField(specs, ptrType) =>			return Opcode2.PtrAtUnboxedObjectField(Lists.map(specs, substSpec(_, func)), ptrType); // XXX: optimize closed case
			PtrAtUnboxedComponentField(specs, ptrType) =>			return Opcode2.PtrAtUnboxedComponentField(Lists.map(specs, substSpec(_, func)), ptrType); // XXX: optimize closed case
			PtrCmpSwp(t, valType) =>					return Opcode2.PtrCmpSwp(t, func(valType));
			PtrLoad(t, valType) =>						return Opcode2.PtrLoad(t, func(valType));
			PtrStore(t, valType) =>						return Opcode2.PtrStore(t, func(valType));
			Alloc(t) =>							return Opcode2.Alloc(func(t));
			CallAddress(p, rep) => {
				var np = substArray(rep.paramTypes, func);
				var nr = substArray(rep.returnTypes, func);
				if (np == rep.paramTypes && nr == rep.returnTypes) return opcode;
				var nrep = Mach_FuncRep.new(rep.origType, rep.machType, np, nr); // TODO: assuming same calling convention
				return Opcode2.CallAddress(p, nrep);
			}
			CallKernel(kernel, paramTypes, resultType) => 			return Opcode2.CallKernel(kernel, substArray(paramTypes, func), func(resultType));
			_ => return opcode;
		}
	}
	def render(op: Opcode2, buf: TerminalBuffer) -> TerminalBuffer {
		buf.puts(op.name);
		def ta = buf.putTypeArg, tf = buf.putToFrom, ta2 = buf.putTypeArg2, tas = buf.putTypeArgs;
		match (op) {
			IntEq(t) => 							ta(t);
			IntAdd(t) => 							ta(t);
			IntSub(t) => 							ta(t);
			IntMul(t) => 							ta(t);
			IntDiv(t) => 							ta(t);
			IntMod(t) => 							ta(t);
			IntAnd(t) => 							ta(t);
			IntOr(t) => 							ta(t);
			IntXor(t) => 							ta(t);
			IntShl(t) => 							ta(t);
			IntSar(t) => 							ta(t);
			IntShr(t) => 							ta(t);
			IntLt(t) => 							ta(t);
			IntLteq(t) => 							ta(t);
			IntWide(op, paramTypes, resultTypes) => ;
			FloatAdd(t) => 							ta(t);
			FloatSub(t) => 							ta(t);
			FloatMul(t) => 							ta(t);
			FloatDiv(t) => 							ta(t);
			FloatBitEq(t) => 						ta(t);
			FloatEq(t) => 							ta(t);
			FloatNe(t) => 							ta(t);
			FloatLt(t) => 							ta(t);
			FloatLteq(t) => 						ta(t);
			FloatAbs(t) => 							ta(t);
			FloatCeil(t) => 						ta(t);
			FloatFloor(t) => 						ta(t);
			FloatSqrt(t) => 						ta(t);
			IntCastF(to, from) => 						tf(to, from);
			IntQueryF(to, from) => 						tf(to, from);
			IntViewI(to, from) => 						tf(to, from);
			IntViewF(to, from) => 						tf(to, from);
			IntTruncF(to, from) => 						tf(to, from);
			FloatCastI(to, from) => 					tf(to, from);
			FloatCastD(to, from) => 					tf(to, from);
			FloatQueryI(to, from) => 					tf(to, from);
			FloatQueryD(to, from) => 					tf(to, from);
			FloatPromoteI(to, from) => 					tf(to, from);
			FloatPromoteF(to, from) => 					tf(to, from);
			FloatViewI(to, from) => 					tf(to, from);
			FloatRoundI(to, from) => 					tf(to, from);
			FloatRound(t) => 						ta(t);
			FloatRoundD(to, from) => 					tf(to, from);
			RefEq(t) => 							ta(t);
			DefaultValue(t) => 						ta(t);
			IntRepCreate(to, from) => 					tf(to, from);
			IntRepView(to, from) => 					tf(to, from);
			TupleCreate(t) => 						ta(t);
			TupleGetElem(t, index) => ;
			ArrayAlloc(t) => 						ta(t);
			ArrayFill(t) => 						ta(t);
			ArrayInit(t, length) => ;
			ArrayTupleInit(t, elems, length) => ;
			ArrayGetElem(t, it) => 						ta2(t, it);
			ArraySetElem(t, it) => 						ta2(t, it);
			ArrayGetElemElem(t, it, index) => 				ta2(t, it).putd(index); // TODO [
			ArraySetElemElem(t, it, index) => 				ta2(t, it).putd(index); // TODO [
			ArrayGetLength(t) => 						ta(t);
			RangeFromTo(t, startType, lengthType) => 			tas([t, startType, lengthType]);
			RangeFromPlus(t, startType, endType) => 			tas([t, startType, endType]);
			RangeGetElem(t, it) => 						ta2(t, it);
			RangeSetElem(t, it) => 						ta2(t, it);
			RangeGetLength(t) => 						ta(t);
			RangeStartPlusIndex(t, it) => 					ta2(t, it);
			RangeStartFromPointer(t, pt) => 				tf(t, pt);
			NormRangeGetElem(t, it) => 					ta2(t, it);
			NormRangeGetElemElem(t, index, it) => ;
			NormRangeSetElem(t, it) => 					ta2(t, it);
			NormRangeSetElemElem(t, index, it) => ;
			Init(method) => ;
			ComponentGetField(field) => ;
			ComponentSetField(field) => ;
			ClassAlloc(spec) => ;
			ClassEmptyAlloc(t, paramTypes) => 					ta(t);
			ClassGetField(spec) => ;
			ClassInitField(spec) => ;
			ClassSetField(spec) => ;
			ClassGetMethod(spec) => ;
			ClassGetVirtual(spec) => ;
			ClassGetSelector(spec) => ;
			VariantEq(t) => 							ta(t);
			VariantGetTag(t) => 							ta(t);
			VariantAlloc(t, paramTypes) => 						ta(t);
			VariantGetField(spec) => ;
			VariantGetMethod(spec) => ;
			VariantGetVirtual(spec) => ;
			VariantGetSelector(spec) => ;
			NullCheck(t) => 							ta(t);
			BoundsCheck(t) => 							ta(t);
			ConditionalThrow(exception) => ;
			OverloadedEq(t) => 							ta(t);
			TypeCast(cast, to, from) => 						tf(to, from);
			TypeQuery(query, to, from) => 						tf(to, from);
			TypeSubsume(to, from) => 						tf(to, from);
			CallMethod(spec) => ;
			CallClassMethod(spec) => ;
			CallClassVirtual(spec) => ;
			CallClassSelector(spec) => ;
			CallVariantVirtual(spec) => ;
			CallVariantSelector(spec) => ;
			CallClosure(t) => 							ta(t);
			CallFunction(t) => 							ta(t);
			CreateClosure(obj, method) => ;
			ForgeClosure(ptrType, closureType, paramType, resultType) => ;
			UnpackClosure(ptrType, closureType, paramType, resultType) => ;
			RefLayoutAt(t) => 							ta(t);
			RefLayoutOf(t) => 							ta(t);
			RefLayoutIn(t, offset, rt) => ;
			RefLayoutGetField(t, offset, ft) => ;
			RefLayoutSetField(t, offset, ft) => ;
			RefLayoutAtRepeatedField(t, offset, scale, max, rt) => ;
			RefLayoutGetRepeatedField(t, offset, scale, max, ft) => ;
			RefLayoutSetRepeatedField(t, offset, scale, max, ft) => ;
			ByteArrayGetField(st, offset, ft) => ;
			ByteArraySetField(st, offset, ft) => ;
			ForgeRange(ptrType, t) => 					ta2(ptrType, t);
			SystemCall(syscall, paramType, resultType) => ;
			VstSugar(op, paramTypes, resultType) => ;
			PtrAdd(t, it) => 						ta2(t, it);
			PtrSub(t, it) => 						ta2(t, it);
			PtrLt(t) => 							ta(t);
			PtrLteq(t) => 							ta(t);
			PtrAtContents(t, at) => 					ta2(t, at);
			PtrAtLength(t, arrayType) => 					ta2(t, arrayType);
			PtrAtObject(t, objType) => 					ta2(t, objType);
			PtrAtRangeElem(t, rangeType, it) => 				tas([t, rangeType, it]);
			PtrAtArrayElem(t, arrayType, it) => 				tas([t, arrayType, it]);
			PtrAtEnd(t, objType) => 					ta2(t, objType);
			PtrAtRef(t, refType) => 					ta2(t, refType);
			PtrAtComponentField(t, spec) => ;
			PtrAtObjectField(t, spec) => ;
			PtrAtRefLayoutField(refType, t, offset) => ;
			PtrAtUnboxedObjectField(specs, t) => ;
			PtrAtUnboxedComponentField(specs, t) => ;
			PtrCmpSwp(t, valType) => 					ta2(t, valType);
			PtrLoad(t, valType) => 						ta2(t, valType);
			PtrStore(t, valType) => 					ta2(t, valType);
			PtrAddRangeStart(t) => 						ta(t);
			CallerIp(t) => 							ta(t);
			CallerSp(t) => 							ta(t);
			Alloc(t) => 							ta(t);
			CallAddress(p, rep) => ;
			CallKernel(kernel, paramTypes, resultType) => ;
			_ => ;
		}
		return buf;
	}
	def isOpenType(t: Type) -> Open {
		return if(t.open(), Open.OPEN, Open.CLOSED);
	}
	def isOpenTypes(types: Range<Type>) -> Open {
		for (t in types) if (t.open()) return Open.OPEN;
		return Open.CLOSED;
	}
	def isOpenSpec(spec: IrSpec) -> Open {
		return if(spec.isPolymorphic(), Open.OPEN, Open.CLOSED);
	}
	def isOpenSpecs(specs: List<IrSpec>) -> Open {
		for (l = specs; l != null; l = l.tail) {
			var open = isOpenType(l.head.receiver);
			if (open != Open.CLOSED) return open;
		}
		return Open.CLOSED;
	}
	def isOpenTypeOrSpec(t: Type, spec: IrSpec) -> Open {
		return if(t.open(), Open.OPEN, isOpenSpec(spec));
	}
	def isOpenTypeOrTypes(t: Type, r: Array<Type>) -> Open {
		return if(t.open(), Open.OPEN, isOpenTypes(r));
	}
	def isOpenType2(t1: Type, t2: Type) -> Open {
		return if(t1.open() || t2.open(), Open.OPEN, Open.CLOSED);
	}
	def substSpec(spec: IrSpec, func: Type -> Type) -> IrSpec {
		var nreceiver = func(spec.receiver);
		var ntypeArgs = substArray(spec.typeArgs, func);
		if (nreceiver != spec.receiver || ntypeArgs != spec.typeArgs) return IrSpec.new(nreceiver, ntypeArgs, spec.member);
		return spec;
	}
	def substArray(a: Array<Type>, func: Type -> Type) -> Array<Type> { return Arrays.mapId(a, func); }
	def substArrayType(t: ArrayType, func: Type -> Type) -> ArrayType { return ArrayType.!(func(t)); }
	def substRangeType(t: RangeType, func: Type -> Type) -> RangeType { return RangeType.!(func(t)); }
	def substFuncType(t: FuncType, func: Type -> Type) -> FuncType { return FuncType.!(func(t)); }
	def substRefType(t: RefType, func: Type -> Type) -> RefType { return RefType.!(func(t)); }
}
