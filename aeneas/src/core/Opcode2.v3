// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Represents the statically-known part of an operation, not including the types.
type Opcode2 {
	// Boolean operators
	case BoolEq;
	case BoolAnd;
	case BoolOr;
	case BoolNot;
	// Integer arithmetic and conversions
	case IntEq(t: IntType);
	case IntAdd(t: IntType);
	case IntSub(t: IntType);
	case IntMul(t: IntType);
	case IntDiv(t: IntType);
	case IntMod(t: IntType);
	case IntAnd(t: IntType);
	case IntOr(t: IntType);
	case IntXor(t: IntType);
	case IntShl(t: IntType);
	case IntSar(t: IntType);
	case IntShr(t: IntType);
	case IntLt(t: IntType);
	case IntLteq(t: IntType);
	case IntWide(op: Operator, paramTypes: Array<Type>, resultTypes: Array<Type>);
	// Floating point arithmetic
	case FloatAdd(t: FloatType);
	case FloatSub(t: FloatType);
	case FloatMul(t: FloatType);
	case FloatDiv(t: FloatType);
	case FloatBitEq(t: FloatType);
	case FloatEq(t: FloatType);
	case FloatNe(t: FloatType);
	case FloatLt(t: FloatType);
	case FloatLteq(t: FloatType);
	case FloatAbs(t: FloatType);
	case FloatCeil(t: FloatType);
	case FloatFloor(t: FloatType);
	case FloatSqrt(t: FloatType);
	// Integer casts and conversions
	case IntCastF(to: IntType, from: FloatType);
	case IntQueryF(to: IntType, from: FloatType);
	case IntViewI(to: IntType, from: Type); // TODO: sharpen "from"
	case IntViewF(to: IntType, from: Type); // TODO: sharpen "from"
	case IntTruncF(to: IntType, from: FloatType);
	// Floating point casts and conversions
	case FloatCastI(to: FloatType, from: IntType);
	case FloatCastD(to: FloatType, from: FloatType);
	case FloatQueryI(to: FloatType, from: IntType);
	case FloatQueryD(to: FloatType, from: FloatType);
	case FloatPromoteI(to: FloatType, from: IntType);
	case FloatPromoteF(to: FloatType, from: FloatType);
	case FloatViewI(to: FloatType, from: Type); // TODO: sharpen "from"
	case FloatRoundI(to: FloatType, from: Type); // TODO: sharpen "from"
	case FloatRound(t: FloatType);
	case FloatRoundD(to: FloatType, from: FloatType);
	// Reference equality
	case RefEq(t: Type);
	// Default value operator
	case DefaultValue(t: Type);
	// Int representation for other types
	case IntRepCreate(to: IntRepType, from: Type);
	case IntRepView(to: Type, from: IntRepType);
	// Tuple operations
	case TupleCreate(t: TupleType);
	case TupleGetElem(t: TupleType, index: int);
	// Array operations
	case ArrayAlloc(t: ArrayType);
	case ArrayFill(t: ArrayType);
	case ArrayInit(t: ArrayType, length: int);
	case ArrayTupleInit(t: ArrayType, elems: int, length: int);
	case ArrayGetElem(t: ArrayType, it: IntType);
	case ArraySetElem(t: ArrayType, it: IntType);
	case ArrayGetElemElem(t: ArrayType, it: IntType, index: int);
	case ArraySetElemElem(t: ArrayType, it: IntType, index: int);
	case ArrayGetLength(t: ArrayType);
	// Range operations
	case RangeFromTo(t: RangeType, startType: IntType, lengthType: IntType);
	case RangeFromPlus(t: RangeType, startType: IntType, endType: IntType);
	case RangeGetElem(t: RangeType, it: IntType);
	case RangeSetElem(t: RangeType, it: IntType);
	case RangeGetLength(t: RangeType);
	case RangeStartPlusIndex(t: RangeType, it: IntType);
	case RangeStartFromPointer(t: RangeType, pt: PointerType);
	// Normalized Range operations
	case NormRangeGetElem(t: ArrayType, it: IntType);
	case NormRangeGetElemElem(t: ArrayType, index: int, it: IntType);
	case NormRangeSetElem(t: ArrayType, it: IntType);
	case NormRangeSetElemElem(t: ArrayType, index: int, it: IntType);
	// Component operations
	case Init(method: IrMethod);
	case ComponentGetField(field: IrField);
	case ComponentSetField(field: IrField);
	// Class operations
	case ClassAlloc(spec: IrSpec); // TODO: ClassNew/ClassAlloc
	case ClassEmptyAlloc(t: ClassType, paramTypes: Array<Type>);
	case ClassGetField(spec: IrSpec);
	case ClassInitField(spec: IrSpec);
	case ClassSetField(spec: IrSpec);
	case ClassGetMethod(spec: IrSpec);
	case ClassGetVirtual(spec: IrSpec);
	case ClassGetSelector(spec: IrSpec);
	// Variant operations
	case VariantEq(t: ClassType);
	case VariantGetTag(t: ClassType);
	case VariantAlloc(t: ClassType, paramTypes: Array<Type>);
	case VariantGetField(spec: IrSpec);
	case VariantGetMethod(spec: IrSpec);
	case VariantGetVirtual(spec: IrSpec);
	case VariantGetSelector(spec: IrSpec);
	// Safety checks
	case NullCheck(t: Type);
	case BoundsCheck(t: Type);
	case ConditionalThrow(exception: string);
	// Overloaded, polymorphic casts
	case OverloadedEq(t: Type);
	case TypeCast(cast: TypeCast, to: Type, from: Type);
	case TypeQuery(query: TypeQuery, to: Type, from: Type);
	case TypeSubsume(to: Type, from: Type);
	// Closure and call operations
	case CallMethod(spec: IrSpec);
	case CallClassMethod(spec: IrSpec);
	case CallClassVirtual(spec: IrSpec);
	case CallClassSelector(spec: IrSpec);
	case CallVariantVirtual(spec: IrSpec);
	case CallVariantSelector(spec: IrSpec);
	case CallClosure(t: FuncType);
	case CallFunction(t: FuncType);
	case CreateClosure(obj: Type, method: IrSpec);
	case ForgeClosure(ptrType: PointerType, closureType: Type, paramType: Type, resultType: Type);
	case UnpackClosure(ptrType: PointerType, closureType: Type, paramType: Type, resultType: Type);
	// RefLayout operations
	case RefLayoutAt(t: RefType);
	case RefLayoutOf(t: RefType);
	case RefLayoutIn(t: RefType, offset: int, rt: RefType);
	case RefLayoutGetField(t: RefType, offset: int, ft: Type);
	case RefLayoutSetField(t: RefType, offset: int, ft: Type);
	case RefLayoutAtRepeatedField(t: RefType, offset: int, scale: int, max: int, rt: RefType);
	case RefLayoutGetRepeatedField(t: RefType, offset: int, scale: int, max: int, ft: Type);
	case RefLayoutSetRepeatedField(t: RefType, offset: int, scale: int, max: int, ft: Type);
	case ByteArrayGetField(st: Type, offset: int, ft: Type);
	case ByteArraySetField(st: Type, offset: int, ft: Type);
	case ForgeRange(ptrType: PointerType, t: RangeType);
	// System operations
	case SystemCall(syscall: SystemCall, paramType: Type, resultType: Type); // TODO: paramTypes
	// Container for VST operations
	case VstSugar(op: VstOperator, paramTypes: Array<Type>, resultType: Type);

// ------- Machine-level operations ---------------------------------------------
	// Pointer operations
	case PtrAdd(t: Type, it: IntType);
	case PtrSub(t: Type, it: IntType);
	case PtrLt(t: PointerType);
	case PtrLteq(t: PointerType);
	case PtrAtContents(t: PointerType, at: Type);
	case PtrAtLength(t: PointerType, arrayType: ArrayType);
	case PtrAtObject(t: PointerType, objType: Type);
	case PtrAtRangeElem(t: PointerType, rangeType: RangeType, it: IntType);
	case PtrAtArrayElem(t: PointerType, arrayType: ArrayType, it: IntType);
	case PtrAtEnd(t: PointerType, objType: Type);
	case PtrAtRef(t: PointerType, refType: Type); // TODO: refType: RefType
	case PtrAtComponentField(t: PointerType, field: IrSpec);
	case PtrAtObjectField(t: PointerType, field: IrSpec);
	case PtrAtRefLayoutField(refType: RefType, t: PointerType, offset: int);
	case PtrAtUnboxedObjectField(fields: List<IrSpec>, t: PointerType);
	case PtrAtUnboxedComponentField(fields: List<IrSpec>, t: PointerType);
	case PtrCmpSwp(t: PointerType, valType: Type);
	case PtrLoad(t: Type, valType: Type);
	case PtrStore(t: Type, valType: Type);
	case PtrAddRangeStart(t: PointerType);
	// Get caller instruction pointer or stack pointer
	case CallerIp(t: PointerType);
	case CallerSp(t: PointerType);
	// Allocate raw memory
	case Alloc(t: Type);
	// Call
	case CallAddress(p: PointerType, rep: Mach_FuncRep);
	case CallKernel(kernel: Kernel, paramTypes: Array<Type>, resultType: Type);
}

component Opcodes2 {
	def table = Array<Fact.set>.new(Opcode2.CallKernel.tag + 1); // XXX: Opcode2.count
	new() {
		// shorthand for SSA optimization facts
		var F = Fact.O_FOLDABLE;
		var M: Fact; // TODO = Fact.O_MONOMORPHIC;
		var P = Fact.O_PURE | Fact.O_FOLDABLE; // pure => foldable
		var C = Fact.O_COMMUTATIVE;
		var A: Fact; // TODO = Fact.O_ASSOCIATIVE;
		var NZ   = Fact.V_NON_ZERO;
		var NNEG = Fact.V_NON_NEGATIVE;
		var NNC = Fact.O_NO_NULL_CHECK;
                var NONE = Facts.NONE;

		def t = table; // for code shortitude

		// register all operators and their optimization facts
		t[Opcode2.BoolEq.tag] =			P  |M|C;
		t[Opcode2.BoolAnd.tag] = 		P|A|M|C;
		t[Opcode2.BoolOr.tag] = 		P|A|M|C;
		t[Opcode2.BoolNot.tag] = 		P|M;

		t[Opcode2.IntEq.tag] =			P  |M|C;
		t[Opcode2.IntAdd.tag] = 		P|A|M|C;
		t[Opcode2.IntSub.tag] = 		P|M;
		t[Opcode2.IntMul.tag] = 		P|A|M|C;
		t[Opcode2.IntDiv.tag] = 		F|M;
		t[Opcode2.IntMod.tag] = 		F|M;
		t[Opcode2.IntAnd.tag] = 		P|A|M|C;
		t[Opcode2.IntOr.tag] = 			P|A|M|C;
		t[Opcode2.IntXor.tag] = 		P|A|M|C;
		t[Opcode2.IntShl.tag] = 		P|M;
		t[Opcode2.IntSar.tag] = 		P|M;
		t[Opcode2.IntShr.tag] = 		P|M;
		t[Opcode2.IntLt.tag] = 			P|M;
		t[Opcode2.IntLteq.tag] = 		P|M;
		t[Opcode2.IntWide.tag] = 		P|M;

		t[Opcode2.FloatAdd.tag] =		P|A|M|C;
		t[Opcode2.FloatSub.tag] =		P|M;
		t[Opcode2.FloatMul.tag] =		P|A|M|C;
		t[Opcode2.FloatDiv.tag] =		P|M;
		t[Opcode2.FloatBitEq.tag] =		P  |M|C;
		t[Opcode2.FloatEq.tag] =		P  |M|C;
		t[Opcode2.FloatNe.tag] =		P  |M|C;
		t[Opcode2.FloatLt.tag] =		P|M;
		t[Opcode2.FloatLteq.tag] =		P|M;
		t[Opcode2.FloatAbs.tag] =		P|M;
		t[Opcode2.FloatCeil.tag] =		P|M;
		t[Opcode2.FloatFloor.tag] =		P|M;
		t[Opcode2.FloatSqrt.tag] =		P|M;

		t[Opcode2.IntCastF.tag] =		F|M;
		t[Opcode2.IntQueryF.tag] =		P|M;
		t[Opcode2.IntViewI.tag] = 		P|M;
		t[Opcode2.IntViewI.tag] =		P|M;
		t[Opcode2.IntViewF.tag] =		P|M;
		t[Opcode2.IntTruncF.tag] =		P|M;

		t[Opcode2.FloatCastI.tag] =		F|M;
		t[Opcode2.FloatCastD.tag] =		F|M;
		t[Opcode2.FloatQueryI.tag] =		P|M;
		t[Opcode2.FloatQueryD.tag] =		P|M;
		t[Opcode2.FloatPromoteI.tag] =		P|M;
		t[Opcode2.FloatPromoteF.tag] =		P|M;
		t[Opcode2.FloatViewI.tag] =		P|M;
		t[Opcode2.FloatRoundI.tag] =		P|M;
		t[Opcode2.FloatRound.tag] =		P|M;
		t[Opcode2.FloatRoundD.tag] =		P|M;

		t[Opcode2.RefEq.tag] =			P  |C;
		t[Opcode2.IntRepCreate.tag] =		P  |F;
		t[Opcode2.IntRepView.tag] =		P  |F;

		t[Opcode2.TupleCreate.tag] = 		P;
		t[Opcode2.TupleGetElem.tag] = 		P;

		t[Opcode2.ArrayAlloc.tag] = 		NZ;
		t[Opcode2.ArrayInit.tag] = 		NZ;
		t[Opcode2.ArrayGetElem.tag] = 		NONE;
		t[Opcode2.ArraySetElem.tag] = 		NONE;
		t[Opcode2.ArrayGetLength.tag] = 	F|NNEG;

		t[Opcode2.RangeFromTo.tag] = 		F;
		t[Opcode2.RangeFromPlus.tag] = 		F;
		t[Opcode2.RangeGetLength.tag] = 	P;

		t[Opcode2.RangeStartPlusIndex.tag] =	P;
		t[Opcode2.RangeStartFromPointer.tag] =	P;
		t[Opcode2.NormRangeGetElem.tag] = 	F;
		t[Opcode2.NormRangeGetElemElem.tag] = 	F;
		t[Opcode2.NormRangeSetElem.tag] = 	NONE;
		t[Opcode2.NormRangeSetElemElem.tag] = 	NONE;
		t[Opcode2.PtrAddRangeStart.tag] =	P;
		t[Opcode2.ForgeRange.tag] =		P;

		t[Opcode2.Init.tag] = 			M;
		t[Opcode2.ComponentGetField.tag] = 	NNC|M;
		t[Opcode2.ComponentSetField.tag] = 	NNC|M;

		t[Opcode2.ClassAlloc.tag] = 		NZ;
		t[Opcode2.ClassEmptyAlloc.tag] =	NZ; // TODO: dead-code elimination
		t[Opcode2.ClassGetField.tag] = 		NONE;
		t[Opcode2.ClassSetField.tag] = 		NONE;
		t[Opcode2.ClassInitField.tag] = 	Fact.O_NO_NULL_CHECK;
		t[Opcode2.ClassGetMethod.tag] = 	NZ|F;
		t[Opcode2.ClassGetVirtual.tag] = 	NZ|F;
		t[Opcode2.ClassGetSelector.tag] = 	NZ|F;

		t[Opcode2.VariantEq.tag] =		P  |C;
		t[Opcode2.VariantGetTag.tag] =		P|NNEG;
		t[Opcode2.VariantAlloc.tag] =		P;
		t[Opcode2.VariantGetField.tag] = 	P;
		t[Opcode2.VariantGetMethod.tag] = 	NZ|P;
		t[Opcode2.VariantGetVirtual.tag] = 	NZ|P;
		t[Opcode2.VariantGetSelector.tag] = 	NZ|P;

		t[Opcode2.NullCheck.tag] = 		F|NZ;
		t[Opcode2.BoundsCheck.tag] = 		F;
		t[Opcode2.ConditionalThrow.tag] = 	F|M;

		t[Opcode2.OverloadedEq.tag] =		P  |C;
		t[Opcode2.TypeCast.tag] = 		F;
		t[Opcode2.TypeQuery.tag] = 		P;
		t[Opcode2.TypeSubsume.tag] = 		P;

		t[Opcode2.CallMethod.tag] = 		NONE;
		t[Opcode2.CallClassVirtual.tag] = 	NONE;
		t[Opcode2.CallClassSelector.tag] = 	NONE;
		t[Opcode2.CallClosure.tag] = 		NONE;
		t[Opcode2.CallFunction.tag] = 		NONE;
		t[Opcode2.CreateClosure.tag] = 		NZ|P|NNC;
		t[Opcode2.ForgeClosure.tag] = 		P|NNC;
		t[Opcode2.UnpackClosure.tag] = 		P|NNC;

		t[Opcode2.SystemCall.tag] = 		NONE;

		t[Opcode2.PtrAdd.tag] =			P|M; // XXX: could be foldable with offset
		t[Opcode2.PtrSub.tag] =			P|M;
		t[Opcode2.PtrLt.tag] =			P|M;
		t[Opcode2.PtrLteq.tag] =		P|M;
		t[Opcode2.PtrAtContents.tag] =		P;
		t[Opcode2.PtrAtLength.tag] =		P;
		t[Opcode2.PtrAtObject.tag] =		P;
		t[Opcode2.PtrAtRangeElem.tag] =		F|M;
		t[Opcode2.PtrAtArrayElem.tag] =		F|M;
		t[Opcode2.PtrAtComponentField.tag] =	P|M;
		t[Opcode2.PtrAtObjectField.tag] =	F;
		t[Opcode2.PtrLoad.tag] =		NONE;
		t[Opcode2.PtrStore.tag] =		NONE;

		t[Opcode2.CallerIp.tag] =		P|M;
		t[Opcode2.CallerSp.tag] =		P|M;

		t[Opcode2.Alloc.tag] =			NONE;

		t[Opcode2.RefLayoutAt.tag] = 		NZ|F|M;
		t[Opcode2.RefLayoutIn.tag] = 		P|F|M;
		t[Opcode2.RefLayoutGetField.tag] =	NONE;
		t[Opcode2.RefLayoutAtRepeatedField.tag] = P|M;
	}
	def facts(opcode: Opcode2) -> Fact.set {
		return table[opcode.tag];
	}
	def checkOpenness(opcode: Opcode2) -> Open {
//TODO		if (table[opcode.tag].O_MONOMORPHIC) return Open.CLOSED;
		var open = Open.OPEN;
		match (opcode) {
			RefEq(t) =>				open = isOpenType(t);
			IntRepCreate(t, f) =>			open = isOpenType(f);
			IntRepView(t, f) =>			open = isOpenType(t);
			IntViewF(t, f) =>			open = isOpenType(f);
			FloatViewI(t, f) =>			open = isOpenType(f);
			FloatRoundI(t, f) =>			open = isOpenType(f);
			TupleCreate(t) => 			open = isOpenType(t);
			TupleGetElem(t, index) => 		open = isOpenType(t);
			ArrayAlloc(t) =>			open = isOpenType(t);
			ArrayInit(t, length) =>			open = isOpenType(t);
			ArrayTupleInit(t, elems, length) => 	open = isOpenType(t);
			ArrayGetElem(t, it) =>			open = isOpenType(t);
			ArraySetElem(t, it) =>			open = isOpenType(t);
			ArrayGetElemElem(t, it, index) => 	open = isOpenType(t);
			ArraySetElemElem(t, it, index) => 	open = isOpenType(t);
			ArrayGetLength(t) =>			open = isOpenType(t);
			RangeFromTo(t, st, lt) =>		open = isOpenType(t);
			RangeFromPlus(t, st, et) =>		open = isOpenType(t);
			RangeGetElem(t, it) =>			open = isOpenType(t);
			RangeSetElem(t, it) =>			open = isOpenType(t);
			RangeGetLength(t) =>			open = isOpenType(t);
			RangeStartPlusIndex(t, it) =>		open = isOpenType(t);
			RangeStartFromPointer(t, pt) =>		open = isOpenType(t);
			NormRangeGetElem(t, it) =>		open = isOpenType(t);
			NormRangeGetElemElem(t, index, it) =>	open = isOpenType(t);
			NormRangeSetElem(t, it) =>		open = isOpenType(t);
			NormRangeSetElemElem(t, index, it) =>	open = isOpenType(t);
			ClassAlloc(spec) => 			open = isOpenSpec(spec);
			ClassEmptyAlloc(t, paramTypes) =>	open = isOpenTypeOrTypes(t, paramTypes);
			ClassGetField(spec) => 			open = isOpenSpec(spec);
			ClassInitField(spec) =>			open = isOpenSpec(spec);
			ClassSetField(spec) => 			open = isOpenSpec(spec);
			ClassGetMethod(spec) =>			open = isOpenSpec(spec);
			ClassGetVirtual(spec) => 		open = isOpenSpec(spec);
			ClassGetSelector(spec) => 		open = isOpenSpec(spec);
			VariantEq(t) =>				open = isOpenType(t);
			VariantGetTag(t) =>			open = isOpenType(t);
			VariantAlloc(t, paramTypes) =>		open = isOpenTypeOrTypes(t, paramTypes);
			VariantGetField(spec) => 		open = isOpenSpec(spec);
			VariantGetMethod(spec) => 		open = isOpenSpec(spec);
			VariantGetVirtual(spec) => 		open = isOpenSpec(spec);
			VariantGetSelector(spec) => 		open = isOpenSpec(spec);
			NullCheck(t) =>				open = isOpenType(t);
			BoundsCheck(t) =>			open = isOpenType(t);
			OverloadedEq(t) =>			open = isOpenType(t);
			TypeCast(cast, to, from) =>		open = isOpenType2(to, from);
			TypeQuery(query, to, from) =>		open = isOpenType2(to, from);
			TypeSubsume(to, from) =>		open = isOpenType2(to, from);
			CallMethod(spec) => 			open = isOpenSpec(spec);
			CallClassMethod(spec) => 		open = isOpenSpec(spec);
			CallClassVirtual(spec) => 		open = isOpenSpec(spec);
			CallClassSelector(spec) => 		open = isOpenSpec(spec);
			CallVariantVirtual(spec) => 		open = isOpenSpec(spec);
			CallVariantSelector(spec) => 		open = isOpenSpec(spec);
			CallClosure(t) => 			open = isOpenType(t);
			CallFunction(t) => 			open = isOpenType(t);
			CreateClosure(obj, method) => 		open = isOpenTypeOrSpec(obj, method);
			ForgeClosure(ptrType, closureType, paramType, resultType) => 	open = isOpenTypes([closureType, paramType, resultType]);
			UnpackClosure(ptrType, closureType, paramType, resultType) => 	open = isOpenTypes([closureType, paramType, resultType]);
			RefLayoutGetField(t, offset, ft) =>				open = isOpenType(ft);
			RefLayoutSetField(t, offset, ft) =>				open = isOpenType(ft);
			RefLayoutGetRepeatedField(t, offset, scale, max, ft) =>		open = isOpenType(ft);
			RefLayoutSetRepeatedField(t, offset, scale, max, ft) =>		open = isOpenType(ft);
			ByteArrayGetField(st, offset, ft) =>				open = isOpenType(ft);
			ByteArraySetField(st, offset, ft) =>				open = isOpenType(ft);
			ForgeRange(ptrType, t) => 					open = isOpenType(t);
			SystemCall(syscall, paramType, resultType) =>			open = isOpenType2(paramType, resultType);
			VstSugar(op, paramTypes, resultType) =>				open = isOpenTypeOrTypes(resultType, paramTypes);
			PtrAtContents(t, at) =>						open = isOpenType(at);
			PtrAtLength(t, arrayType) =>					open = isOpenType(arrayType);
			PtrAtObject(t, objType) =>					open = isOpenType(objType);
			PtrAtRangeElem(t, at, it) =>					open = isOpenType(at);
			PtrAtArrayElem(t, at, it) =>					open = isOpenType(at);
			PtrAtRef(t, refType) =>						open = isOpenType(refType);
			PtrAtEnd(t, objType) =>						open = isOpenType(objType);
			PtrAtObjectField(t, field) =>					open = isOpenType(t);
			PtrAtRefLayoutField(refType, t, offset) =>			open = isOpenType(t);
			PtrAtUnboxedObjectField(fields, ptrType) =>			open = isOpenSpecs(fields);
			PtrAtUnboxedComponentField(fields, ptrType) =>			open = isOpenSpecs(fields);
			PtrCmpSwp(t, valType) =>					open = isOpenType(valType);
			PtrLoad(t, valType) =>						open = isOpenType(valType);
			PtrStore(t, valType) =>						open = isOpenType(valType);
			Alloc(t) =>							open = isOpenType(t);
			CallAddress(p, rep) => {
				if (isOpenTypes(rep.paramTypes) != Open.CLOSED) return Open.OPEN;
				if (isOpenTypes(rep.returnTypes) != Open.CLOSED) return Open.OPEN;
				open = Open.CLOSED;
			}
			CallKernel(kernel, paramTypes, resultType) => 			open = isOpenTypeOrTypes(resultType, paramTypes);
			_ => ;
		}
		return open;
	}
	def subst(opcode: Opcode2, func: Type -> Type) -> Opcode2 {
		match (opcode) {
			RefEq(t) =>				return Opcode2.RefEq(func(t));
			IntViewF(t, f) =>			return Opcode2.IntViewF(t, func(f));
			FloatViewI(t, f) =>			return Opcode2.FloatViewI(t, func(f));
			FloatRoundI(t, f) =>			return Opcode2.FloatRoundI(t, func(f));
			TupleCreate(t) => 			return Opcode2.TupleCreate(TupleType.!(func(t)));
			TupleGetElem(t, index) => 		return Opcode2.TupleGetElem(TupleType.!(func(t)), index);
			ArrayAlloc(t) =>			return Opcode2.ArrayAlloc(substArrayType(t, func));
			ArrayFill(t) =>				return Opcode2.ArrayFill(substArrayType(t, func));
			ArrayInit(t, length) =>			return Opcode2.ArrayInit(substArrayType(t, func), length);
			ArrayTupleInit(t, elems, length) => 	return Opcode2.ArrayTupleInit(substArrayType(t, func), elems, length);
			ArrayGetElem(t, it) =>			return Opcode2.ArrayGetElem(substArrayType(t, func), it);
			ArraySetElem(t, it) =>			return Opcode2.ArraySetElem(substArrayType(t, func), it);
			ArrayGetElemElem(t, it, index) => 	return Opcode2.ArrayGetElemElem(substArrayType(t, func), it, index);
			ArraySetElemElem(t, it, index) => 	return Opcode2.ArraySetElemElem(substArrayType(t, func), it, index);
			ArrayGetLength(t) =>			return Opcode2.ArrayGetLength(substArrayType(t, func));
			RangeFromTo(t, st, et) =>		return Opcode2.RangeFromTo(substRangeType(t, func), st, et);
			RangeFromPlus(t, st, lt) =>		return Opcode2.RangeFromPlus(substRangeType(t, func), st, lt);
			RangeGetElem(t, it) =>			return Opcode2.RangeGetElem(substRangeType(t, func), it);
			RangeSetElem(t, it) =>			return Opcode2.RangeSetElem(substRangeType(t, func), it);
			RangeGetLength(t) =>			return Opcode2.RangeGetLength(substRangeType(t, func));
			RangeStartPlusIndex(t, it) =>		return Opcode2.RangeStartPlusIndex(substRangeType(t, func), it);
			RangeStartFromPointer(t, pt) =>		return Opcode2.RangeStartFromPointer(substRangeType(t, func), pt);
			NormRangeGetElem(t, it) =>		return Opcode2.NormRangeGetElem(substArrayType(t, func), it);
			NormRangeGetElemElem(t, index, it) =>	return Opcode2.NormRangeGetElemElem(substArrayType(t, func), index, it);
			NormRangeSetElem(t, it) =>		return Opcode2.NormRangeSetElem(substArrayType(t, func), it);
			NormRangeSetElemElem(t, index, it) =>	return Opcode2.NormRangeSetElemElem(substArrayType(t, func), index, it);
			ClassAlloc(spec) => 			return Opcode2.ClassAlloc(substSpec(spec, func));
			ClassEmptyAlloc(classType, paramTypes) => return Opcode2.ClassEmptyAlloc(ClassType.!(func(classType)), substArray(paramTypes, func));
			ClassGetField(spec) => 			return Opcode2.ClassGetField(substSpec(spec, func));
			ClassInitField(spec) =>			return Opcode2.ClassInitField(substSpec(spec, func));
			ClassSetField(spec) => 			return Opcode2.ClassSetField(substSpec(spec, func));
			ClassGetMethod(spec) =>			return Opcode2.ClassGetMethod(substSpec(spec, func));
			ClassGetVirtual(spec) => 		return Opcode2.ClassGetVirtual(substSpec(spec, func));
			ClassGetSelector(spec) => 		return Opcode2.ClassGetSelector(substSpec(spec, func));
			VariantEq(t) =>				return Opcode2.VariantEq(ClassType.!(func(t)));
			VariantGetTag(t) =>			return Opcode2.VariantGetTag(ClassType.!(func(t)));
			VariantAlloc(classType, paramTypes) =>	return Opcode2.VariantAlloc(ClassType.!(func(classType)), substArray(paramTypes, func));
			VariantGetField(spec) => 		return Opcode2.VariantGetField(substSpec(spec, func));
			VariantGetMethod(spec) => 		return Opcode2.VariantGetMethod(substSpec(spec, func));
			VariantGetVirtual(spec) => 		return Opcode2.VariantGetVirtual(substSpec(spec, func));
			VariantGetSelector(spec) => 		return Opcode2.VariantGetSelector(substSpec(spec, func));
			NullCheck(t) =>				return Opcode2.NullCheck(func(t));
			BoundsCheck(t) =>			return Opcode2.BoundsCheck(func(t));
			OverloadedEq(t) =>			return Opcode2.OverloadedEq(func(t));
			TypeCast(cast, to, from) =>		return Opcode2.TypeCast(cast, func(to), func(from));
			TypeQuery(query, to, from) =>		return Opcode2.TypeQuery(query, func(to), func(from));
			TypeSubsume(to, from) =>		return Opcode2.TypeSubsume(func(to), func(from));
			CallMethod(spec) => 			return Opcode2.CallMethod(substSpec(spec, func));
			CallClassMethod(spec) => 		return Opcode2.CallClassMethod(substSpec(spec, func));
			CallClassVirtual(spec) => 		return Opcode2.CallClassVirtual(substSpec(spec, func));
			CallClassSelector(spec) => 		return Opcode2.CallClassSelector(substSpec(spec, func));
			CallVariantVirtual(spec) => 		return Opcode2.CallVariantVirtual(substSpec(spec, func));
			CallVariantSelector(spec) => 		return Opcode2.CallVariantSelector(substSpec(spec, func));
			CallClosure(t) => 			return Opcode2.CallClosure(FuncType.!(func(t)));
			CallFunction(t) => 			return Opcode2.CallFunction(FuncType.!(func(t)));
			CreateClosure(obj, method) => 		return Opcode2.CreateClosure(func(obj), substSpec(method, func));
			ForgeClosure(ptrType, closureType, paramType, resultType) => 	return Opcode2.ForgeClosure(ptrType, func(closureType), func(paramType), func(resultType));
			UnpackClosure(ptrType, closureType, paramType, resultType) => 	return Opcode2.UnpackClosure(ptrType, func(closureType), func(paramType), func(resultType));
			RefLayoutGetField(t, offset, ft) =>				return Opcode2.RefLayoutGetField(t, offset, func(ft));
			RefLayoutSetField(t, offset, ft) =>				return Opcode2.RefLayoutSetField(t, offset, func(ft));
			RefLayoutGetRepeatedField(t, offset, scale, max, ft) =>		return Opcode2.RefLayoutGetRepeatedField(t, offset, scale, max, func(ft));
			RefLayoutSetRepeatedField(t, offset, scale, max, ft) =>		return Opcode2.RefLayoutSetRepeatedField(t, offset, scale, max, func(ft));
			ByteArrayGetField(st, offset, ft) =>				return Opcode2.ByteArrayGetField(st, offset, func(ft));
			ByteArraySetField(st, offset, ft) =>				return Opcode2.ByteArraySetField(st, offset, func(ft));
			ForgeRange(ptrType, t) => 					return Opcode2.ForgeRange(ptrType, substRangeType(t, func));
			SystemCall(syscall, paramType, resultType) =>			return Opcode2.SystemCall(syscall, func(paramType), func(resultType));
			VstSugar(op, paramTypes, resultType) =>				return Opcode2.VstSugar(op, substArray(paramTypes, func), func(resultType));
			PtrAtContents(t, at) =>						return Opcode2.PtrAtContents(t, func(at));
			PtrAtLength(t, arrayType) =>					return Opcode2.PtrAtLength(t, ArrayType.!(func(arrayType)));
			PtrAtObject(t, objType) =>					return Opcode2.PtrAtObject(t, func(objType));
			PtrAtRangeElem(t, at, it) =>					return Opcode2.PtrAtRangeElem(t, substRangeType(at, func), it);
			PtrAtArrayElem(t, at, it) =>					return Opcode2.PtrAtArrayElem(t, substArrayType(at, func), it);
			PtrAtRef(t, refType) =>						return Opcode2.PtrAtRef(t, func(refType));
			PtrAtEnd(t, objType) =>						return Opcode2.PtrAtEnd(t, func(objType));
			PtrAtObjectField(t, field) =>					return Opcode2.PtrAtObjectField(t, substSpec(field, func));
			PtrAtRefLayoutField(refType, t, offset) =>			return Opcode2.PtrAtRefLayoutField(substRefType(refType, func), t, offset);
			PtrAtUnboxedObjectField(fields, ptrType) =>			return Opcode2.PtrAtUnboxedObjectField(Lists.map(fields, substSpec(_, func)), ptrType); // XXX: optimize closed case
			PtrAtUnboxedComponentField(fields, ptrType) =>			return Opcode2.PtrAtUnboxedComponentField(Lists.map(fields, substSpec(_, func)), ptrType); // XXX: optimize closed case
			PtrCmpSwp(t, valType) =>					return Opcode2.PtrCmpSwp(t, func(valType));
			PtrLoad(t, valType) =>						return Opcode2.PtrLoad(t, func(valType));
			PtrStore(t, valType) =>						return Opcode2.PtrStore(t, func(valType));
			Alloc(t) =>							return Opcode2.Alloc(func(t));
			CallAddress(p, rep) => {
				var np = substArray(rep.paramTypes, func);
				var nr = substArray(rep.returnTypes, func);
				if (np == rep.paramTypes && nr == rep.returnTypes) return opcode;
				var nrep = Mach_FuncRep.new(rep.origType, rep.machType, np, nr); // TODO: assuming same calling convention
				return Opcode2.CallAddress(p, nrep);
			}
			CallKernel(kernel, paramTypes, resultType) => 			return Opcode2.CallKernel(kernel, substArray(paramTypes, func), func(resultType));
			_ => return opcode;
		}
	}
	def isOpenType(t: Type) -> Open {
		return if(t.open(), Open.OPEN, Open.CLOSED);
	}
	def isOpenTypes(types: Range<Type>) -> Open {
		for (t in types) if (t.open()) return Open.OPEN;
		return Open.CLOSED;
	}
	def isOpenSpec(spec: IrSpec) -> Open {
		return if(spec.isPolymorphic(), Open.OPEN, Open.CLOSED);
	}
	def isOpenSpecs(specs: List<IrSpec>) -> Open {
		for (l = specs; l != null; l = l.tail) {
			var open = isOpenType(l.head.receiver);
			if (open != Open.CLOSED) return open;
		}
		return Open.CLOSED;
	}
	def isOpenTypeOrSpec(t: Type, spec: IrSpec) -> Open {
		return if(t.open(), Open.OPEN, isOpenSpec(spec));
	}
	def isOpenTypeOrTypes(t: Type, r: Array<Type>) -> Open {
		return if(t.open(), Open.OPEN, isOpenTypes(r));
	}
	def isOpenType2(t1: Type, t2: Type) -> Open {
		return if(t1.open() || t2.open(), Open.OPEN, Open.CLOSED);
	}
	def substSpec(spec: IrSpec, func: Type -> Type) -> IrSpec {
		var nreceiver = func(spec.receiver);
		var ntypeArgs = substArray(spec.typeArgs, func);
		if (nreceiver != spec.receiver || ntypeArgs != spec.typeArgs) return IrSpec.new(nreceiver, ntypeArgs, spec.member);
		return spec;
	}
	def substArray(a: Array<Type>, func: Type -> Type) -> Array<Type> {
		for (i < a.length) {
			var prev = a[i], ntype = func(prev);
			if (prev != ntype) return Arrays.map(a, func); // XXX: slight redundant work for j < i
		}
		return a;
	}
	def substArrayType(t: ArrayType, func: Type -> Type) -> ArrayType { return ArrayType.!(func(t)); }
	def substRangeType(t: RangeType, func: Type -> Type) -> RangeType { return RangeType.!(func(t)); }
	def substFuncType(t: FuncType, func: Type -> Type) -> FuncType { return FuncType.!(func(t)); }
	def substRefType(t: RefType, func: Type -> Type) -> RefType { return RefType.!(func(t)); }
}
