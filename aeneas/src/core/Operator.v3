// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An operator represents a computation from argument values to a result value
// with possible side-effects.
class Operator(opcode: Opcode, typeArgs: Array<Type>, sig_: Signature) {
	private var openness: Open;			// lazily computed open / closed
	var op2: Operator2;

	def checkOpenness() -> Open {
		// openness is not known. check all type args and operator type
		if (openness != Open.UNKNOWN) return openness;
		var hash = 0;
		// XXX: bail out earlier if a nested type is open
		for (t in typeArgs) hash = hash | t.hash;
		var sig = this.sig();
		for (t in sig.paramTypes) hash = hash | t.hash;
		for (t in sig.returnTypes) hash = hash | t.hash;
		return openness = if((hash & TypeConst.OPEN_MASK) != 0, Open.OPEN, Open.CLOSED);
	}
	def isPolymorphic() -> bool {
		return checkOpenness() == Open.OPEN;
	}
	def subst(f: Type -> Type) -> Operator {
		if (openness == Open.CLOSED) return this;
		if (checkOpenness() == Open.OPEN) {
			var op = Operator.new(opcode, Arrays.map(typeArgs, f), sig_.subst(f));
			if (op2 != null) op.op2 = this.op2.subst(f);
			return op;
		}
		return this;
	}
	def equals(that: Operator) -> bool {
		if (this == that) return true;
		return this.opcode == that.opcode && Arrays.equal(this.typeArgs, that.typeArgs);
	}
	def render(buf: StringBuilder) -> StringBuilder {
		return renderOp(this, buf);
	}
	def evaluate(args: Arguments) -> Result {
		return Eval.doOp(this, args);
	}
	def setOp2(op: Opcode2) -> this {
		this.op2 = Operator2.new(op);
	}
	def sig() -> Signature {
		if (op2 != null) return op2.sig();
		return sig_;
	}
}

// Whether an operator is known to contain any open (polymorphic) types.
enum Open { UNKNOWN, OPEN, CLOSED }

// Everything for building and caching operators. Named {Op} to keep
// the rest of the code short.
component V3Op {
	// Cached sigs and parts of sigs
	def arr_v = TypeUtil.NO_TYPES;
	def type_i = Int.TYPE;
	def type_u = Int.getType(false, 32);
	def type_z = Bool.TYPE;
	def type_v = Void.TYPE;
	def type_f: Type = Float.FLOAT32;
	def type_d: Type = Float.FLOAT64;
	def type_rs = V3Range.START_TYPE;

	def arr_z = Bool.ARRAY_T;
	def arr_i = Int.ARRAY_T;
	def arr_f = [type_f];
	def arr_ff = [type_f, type_f];
	def arr_d = [type_d];
	def arr_dd = [type_d, type_d];
	def arr_zz = Bool.ARRAY_TT;

	def sig_zz_z = Signature.new(null, arr_zz, arr_z);
	def sig_z_z = Signature.new(null, arr_z, arr_z);

	private def newOp0(opcode: Opcode, typeArgs: Array<Type>, paramTypes: Array<Type>, returnType: Type) -> Operator {
		return Operator.new(opcode, typeArgs, Function.siga(paramTypes, returnType));
	}

//----------------------------------------------------------------------------
	def opBoolEq = Operator.new(Opcode.BoolEq, arr_z, sig_zz_z).setOp2(Opcode2.BoolEq);
	def opBoolAnd = Operator.new(Opcode.BoolAnd, arr_v, sig_zz_z).setOp2(Opcode2.BoolAnd);
	def opBoolOr = Operator.new(Opcode.BoolOr, arr_v, sig_zz_z).setOp2(Opcode2.BoolOr);
	def opBoolNot = Operator.new(Opcode.BoolNot, arr_v, sig_z_z).setOp2(Opcode2.BoolNot);
//----------------------------------------------------------------------------
	def newIntEq(t: IntType) -> Operator {
		return newOp0(Opcode.IntEq, [t], [t, t], type_z).setOp2(Opcode2.IntEq(t))
			.setOp2(Opcode2.IntEq(t));
	}
	def newIntWide(op: Operator, normal: Array<Type>, result: Type) -> Operator {
		return newOp0(Opcode.IntWide(op), arr_v, normal, result)
			.setOp2(Opcode2.IntWide(op, normal, Tuple.toTypeArray(result)));
	}
//----------------------------------------------------------------------------
	def opFloatBitEq32 = newOp0(Opcode.FloatBitEq(false), arr_f, arr_ff, type_z).setOp2(Opcode2.FloatBitEq(Float.FLOAT32));
	def opFloatBitEq64 = newOp0(Opcode.FloatBitEq(true), arr_d, arr_dd, type_z).setOp2(Opcode2.FloatBitEq(Float.FLOAT64));
//----------------------------------------------------------------------------
	def newIntCastF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntCastF(V3.isDouble(ft)), [ft, tt], [ft], tt)
			.setOp2(Opcode2.IntCastF(IntType.!(tt), FloatType.!(ft)));
	}
	def newIntQueryF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntQueryF(V3.isDouble(ft)), [ft, tt], [ft], type_z)
			.setOp2(Opcode2.IntQueryF(IntType.!(tt), FloatType.!(ft)));
	}
	def newIntViewI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntViewI, [ft, tt], [ft], tt)
			.setOp2(Opcode2.IntViewI(IntType.!(tt), IntType.!(ft)));
	}
	def opIntViewF32 = newOp0(Opcode.IntViewF(false), arr_f, arr_f, type_u).setOp2(Opcode2.IntViewF(Int.U32, Float.FLOAT32));
	def opIntViewF64 = newOp0(Opcode.IntViewF(true), arr_d, arr_d, Int.getType(false, 64)).setOp2(Opcode2.IntViewF(Long.U64, Float.FLOAT64));
	def newIntTruncF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntTruncF(V3.isDouble(ft)), [ft, tt], [ft], tt)
			.setOp2(Opcode2.IntTruncF(IntType.!(tt), FloatType.!(ft)));
	}
//----------------------------------------------------------------------------
	def newFloatCastI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatCastI(V3.isDouble(tt)), [ft, tt], [ft], tt)
			.setOp2(Opcode2.FloatCastI(FloatType.!(tt), IntType.!(ft)));
	}
	def opFloatCastD = newOp0(Opcode.FloatCastD, arr_d, arr_d, type_f).setOp2(Opcode2.FloatCastD(Float.FLOAT32, Float.FLOAT64));
	def newFloatQueryI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatQueryI(V3.isDouble(tt)), [ft, tt], [ft], type_z)
			.setOp2(Opcode2.FloatQueryI(FloatType.!(tt), IntType.!(ft)));
	}
	def opFloatQueryD = newOp0(Opcode.FloatQueryD, arr_d, arr_d, type_z).setOp2(Opcode2.FloatQueryD(Float.FLOAT32, Float.FLOAT64));
	def newFloatPromoteI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatPromoteI(V3.isDouble(tt)), [ft, tt], [ft], tt)
			.setOp2(Opcode2.FloatPromoteI(FloatType.!(tt), IntType.!(ft)));
	}
	def opFloatPromoteF = newOp0(Opcode.FloatPromoteF, arr_f, arr_f, type_d).setOp2(Opcode2.FloatPromoteF(Float.FLOAT64, Float.FLOAT32));
	def newFloat32ViewI(ft: Type) -> Operator {
		return newOp0(Opcode.FloatViewI(false), [ft, type_f], [ft], type_f)
			.setOp2(Opcode2.FloatViewI(Float.FLOAT32, ft)); // TODO: ft should be IntType
	}
	def newFloat64ViewI(ft: Type) -> Operator {
		return newOp0(Opcode.FloatViewI(true), [ft, type_d], [ft], type_d)
			.setOp2(Opcode2.FloatViewI(Float.FLOAT64, ft)); // TODO: ft should be IntType
	}
	def newFloatRoundI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatRoundI(V3.isDouble(tt)), [ft, tt], [ft], tt)
			.setOp2(Opcode2.FloatRoundI(FloatType.!(tt), ft)); // TODO: ft should be IntType
	}
	def newFloatRound(t: Type) -> Operator {
		return newOp0(Opcode.FloatRound(V3.isDouble(t)), [t], [t], t)
			.setOp2(Opcode2.FloatRound(FloatType.!(t)));
	}
	def opFloatRoundD = newOp0(Opcode.FloatRoundD, arr_v, arr_d, type_f)
		.setOp2(Opcode2.FloatRoundD(Float.FLOAT32, Float.FLOAT64));
//----------------------------------------------------------------------------
	def newRefEq(t: Type) -> Operator {
		return newOp0(Opcode.RefEq, [t], [t, t], type_z)
			.setOp2(Opcode2.RefEq(t));
	}
//----------------------------------------------------------------------------
	def newDefaultValue(t: Type) -> Operator {
		return newOp0(Opcode.DefaultValue, [t], arr_v, t)
			.setOp2(Opcode2.DefaultValue(t));
	}
//----------------------------------------------------------------------------
	def newIntRepCreate(ft: Type, tt: IntRepType) -> Operator {
		return newOp0(Opcode.IntRepCreate, [ft, tt], [ft], tt)
			.setOp2(Opcode2.IntRepCreate(tt, ft));
	}
	def newIntRepView(ft: IntRepType, tt: Type) -> Operator {
		return newOp0(Opcode.IntRepView, [ft, tt], [ft], tt)
			.setOp2(Opcode2.IntRepView(tt, ft));
	}
//----------------------------------------------------------------------------
	def newTupleCreate(tupleType: Type) -> Operator {
		var paramTypes = Lists.toArray(tupleType.nested);
		return newOp0(Opcode.TupleCreate(paramTypes.length), [tupleType], paramTypes, tupleType)
			.setOp2(Opcode2.TupleCreate(TupleType.!(tupleType)));
	}
	def newTupleGetElem(tupleType: Type, index: int) -> Operator {
		var tt = [tupleType];
		return newOp0(Opcode.TupleGetElem(index), tt, tt, Lists.get(tupleType.nested, index))
			.setOp2(Opcode2.TupleGetElem(TupleType.!(tupleType), index));
	}
//----------------------------------------------------------------------------
	def newArrayAlloc(arrayType: Type) -> Operator {
		return newOp0(Opcode.ArrayAlloc, [arrayType], arr_i, arrayType)
			.setOp2(Opcode2.ArrayAlloc(ArrayType.!(arrayType)));
	}
	def newArrayFill(arrayType: Type) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		return newOp0(Opcode.ArrayFill, [arrayType], [arrayType, elemType], arrayType)
			.setOp2(Opcode2.ArrayFill(ArrayType.!(arrayType)));
	}
	def newArrayInit(arrayType: Type, length: int) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var paramTypes = Array<Type>.new(length);
		for (i < paramTypes.length) paramTypes[i] = elemType;
		return newOp0(Opcode.ArrayInit(length), [arrayType], paramTypes, arrayType)
			.setOp2(Opcode2.ArrayInit(ArrayType.!(arrayType), length));
	}
	def newArrayTupleInit(arrayType: Type, elems: int, length: int) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var paramTypes = Array<Type>.new(elems * length);
		var tuple = Tuple.toTypeArray(V3Array.elementType(arrayType));
		var i = 0;
		for (j < length) {
			for (k < tuple.length) {
				paramTypes[i++] = tuple[k];
			}
		}
		return newOp0(Opcode.ArrayTupleInit(elems, length), [arrayType], paramTypes, arrayType)
			.setOp2(Opcode2.ArrayTupleInit(ArrayType.!(arrayType), elems, length));
	}
	def newArrayGetElem(arrayType: Type, indexType: IntType) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var tt = [arrayType, indexType];
		match (arrayType) {
			x: ArrayType => return newOp0(Opcode.ArrayGetElem, tt, tt, elemType)
				.setOp2(Opcode2.ArrayGetElem(x, indexType));
			x: RangeType => return newOp0(Opcode.RangeGetElem, tt, tt, elemType)
				.setOp2(Opcode2.RangeGetElem(x, indexType));
			_ => return null; // TODO: error
		}
	}
	def newArraySetElem(arrayType: Type, indexType: IntType) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var tt = [arrayType, indexType, elemType];
		match (arrayType) {
			x: ArrayType => return newOp0(Opcode.ArraySetElem, tt, tt, type_v)
				.setOp2(Opcode2.ArraySetElem(x, indexType));
			x: RangeType => return newOp0(Opcode.RangeSetElem, tt, tt, type_v)
				.setOp2(Opcode2.RangeSetElem(x, indexType));
			_ => return null; // TODO: error
		}
	}
	def newArrayGetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		var tt = [arrayType, indexType];
		return newOp0(Opcode.ArrayGetElemElem(index), tt, tt, etype)
			.setOp2(Opcode2.ArrayGetElemElem(ArrayType.!(arrayType), IntType.!(indexType), index));
	}
	def newArraySetElemElem(arrayType: Type, indexType: Type, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		var tt = [arrayType, indexType, etype];
		return newOp0(Opcode.ArraySetElemElem(index), tt, tt, type_v)
			.setOp2(Opcode2.ArraySetElemElem(ArrayType.!(arrayType), IntType.!(indexType), index));
	}
	def newArrayGetLength(arrayType: Type) -> Operator {
		var tt = [arrayType];
		match (arrayType) {
			x: ArrayType => return newOp0(Opcode.ArrayGetLength, tt, tt, type_i)
				.setOp2(Opcode2.ArrayGetLength(x));
			x: RangeType => return newOp0(Opcode.RangeGetLength, tt, tt, type_i)
				.setOp2(Opcode2.RangeGetLength(x));
			_ => return null; // TODO: error
		}
	}
//----------------------------------------------------------------------------
	def newRangeFromPlus(rangeType: Type, startType: Type, lengthType: Type) -> Operator {
		var tt = [rangeType, startType, lengthType];
		return newOp0(Opcode.RangeFromPlus, tt, tt, rangeType)
			.setOp2(Opcode2.RangeFromPlus(RangeType.!(rangeType), IntType.!(startType), IntType.!(lengthType)));
	}
	def newRangeFromTo(rangeType: Type, startType: Type, endType: Type) -> Operator {
		var tt = [rangeType, startType, endType];
		return newOp0(Opcode.RangeFromTo, tt, tt, rangeType)
			.setOp2(Opcode2.RangeFromTo(RangeType.!(rangeType), IntType.!(startType), IntType.!(endType)));
	}
	def newRangeGetLength(rangeType: Type) -> Operator {
		var tt = [rangeType];
		return newOp0(Opcode.RangeGetLength, tt, tt, type_i)
			.setOp2(Opcode2.RangeGetLength(RangeType.!(rangeType)));
	}
	def newRangeStartPlusIndex(rangeType: Type, indexType: IntType) -> Operator {
		return newOp0(Opcode.RangeStartPlusIndex, [rangeType, indexType], [type_rs, indexType], type_rs)
			.setOp2(Opcode2.RangeStartPlusIndex(RangeType.!(rangeType), indexType));
	}
	def newRangeStartFromPointer(rangeType: Type, ptrType: PointerType) -> Operator {
		return newOp0(Opcode.RangeStartFromPointer, [rangeType, ptrType], [ptrType], type_rs)
			.setOp2(Opcode2.RangeStartFromPointer(RangeType.!(rangeType), ptrType));
	}
	def newNormRangeGetElem(arrayType: Type, indexType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return newOp0(Opcode.NormRangeGetElem, [arrayType, indexType], [arrayType, type_rs, indexType], etype)
			.setOp2(Opcode2.NormRangeGetElem(ArrayType.!(arrayType), IntType.!(indexType)));
	}
	def newNormRangeGetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		return newOp0(Opcode.NormRangeGetElemElem(index), [arrayType, indexType], [arrayType, type_rs, indexType], etype)
			.setOp2(Opcode2.NormRangeGetElemElem(ArrayType.!(arrayType), index, IntType.!(indexType)));
	}
	def newNormRangeSetElem(arrayType: Type, indexType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return newOp0(Opcode.NormRangeSetElem, [arrayType, indexType], [arrayType, type_rs, indexType, etype], type_v)
			.setOp2(Opcode2.NormRangeSetElem(ArrayType.!(arrayType), IntType.!(indexType)));
	}
	def newNormRangeSetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		return newOp0(Opcode.NormRangeSetElemElem(index), [arrayType, indexType], [arrayType, type_rs, indexType, etype], type_v)
			.setOp2(Opcode2.NormRangeSetElemElem(ArrayType.!(arrayType), index, IntType.!(indexType)));
	}
//----------------------------------------------------------------------------
	def newInit(meth: IrMethod) -> Operator {
		return newOp0(Opcode.Init(meth), TypeUtil.NO_TYPES, TypeUtil.NO_TYPES, meth.receiver)
			.setOp2(Opcode2.Init(meth));
	}
	def newComponentGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.ComponentGetField(fieldRef.asField()), tt, tt, fieldRef.getFieldType())
			.setOp2(Opcode2.ComponentGetField(fieldRef.asField()));
	}
	def newComponentSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ComponentSetField(fieldRef.asField()), [fieldRef.receiver], [fieldRef.receiver, fieldType], type_v)
			.setOp2(Opcode2.ComponentSetField(fieldRef.asField()));
	}
//----------------------------------------------------------------------------
	def newClassAlloc(newRef: IrSpec) -> Operator {
		var ftype = newRef.getBoundType(), paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.ClassAlloc(newRef.asMethod()), [newRef.receiver], paramTypes, newRef.receiver)
			.setOp2(Opcode2.ClassAlloc(newRef));
	}
	def newEmptyClassAlloc(classType: Type) -> Operator {
		return newOp0(Opcode.ClassAlloc(null), [classType], TypeUtil.NO_TYPES, classType)
			.setOp2(Opcode2.ClassEmptyAlloc(ClassType.!(classType), TypeUtil.NO_TYPES));
	}
	def newEmptyClassAllocP(classType: Type, paramTypes: Array<Type>) -> Operator {
		return newOp0(Opcode.ClassAlloc(null), [classType], paramTypes, classType)
			.setOp2(Opcode2.ClassEmptyAlloc(ClassType.!(classType), paramTypes));
	}
	def newClassGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.ClassGetField(fieldRef.asField()), tt, tt, fieldRef.getFieldType())
			.setOp2(Opcode2.ClassGetField(fieldRef));
	}
	def newClassInitField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ClassInitField(fieldRef.asField()), [fieldRef.receiver], [fieldRef.receiver, fieldType], type_v)
			.setOp2(Opcode2.ClassInitField(fieldRef));
	}
	def newClassSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ClassSetField(fieldRef.asField()), [fieldRef.receiver], [fieldRef.receiver, fieldType], type_v)
			.setOp2(Opcode2.ClassSetField(fieldRef));
	}
	def newClassGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.ClassGetMethod(methodRef.asMethod()), typeArgs, [methodRef.receiver], methodRef.getBoundType())
			.setOp2(Opcode2.ClassGetMethod(methodRef));
	}
	def newClassGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.ClassGetVirtual(methodRef.asMethod()), typeArgs, [methodRef.receiver], methodRef.getBoundType())
			.setOp2(Opcode2.ClassGetVirtual(methodRef));
	}
	def newClassGetSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.ClassGetSelector(selector), typeArgs, [methodRef.receiver], methodRef.getFuncType())
			.setOp2(Opcode2.ClassGetSelector(methodRef));
	}
//----------------------------------------------------------------------------
	def newVariantGetTag(vtype: Type) -> Operator {
		var vt = [vtype];
		return newOp0(Opcode.VariantGetTag, vt, vt, V3.classDecl(vtype).tagType)
			.setOp2(Opcode2.VariantGetTag(ClassType.!(vtype)));
	}
	def newVariantGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.VariantGetField(fieldRef.asField()), tt, tt, fieldRef.getFieldType())
			.setOp2(Opcode2.VariantGetField(fieldRef));
	}
	def newVariantGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.VariantGetMethod(methodRef.asMethod()), typeArgs, [methodRef.receiver], methodRef.getBoundType())
			.setOp2(Opcode2.VariantGetMethod(methodRef));
	}
	def newVariantGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.VariantGetVirtual(methodRef.asMethod()), typeArgs, [methodRef.receiver], methodRef.getBoundType())
			.setOp2(Opcode2.VariantGetVirtual(methodRef));
	}
	def newVariantGetSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.VariantGetSelector(selector), typeArgs, [methodRef.receiver], methodRef.getFuncType())
			.setOp2(Opcode2.VariantGetSelector(methodRef));
	}
//----------------------------------------------------------------------------
	def newNullCheck(rtype: Type) -> Operator {
		var tt = [rtype];
		return newOp0(Opcode.NullCheck, tt, tt, rtype)
			.setOp2(Opcode2.NullCheck(rtype));
	}
	def newBoundsCheck(rtype: Type) -> Operator {
		return newOp0(Opcode.BoundsCheck, [rtype], [rtype, type_i], type_v)
			.setOp2(Opcode2.BoundsCheck(rtype));
	}
	def newConditionalThrow(exception: string) -> Operator {
		return newOp0(Opcode.ConditionalThrow(exception), arr_v, Bool.ARRAY_T, type_v)
			.setOp2(Opcode2.ConditionalThrow(exception));
	}
//----------------------------------------------------------------------------
	def newEqual(t: Type) -> Operator {
		var opcode: Opcode;
		var opcode2: Opcode2;
		match (t.typeCon.kind) {
			BOOL => return opBoolEq;
			INT => 		{ opcode = Opcode.IntEq; opcode2 = Opcode2.IntEq(IntType.!(t)); }
			ENUM,
			ENUM_SET =>	{ opcode = Opcode.IntEq; opcode2 = Opcode2.OverloadedEq(t); } // TODO
			FLOAT =>	{ opcode = Opcode.FloatEq(V3.isDouble(t)); opcode2 = Opcode2.FloatEq(FloatType.!(t)); }
			POINTER,
			ARRAY,
			CLASS,
			FUNCREF,
			RANGE_START =>	{ opcode = Opcode.RefEq; opcode2 = Opcode2.RefEq(t); }
			VARIANT =>	{ opcode = Opcode.VariantEq; opcode2 = Opcode2.VariantEq(ClassType.!(t)); }
			_ => 		{ opcode = Opcode.OverloadedEq; opcode2 = Opcode2.OverloadedEq(t); }
		}
		return newOp0(opcode, [t], [t, t], type_z)
			.setOp2(opcode2);
	}
	def newTypeCast(f: Type, t: Type) -> Operator {
		var cast = TypeSystem.newTypeCast(f, t);
		return newOp0(Opcode.TypeCast(cast), [f, t], [f], t)
			.setOp2(Opcode2.TypeCast(cast, t, f));
	}
	def newTypeQuery(f: Type, t: Type) -> Operator {
		var query = TypeSystem.newTypeQuery(f, t);
		return newOp0(Opcode.TypeQuery(query), [f, t], [f], type_z)
			.setOp2(Opcode2.TypeQuery(query, t, f));
	}
	def newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {
		return newOp0(Opcode.TypeSubsume, [typeFrom, typeTo], [typeFrom], typeTo)
			.setOp2(Opcode2.TypeSubsume(typeTo, typeFrom));
	}
//----------------------------------------------------------------------------
	def newCallMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallMethod(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallMethod(methodRef));
	}
	def newCallClassMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallClassMethod(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallClassMethod(methodRef));
	}
	def newCallClassVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallClassVirtual(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallClassVirtual(methodRef));
	}
	def newCallVariantVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallVariantVirtual(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallVariantVirtual(methodRef));
	}
	def newCallClassSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.CallClassSelector(selector), typeArgs, paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallClassSelector(methodRef));
	}
	def newCallVariantSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.CallVariantSelector(selector), typeArgs, paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallVariantSelector(methodRef));
	}
	def newCallClosure(ftype: Type) -> Operator {
		var fTypes = Function.getParamTypeArray(ftype);
		var paramTypes = Arrays.prepend(ftype, fTypes);
		return newOp0(Opcode.CallClosure, [ftype], paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallClosure(FuncType.!(ftype)));
	}
	def newCallFunction(ftype: Type) -> Operator {
		ftype = Function.funcRefType(Function.prependParamType(AnyRef.TYPE, ftype));
		if (ftype.typeCon.kind != Kind.FUNCREF) return V3.fail("only function types allowed");
		var paramTypes = Arrays.prepend(ftype, Function.getParamTypeArray(ftype));
		return newOp0(Opcode.CallFunction, [ftype], paramTypes, Function.getReturnType(ftype))
			.setOp2(Opcode2.CallFunction(FuncType.!(ftype)));
	}
	def newCreateClosure(methodRef: IrSpec, objType: Type) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.CreateClosure(methodRef.asMethod()), typeArgs, [objType], methodRef.getBoundType())
			.setOp2(Opcode2.CreateClosure(objType, methodRef));
	}
	def newForgeClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {
		var funcType = Function.newType(param, result);
		return newOp0(Opcode.ForgeClosure, [receiver, param, result], [ptrType, receiver], funcType)
			.setOp2(Opcode2.ForgeClosure(PointerType.!(ptrType), receiver, param, result));
	}
	def newUnpackClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {
		var funcType = Function.newType(param, result);
		return newOp0(Opcode.UnpackClosure, [receiver, param, result], [funcType], Tuple.newType(Lists.cons2(ptrType, receiver)))
			.setOp2(Opcode2.UnpackClosure(PointerType.!(ptrType), receiver, param, result));
	}
	def newForgeRange(elementType: Type, ptrType: Type) -> Operator {
		var rangeType = V3Range.newType(elementType);
		return newOp0(Opcode.ForgeRange, [elementType, ptrType], [ptrType, Int.TYPE], rangeType)
			.setOp2(Opcode2.ForgeRange(PointerType.!(ptrType), RangeType.!(V3Range.newType(elementType))));
	}
//----------------------------------------------------------------------------
	def newSystemCall(syscall: SystemCall, paramTypes: Array<Type>, returnType: Type) -> Operator {
		return newOp0(Opcode.SystemCall(syscall), arr_v, paramTypes, returnType)
			.setOp2(Opcode2.SystemCall(syscall, Tuple.fromTypeArray(paramTypes), returnType));
	}
//----------------------------------------------------------------------------
	def newVstSugar(op: VstOperator, typeParams: Array<Type>, paramTypes: Array<Type>, result: Type) -> Operator {
		return Operator.new(Opcode.VstSugar(op), typeParams, Function.siga(paramTypes, result))
			.setOp2(Opcode2.VstSugar(op, Tuple.fromTypeArray(paramTypes), result));
	}
//----------------------------------------------------------------------------
	def newPtrAdd(ptrType: Type, it: IntType) -> Operator {
		return newOp0(Opcode.PtrAdd, [ptrType, it], [ptrType, it], ptrType)
			.setOp2(Opcode2.PtrAdd(PointerType.!(ptrType), IntType.!(it)));
	}
	def newPtrSub(ptrType: Type, it: IntType) -> Operator {
		return newOp0(Opcode.PtrSub, [ptrType, it], [ptrType, ptrType], it)
			.setOp2(Opcode2.PtrSub(PointerType.!(ptrType), IntType.!(it)));
	}
	def newPtrLt(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrLt, [ptrType], [ptrType, ptrType], type_z)
			.setOp2(Opcode2.PtrLt(PointerType.!(ptrType)));
	}
	def newPtrLteq(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrLteq, [ptrType], [ptrType, ptrType], type_z)
			.setOp2(Opcode2.PtrLteq(PointerType.!(ptrType)));
	}
	def newPtrAtContents(rangeType: Type, ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAtContents, [rangeType], [rangeType], ptrType)
			.setOp2(Opcode2.PtrAtContents(PointerType.!(ptrType), rangeType));
	}
	def newPtrAtLength(arrayType: Type, ptrType: Type) -> Operator {
		var tt = [arrayType];
		return newOp0(Opcode.PtrAtLength, tt, tt, ptrType)
			.setOp2(Opcode2.PtrAtLength(PointerType.!(ptrType), ArrayType.!(arrayType)));
	}
	def newPtrAtObject(objType: Type, ptrType: Type) -> Operator {
		var tt = [objType];
		return newOp0(Opcode.PtrAtObject, tt, tt, ptrType)
			.setOp2(Opcode2.PtrAtObject(PointerType.!(ptrType), objType));
	}
	def newPtrAtArrayElem(arrayType: Type, indexType: IntType, ptrType: Type) -> Operator {
		var tt = [arrayType, indexType];
		return newOp0(Opcode.PtrAtArrayElem, tt, tt, ptrType)
			.setOp2(Opcode2.PtrAtArrayElem(PointerType.!(ptrType), ArrayType.!(arrayType), IntType.!(indexType)));
	}
	def newPtrAtRangeElem(rangeType: Type, indexType: IntType, ptrType: Type) -> Operator {
		var tt = [rangeType, indexType];
		return newOp0(Opcode.PtrAtRangeElem, tt, tt, ptrType)
			.setOp2(Opcode2.PtrAtRangeElem(PointerType.!(ptrType), RangeType.!(rangeType), IntType.!(indexType)));
	}
	def newPtrAtEnd(objType: Type, ptrType: Type) -> Operator {
		var tt = [objType];
		return newOp0(Opcode.PtrAtEnd, tt, tt, ptrType)
			.setOp2(Opcode2.PtrAtEnd(PointerType.!(ptrType), objType));
	}
	def newPtrAtRef(layoutType: Type, ptrType: Type) -> Operator {
		var tt = [layoutType];
		return newOp0(Opcode.PtrAtRef, tt, tt, ptrType)
			.setOp2(Opcode2.PtrAtRef(PointerType.!(ptrType), RefType.!(layoutType)));
	}
	def newPtrAtComponentField(spec: IrSpec, ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAtComponentField(spec.asField()), [spec.receiver], TypeUtil.NO_TYPES, ptrType)
			.setOp2(Opcode2.PtrAtComponentField(PointerType.!(ptrType), spec));
	}
	def newPtrAtObjectField(spec: IrSpec, ptrType: Type) -> Operator {
		var tt = [spec.receiver];
		return newOp0(Opcode.PtrAtObjectField(spec.asField()), tt, tt, ptrType)
			.setOp2(Opcode2.PtrAtObjectField(PointerType.!(ptrType), spec));
	}
	def newPtrAtRefLayoutField(refType: Type, offset: int, ptrType: Type) -> Operator {
		var ta = [refType];
		return newOp0(Opcode.PtrAtRefLayoutField(offset), ta, ta, ptrType)
			.setOp2(Opcode2.PtrAtRefLayoutField(RefType.!(refType), PointerType.!(ptrType), offset));
	}
	def newPtrCmpSwp(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrCmpSwp, [ptrType, valueType], [ptrType, valueType, valueType], type_z)
			.setOp2(Opcode2.PtrCmpSwp(PointerType.!(ptrType), valueType));
	}
	def newPtrLoad(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrLoad, [ptrType, valueType], [ptrType], valueType)
			.setOp2(Opcode2.PtrLoad(PointerType.!(ptrType), valueType));
	}
	def newPtrStore(ptrType: Type, valueType: Type) -> Operator {
		var tt = [ptrType, valueType];
		return newOp0(Opcode.PtrStore, tt, tt, type_v)
			.setOp2(Opcode2.PtrStore(PointerType.!(ptrType), valueType));
	}
	def newPtrAddRangeStart(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAddRangeStart, [ptrType], [ptrType, type_rs], ptrType)
			.setOp2(Opcode2.PtrAddRangeStart(PointerType.!(ptrType)));
	}
//----------------------------------------------------------------------------
	def newCallerIp(ptrType: Type) -> Operator {
		return newOp0(Opcode.CallerIp, TypeUtil.NO_TYPES, arr_v, ptrType)
			.setOp2(Opcode2.CallerIp(PointerType.!(ptrType)));
	}
	def newCallerSp(ptrType: Type) -> Operator {
		return newOp0(Opcode.CallerSp, TypeUtil.NO_TYPES, arr_v, ptrType)
			.setOp2(Opcode2.CallerSp(PointerType.!(ptrType)));
	}
//----------------------------------------------------------------------------
	def newAlloc(ptrType: Type) -> Operator {
		return newOp0(Opcode.Alloc, [ptrType], arr_i, ptrType)
			.setOp2(Opcode2.Alloc(PointerType.!(ptrType)));

	}
//----------------------------------------------------------------------------
	def newCallAddress(rep: Mach_FuncRep) -> Operator {
		var funcType = rep.machType.nested.head;
		return newOp0(Opcode.CallAddress(rep), [rep.machType], rep.paramTypes, Function.getReturnType(funcType)); // TODO: setOp2
	}
	def newCallKernel(kernel: Kernel, typeParams: Array<Type>, sig: Signature) -> Operator {
		return Operator.new(Opcode.CallKernel(kernel), typeParams, sig); // TODO: setOp2
	}
//----------------------------------------------------------------------------
	def newRefLayoutAt(refType: RefType) -> Operator {
		var at: Array<Type> = [refType];
		return newOp0(Opcode.RefLayoutAt, at, [V3.arrayByteType, Int.TYPE], refType)
			.setOp2(Opcode2.RefLayoutAt(refType));
	}
	def newRefLayoutOf(refType: RefType) -> Operator {
		var at: Array<Type> = [refType];
		return newOp0(Opcode.RefLayoutOf, at, [V3.rangeByteType], refType)
			.setOp2(Opcode2.RefLayoutOf(refType));
	}
	def newRefLayoutIn(refType: RefType, offset: int, result: RefType) -> Operator {
		var at: Array<Type> = [refType, result];
		return newOp0(Opcode.RefLayoutIn(offset), at, [refType], result)
			.setOp2(Opcode2.RefLayoutIn(refType, offset, result));
	}
	def newRefLayoutGetField(refType: RefType, offset: int, fieldType: Type, order: ByteOrder) -> Operator {
		return newOp0(Opcode.RefLayoutGetField(offset, order), [refType, fieldType], [refType], fieldType)
			.setOp2(Opcode2.RefLayoutGetField(refType, offset, fieldType));
	}
	def newRefLayoutSetField(refType: RefType, offset: int, fieldType: Type, order: ByteOrder) -> Operator {
		var at = [refType, fieldType];
		return newOp0(Opcode.RefLayoutSetField(offset, order), at, at, Void.TYPE)
			.setOp2(Opcode2.RefLayoutSetField(refType, offset, fieldType));
	}
	def newRefLayoutAtRepeatedField(refType: RefType, offset: int, scale: int, max: int, result: RefType) -> Operator {
		var opcode = Opcode.RefLayoutAtRepeatedField(offset, scale, max);
		return newOp0(opcode, [refType, result], [refType, Int.TYPE], result)
			.setOp2(Opcode2.RefLayoutAtRepeatedField(refType, offset, scale, max, result));
	}
	def newRefLayoutGetRepeatedField(refType: RefType, offset: int, scale: int, max: int, fieldType: Type, order: ByteOrder) -> Operator {
		var opcode = Opcode.RefLayoutGetRepeatedField(offset, scale, max, order);
		return newOp0(opcode, [refType, fieldType], [refType, Int.TYPE], fieldType)
			.setOp2(Opcode2.RefLayoutGetRepeatedField(refType, offset, scale, max, fieldType));
	}
	def newRefLayoutSetRepeatedField(refType: RefType, offset: int, scale: int, max: int, fieldType: Type, order: ByteOrder) -> Operator {
		var opcode = Opcode.RefLayoutSetRepeatedField(offset, scale, max, order);
		return newOp0(opcode, [refType, fieldType], [refType, Int.TYPE, fieldType], Void.TYPE)
			.setOp2(Opcode2.RefLayoutSetRepeatedField(refType, offset, scale, max, fieldType));
	}
	def newByteArrayGetField(offset: int, fieldType: Type, order: ByteOrder, startType: Type) -> Operator {
		var opcode = Opcode.ByteArrayGetField(offset, order);
		return newOp0(opcode, [fieldType, startType], [V3.arrayByteType, startType], fieldType)
			.setOp2(Opcode2.ByteArrayGetField(startType, offset, fieldType));
	}
	def newByteArraySetField(offset: int, fieldType: Type, order: ByteOrder, startType: Type) -> Operator {
		var opcode = Opcode.ByteArraySetField(offset, order);
		return newOp0(opcode, [fieldType, startType], [V3.arrayByteType, startType, fieldType], Void.TYPE)
			.setOp2(Opcode2.ByteArraySetField(startType, offset, fieldType));
	}
//----------------------------------------------------------------------------
	def bestCallVirtual(spec: IrSpec) -> Operator {
		if (spec.receiver.typeCon.kind == Kind.CLASS) {
			if (!spec.member.facts.M_OVERRIDDEN) return newCallClassMethod(spec);
			return newCallClassVirtual(spec);
		} else {
			if (!spec.member.facts.M_OVERRIDDEN) return newCallMethod(spec);
			return newCallVariantVirtual(spec);
		}
	}
	def bestGetVirtual(spec: IrSpec) -> Operator {
		if (spec.receiver.typeCon.kind == Kind.CLASS) {
			if (!spec.member.facts.M_OVERRIDDEN) return newClassGetMethod(spec);
			else return V3Op.newClassGetVirtual(spec);
		} else {
			if (!spec.member.facts.M_OVERRIDDEN) return newVariantGetMethod(spec);
			return newVariantGetVirtual(spec);
		}
	}
	def bestGetSelector(spec: IrSpec) -> Operator {
		return if(spec.receiver.typeCon.kind == Kind.CLASS, newClassGetSelector(spec), newVariantGetSelector(spec));
	}

	// XXX: migrate to Compiler.nullCheckFacts
	def needsNullCheck(app: SsaInstr, obj: SsaInstr) -> bool {
		if (obj.facts.V_NON_ZERO) return false;
		return !app.facts.O_NO_NULL_CHECK;
	}
	def extractIrSpec(op: Operator, member: IrMember) -> IrSpec {
		var ta = op.typeArgs;
		return IrSpec.new(ta[0], ta, member);
	}
}

def renderOp(op: Operator, buf: StringBuilder) -> StringBuilder {
	buf.puts(op.opcode.name);
	if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).green();

	var rfunc: StringBuilder -> StringBuilder;
	match (op.opcode) {
		IntWide(wideOp) => {
			buf.putc('<');
			buf.puts(wideOp.opcode.name);
			buf.putc('>');
		}
		TypeCast(cast) => rfunc = StringBuilder.puts(_, cast.name);
		TypeQuery(query) => rfunc = StringBuilder.puts(_, query.name);
		TupleCreate(length) => rfunc = StringBuilder.putd(_, length);
		TupleGetElem(length) => rfunc = StringBuilder.putd(_, length);
		Init(method) => if(method != null) rfunc = method.render;
		ArrayInit(length) => rfunc = StringBuilder.putd(_, length);
		ArrayTupleInit(elems, length) => rfunc = StringBuilder.put2(_, "%d,%d", elems, length);
		ArrayGetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		ArraySetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		NormRangeGetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		NormRangeSetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		ComponentGetField(field) => rfunc = field.render;
		ComponentSetField(field) => rfunc = field.render;
		ClassGetField(field) => rfunc = field.render;
		ClassInitField(field) => rfunc = field.render;
		ClassSetField(field) => rfunc = field.render;
		VariantGetField(field) => rfunc = field.render;
		ClassAlloc(method) => if(method != null) rfunc = method.render;
		ClassGetMethod(method) => rfunc = method.render;
		ClassGetVirtual(method) => rfunc = method.render;
		ClassGetSelector(selector) => rfunc = selector.render;
		VariantGetMethod(method) => rfunc = method.render;
		VariantGetVirtual(method) => rfunc = method.render;
		VariantGetSelector(selector) => rfunc = selector.render;
		CallMethod(method) => rfunc = method.render;
		CallClassMethod(method) => rfunc = method.render;
		CallClassVirtual(method) => rfunc = method.render;
		CallClassSelector(selector) => rfunc = selector.render;
		CallVariantVirtual(method) => rfunc = method.render;
		CallVariantSelector(selector) => rfunc = selector.render;
		CreateClosure(method) => rfunc = method.render;
		RefLayoutIn(offset) => rfunc = StringBuilder.putd(_, offset);
		RefLayoutGetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		RefLayoutSetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		RefLayoutAtRepeatedField(offset, scale, max) => rfunc = StringBuilder.put2(_, "%d,%d", offset, scale);
		RefLayoutGetRepeatedField(offset, scale, max, order) => rfunc = StringBuilder.put3(_, "%d,%d,%s", offset, scale, order.name);
		RefLayoutSetRepeatedField(offset, scale, max, order) => rfunc = StringBuilder.put3(_, "%d,%d,%s", offset, scale, order.name);
		ByteArrayGetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		ByteArraySetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		ConditionalThrow(exception) => rfunc = StringBuilder.puts(_, exception);
		SystemCall(syscall) => rfunc = StringBuilder.puts(_, syscall.name);
		VstSugar(op) => rfunc = StringBuilder.puts(_, op.name);
		_ => ;
	}

	if (rfunc != null) rfunc(buf.putc('[')).putc(']');
	var typeArgs = op.typeArgs;
	if (typeArgs.length > 0) {
		buf.putc('<');
		for (i < typeArgs.length) {
			if (i > 0) buf.csp();
			var t = typeArgs[i];
			if (t == null) buf.puts("null");
			else t.render(buf);
		}
		buf.putc('>');
	}
	if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).end();
	return buf;
}
