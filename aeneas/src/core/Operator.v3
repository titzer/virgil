// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An operator represents a computation from argument values to a result value
// with possible side-effects.
class Operator(opcode: Opcode, typeArgs: Array<Type>, sig: Signature) {
	private var openness: Open;			// lazily computed open / closed

	def checkOpenness() -> Open {
		// openness is not known. check all type args and operator type
		if (openness != Open.UNKNOWN) return openness;
		var hash = 0;
		// XXX: bail out earlier if a nested type is open
		for (t in typeArgs) hash = hash | t.hash;
		for (t in sig.paramTypes) hash = hash | t.hash;
		for (t in sig.returnTypes) hash = hash | t.hash;
		return openness = if((hash & TypeConst.OPEN_MASK) != 0, Open.OPEN, Open.CLOSED);
	}
	def isPolymorphic() -> bool {
		return checkOpenness() == Open.OPEN;
	}
	// get the type of this operator when the given parameter indices are bound
	def getResidualType(indexMap: Array<int>) -> Type {
		if (indexMap.length == 0) return sig.funcType();
		return Function.newType(getResidualParamType(indexMap), sig.returnType());
	}
	// get the list of residual types
	def getResidualParamTypeList(indexMap: Array<int>) -> List<Type> {
		if (indexMap.length == 0) return null;
		var rl: List<Type>;
		var p = sig.paramTypes, iv = indexMap.length - 1;
		for (i = p.length - 1; i >= 0; i--) {
			var pt = p[i];
			if (iv < 0 || i != indexMap[iv]) rl = List.new(pt, rl);
			else iv--;
		}
		return rl;
	}
	def subst(f: Type -> Type) -> Operator {
		if (openness == Open.CLOSED) return this;
		if (checkOpenness() == Open.OPEN) {
			return Operator.new(opcode, Arrays.map(typeArgs, f), sig.subst(f));
		}
		return this;
	}

	def getResidualParamType(indexMap: Array<int>) -> Type {
		return Tuple.TYPECON.create(getResidualParamTypeList(indexMap));
	}
	def equals(that: Operator) -> bool {
		if (this == that) return true;
		return this.opcode == that.opcode && Arrays.equal(this.typeArgs, that.typeArgs);
	}
	def render(buf: StringBuilder) -> StringBuilder {
		return renderOp(this, buf);
	}
	def evaluate(args: Arguments) -> Result {
		return Eval.doOp(this, args);
	}
}

// Whether an operator is known to contain any open (polymorphic) types.
enum Open { UNKNOWN, OPEN, CLOSED }

// Everything for building and caching operators. Named {Op} to keep
// the rest of the code short.
component V3Op {
	// Cached sigs and parts of sigs
	def arr_v = TypeUtil.NO_TYPES;
	def type_i = Int.TYPE;
	def type_u = Int.getType(false, 32);
	def type_z = Bool.TYPE;
	def type_v = Void.TYPE;
	def type_f = Float.FLOAT32;
	def type_d = Float.FLOAT64;

	def arr_z = Bool.ARRAY_T;
	def arr_i = Int.ARRAY_T;
	def arr_f = [type_f];
	def arr_ff = [type_f, type_f];
	def arr_d = [type_d];
	def arr_dd = [type_d, type_d];
	def arr_zz = [type_z, type_z];

	def sig_zz_z = Signature.new(null, arr_zz, arr_z);
	def sig_z_z = Signature.new(null, arr_z, arr_z);

	private def newOp0(opcode: Opcode, typeArgs: Array<Type>, paramTypes: Array<Type>, returnType: Type) -> Operator {
		return Operator.new(opcode, typeArgs, Function.siga(paramTypes, returnType));
	}

//----------------------------------------------------------------------------
	def opBoolEq = Operator.new(Opcode.BoolEq, arr_z, sig_zz_z);
	def opBoolAnd = Operator.new(Opcode.BoolAnd, arr_v, sig_zz_z);
	def opBoolOr = Operator.new(Opcode.BoolOr, arr_v, sig_zz_z);
	def opBoolNot = Operator.new(Opcode.BoolNot, arr_v, sig_z_z);
//----------------------------------------------------------------------------
	def newIntEq(t: Type) -> Operator {
		return newOp0(Opcode.IntEq, [t], [t, t], type_z);
	}
	def newIntWide(op: Operator, normal: Array<Type>, result: Type) -> Operator {
		return newOp0(Opcode.IntWide(op), arr_v, normal, result);
	}
//----------------------------------------------------------------------------
	def opFloatBitEq32 = newOp0(Opcode.FloatBitEq(false), arr_f, arr_ff, type_z);
	def opFloatBitEq64 = newOp0(Opcode.FloatBitEq(true), arr_d, arr_dd, type_z);
//----------------------------------------------------------------------------
	def newIntCastI(f: Type, t: Type) -> Operator {
		return newOp0(Opcode.IntCastI, [f, t], [f], t);
	}
	def newIntCastF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntCastF(V3.isDouble(ft)), [ft, tt], [ft], tt);
	}
	def newIntQueryI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntQueryI, [ft, tt], [ft], type_z);
	}
	def newIntQueryF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntQueryF(V3.isDouble(ft)), [ft, tt], [ft], type_z);
	}
	def newIntViewI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntViewI, [ft, tt], [ft], tt);
	}
	def newIntPromoteI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntPromoteI, [ft, tt], [ft], tt);
	}
	def opIntViewF32 = newOp0(Opcode.IntViewF(false), arr_f, arr_f, type_u);
	def opIntViewF64 = newOp0(Opcode.IntViewF(true), arr_d, arr_d, Int.getType(false, 64));
	def newIntTruncF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntTruncF(V3.isDouble(ft)), [ft, tt], [ft], tt);
	}
//----------------------------------------------------------------------------
	def newFloatCastI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatCastI(V3.isDouble(tt)), [ft, tt], [ft], tt);
	}
	def opFloatCastD = newOp0(Opcode.FloatCastD, arr_d, arr_d, type_f);
	def newFloatQueryI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatQueryI(V3.isDouble(tt)), [ft, tt], [ft], type_z);
	}
	def opFloatQueryD = newOp0(Opcode.FloatQueryD, arr_d, arr_d, type_z);
	def newFloatPromoteI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatPromoteI(V3.isDouble(tt)), [ft, tt], [ft], tt);
	}
	def opFloatPromoteF = newOp0(Opcode.FloatPromoteF, arr_f, arr_f, type_d);
	def newFloat32ViewI(ft: Type) -> Operator {
		return newOp0(Opcode.FloatViewI(false), [ft, type_f], [ft], type_f);
	}
	def newFloat64ViewI(ft: Type) -> Operator {
		return newOp0(Opcode.FloatViewI(true), [ft, type_d], [ft], type_d);
	}
	def newFloatRoundI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatRoundI(V3.isDouble(tt)), [ft, tt], [ft], tt);
	}
	def newFloatRound(t: Type) -> Operator {
		return newOp0(Opcode.FloatRound(V3.isDouble(t)), [t], [t], t);
	}
	def opFloatRoundD = newOp0(Opcode.FloatRoundD, arr_v, arr_d, type_f);
//----------------------------------------------------------------------------
	def newRefEq(t: Type) -> Operator {
		return newOp0(Opcode.RefEq, [t], [t, t], type_z);
	}
//----------------------------------------------------------------------------
	def newTupleCreate(tupleType: Type) -> Operator {
		var paramTypes = Lists.toArray(tupleType.nested);
		return newOp0(Opcode.TupleCreate(paramTypes.length), [tupleType], paramTypes, tupleType);
	}
	def newTupleGetElem(tupleType: Type, index: int) -> Operator {
		var tt = [tupleType];
		return newOp0(Opcode.TupleGetElem(index), tt, tt, Lists.get(tupleType.nested, index));
	}
//----------------------------------------------------------------------------
	def newArrayAlloc(arrayType: Type) -> Operator {
		return newOp0(Opcode.ArrayAlloc, [arrayType], arr_i, arrayType);
	}
	def newArrayInit(arrayType: Type, length: int) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var paramTypes = Array<Type>.new(length);
		for (i < paramTypes.length) paramTypes[i] = elemType;
		var ta = [arrayType];
		return newOp0(Opcode.ArrayInit(length), ta, paramTypes, arrayType);
	}
	def newArrayGetElem(arrayType: Type) -> Operator {
		return newOp0(Opcode.ArrayGetElem, [arrayType], [arrayType, type_i], V3Array.elementType(arrayType));
	}
	def newArraySetElem(arrayType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return newOp0(Opcode.ArraySetElem, [arrayType], [arrayType, type_i, etype], type_v);
	}
	def newArrayGetLength(arrayType: Type) -> Operator {
		return newOp0(Opcode.ArrayGetLength, [arrayType], [arrayType], type_i);
	}
//----------------------------------------------------------------------------
	def newInit(meth: IrMethod) -> Operator {
		return newOp0(Opcode.Init(meth), TypeUtil.NO_TYPES, TypeUtil.NO_TYPES, meth.receiver);
	}
	def newComponentGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.ComponentGetField(fieldRef.asField()), tt, tt,
			fieldRef.getFieldType());
	}
	def newComponentSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ComponentSetField(fieldRef.asField()), [fieldRef.receiver], [fieldRef.receiver, fieldType],
			type_v);
	}
//----------------------------------------------------------------------------
	def newClassAlloc(newRef: IrSpec) -> Operator {
		var ftype = newRef.getBoundType(), paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.ClassAlloc(newRef.asMethod()), [newRef.receiver], paramTypes, newRef.receiver);
	}
	def newEmptyClassAlloc(classType: Type) -> Operator {
		return newOp0(Opcode.ClassAlloc(null), [classType], TypeUtil.NO_TYPES, classType);
	}
	def newEmptyClassAllocP(classType: Type, paramTypes: Array<Type>) -> Operator {
		return newOp0(Opcode.ClassAlloc(null), [classType], paramTypes, classType);
	}
	def newClassGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.ClassGetField(fieldRef.asField()), tt, tt, fieldRef.getFieldType());
	}
	def newClassInitField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ClassInitField(fieldRef.asField()), [fieldRef.receiver],
			[fieldRef.receiver, fieldType], type_v);
	}
	def newClassSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ClassSetField(fieldRef.asField()), [fieldRef.receiver],
			[fieldRef.receiver, fieldType], type_v);
	}
	def newClassGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.ClassGetMethod(methodRef.asMethod()), typeArgs, [methodRef.receiver],
			methodRef.getBoundType());
	}
	def newClassGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.ClassGetVirtual(methodRef.asMethod()), typeArgs, [methodRef.receiver],
			methodRef.getBoundType());
	}
	def newClassGetSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.ClassGetSelector(selector), typeArgs, [methodRef.receiver],
			methodRef.getFuncType());
	}
//----------------------------------------------------------------------------
	def newVariantGetTag(vtype: Type) -> Operator {
		if (V3.isEnum(vtype)) {
			// enums are directly represented as integers.
			return newTypeSubsume(vtype, V3.getVariantTagType(vtype));
		}
		var vt = [vtype];
		return newOp0(Opcode.VariantGetTag, vt, vt, V3.classDecl(vtype).tagType);
	}
	def newVariantGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.VariantGetField(fieldRef.asField()), tt, tt, fieldRef.getFieldType());
	}
//----------------------------------------------------------------------------
	def newNullCheck(rtype: Type) -> Operator {
		var tt = [rtype];
		return newOp0(Opcode.NullCheck, tt, tt, rtype);
	}
	def newBoundsCheck(rtype: Type) -> Operator {
		return newOp0(Opcode.BoundsCheck, [rtype], [rtype, type_i], type_v);
	}
	def newConditionalThrow(exception: string) -> Operator {
		return newOp0(Opcode.ConditionalThrow(exception), arr_v, Bool.ARRAY_T, type_v);
	}
//----------------------------------------------------------------------------
	def newEqual(t: Type) -> Operator {
		var opcode: Opcode = Opcode.OverloadedEq;
		match (t.typeCon.kind) {
			V3Kind.BOOL => return opBoolEq;
			V3Kind.ENUM,
			V3Kind.ENUM_SET,
			V3Kind.INT => opcode = Opcode.IntEq;
			V3Kind.FLOAT => opcode = Opcode.FloatEq(V3.isDouble(t));

			MachType.MACH_POINTER,
			V3Kind.ARRAY,
			V3Kind.CLASS,
			V3Kind.FUNCREF => opcode = Opcode.RefEq;
			V3Kind.VARIANT => opcode = Opcode.VariantEq;
		}
		return newOp0(opcode, [t], [t, t], type_z);
	}
	def newTypeCast(f: Type, t: Type) -> Operator {
		var cast = TypeSystem.newTypeCast(f, t);
		return newOp0(Opcode.TypeCast(cast), [f, t], [f], t);
	}
	def newTypeQuery(f: Type, t: Type) -> Operator {
		var query = TypeSystem.newTypeQuery(f, t);
		return newOp0(Opcode.TypeQuery(query), [f, t], [f], type_z);
	}
	def newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {
		return newOp0(Opcode.TypeSubsume, [typeFrom, typeTo], [typeFrom], typeTo);
	}
//----------------------------------------------------------------------------
	def newCallMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallMethod(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype));
	}
	def newCallClassVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallClassVirtual(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype));
	}
	def newCallClassSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.CallClassSelector(selector), typeArgs, paramTypes, Function.getReturnType(ftype));
	}
	def newCallClosure(ftype: Type) -> Operator {
		var fTypes = Function.getParamTypeArray(ftype);
		var paramTypes = Arrays.prepend(ftype, fTypes);
		return newOp0(Opcode.CallClosure, [ftype], paramTypes, Function.getReturnType(ftype));
	}
	def newCallFunction(ftype: Type) -> Operator {
		ftype = Function.funcRefType(Function.prependParamType(AnyObject.TYPE, ftype));
		if (ftype.typeCon.kind != V3Kind.FUNCREF) return V3.fail("only function types allowed");
		var paramTypes = Arrays.prepend(ftype, Function.getParamTypeArray(ftype));
		return newOp0(Opcode.CallFunction, [ftype], paramTypes, Function.getReturnType(ftype));
	}
	def newCreateClosure(methodRef: IrSpec, closure: Type) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.CreateClosure(methodRef.asMethod()), typeArgs, [closure], methodRef.getBoundType());
	}
	def newForgeClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {
		var funcType = Function.newType(param, result);
		return newOp0(Opcode.ForgeClosure, [receiver, param, result], [ptrType, receiver], funcType);
	}
	def newUnpackClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {
		var funcType = Function.newType(param, result);
		return newOp0(Opcode.UnpackClosure, [receiver, param, result], [funcType], Tuple.newType(Lists.cons2(ptrType, receiver)));
	}
//----------------------------------------------------------------------------
	def newSystemCall(syscall: SystemCall) -> Operator {
		return newOp0(Opcode.SystemCall(syscall), arr_v, syscall.paramTypes, syscall.returnType);
	}
//----------------------------------------------------------------------------
	def newVstSugar(op: VstOperator, typeParams: Array<Type>, paramTypes: Array<Type>, result: Type) -> Operator {
		return Operator.new(Opcode.VstSugar(op), typeParams, Function.siga(paramTypes, result));
	}
//----------------------------------------------------------------------------
	def newPtrAdd(ptrType: Type, it: IntType) -> Operator {
		return newOp0(Opcode.PtrAdd, [ptrType], [ptrType, it], ptrType);
	}
	def newPtrSub(ptrType: Type, it: IntType) -> Operator {
		return newOp0(Opcode.PtrSub, [ptrType], [ptrType, ptrType], it);
	}
	def newPtrLt(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrLt, [ptrType], [ptrType, ptrType], type_z);
	}
	def newPtrLteq(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrLteq, [ptrType], [ptrType, ptrType], type_z);
	}
	def newPtrAtContents(elemType: Type, ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAtContents, [elemType], [V3Array.newType(elemType)], ptrType);
	}
	def newPtrAtLength(elemType: Type, ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAtLength, [elemType], [V3Array.newType(elemType)], ptrType);
	}
	def newPtrAtObject(objType: Type, ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAtObject, [objType], [objType], ptrType);
	}
	def newPtrCmpSwp(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrCmpSwp, [ptrType, valueType], [ptrType, valueType, valueType], type_z);
	}
	def newPtrLoad(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrLoad, [ptrType, valueType], [ptrType], valueType);
	}
	def newPtrStore(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrStore, [ptrType, valueType], [ptrType, valueType], type_v);
	}
//----------------------------------------------------------------------------
	def newCallerIp(ptrType: Type) -> Operator {
		return newOp0(Opcode.CallerIp, TypeUtil.NO_TYPES, arr_v, ptrType);
	}
	def newCallerSp(ptrType: Type) -> Operator {
		return newOp0(Opcode.CallerSp, TypeUtil.NO_TYPES, arr_v, ptrType);
	}
//----------------------------------------------------------------------------
	def newAlloc(ptrType: Type) -> Operator {
		return newOp0(Opcode.Alloc, [ptrType], arr_i, ptrType);
	}
//----------------------------------------------------------------------------
	def newCallAddress(rep: Mach_FuncRep) -> Operator {
		var funcType = rep.machType.nested.head;
		return newOp0(Opcode.CallAddress(rep), [rep.machType], rep.paramTypes, Function.getReturnType(funcType));
	}
	def newCallKernel(kernel: Kernel, typeParams: Array<Type>, sig: Signature) -> Operator {
		return Operator.new(Opcode.CallKernel(kernel), typeParams, sig);
	}
//----------------------------------------------------------------------------

	// XXX: move to SsaUtil?
	def needsNullCheck(app: SsaInstr, obj: SsaInstr) -> bool {
		if (obj.facts.V_NON_ZERO) return false;
		return !app.facts.O_NO_NULL_CHECK;
	}
	def extractIrSpec(op: Operator, member: IrMember) -> IrSpec {
		var ta = op.typeArgs;
		return IrSpec.new(ta[0], ta, member);
	}
}

def renderOp(op: Operator, buf: StringBuilder) -> StringBuilder {
	buf.puts(op.opcode.name);
	if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).green();

	var rfunc: StringBuilder -> StringBuilder;
	match (op.opcode) {
		IntWide(wideOp) => {
			buf.putc('<');
			buf.puts(wideOp.opcode.name);
			buf.putc('>');
		}
		TypeCast(cast) => rfunc = StringBuilder.puts(_, cast.name);
		TypeQuery(query) => rfunc = StringBuilder.puts(_, query.name);
		TupleCreate(length) => rfunc = StringBuilder.putd(_, length);
		TupleGetElem(length) => rfunc = StringBuilder.putd(_, length);
		Init(method) => if(method != null) rfunc = method.render;
		ComponentGetField(field) => rfunc = field.render;
		ComponentSetField(field) => rfunc = field.render;
		ClassGetField(field) => rfunc = field.render;
		ClassInitField(field) => rfunc = field.render;
		ClassSetField(field) => rfunc = field.render;
		VariantGetField(field) => rfunc = field.render;
		ClassGetMethod(method) => rfunc = method.render;
		ClassGetVirtual(method) => rfunc = method.render;
		ClassGetSelector(selector) => rfunc = selector.render;
		CallMethod(method) => rfunc = method.render;
		CallClassVirtual(method) => rfunc = method.render;
		CallClassSelector(selector) => rfunc = selector.render;
		CreateClosure(method) => rfunc = method.render;
		ConditionalThrow(exception) => StringBuilder.puts(_, exception);
		SystemCall(syscall) => StringBuilder.puts(_, syscall.name);
		_ => ;
	}

	if (rfunc != null) rfunc(buf.putc('[')).putc(']');
	var typeArgs = op.typeArgs;
	if (typeArgs.length > 0) {
		buf.putc('<');
		for (i < typeArgs.length) {
			if (i > 0) buf.csp();
			var t = typeArgs[i];
			if (t == null) buf.puts("null");
			else t.render(buf);
		}
		buf.putc('>');
	}
	if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).end();
	return buf;
}
