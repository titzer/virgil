// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An operator represents a computation from argument values to a result value
// with possible side-effects.
class Operator(opcode: Opcode, typeArgs: Array<Type>, sig: Signature) {
	private var openness: Open;			// lazily computed open / closed

	def checkOpenness() -> Open {
		// openness is not known. check all type args and operator type
		if (openness != Open.UNKNOWN) return openness;
		var hash = 0;
		// XXX: bail out earlier if a nested type is open
		for (t in typeArgs) hash = hash | t.hash;
		for (t in sig.paramTypes) hash = hash | t.hash;
		for (t in sig.returnTypes) hash = hash | t.hash;
		return openness = if((hash & TypeConst.OPEN_MASK) != 0, Open.OPEN, Open.CLOSED);
	}
	def isPolymorphic() -> bool {
		return checkOpenness() == Open.OPEN;
	}
	// get the type of this operator when the given parameter indices are bound
	def getResidualType(indexMap: Array<int>) -> Type {
		if (indexMap.length == 0) return sig.funcType();
		return Function.newType(getResidualParamType(indexMap), sig.returnType());
	}
	// get the list of residual types
	def getResidualParamTypeList(indexMap: Array<int>) -> List<Type> {
		if (indexMap.length == 0) return null;
		var rl: List<Type>;
		var p = sig.paramTypes, iv = indexMap.length - 1;
		for (i = p.length - 1; i >= 0; i--) {
			var pt = p[i];
			if (iv < 0 || i != indexMap[iv]) rl = List.new(pt, rl);
			else iv--;
		}
		return rl;
	}
	def subst(f: Type -> Type) -> Operator {
		if (openness == Open.CLOSED) return this;
		if (checkOpenness() == Open.OPEN) {
			return Operator.new(opcode, Arrays.map(typeArgs, f), sig.subst(f));
		}
		return this;
	}

	def getResidualParamType(indexMap: Array<int>) -> Type {
		return Tuple.TYPECON.create(getResidualParamTypeList(indexMap));
	}
	def equals(that: Operator) -> bool {
		if (this == that) return true;
		return this.opcode == that.opcode && Arrays.equal(this.typeArgs, that.typeArgs);
	}
	def render(buf: StringBuffer) -> StringBuffer {
		return renderOp(this, buf);
	}
	def evaluate(args: Arguments) -> Result {
		return evalOp(this, args);
	}
}

// Whether an operator is known to contain any open (polymorphic) types.
enum Open { UNKNOWN, OPEN, CLOSED }

// Everything for building and caching operators. Named {Op} to keep
// the rest of the code short.
component V3Op {
	// Cached sigs and parts of sigs
	def arr_v = TypeUtil.NO_TYPES;
	def type_i = Int.TYPE;
	def type_u = Int.getType(false, 32);
	def type_z = Bool.TYPE;
	def type_v = Void.TYPE;
	def type_f = Float.FLOAT32;
	def type_d = Float.FLOAT64;

	def arr_z = Bool.ARRAY_T;
	def arr_i = Int.ARRAY_T;
	def arr_f = [type_f];
	def arr_ff = [type_f, type_f];
	def arr_d = [type_d];
	def arr_dd = [type_d, type_d];
	def arr_zz = [type_z, type_z];

	def sig_zz_z = Signature.new(null, arr_zz, arr_z);
	def sig_z_z = Signature.new(null, arr_z, arr_z);

	private def newOp0(opcode: Opcode, typeArgs: Array<Type>, paramTypes: Array<Type>, returnType: Type) -> Operator {
		return Operator.new(opcode, typeArgs, Function.siga(paramTypes, returnType));
	}

//----------------------------------------------------------------------------
	def opBoolEq = Operator.new(Opcode.BoolEq, arr_z, sig_zz_z);
	def opBoolAnd = Operator.new(Opcode.BoolAnd, arr_v, sig_zz_z);
	def opBoolOr = Operator.new(Opcode.BoolOr, arr_v, sig_zz_z);
	def opBoolNot = Operator.new(Opcode.BoolNot, arr_v, sig_z_z);
//----------------------------------------------------------------------------
	def newIntEq(t: Type) -> Operator {
		return newOp0(Opcode.IntEq, [t], [t, t], type_z);
	}
	def newIntWide(op: Operator, normal: Array<Type>, result: Type) -> Operator {
		return newOp0(Opcode.IntWide(op), arr_v, normal, result);
	}
//----------------------------------------------------------------------------
	def opFloatBitEq32 = newOp0(Opcode.FloatBitEq(false), arr_f, arr_ff, type_z);
	def opFloatBitEq64 = newOp0(Opcode.FloatBitEq(true), arr_d, arr_dd, type_z);
//----------------------------------------------------------------------------
	def newIntConvert(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntConvert, [ft, tt], [ft], tt);
	}
	def newIntCastI(f: Type, t: Type) -> Operator {
		return newOp0(Opcode.IntCastI, [f, t], [f], t);
	}
	def newIntCastF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntCastF(isDouble(ft)), [ft, tt], [ft], tt);
	}
	def newIntQueryI(f: Type, t: Type) -> Operator {
		return newOp0(Opcode.IntQueryI, [f, t], [f], type_z);
	}
	def newIntQueryF(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.IntQueryF(isDouble(ft)), [ft, tt], [ft], type_z);
	}
	def opIntViewF32 = newOp0(Opcode.IntViewF(false), arr_f, arr_f, type_u);
	def opIntViewF64 = newOp0(Opcode.IntViewF(true), arr_d, arr_d, Int.getType(false, 64));
	def newIntTruncF(ft: Type, t: Type) -> Operator {
		return newOp0(Opcode.IntTruncF(isDouble(ft)), [ft, t], [ft], t);
	}
//----------------------------------------------------------------------------
	def newFloatCastI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatCastI(isDouble(tt)), [ft, tt], [ft], tt);
	}
	def opFloatCastD = newOp0(Opcode.FloatCastD, arr_d, arr_d, type_f);
	def newFloatQueryI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatQueryI(isDouble(tt)), [ft, tt], [ft], type_z);
	}
	def opFloatQueryD = newOp0(Opcode.FloatQueryD, arr_d, arr_d, type_z);
	def newFloatPromoteI(ft: Type, tt: Type) -> Operator {
		return newOp0(Opcode.FloatPromoteI(isDouble(tt)), [ft, tt], [ft], tt);
	}
	def opFloatPromoteF = newOp0(Opcode.FloatPromoteF, arr_f, arr_f, type_d);
	def newFloat32ViewI(t: Type) -> Operator {
		return newOp0(Opcode.FloatViewI(false), [type_f, t], [t], type_f);
	}
	def newFloat64ViewI(t: Type) -> Operator {
		return newOp0(Opcode.FloatViewI(true), [type_d, t], [t], type_d);
	}
	def newFloatRoundI(it: Type, ft: Type) -> Operator {
		return newOp0(Opcode.FloatRoundI(isDouble(ft)), [it], [it], ft);
	}
	def newFloatRound(t: Type) -> Operator {
		return newOp0(Opcode.FloatRound(isDouble(t)), [t], [t], t);
	}
	def opFloatRoundD = newOp0(Opcode.FloatRoundD, arr_v, arr_d, type_f);
//----------------------------------------------------------------------------
	def newRefEq(t: Type) -> Operator {
		return newOp0(Opcode.RefEq, [t], [t, t], type_z);
	}
//----------------------------------------------------------------------------
	def newTupleCreate(tupleType: Type) -> Operator {
		var paramTypes = Lists.toArray(tupleType.nested);
		return newOp0(Opcode.TupleCreate(paramTypes.length), [tupleType], paramTypes, tupleType);
	}
	def newTupleGetElem(tupleType: Type, index: int) -> Operator {
		var tt = [tupleType];
		return newOp0(Opcode.TupleGetElem(index), tt, tt, Lists.get(tupleType.nested, index));
	}
//----------------------------------------------------------------------------
	def newArrayAlloc(arrayType: Type) -> Operator {
		return newOp0(Opcode.ArrayAlloc, [arrayType], arr_i, arrayType);
	}
	def newArrayInit(arrayType: Type, length: int) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var paramTypes = Array<Type>.new(length);
		for (i < paramTypes.length) paramTypes[i] = elemType;
		var ta = [arrayType];
		return newOp0(Opcode.ArrayInit(length), ta, paramTypes, arrayType);
	}
	def newArrayGetElem(arrayType: Type) -> Operator {
		return newOp0(Opcode.ArrayGetElem, [arrayType], [arrayType, type_i], V3Array.elementType(arrayType));
	}
	def newArraySetElem(arrayType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return newOp0(Opcode.ArraySetElem, [arrayType], [arrayType, type_i, etype], type_v);
	}
	def newArrayGetLength(arrayType: Type) -> Operator {
		return newOp0(Opcode.ArrayGetLength, [arrayType], [arrayType], type_i);
	}
//----------------------------------------------------------------------------
	def newInit(meth: IrMethod) -> Operator {
		return newOp0(Opcode.Init(meth), TypeUtil.NO_TYPES, TypeUtil.NO_TYPES, meth.receiver);
	}
	def newComponentGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.ComponentGetField(fieldRef.asField()), tt, tt,
			fieldRef.getFieldType());
	}
	def newComponentSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ComponentSetField(fieldRef.asField()), [fieldRef.receiver], [fieldRef.receiver, fieldType],
			type_v);
	}
//----------------------------------------------------------------------------
	def newClassAlloc(newRef: IrSpec) -> Operator {
		var ftype = newRef.getBoundType(), paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.ClassAlloc(newRef.asMethod()), [newRef.receiver], paramTypes, newRef.receiver);
	}
	def newEmptyClassAlloc(classType: Type) -> Operator {
		return newOp0(Opcode.ClassAlloc(null), [classType], TypeUtil.NO_TYPES, classType);
	}
	def newEmptyClassAllocP(classType: Type, paramTypes: Array<Type>) -> Operator {
		return newOp0(Opcode.ClassAlloc(null), [classType], paramTypes, classType);
	}
	def newClassGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.ClassGetField(fieldRef.asField()), tt, tt, fieldRef.getFieldType());
	}
	def newClassInitField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ClassInitField(fieldRef.asField()), [fieldRef.receiver],
			[fieldRef.receiver, fieldType], type_v);
	}
	def newClassSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp0(Opcode.ClassSetField(fieldRef.asField()), [fieldRef.receiver],
			[fieldRef.receiver, fieldType], type_v);
	}
	def newClassGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.ClassGetMethod(methodRef.asMethod()), typeArgs, [methodRef.receiver],
			methodRef.getBoundType());
	}
	def newClassGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.ClassGetVirtual(methodRef.asMethod()), typeArgs, [methodRef.receiver],
			methodRef.getBoundType());
	}
	def newClassGetSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.ClassGetSelector(selector), typeArgs, [methodRef.receiver],
			methodRef.getFuncType());
	}
//----------------------------------------------------------------------------
	def newVariantGetTag(vtype: Type) -> Operator {
		if (vtype.typeCon.kind == V3Kind.ENUM) {
			// enums are directly represented as integers.
			return newTypeSubsume(vtype, V3.getVariantTagType(vtype));
		}
		var vt = [vtype];
		return newOp0(Opcode.VariantGetTag, vt, vt, V3.classDecl(vtype).tagType);
	}
	def newVariantGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return newOp0(Opcode.VariantGetField(fieldRef.asField()), tt, tt, fieldRef.getFieldType());
	}
//----------------------------------------------------------------------------
	def newNullCheck(rtype: Type) -> Operator {
		var tt = [rtype];
		return newOp0(Opcode.NullCheck, tt, tt, rtype);
	}
	def newBoundsCheck(rtype: Type) -> Operator {
		return newOp0(Opcode.BoundsCheck, [rtype], [rtype, type_i], type_v);
	}
	def newConditionalThrow(exception: string) -> Operator {
		return newOp0(Opcode.ConditionalThrow(exception), arr_v, Bool.ARRAY_T, type_v);
	}
//----------------------------------------------------------------------------
	def newEqual(t: Type) -> Operator {
		var opcode: Opcode = Opcode.OverloadedEq;
		match (t.typeCon.kind) {
			V3Kind.BOOL => return opBoolEq;
			V3Kind.ENUM,
			V3Kind.ENUM_SET,
			V3Kind.INT => opcode = Opcode.IntEq;
			V3Kind.FLOAT => opcode = Opcode.FloatEq(Float_TypeCon.!(t.typeCon).is64);

			MachType.MACH_POINTER,
			V3Kind.ARRAY,
			V3Kind.CLASS,
			V3Kind.FUNCREF => opcode = Opcode.RefEq;
			V3Kind.VARIANT => opcode = Opcode.VariantEq;
		}
		return newOp0(opcode, [t], [t, t], type_z);
	}
	def newTypeCast(f: Type, t: Type) -> Operator {
		var cast = TypeSystem.newTypeCast(f, t);
		return newOp0(Opcode.TypeCast(cast), [f, t], [f], t);
	}
	def newTypeQuery(f: Type, t: Type) -> Operator {
		var cast = TypeSystem.newTypeQuery(f, t);
		return newOp0(Opcode.TypeQuery(cast), [f, t], [f], type_z);
	}
	def newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {
		return newOp0(Opcode.TypeSubsume, [typeFrom, typeTo], [typeFrom], typeTo);
	}
//----------------------------------------------------------------------------
	def newCallMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallMethod(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype));
	}
	def newCallClassVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp0(Opcode.CallClassVirtual(methodRef.asMethod()), typeArgs, paramTypes, Function.getReturnType(ftype));
	}
	def newCallClassSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		var selector = IrSelector.!(methodRef.member);
		return newOp0(Opcode.CallClassSelector(selector), typeArgs, paramTypes, Function.getReturnType(ftype));
	}
	def newCallClosure(ftype: Type) -> Operator {
		var fTypes = Function.getParamTypeArray(ftype);
		var paramTypes = Arrays.prepend(ftype, fTypes);
		return newOp0(Opcode.CallClosure, [ftype], paramTypes, Function.getReturnType(ftype));
	}
	def newCallFunction(ftype: Type) -> Operator {
		ftype = Function.funcRefType(Function.prependParamType(AnyObject.TYPE, ftype));
		if (ftype.typeCon.kind != V3Kind.FUNCREF) return V3.fail("only function types allowed");
		var paramTypes = Arrays.prepend(ftype, Function.getParamTypeArray(ftype));
		return newOp0(Opcode.CallFunction, [ftype], paramTypes, Function.getReturnType(ftype));
	}
	def newCreateClosure(methodRef: IrSpec, closure: Type) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp0(Opcode.CreateClosure(methodRef.asMethod()), typeArgs, [closure], methodRef.getBoundType());
	}
//----------------------------------------------------------------------------
	def newSystemCall(syscall: SystemCall) -> Operator {
		return newOp0(Opcode.SystemCall(syscall), arr_v, syscall.paramTypes, syscall.returnType);
	}
//----------------------------------------------------------------------------
	def newVstSugar(op: VstOperator, typeParams: Array<Type>, paramTypes: Array<Type>, result: Type) -> Operator {
		return Operator.new(Opcode.VstSugar(op), typeParams, Function.siga(paramTypes, result));
	}
//----------------------------------------------------------------------------
	def newPtrAdd(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAdd, [ptrType], [ptrType, type_i], ptrType);
	}
	def newPtrSub(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrSub, [ptrType], [ptrType, ptrType], type_i);
	}
	def newPtrLt(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrLt, [ptrType], [ptrType, ptrType], type_z);
	}
	def newPtrLteq(ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrLteq, [ptrType], [ptrType, ptrType], type_z);
	}
	def newPtrAtContents(elemType: Type, ptrType: Type) -> Operator {
		return newOp0(Opcode.PtrAtContents, [elemType], [V3Array.newType(elemType)], ptrType);
	}
	def newPtrCmpSwp(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrCmpSwp, [ptrType, valueType], [ptrType, valueType, valueType], type_z);
	}
	def newPtrLoad(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrLoad, [ptrType, valueType], [ptrType], valueType);
	}
	def newPtrStore(ptrType: Type, valueType: Type) -> Operator {
		return newOp0(Opcode.PtrStore, [ptrType, valueType], [ptrType, valueType], type_v);
	}
//----------------------------------------------------------------------------
	def newCallerIp(ptrType: Type) -> Operator {
		return newOp0(Opcode.CallerIp, TypeUtil.NO_TYPES, arr_v, ptrType);
	}
	def newCallerSp(ptrType: Type) -> Operator {
		return newOp0(Opcode.CallerSp, TypeUtil.NO_TYPES, arr_v, ptrType);
	}
//----------------------------------------------------------------------------
	def newAlloc(ptrType: Type) -> Operator {
		return newOp0(Opcode.Alloc, [ptrType], arr_i, ptrType);
	}
//----------------------------------------------------------------------------
	def newCallAddress(rep: Mach_FuncRep) -> Operator {
		var funcType = rep.machType.nested.head;
		return newOp0(Opcode.CallAddress(rep), [rep.machType], rep.paramTypes, Function.getReturnType(funcType));
	}
	def newCallKernel(typeParams: Array<Type>, sig: Signature) -> Operator {
		return Operator.new(Opcode.CallKernel, typeParams, sig);
	}
//----------------------------------------------------------------------------

	// XXX: move to SsaUtil?
	def needsNullCheck(app: SsaInstr, obj: SsaInstr) -> bool {
		if (obj.facts.V_NON_ZERO) return false;
		return !app.facts.O_NO_NULL_CHECK;
	}
	def extractIrSpec(op: Operator, member: IrMember) -> IrSpec {
		var ta = op.typeArgs;
		return IrSpec.new(ta[0], ta, member);
	}
	def isDouble(t: Type) -> bool {
		return Float_TypeCon.!(t.typeCon).is64;
	}
}

// Accessor to the value arguments, type arguments, and dynamic environment
// for operator evaluation.
class Arguments {
	def numArgs() -> int;
	def getArg(i: int) -> Val;
	def getType(i: int) -> Type;
	def getTypes() -> Array<Type>;
	def getProgram() -> Program;
	def fwCall(spec: IrSpec, recvr: Val, startArg: int, endArg: int) -> Result;
	def throw(ex: string, msg: string) -> Exception;

	// Convenience accessors that perform casts on arguments
	def z(i: int) -> bool { return Bool.unbox(getArg(i)); }
	def r(i: int) -> Record { return Record.!(getArg(i)); }
	def i(i: int) -> int { return Int.unbox(getArg(i)); }
	def b(i: int) -> byte { return Byte.unbox(getArg(i)); }
	def s(i: int) -> string { return Byte.unboxString(getArg(i)); }
	def addr(i: int) -> Addr {
		var p = getArg(i);
		if (p == null) return NULL_PTR;
		return Addr.!(p);
	}
}
def NULL_PTR = Addr.new(null, null, 0).setAbsolute(0);

def evalOp(op: Operator, args: Arguments) -> Result {
	match (op.opcode) {
//----------------------------------------------------------------------------
		BoolEq => return Bool.box(args.z(0) == args.z(1));
		BoolAnd => return Bool.box(args.z(0) && args.z(1));
		BoolOr => return Bool.box(args.z(0) || args.z(1));
		BoolNot => return Bool.box(!args.z(0));
//----------------------------------------------------------------------------
		OverloadedEq, IntEq, VariantEq => return Bool.box(Values.equal(args.getArg(0), args.getArg(1)));
//----------------------------------------------------------------------------
		IntCastI => {
			var val = args.getArg(0), ft = args.getType(0), tt = args.getType(1);
			if (!IntType.?(ft)) return Bool.FALSE;
			var ift = IntType.!(ft), itt = IntType.!(tt);
			if(!itt.query(ift, val)) return args.throw(V3Exception.TypeCheck, null);
			var r = IntOp.evalConversion(ft, tt, val);
			if (r.approx == CastOp.TRUE) return val;
			if (r.approx == CastOp.VALUE) return r.result;
			else return args.throw(V3Exception.TypeCheck, null);
		}
		IntQueryI => {
			var val = args.getArg(0), ft = args.getType(0), tt = args.getType(1);
			if (!IntType.?(ft)) return Bool.FALSE;
			var ift = IntType.!(ft), itt = IntType.!(tt);
			return if(itt.query(ift, val), Bool.TRUE, Bool.FALSE);
		}
		IntViewF => {
			var v = args.getArg(0);
			if (v == null) return null;
			if (Float_TypeCon.!(args.getType(0).typeCon).is64) {
				return Long.box(long.view(Float64Val.!(v).bits));
			} else {
				return Int.box(int.view(Float32Val.!(v).bits));
			}
		}
		FloatViewI => {
			var v = args.getArg(0);
			if (v == null) return null;
			if (Float_TypeCon.!(args.getType(0).typeCon).is64) {
				return Float64Val.new(u64.view(Long.unboxSU(v, false)));
			} else {
				return Float32Val.new(u32.view(Int.unbox(v)));
			}
		}
//----------------------------------------------------------------------------
		RefEq => return Bool.box(args.getArg(0) == args.getArg(1));
//----------------------------------------------------------------------------
		TupleCreate(length) => {
			var vals = Array<Val>.new(length);
			for (i < vals.length) vals[i] = args.getArg(i);
			return TupleVal.new(vals);
		}
		TupleGetElem(index) => {
			var tuple = args.getArg(0);
			if (tuple == Values.BOTTOM) return Values.BOTTOM;
			return (TupleVal.!(tuple)).values[index];
		}
//----------------------------------------------------------------------------
		ArrayAlloc => {
			var length = args.i(0);
			if (length < 0) return args.throw(V3Exception.LengthCheck, null);
			var arrayType = args.getType(0);
			return args.getProgram().newRecord(arrayType, length);
		}
		ArrayInit(length) => {
			var array = args.getProgram().newRecord(args.getType(0), length);
			for (i < length) array.values[i] = args.getArg(i);
			return array;
		}
		ArrayGetElem => {
			var array = args.r(0), index = args.i(1);
			if (array == null) return args.throw(V3Exception.NullCheck, null);
			if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
			return array.values[index];
		}
		ArraySetElem => {
			var array = args.r(0), index = args.i(1);
			if (array == null) return args.throw(V3Exception.NullCheck, null);
			if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
			var val = args.getArg(2);
			array.values[index] = val;
			return val;
		}
		ArrayGetLength => {
			var array = args.r(0);
			if (array == null) return args.throw(V3Exception.NullCheck, null);
			return Int.box(array.values.length);
		}
//----------------------------------------------------------------------------
		Init(method) => {
			var index = VstNew.!(method.source).initIndex;
			var prog = args.getProgram();
			if (prog.initState[index] == InitState.Uninit) {
				var ctype = method.receiver;
				var receiver = Values.BOTTOM;
				if (ctype.typeCon.kind == V3Kind.COMPONENT) {
					receiver = prog.getComponentRecord(V3.asComponent(ctype).componentDecl);
				}
				prog.initState[index] = InitState.Running;
				var spec = IrSpec.new(ctype, [ctype], method);
				return args.fwCall(spec, receiver, 0, 0);
			}
			return Values.BOTTOM;
		}
		ComponentGetField(field) => {
			var decl = V3.asComponent(args.getType(0)).componentDecl;
			var object = args.getProgram().getComponentRecord(decl);
			return object.values[field.index];
		}
		ComponentSetField(field) => {
			var decl = V3.asComponent(args.getType(0)).componentDecl;
			var object = args.getProgram().getComponentRecord(decl);
			object.values[field.index] = args.getArg(1);
			return Values.BOTTOM;
		}
//----------------------------------------------------------------------------
		ClassAlloc(method) => {
			if (method != null) {
				var spec = getIrSpec(method, args), prog = args.getProgram();
				var record = prog.newRecord(spec.receiver, prog.ir.numFields(spec.receiver));
				return args.fwCall(spec, record, 0, args.numArgs());
			} else {
				var classType = args.getType(0), prog = args.getProgram();
				var record = prog.newRecord(classType, prog.ir.numFields(classType));
				return record;
			}
		}
		ClassGetField(field) => {
			var object = args.r(0);
			if (object == null) return args.throw(V3Exception.NullCheck, null);
			return object.values[field.index];
		}
		ClassInitField(field) => {
			var object = args.r(0);
			if (object == null) return args.throw(V3Exception.NullCheck, null);
			var val = args.getArg(1);
			object.values[field.index] = val;
			return Values.BOTTOM;
		}
		ClassSetField(field) => {
			var object = args.r(0);
			if (object == null) return args.throw(V3Exception.NullCheck, null);
			var val = args.getArg(1);
			object.values[field.index] = val;
			return Values.BOTTOM;
		}
//----------------------------------------------------------------------------
		ClassGetMethod(method) => {
			var object = args.r(0);
			var spec = getIrSpec(method, args);
			if (object == null) {
				if (!V3.isVariant(method.receiver)) return args.throw(V3Exception.NullCheck, null);
			}
			return Closure.new(object, spec);
		}
		ClassGetVirtual(method) => {
			var object = getReceiver(args);
			var spec = lookupVirtual(args, object, method);
			if (spec == null) return Values.BOTTOM;
			return Closure.new(object, spec);
		}
		ClassGetSelector(selector) => {
			var object = getReceiver(args);
			var spec = lookupVirtual(args, object, selector);
			if (spec == null) return Values.BOTTOM;
			return FuncVal.new(spec);
		}
//----------------------------------------------------------------------------
		VariantGetTag => {
			var val = args.getArg(0);
			return if(Record.?(val), Int.box(V3.getVariantTag(Record.!(val).rtype)));
		}
		VariantGetField(field) => {
			var object = args.r(0);
			return if(object != null, object.values[field.index]);
		}

//----------------------------------------------------------------------------
		NullCheck => {
			var object = args.r(0);
			if (object == null) return args.throw(V3Exception.NullCheck, null);
			return Values.BOTTOM;
		}
		BoundsCheck => {
			var array = args.r(0), index = args.i(1);
			if (array == null) return args.throw(V3Exception.NullCheck, null);
			if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
			return Values.BOTTOM;
		}
		ConditionalThrow(exception) => {
			if (Bool.unbox(args.getArg(0))) return args.throw(exception, null);
			return Values.BOTTOM;
		}
//----------------------------------------------------------------------------
		TypeCast(cast) => {
			var val = args.getArg(0), r = cast.eval(args.getType(0), args.getType(1), val);
			if (r.approx == CastOp.TRUE) return val;
			if (r.approx == CastOp.VALUE) return r.result;
			else return args.throw(V3Exception.TypeCheck, null);
		}
		TypeQuery(cast) => {
			var val = args.getArg(0), r = cast.eval(args.getType(0), args.getType(1), val);
			return if(r.approx == CastOp.TRUE, Bool.TRUE, Bool.FALSE);
		}
		TypeSubsume => return args.getArg(0);
//----------------------------------------------------------------------------
		CallMethod(method) => {
			var spec = getIrSpec(method, args);
			var object = getReceiver(args);
			if (method.receiver.typeCon.kind == V3Kind.CLASS && object == null) {
				return args.throw(V3Exception.NullCheck, null);
			}
			return args.fwCall(spec, object, 1, args.numArgs());
		}
		CallClassVirtual(method) => {
			var object = getReceiver(args);
			var spec = lookupVirtual(args, object, method);
			if (spec == null) return Values.BOTTOM;
			return args.fwCall(spec, object, 1, args.numArgs());
		}
		CallClassSelector(selector) => {
			var object = getReceiver(args);
			var spec = lookupVirtual(args, object, selector);
			if (spec == null) return Values.BOTTOM;
			return args.fwCall(spec, object, 1, args.numArgs());
		}
		CreateClosure(method) => {
			return Closure.new(args.getArg(0), getIrSpec(method, args));
		}
//----------------------------------------------------------------------------
		PtrAdd => {
			var p = args.addr(0), off = args.i(1);
			if (Addr.?(p)) return Addr.!(p).add(off);
			return args.throw(V3Exception.InternalError, "not a pointer");
		}
		PtrSub => {
			var p = args.addr(0), q = args.addr(1);
			if (p.base == q.base) return Int.box(p.offset - q.offset);
			if (p.base == q) return Int.box(p.offset);
			return args.throw(V3Exception.InternalError, "unfoldable pointer subtraction");
		}
//----------------------------------------------------------------------------
		SystemCall(syscall) => {
			var prog = args.getProgram();
			var sys = prog.system;
			if (sys == null) prog.system = sys = SystemCallState.new();
			return syscall.eval(sys, args);
		}
		_ => ;
	}
	return args.throw("EvalUnimplemented", op.opcode.name);
}
def lookupVirtual(args: Arguments, object: Record, member: IrMember) -> IrSpec {
	if (object == null) {
		if (V3.isVariant(member.receiver)) {
			return args.getProgram().ir.resolveVariantDefaultMethodImpl(getIrSpec(member, args));
		}
		args.throw(V3Exception.NullCheck, null);
	} else {
		return args.getProgram().ir.resolveMethodImpl(object.rtype, getIrSpec(member, args));
	}
	return null;
}
def getIrSpec(member: IrMember, args: Arguments) -> IrSpec {
	var ta = args.getTypes();
	return IrSpec.new(ta[0], ta, member);
}
def getReceiver(args: Arguments) -> Record {
	// TODO: this a giant hack for adapting arguments to void calls
	var r = args.getArg(0);
	if (Record.?(r)) return Record.!(r);
	if (TupleVal.?(r)) return Record.!(TupleVal.!(r).values[0]);
	if (r != null) args.throw(V3Exception.InternalError, "invalid receiver for call");
	return null;
}

def renderOp(op: Operator, buf: StringBuffer) -> StringBuffer {
	buf.puts(op.opcode.name);
	if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).green();

	var rfunc: StringBuffer -> StringBuffer;
	match (op.opcode) {
		IntWide(wideOp) => {
			buf.putc('<');
			buf.puts(wideOp.opcode.name);
			buf.putc('>');
		}
		TypeCast(cast) => rfunc = StringBuffer.puts(_, cast.approx.name);
		TypeQuery(cast) => rfunc = StringBuffer.puts(_, cast.approx.name);
		TupleCreate(length) => rfunc = StringBuffer.puti(_, length);
		TupleGetElem(length) => rfunc = StringBuffer.puti(_, length);
		Init(method) => if(method != null) rfunc = method.render;
		ComponentGetField(field) => rfunc = field.render;
		ComponentSetField(field) => rfunc = field.render;
		ClassGetField(field) => rfunc = field.render;
		ClassInitField(field) => rfunc = field.render;
		ClassSetField(field) => rfunc = field.render;
		VariantGetField(field) => rfunc = field.render;
		ClassGetMethod(method) => rfunc = method.render;
		ClassGetVirtual(method) => rfunc = method.render;
		ClassGetSelector(selector) => rfunc = selector.render;
		CallMethod(method) => rfunc = method.render;
		CallClassVirtual(method) => rfunc = method.render;
		CallClassSelector(selector) => rfunc = selector.render;
		CreateClosure(method) => rfunc = method.render;
		ConditionalThrow(exception) => StringBuffer.puts(_, exception);
		SystemCall(syscall) => StringBuffer.puts(_, syscall.name);
		_ => ;
	}

	if (rfunc != null) rfunc(buf.putc('[')).putc(']');
	var typeArgs = op.typeArgs;
	if (typeArgs.length > 0) {
		buf.putc('<');
		for (i < typeArgs.length) {
			if (i > 0) buf.csp();
			var t = typeArgs[i];
			if (t == null) buf.puts("null");
			else t.render(buf);
		}
		buf.putc('>');
	}
	return buf.end();
}
