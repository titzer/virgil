// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An operator represents a computation from argument values to a result value
// with possible side-effects.
class Operator(opcode: Opcode, typeArgs: Array<Type>, opc2: Opcode2) {
	private var openness: Open;			// lazily computed open / closed
	var op2 = Operator2.new(opc2);

	def checkOpenness() -> Open {
		// openness is not known. check all type args and operator type
		if (openness != Open.UNKNOWN) return openness;
		var hash = 0;
		// XXX: bail out earlier if a nested type is open
		for (t in typeArgs) hash = hash | t.hash;
		var sig = this.sig();
		for (t in sig.paramTypes) hash = hash | t.hash;
		for (t in sig.returnTypes) hash = hash | t.hash;
		return openness = if((hash & TypeConst.OPEN_MASK) != 0, Open.OPEN, Open.CLOSED);
	}
	def isPolymorphic() -> bool {
		return checkOpenness() == Open.OPEN;
	}
	def subst(f: Type -> Type) -> Operator {
		if (openness == Open.CLOSED) return this;
		if (checkOpenness() == Open.OPEN) return Operator.new(opcode, Arrays.map(typeArgs, f), Opcodes2.subst(opc2, f));
		return this;
	}
	def equals(that: Operator) -> bool {
		if (this == that) return true;
		return this.opcode == that.opcode && Arrays.equal(this.typeArgs, that.typeArgs);
	}
	def render(buf: TerminalBuffer) -> StringBuilder {
		return renderOp(this, buf);
	}
	def sig() -> Signature {
		return op2.sig();
	}
}

// Whether an operator is known to contain any open (polymorphic) types.
enum Open { UNKNOWN, OPEN, CLOSED }

// Everything for building and caching operators. Named {Op} to keep
// the rest of the code short.
component V3Op {
	// Cached sigs and parts of sigs
	def arr_v = TypeUtil.NO_TYPES;
	def type_i = Int.TYPE;
	def type_u = Int.getType(false, 32);
	def type_z = Bool.TYPE;
	def type_v = Void.TYPE;
	def type_f: Type = Float.FLOAT32;
	def type_d: Type = Float.FLOAT64;
	def type_rs = V3Range.START_TYPE;

	def arr_z = Bool.ARRAY_T;
	def arr_i = Int.ARRAY_T;
	def arr_f = [type_f];
	def arr_ff = [type_f, type_f];
	def arr_d = [type_d];
	def arr_dd = [type_d, type_d];
	def arr_zz = Bool.ARRAY_TT;

	def sig_zz_z = Signature.new(null, arr_zz, arr_z);
	def sig_z_z = Signature.new(null, arr_z, arr_z);

//----------------------------------------------------------------------------
	def opBoolEq = Operator.new(Opcode.BoolEq, arr_z, Opcode2.BoolEq);
	def opBoolAnd = Operator.new(Opcode.BoolAnd, arr_v, Opcode2.BoolAnd);
	def opBoolOr = Operator.new(Opcode.BoolOr, arr_v, Opcode2.BoolOr);
	def opBoolNot = Operator.new(Opcode.BoolNot, arr_v, Opcode2.BoolNot);
//----------------------------------------------------------------------------
	def newIntEq(t: IntType) -> Operator {
		return Operator.new(Opcode.IntEq, [t], Opcode2.IntEq(t));
	}
	def newIntWide(op: Operator, normal: Array<Type>, result: Type) -> Operator {
		return Operator.new(Opcode.IntWide(op), arr_v, Opcode2.IntWide(op, normal, Tuple.toTypeArray(result)));
	}
//----------------------------------------------------------------------------
	def opFloatBitEq32 = Operator.new(Opcode.FloatBitEq(false), arr_f, Opcode2.FloatBitEq(Float.FLOAT32));
	def opFloatBitEq64 = Operator.new(Opcode.FloatBitEq(true), arr_d, Opcode2.FloatBitEq(Float.FLOAT64));
//----------------------------------------------------------------------------
	def newIntCastF(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.IntCastF(V3.isDouble(ft)), [ft, tt], Opcode2.IntCastF(IntType.!(tt), FloatType.!(ft)));
	}
	def newIntQueryF(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.IntQueryF(V3.isDouble(ft)), [ft, tt], Opcode2.IntQueryF(IntType.!(tt), FloatType.!(ft)));
	}
	def newIntViewI(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.IntViewI, [ft, tt], Opcode2.IntViewI(IntType.!(tt), IntType.!(ft)));
	}
	def opIntViewF32 = Operator.new(Opcode.IntViewF(false), arr_f, Opcode2.IntViewF(Int.U32, Float.FLOAT32));
	def opIntViewF64 = Operator.new(Opcode.IntViewF(true), arr_d, Opcode2.IntViewF(Long.U64, Float.FLOAT64));
	def newIntTruncF(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.IntTruncF(V3.isDouble(ft)), [ft, tt], Opcode2.IntTruncF(IntType.!(tt), FloatType.!(ft)));
	}
//----------------------------------------------------------------------------
	def newFloatCastI(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.FloatCastI(V3.isDouble(tt)), [ft, tt], Opcode2.FloatCastI(FloatType.!(tt), IntType.!(ft)));
	}
	def opFloatCastD = Operator.new(Opcode.FloatCastD, arr_d, Opcode2.FloatCastD(Float.FLOAT32, Float.FLOAT64));
	def newFloatQueryI(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.FloatQueryI(V3.isDouble(tt)), [ft, tt], Opcode2.FloatQueryI(FloatType.!(tt), IntType.!(ft)));
	}
	def opFloatQueryD = Operator.new(Opcode.FloatQueryD, arr_d, Opcode2.FloatQueryD(Float.FLOAT32, Float.FLOAT64));
	def newFloatPromoteI(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.FloatPromoteI(V3.isDouble(tt)), [ft, tt], Opcode2.FloatPromoteI(FloatType.!(tt), IntType.!(ft)));
	}
	def opFloatPromoteF = Operator.new(Opcode.FloatPromoteF, arr_f, Opcode2.FloatPromoteF(Float.FLOAT64, Float.FLOAT32));
	def newFloat32ViewI(ft: Type) -> Operator {
		return Operator.new(Opcode.FloatViewI(false), [ft, type_f], Opcode2.FloatViewI(Float.FLOAT32, ft)); // TODO: ft should be IntType
	}
	def newFloat64ViewI(ft: Type) -> Operator {
		return Operator.new(Opcode.FloatViewI(true), [ft, type_d], Opcode2.FloatViewI(Float.FLOAT64, ft)); // TODO: ft should be IntType
	}
	def newFloatRoundI(ft: Type, tt: Type) -> Operator {
		return Operator.new(Opcode.FloatRoundI(V3.isDouble(tt)), [ft, tt], Opcode2.FloatRoundI(FloatType.!(tt), ft)); // TODO: ft should be IntType
	}
	def newFloatRound(t: Type) -> Operator {
		return Operator.new(Opcode.FloatRound(V3.isDouble(t)), [t], Opcode2.FloatRound(FloatType.!(t)));
	}
	def opFloatRoundD = Operator.new(Opcode.FloatRoundD, arr_v, Opcode2.FloatRoundD(Float.FLOAT32, Float.FLOAT64));
//----------------------------------------------------------------------------
	def newRefEq(t: Type) -> Operator {
		return Operator.new(Opcode.RefEq, [t], Opcode2.RefEq(t));
	}
//----------------------------------------------------------------------------
	def newDefaultValue(t: Type) -> Operator {
		return Operator.new(Opcode.DefaultValue, [t], Opcode2.DefaultValue(t));
	}
//----------------------------------------------------------------------------
	def newIntRepCreate(ft: Type, tt: IntRepType) -> Operator {
		return Operator.new(Opcode.IntRepCreate, [ft, tt], Opcode2.IntRepCreate(tt, ft));
	}
	def newIntRepView(ft: IntRepType, tt: Type) -> Operator {
		return Operator.new(Opcode.IntRepView, [ft, tt], Opcode2.IntRepView(tt, ft));
	}
//----------------------------------------------------------------------------
	def newTupleCreate(tupleType: Type) -> Operator {
		var paramTypes = Lists.toArray(tupleType.nested);
		return Operator.new(Opcode.TupleCreate(paramTypes.length), [tupleType], Opcode2.TupleCreate(TupleType.!(tupleType)));
	}
	def newTupleGetElem(tupleType: Type, index: int) -> Operator {
		var tt = [tupleType];
		return Operator.new(Opcode.TupleGetElem(index), tt, Opcode2.TupleGetElem(TupleType.!(tupleType), index));
	}
//----------------------------------------------------------------------------
	def newArrayAlloc(arrayType: Type) -> Operator {
		return Operator.new(Opcode.ArrayAlloc, [arrayType], Opcode2.ArrayAlloc(ArrayType.!(arrayType)));
	}
	def newArrayFill(arrayType: Type) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		return Operator.new(Opcode.ArrayFill, [arrayType], Opcode2.ArrayFill(ArrayType.!(arrayType)));
	}
	def newArrayInit(arrayType: Type, length: int) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var paramTypes = Array<Type>.new(length);
		for (i < paramTypes.length) paramTypes[i] = elemType;
		return Operator.new(Opcode.ArrayInit(length), [arrayType], Opcode2.ArrayInit(ArrayType.!(arrayType), length));
	}
	def newArrayTupleInit(arrayType: Type, elems: int, length: int) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var paramTypes = Array<Type>.new(elems * length);
		var tuple = Tuple.toTypeArray(V3Array.elementType(arrayType));
		var i = 0;
		for (j < length) {
			for (k < tuple.length) {
				paramTypes[i++] = tuple[k];
			}
		}
		return Operator.new(Opcode.ArrayTupleInit(elems, length), [arrayType], Opcode2.ArrayTupleInit(ArrayType.!(arrayType), elems, length));
	}
	def newArrayGetElem(arrayType: Type, indexType: IntType) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var tt = [arrayType, indexType];
		match (arrayType) {
			x: ArrayType => return Operator.new(Opcode.ArrayGetElem, tt, Opcode2.ArrayGetElem(x, indexType));
			x: RangeType => return Operator.new(Opcode.RangeGetElem, tt, Opcode2.RangeGetElem(x, indexType));
			_ => return null; // TODO: error
		}
	}
	def newArraySetElem(arrayType: Type, indexType: IntType) -> Operator {
		var elemType = V3Array.elementType(arrayType);
		var tt = [arrayType, indexType, elemType];
		match (arrayType) {
			x: ArrayType => return Operator.new(Opcode.ArraySetElem, tt, Opcode2.ArraySetElem(x, indexType));
			x: RangeType => return Operator.new(Opcode.RangeSetElem, tt, Opcode2.RangeSetElem(x, indexType));
			_ => return null; // TODO: error
		}
	}
	def newArrayGetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		var tt = [arrayType, indexType];
		return Operator.new(Opcode.ArrayGetElemElem(index), tt, Opcode2.ArrayGetElemElem(ArrayType.!(arrayType), IntType.!(indexType), index));
	}
	def newArraySetElemElem(arrayType: Type, indexType: Type, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		var tt = [arrayType, indexType, etype];
		return Operator.new(Opcode.ArraySetElemElem(index), tt, Opcode2.ArraySetElemElem(ArrayType.!(arrayType), IntType.!(indexType), index));
	}
	def newArrayGetLength(arrayType: Type) -> Operator {
		var tt = [arrayType];
		match (arrayType) {
			x: ArrayType => return Operator.new(Opcode.ArrayGetLength, tt, Opcode2.ArrayGetLength(x));
			x: RangeType => return Operator.new(Opcode.RangeGetLength, tt, Opcode2.RangeGetLength(x));
			_ => return null; // TODO: error
		}
	}
//----------------------------------------------------------------------------
	def newRangeFromPlus(rangeType: Type, startType: Type, lengthType: Type) -> Operator {
		var tt = [rangeType, startType, lengthType];
		return Operator.new(Opcode.RangeFromPlus, tt, Opcode2.RangeFromPlus(RangeType.!(rangeType), IntType.!(startType), IntType.!(lengthType)));
	}
	def newRangeFromTo(rangeType: Type, startType: Type, endType: Type) -> Operator {
		var tt = [rangeType, startType, endType];
		return Operator.new(Opcode.RangeFromTo, tt, Opcode2.RangeFromTo(RangeType.!(rangeType), IntType.!(startType), IntType.!(endType)));
	}
	def newRangeGetLength(rangeType: Type) -> Operator {
		var tt = [rangeType];
		return Operator.new(Opcode.RangeGetLength, tt, Opcode2.RangeGetLength(RangeType.!(rangeType)));
	}
	def newRangeStartPlusIndex(rangeType: Type, indexType: IntType) -> Operator {
		return Operator.new(Opcode.RangeStartPlusIndex, [rangeType, indexType], Opcode2.RangeStartPlusIndex(RangeType.!(rangeType), indexType));
	}
	def newRangeStartFromPointer(rangeType: Type, ptrType: PointerType) -> Operator {
		return Operator.new(Opcode.RangeStartFromPointer, [rangeType, ptrType], Opcode2.RangeStartFromPointer(RangeType.!(rangeType), ptrType));
	}
	def newNormRangeGetElem(arrayType: Type, indexType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return Operator.new(Opcode.NormRangeGetElem, [arrayType, indexType], Opcode2.NormRangeGetElem(ArrayType.!(arrayType), IntType.!(indexType)));
	}
	def newNormRangeGetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		return Operator.new(Opcode.NormRangeGetElemElem(index), [arrayType, indexType], Opcode2.NormRangeGetElemElem(ArrayType.!(arrayType), index, IntType.!(indexType)));
	}
	def newNormRangeSetElem(arrayType: Type, indexType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return Operator.new(Opcode.NormRangeSetElem, [arrayType, indexType], Opcode2.NormRangeSetElem(ArrayType.!(arrayType), IntType.!(indexType)));
	}
	def newNormRangeSetElemElem(arrayType: Type, indexType: IntType, index: int) -> Operator {
		var etype = Tuple.elementType(V3Array.elementType(arrayType), index);
		return Operator.new(Opcode.NormRangeSetElemElem(index), [arrayType, indexType], Opcode2.NormRangeSetElemElem(ArrayType.!(arrayType), index, IntType.!(indexType)));
	}
//----------------------------------------------------------------------------
	def newInit(meth: IrMethod) -> Operator {
		return Operator.new(Opcode.Init(meth), TypeUtil.NO_TYPES, Opcode2.Init(meth));
	}
	def newComponentGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return Operator.new(Opcode.ComponentGetField(fieldRef.asField()), tt, Opcode2.ComponentGetField(fieldRef.asField()));
	}
	def newComponentSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return Operator.new(Opcode.ComponentSetField(fieldRef.asField()), [fieldRef.receiver], Opcode2.ComponentSetField(fieldRef.asField()));
	}
//----------------------------------------------------------------------------
	def newClassAlloc(newRef: IrSpec) -> Operator {
		var ftype = newRef.getBoundType(), paramTypes = Function.getParamTypeArray(ftype);
		return Operator.new(Opcode.ClassAlloc(newRef.asMethod()), [newRef.receiver], Opcode2.ClassAlloc(newRef));
	}
	def newEmptyClassAlloc(classType: Type) -> Operator {
		return Operator.new(Opcode.ClassAlloc(null), [classType], Opcode2.ClassEmptyAlloc(ClassType.!(classType), TypeUtil.NO_TYPES));
	}
	def newEmptyClassAllocP(classType: Type, paramTypes: Array<Type>) -> Operator {
		return Operator.new(Opcode.ClassAlloc(null), [classType], Opcode2.ClassEmptyAlloc(ClassType.!(classType), paramTypes));
	}
	def newClassGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return Operator.new(Opcode.ClassGetField(fieldRef.asField()), tt, Opcode2.ClassGetField(fieldRef));
	}
	def newClassInitField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return Operator.new(Opcode.ClassInitField(fieldRef.asField()), [fieldRef.receiver], Opcode2.ClassInitField(fieldRef));
	}
	def newClassSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return Operator.new(Opcode.ClassSetField(fieldRef.asField()), [fieldRef.receiver], Opcode2.ClassSetField(fieldRef));
	}
	def newClassGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return Operator.new(Opcode.ClassGetMethod(methodRef.asMethod()), typeArgs, Opcode2.ClassGetMethod(methodRef));
	}
	def newClassGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return Operator.new(Opcode.ClassGetVirtual(methodRef.asMethod()), typeArgs, Opcode2.ClassGetVirtual(methodRef));
	}
	def newClassGetSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var selector = IrSelector.!(methodRef.member);
		return Operator.new(Opcode.ClassGetSelector(selector), typeArgs, Opcode2.ClassGetSelector(methodRef));
	}
//----------------------------------------------------------------------------
	def newVariantGetTag(vtype: Type) -> Operator {
		var vt = [vtype];
		return Operator.new(Opcode.VariantGetTag, vt, Opcode2.VariantGetTag(ClassType.!(vtype)));
	}
	def newVariantAlloc(t: Type, fieldTypes: Array<Type>) -> Operator {
		return Operator.new(Opcode.VariantAlloc, [t], Opcode2.VariantAlloc(ClassType.!(t), fieldTypes));
	}
	def newVariantGetField(fieldRef: IrSpec) -> Operator {
		var tt = [fieldRef.receiver];
		return Operator.new(Opcode.VariantGetField(fieldRef.asField()), tt, Opcode2.VariantGetField(fieldRef));
	}
	def newVariantGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return Operator.new(Opcode.VariantGetMethod(methodRef.asMethod()), typeArgs, Opcode2.VariantGetMethod(methodRef));
	}
	def newVariantGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return Operator.new(Opcode.VariantGetVirtual(methodRef.asMethod()), typeArgs, Opcode2.VariantGetVirtual(methodRef));
	}
	def newVariantGetSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		var selector = IrSelector.!(methodRef.member);
		return Operator.new(Opcode.VariantGetSelector(selector), typeArgs, Opcode2.VariantGetSelector(methodRef));
	}
//----------------------------------------------------------------------------
	def newNullCheck(rtype: Type) -> Operator {
		var tt = [rtype];
		return Operator.new(Opcode.NullCheck, tt, Opcode2.NullCheck(rtype));
	}
	def newBoundsCheck(rtype: Type) -> Operator {
		return Operator.new(Opcode.BoundsCheck, [rtype], Opcode2.BoundsCheck(rtype));
	}
	def newConditionalThrow(exception: string) -> Operator {
		return Operator.new(Opcode.ConditionalThrow(exception), arr_v, Opcode2.ConditionalThrow(exception));
	}
//----------------------------------------------------------------------------
	def newEqual(t: Type) -> Operator {
		var opcode: Opcode;
		var opcode2: Opcode2;
		match (t.typeCon.kind) {
			BOOL => return opBoolEq;
			INT => 		{ opcode = Opcode.IntEq; opcode2 = Opcode2.IntEq(IntType.!(t)); }
			ENUM,
			ENUM_SET =>	{ opcode = Opcode.IntEq; opcode2 = Opcode2.OverloadedEq(t); } // TODO
			FLOAT =>	{ opcode = Opcode.FloatEq(V3.isDouble(t)); opcode2 = Opcode2.FloatEq(FloatType.!(t)); }
			POINTER,
			ARRAY,
			CLASS,
			ANYREF,
			ANYFUNC,
			FUNCREF,
			RANGE_START =>	{ opcode = Opcode.RefEq; opcode2 = Opcode2.RefEq(t); }
			VARIANT =>	{ opcode = Opcode.VariantEq; opcode2 = Opcode2.VariantEq(ClassType.!(t)); }
			_ => 		{ opcode = Opcode.OverloadedEq; opcode2 = Opcode2.OverloadedEq(t); }
		}
		return Operator.new(opcode, [t], opcode2);
	}
	def newTypeCast(f: Type, t: Type) -> Operator {
		var cast = TypeSystem.newTypeCast(f, t);
		return Operator.new(Opcode.TypeCast(cast), [f, t], Opcode2.TypeCast(cast, t, f));
	}
	def newTypeQuery(f: Type, t: Type) -> Operator {
		var query = TypeSystem.newTypeQuery(f, t);
		return Operator.new(Opcode.TypeQuery(query), [f, t], Opcode2.TypeQuery(query, t, f));
	}
	def newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {
		return Operator.new(Opcode.TypeSubsume, [typeFrom, typeTo], Opcode2.TypeSubsume(typeTo, typeFrom));
	}
//----------------------------------------------------------------------------
	def newCallMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return Operator.new(Opcode.CallMethod(methodRef.asMethod()), typeArgs, Opcode2.CallMethod(methodRef));
	}
	def newCallClassMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		return Operator.new(Opcode.CallClassMethod(methodRef.asMethod()), typeArgs, Opcode2.CallClassMethod(methodRef));
	}
	def newCallClassVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		return Operator.new(Opcode.CallClassVirtual(methodRef.asMethod()), typeArgs, Opcode2.CallClassVirtual(methodRef));
	}
	def newCallVariantVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		return Operator.new(Opcode.CallVariantVirtual(methodRef.asMethod()), typeArgs, Opcode2.CallVariantVirtual(methodRef));
	}
	def newCallClassSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var selector = IrSelector.!(methodRef.member);
		return Operator.new(Opcode.CallClassSelector(selector), typeArgs, Opcode2.CallClassSelector(methodRef));
	}
	def newCallVariantSelector(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var selector = IrSelector.!(methodRef.member);
		return Operator.new(Opcode.CallVariantSelector(selector), typeArgs, Opcode2.CallVariantSelector(methodRef));
	}
	def newCallClosure(ftype: Type) -> Operator {
		return Operator.new(Opcode.CallClosure, [ftype], Opcode2.CallClosure(FuncType.!(ftype)));
	}
	def newCallFunction(ftype: Type) -> Operator {
		ftype = Function.funcRefType(Function.prependParamType(AnyRef.TYPE, ftype));
		if (ftype.typeCon.kind != Kind.FUNCREF) return V3.fail("only function types allowed");
		return Operator.new(Opcode.CallFunction, [ftype], Opcode2.CallFunction(FuncType.!(ftype)));
	}
	def newCreateClosure(methodRef: IrSpec, objType: Type) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return Operator.new(Opcode.CreateClosure(methodRef.asMethod()), typeArgs, Opcode2.CreateClosure(objType, methodRef));
	}
	def newForgeClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {
		return Operator.new(Opcode.ForgeClosure, [receiver, param, result], Opcode2.ForgeClosure(PointerType.!(ptrType), receiver, param, result));
	}
	def newUnpackClosure(ptrType: Type, receiver: Type, param: Type, result: Type) -> Operator {
		return Operator.new(Opcode.UnpackClosure, [receiver, param, result], Opcode2.UnpackClosure(PointerType.!(ptrType), receiver, param, result));
	}
	def newForgeRange(elementType: Type, ptrType: Type) -> Operator {
		return Operator.new(Opcode.ForgeRange, [elementType, ptrType], Opcode2.ForgeRange(PointerType.!(ptrType), RangeType.!(V3Range.newType(elementType))));
	}
//----------------------------------------------------------------------------
	def newSystemCall(syscall: SystemCall, paramTypes: Array<Type>, returnType: Type) -> Operator {
		return Operator.new(Opcode.SystemCall(syscall), arr_v, Opcode2.SystemCall(syscall, Tuple.fromTypeArray(paramTypes), returnType));
	}
//----------------------------------------------------------------------------
	def newVstSugar(op: VstOperator, typeParams: Array<Type>, paramTypes: Array<Type>, result: Type) -> Operator {
		return Operator.new(Opcode.VstSugar(op), typeParams, Opcode2.VstSugar(op, paramTypes, result));
	}
//----------------------------------------------------------------------------
	def newPtrAdd(ptrType: Type, it: IntType) -> Operator {
		return Operator.new(Opcode.PtrAdd, [ptrType, it], Opcode2.PtrAdd(ptrType, IntType.!(it)));
	}
	def newPtrSub(ptrType: Type, it: IntType) -> Operator {
		return Operator.new(Opcode.PtrSub, [ptrType, it], Opcode2.PtrSub(ptrType, IntType.!(it)));
	}
	def newPtrLt(ptrType: Type) -> Operator {
		return Operator.new(Opcode.PtrLt, [ptrType], Opcode2.PtrLt(PointerType.!(ptrType)));
	}
	def newPtrLteq(ptrType: Type) -> Operator {
		return Operator.new(Opcode.PtrLteq, [ptrType], Opcode2.PtrLteq(PointerType.!(ptrType)));
	}
	def newPtrAtContents(rangeType: Type, ptrType: Type) -> Operator {
		return Operator.new(Opcode.PtrAtContents, [rangeType], Opcode2.PtrAtContents(PointerType.!(ptrType), rangeType));
	}
	def newPtrAtLength(arrayType: Type, ptrType: Type) -> Operator {
		var tt = [arrayType];
		return Operator.new(Opcode.PtrAtLength, tt, Opcode2.PtrAtLength(PointerType.!(ptrType), ArrayType.!(arrayType)));
	}
	def newPtrAtObject(objType: Type, ptrType: Type) -> Operator {
		var tt = [objType];
		return Operator.new(Opcode.PtrAtObject, tt, Opcode2.PtrAtObject(PointerType.!(ptrType), objType));
	}
	def newPtrAtArrayElem(arrayType: Type, indexType: IntType, ptrType: Type) -> Operator {
		var tt = [arrayType, indexType];
		return Operator.new(Opcode.PtrAtArrayElem, tt, Opcode2.PtrAtArrayElem(PointerType.!(ptrType), ArrayType.!(arrayType), IntType.!(indexType)));
	}
	def newPtrAtRangeElem(rangeType: Type, indexType: IntType, ptrType: Type) -> Operator {
		var tt = [rangeType, indexType];
		return Operator.new(Opcode.PtrAtRangeElem, tt, Opcode2.PtrAtRangeElem(PointerType.!(ptrType), RangeType.!(rangeType), IntType.!(indexType)));
	}
	def newPtrAtEnd(objType: Type, ptrType: Type) -> Operator {
		var tt = [objType];
		return Operator.new(Opcode.PtrAtEnd, tt, Opcode2.PtrAtEnd(PointerType.!(ptrType), objType));
	}
	def newPtrAtRef(layoutType: Type, ptrType: Type) -> Operator {
		var tt = [layoutType];
		return Operator.new(Opcode.PtrAtRef, tt, Opcode2.PtrAtRef(PointerType.!(ptrType), layoutType));
	}
	def newPtrAtComponentField(spec: IrSpec, ptrType: Type) -> Operator {
		return Operator.new(Opcode.PtrAtComponentField(spec.asField()), [spec.receiver], Opcode2.PtrAtComponentField(PointerType.!(ptrType), spec));
	}
	def newPtrAtObjectField(spec: IrSpec, ptrType: Type) -> Operator {
		var tt = [spec.receiver];
		return Operator.new(Opcode.PtrAtObjectField(spec.asField()), tt, Opcode2.PtrAtObjectField(PointerType.!(ptrType), spec));
	}
	def newPtrAtRefLayoutField(refType: Type, offset: int, ptrType: Type) -> Operator {
		var ta = [refType];
		return Operator.new(Opcode.PtrAtRefLayoutField(offset), ta, Opcode2.PtrAtRefLayoutField(RefType.!(refType), PointerType.!(ptrType), offset));
	}
	def newPtrAtUnboxedObjectField(specs: List<IrSpec>, ptrType: Type) -> Operator {
		var ta = [specs.head.receiver];
		return Operator.new(Opcode.PtrAtUnboxedObjectField(Lists.map(specs, IrSpec.asField)), ta, Opcode2.PtrAtUnboxedObjectField(specs, PointerType.!(ptrType)));
	}
	def newPtrAtUnboxedComponentField(specs: List<IrSpec>, ptrType: Type) -> Operator {
		var ta = [specs.head.receiver];
		return Operator.new(Opcode.PtrAtUnboxedComponentField(Lists.map(specs, IrSpec.asField)), ta, Opcode2.PtrAtUnboxedComponentField(specs, PointerType.!(ptrType)));
	}
	def newPtrCmpSwp(ptrType: Type, valueType: Type) -> Operator {
		return Operator.new(Opcode.PtrCmpSwp, [ptrType, valueType], Opcode2.PtrCmpSwp(PointerType.!(ptrType), valueType));
	}
	def newPtrLoad(ptrType: Type, valueType: Type) -> Operator {
		return Operator.new(Opcode.PtrLoad, [ptrType, valueType], Opcode2.PtrLoad(ptrType, valueType));
	}
	def newPtrStore(ptrType: Type, valueType: Type) -> Operator {
		var tt = [ptrType, valueType];
		return Operator.new(Opcode.PtrStore, tt, Opcode2.PtrStore(ptrType, valueType));
	}
	def newPtrAddRangeStart(ptrType: Type) -> Operator {
		return Operator.new(Opcode.PtrAddRangeStart, [ptrType], Opcode2.PtrAddRangeStart(PointerType.!(ptrType)));
	}
//----------------------------------------------------------------------------
	def newCallerIp(ptrType: Type) -> Operator {
		return Operator.new(Opcode.CallerIp, TypeUtil.NO_TYPES, Opcode2.CallerIp(PointerType.!(ptrType)));
	}
	def newCallerSp(ptrType: Type) -> Operator {
		return Operator.new(Opcode.CallerSp, TypeUtil.NO_TYPES, Opcode2.CallerSp(PointerType.!(ptrType)));
	}
//----------------------------------------------------------------------------
	def newAlloc(ptrType: Type) -> Operator {
		return Operator.new(Opcode.Alloc, [ptrType], Opcode2.Alloc(ptrType));

	}
//----------------------------------------------------------------------------
	def newCallAddress(p: PointerType, rep: Mach_FuncRep) -> Operator {
		var funcType = rep.machType.nested.head;
		return Operator.new(Opcode.CallAddress(rep), [rep.machType], Opcode2.CallAddress(p, rep));
	}
	def newCallKernel(kernel: Kernel, typeParams: Array<Type>, sig: Signature) -> Operator {
		return Operator.new(Opcode.CallKernel(kernel), typeParams, Opcode2.CallKernel(kernel, sig.paramTypes, sig.returnType()));
	}
//----------------------------------------------------------------------------
	def newRefLayoutAt(refType: RefType) -> Operator {
		var at: Array<Type> = [refType];
		return Operator.new(Opcode.RefLayoutAt, at, Opcode2.RefLayoutAt(refType));
	}
	def newRefLayoutOf(refType: RefType) -> Operator {
		var at: Array<Type> = [refType];
		return Operator.new(Opcode.RefLayoutOf, at, Opcode2.RefLayoutOf(refType));
	}
	def newRefLayoutIn(refType: RefType, offset: int, result: RefType) -> Operator {
		var at: Array<Type> = [refType, result];
		return Operator.new(Opcode.RefLayoutIn(offset), at, Opcode2.RefLayoutIn(refType, offset, result));
	}
	def newRefLayoutGetField(refType: RefType, offset: int, fieldType: Type, order: ByteOrder) -> Operator {
		return Operator.new(Opcode.RefLayoutGetField(offset, order), [refType, fieldType], Opcode2.RefLayoutGetField(refType, offset, fieldType));
	}
	def newRefLayoutSetField(refType: RefType, offset: int, fieldType: Type, order: ByteOrder) -> Operator {
		var at = [refType, fieldType];
		return Operator.new(Opcode.RefLayoutSetField(offset, order), at, Opcode2.RefLayoutSetField(refType, offset, fieldType));
	}
	def newRefLayoutAtRepeatedField(refType: RefType, offset: int, scale: int, max: int, result: RefType) -> Operator {
		var opcode = Opcode.RefLayoutAtRepeatedField(offset, scale, max);
		return Operator.new(opcode, [refType, result], Opcode2.RefLayoutAtRepeatedField(refType, offset, scale, max, result));
	}
	def newRefLayoutGetRepeatedField(refType: RefType, offset: int, scale: int, max: int, fieldType: Type, order: ByteOrder) -> Operator {
		var opcode = Opcode.RefLayoutGetRepeatedField(offset, scale, max, order);
		return Operator.new(opcode, [refType, fieldType], Opcode2.RefLayoutGetRepeatedField(refType, offset, scale, max, fieldType));
	}
	def newRefLayoutSetRepeatedField(refType: RefType, offset: int, scale: int, max: int, fieldType: Type, order: ByteOrder) -> Operator {
		var opcode = Opcode.RefLayoutSetRepeatedField(offset, scale, max, order);
		return Operator.new(opcode, [refType, fieldType], Opcode2.RefLayoutSetRepeatedField(refType, offset, scale, max, fieldType));
	}
	def newByteArrayGetField(offset: int, fieldType: Type, order: ByteOrder, startType: Type) -> Operator {
		var opcode = Opcode.ByteArrayGetField(offset, order);
		return Operator.new(opcode, [fieldType, startType], Opcode2.ByteArrayGetField(startType, offset, fieldType));
	}
	def newByteArraySetField(offset: int, fieldType: Type, order: ByteOrder, startType: Type) -> Operator {
		var opcode = Opcode.ByteArraySetField(offset, order);
		return Operator.new(opcode, [fieldType, startType], Opcode2.ByteArraySetField(startType, offset, fieldType));
	}
//----------------------------------------------------------------------------
	def bestCallVirtual(spec: IrSpec) -> Operator {
		if (spec.receiver.typeCon.kind == Kind.CLASS) {
			if (!spec.member.facts.M_OVERRIDDEN) return newCallClassMethod(spec);
			return newCallClassVirtual(spec);
		} else {
			if (!spec.member.facts.M_OVERRIDDEN) return newCallMethod(spec);
			return newCallVariantVirtual(spec);
		}
	}
	def bestGetVirtual(spec: IrSpec) -> Operator {
		if (spec.receiver.typeCon.kind == Kind.CLASS) {
			if (!spec.member.facts.M_OVERRIDDEN) return newClassGetMethod(spec);
			else return V3Op.newClassGetVirtual(spec);
		} else {
			if (!spec.member.facts.M_OVERRIDDEN) return newVariantGetMethod(spec);
			return newVariantGetVirtual(spec);
		}
	}
	def bestGetSelector(spec: IrSpec) -> Operator {
		return if(spec.receiver.typeCon.kind == Kind.CLASS, newClassGetSelector(spec), newVariantGetSelector(spec));
	}

	// XXX: migrate to Compiler.nullCheckFacts
	def needsNullCheck(app: SsaInstr, obj: SsaInstr) -> bool {
		if (obj.facts.V_NON_ZERO) return false;
		return !app.facts.O_NO_NULL_CHECK;
	}
	def extractIrSpec(op: Operator, member: IrMember) -> IrSpec {
		var ta = op.typeArgs;
		return IrSpec.new(ta[0], ta, member);
	}
}

def renderList<T>(sb: StringBuilder, lst: List<T>,
		  rfunc: (T, StringBuilder) -> StringBuilder, sep: string) -> StringBuilder {
	for (node = lst; node != null; node = node.tail) {
		sb = rfunc(node.head, sb).puts(if(node.tail == null, "", sep));
	}
	return sb;
}

def renderOp(op: Operator, buf: TerminalBuffer) -> StringBuilder {
	buf.puts(op.opcode.name);
	if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).green();

	var rfunc: StringBuilder -> StringBuilder;
	match (op.opcode) {
		IntWide(wideOp) => {
			buf.putc('<');
			buf.puts(wideOp.opcode.name);
			buf.putc('>');
		}
		TypeCast(cast) => rfunc = StringBuilder.puts(_, cast.name);
		TypeQuery(query) => rfunc = StringBuilder.puts(_, query.name);
		TupleCreate(length) => rfunc = StringBuilder.putd(_, length);
		TupleGetElem(length) => rfunc = StringBuilder.putd(_, length);
		Init(method) => if(method != null) rfunc = method.render;
		ArrayInit(length) => rfunc = StringBuilder.putd(_, length);
		ArrayTupleInit(elems, length) => rfunc = StringBuilder.put2(_, "%d,%d", elems, length);
		ArrayGetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		ArraySetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		NormRangeGetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		NormRangeSetElemElem(index) => rfunc = StringBuilder.putd(_, index);
		ComponentGetField(field) => rfunc = field.render;
		ComponentSetField(field) => rfunc = field.render;
		ClassGetField(field) => rfunc = field.render;
		ClassInitField(field) => rfunc = field.render;
		ClassSetField(field) => rfunc = field.render;
		VariantGetField(field) => rfunc = field.render;
		PtrAtComponentField(field) => rfunc = field.render;
		PtrAtObjectField(field) => rfunc = field.render;
		PtrAtRefLayoutField(field) => rfunc = StringBuilder.put1(_, "%d", field);
		PtrAtUnboxedObjectField(specs) => rfunc = renderList<IrField>(_, specs, IrField.renderLong, ",");
		PtrAtUnboxedComponentField(specs) => rfunc = renderList<IrField>(_, specs, IrField.renderLong, ",");
		ClassAlloc(method) => if(method != null) rfunc = method.render;
		ClassGetMethod(method) => rfunc = method.render;
		ClassGetVirtual(method) => rfunc = method.render;
		ClassGetSelector(selector) => rfunc = selector.render;
		VariantGetMethod(method) => rfunc = method.render;
		VariantGetVirtual(method) => rfunc = method.render;
		VariantGetSelector(selector) => rfunc = selector.render;
		CallMethod(method) => rfunc = method.render;
		CallClassMethod(method) => rfunc = method.render;
		CallClassVirtual(method) => rfunc = method.render;
		CallClassSelector(selector) => rfunc = selector.render;
		CallVariantVirtual(method) => rfunc = method.render;
		CallVariantSelector(selector) => rfunc = selector.render;
		CreateClosure(method) => rfunc = method.render;
		RefLayoutIn(offset) => rfunc = StringBuilder.putd(_, offset);
		RefLayoutGetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		RefLayoutSetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		RefLayoutAtRepeatedField(offset, scale, max) => rfunc = StringBuilder.put2(_, "%d,%d", offset, scale);
		RefLayoutGetRepeatedField(offset, scale, max, order) => rfunc = StringBuilder.put3(_, "%d,%d,%s", offset, scale, order.name);
		RefLayoutSetRepeatedField(offset, scale, max, order) => rfunc = StringBuilder.put3(_, "%d,%d,%s", offset, scale, order.name);
		ByteArrayGetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		ByteArraySetField(offset, order) => rfunc = StringBuilder.put2(_, "%d,%s", offset, order.name);
		ConditionalThrow(exception) => rfunc = StringBuilder.puts(_, exception);
		SystemCall(syscall) => rfunc = StringBuilder.puts(_, syscall.name);
		VstSugar(op) => rfunc = StringBuilder.puts(_, op.name);
		_ => ;
	}

	if (rfunc != null) rfunc(buf.putc('[')).putc(']');
	var typeArgs = op.typeArgs;
	if (typeArgs.length > 0) {
		buf.putc('<');
		for (i < typeArgs.length) {
			if (i > 0) buf.csp();
			var t = typeArgs[i];
			if (t == null) buf.puts("null");
			else t.render(buf);
		}
		buf.putc('>');
	}
	if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).end();
	return buf;
}
