// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component V3Ref {
	def RW_TYPECON = V3Ref_TypeCon.new(null, true, TypeUtil.globalCache);
	def RO_TYPECON = V3Ref_TypeCon.new(null, false, TypeUtil.globalCache);
}

class V3Ref_TypeCon extends TypeCon {
	def layoutDecl: VstLayout;
	def writeable: bool;

	new(layoutDecl, writeable, typeCache: TypeCache)
		super(if(writeable, "Ref", "ref"), Kind.REF, if(layoutDecl == null, 1, 0), typeCache) {
		singleton = RefType.new(uid, layoutDecl, this);
	}
	def renderType(buffer: StringBuilder, list: List<Type>) -> StringBuilder {
		buffer.puts(name);
		if (layoutDecl != null) buffer.putc('<').puts(layoutDecl.fullName).putc('>');
		return buffer;
	}
}

class RefType extends Type {
	def layoutDecl: VstLayout;

	new(hash: int, layoutDecl, typeCon: TypeCon) super(hash, typeCon, null) { }
	def getSuperType() -> RefType {
		if (V3Ref_TypeCon.!(typeCon).writeable == true) {
			return RefType.!(layoutDecl.readonlyType);
		} else {
			return null;
		}
	}
}

class ByteArrayOffset(array: Record, offset: int) extends Val {
	def equals(other: Val) -> bool {
		if (other == this) return true;
		if (other == null) return array == null && offset == 0;
		if (!ByteArrayOffset.?(other)) return false;
		var that = ByteArrayOffset.!(other);
		return this.array == that.array && this.offset == that.offset;
	}
	def hash() -> int {
		var h = if(array != null, array.id);
		return h + offset * 33;
	}
	// read {count <= 8} bytes and pack into the result value
	def read(bigEndian: bool, offset: int, count: int) -> u64 {
		var v = array.values;
		var r: u64, shift = 0;
		if (bigEndian) {
			for (i < count) {
				var ival = Int.unbox(v[this.offset + offset + i]);
				r = (r << 8) | u8.view(ival);
			}
		} else {
			for (i < count) {
				var ival = Int.unbox(v[this.offset + offset + i]);
				r |= (u64.view(u8.view(ival)) << u6.view(shift));
				shift += 8;
			}
		}
		return r;
	}
	// write {count <= 8} bytes into underlying byte array
	def write(bigEndian: bool, offset: int, count: int, val: u64) {
		var v = array.values;
		if (bigEndian) {
			var shift = (count - 1) * 8;
			for (i < count) {
				v[this.offset + offset + i] = Int.box(byte.view(val >> u6.view(shift)));
				shift -= 8;
			}
		} else {
			for (i < count) {
				v[this.offset + offset + i] = Int.box(byte.view(val));
				val = val >> 8;
			}
		}
	}
}

class PackedRef(r: Val, m: Val) extends Val {
	def equals(other: Val) -> bool {
		if (other == this) return true;
		if (!PackedRef.?(other)) return false;
		var that = PackedRef.!(other);
		return this.r == that.r && this.m.equals(that.m);
	}
	def hash() -> int {
		if (r == null && m == null) return 0;
		if (r == null) return m.hash() * 33;
		if (m == null) return r.hash();
		return r.hash() + m.hash() * 33;
	}
}