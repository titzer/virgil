// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Keywords in Virgil III.
component Keywords {
	private def KWMAP_HASH = 11; // hash parameter of perfect hashmap for keywords
	private def KWMAP_SIZE = 103; // size of perfect hashmap for keywords
	def kwKeys    = Array<string>.new(KWMAP_SIZE);
	def kwClass   = Array<byte>.new(KWMAP_SIZE);

	def KC_OTHER = '\x01';
	def KC_TRUE  = '\x02';
	def KC_FALSE = '\x03';
	def KC_NULL  = '\x04';
	def KC_VAR   = '\x05';
	def KC_PACKING = '\x06';

	new() {
		var keywords = [
			("break",	KC_OTHER),
			("case",	KC_OTHER),
			("class",	KC_OTHER),
			("component",	KC_OTHER),
			("continue",	KC_OTHER),
			("def",		KC_OTHER),
			("else",	KC_OTHER),
			("enum",	KC_OTHER),
			("export",	KC_OTHER),
			("extends",	KC_OTHER),
			("false",	KC_FALSE),
			("for",		KC_OTHER),
			("fun",		KC_OTHER),
			("if",		KC_OTHER),
			("import",	KC_OTHER),
			("in",		KC_OTHER),
			("layout",	KC_OTHER),
			("match",	KC_OTHER),
			("new",		KC_OTHER),
			("null",	KC_NULL),
			("packing",	KC_PACKING),
			("private",	KC_OTHER),
			("return",	KC_OTHER),
			("struct",	KC_OTHER),
			("super",	KC_OTHER),
			("true",	KC_TRUE),
			("type",	KC_OTHER),
			("var",		KC_VAR),
			("while",	KC_OTHER)
		];
		for (t in keywords) {
			if (!addKeyword(t.0, t.1)) {
				var t = optimizePerfectHashTable(keywords);
				System.error("ParserInternalError", Strings.format2("new perfect hashtable parameters: KWMAP_HASH=%d, KWMAP_SIZE=%d", t.0, t.1));
			}
		}
	}
	private def addKeyword(kw: string, kc: byte) -> bool {
		var index = kwIndex(kw);
		if (kwKeys[index] != null) return false;
		kwKeys[index] = kw;
		kwClass[index] = kc;
		return true;
	}
	private def optimizePerfectHashTable(keywords: Array<(string, byte)>) -> (int, int) {
		var array = Array<bool>.new(153);
		for (size = 91; size < array.length; size += 2) {
			for (mul in [3, 5, 7, 11, 13, 17]) {
				for (i < array.length) array[i] = false;
				var passed = true;
				for (t in keywords) {
					var s = t.0;
					var hash = (s.length * 5 + s[0] + mul * s[1]) % size;
					if (array[hash]) { passed = false; break; }
					array[hash] = true;
				}
				if (passed) return (mul, size);
			}
			for (i < size) array[i] = false;
		}
		return (-1, -1);
	}
	def kwIndex(s: string) -> int {
		return (s.length * 5 + s[0] + KWMAP_HASH * s[1]) % KWMAP_SIZE;
	}
}

// Stateless parser logic for all of Virgil-III syntax
component Parser {
	def NONE      = '\x00';
	def COMMA     = ',';
	def END       = '\x00';

	def PRIVATE_VAR = VarDefParser.new(true, Writability.WRITEABLE);
	def PRIVATE_DEF = VarDefParser.new(true, Writability.READ_ONLY);
	def PUBLIC_VAR  = VarDefParser.new(false, Writability.WRITEABLE);
	def PUBLIC_DEF  = VarDefParser.new(false, Writability.READ_ONLY);
	def PUBLIC_DEFVAR  = VarDefParser.new(false, Writability.PRIVATE_WRITEABLE);

	def parseFile(fileName: string, input: Array<byte>, ERROR: ErrorGen, typeCache: TypeCache) -> VstFile {
		var file = VstFile.new(fileName, input);
		var p = ParserState.new(file, ERROR, skipToNextToken, typeCache);
		p.enableFunExprs = CLOptions.FUN_EXPRS.get();
		p.enableSimpleBodies = CLOptions.SIMPLE_BODIES.get();

		file.input = input;
		file.lineEnds = p.lineEnds;
		// parse class, component, var, and def declarations
		while (p.curByte != END) {
			if (!parseToplevelDecl(p, file)) break;
		}
		if (file.synthetic != null) {
			file.synthetic.members = Lists.reverse(file.synthetic.members);
		}
		return file;
	}
	def parseRedefFields(fileName: string, input: Array<byte>, skip: int, ERROR: ErrorGen) -> (VstFile, VstList<VstRedefField>) {
		var file = VstFile.new(fileName, input);
		var p = ParserState.new(file, ERROR, skipToNextToken, null);
		p.advance(skip);
		return (file, parseList(0, p, 0, COMMA, 0, parseRedefField));
	}
	def parseToplevelDecl(p: ParserState, file: VstFile) -> bool {
		match (p.curByte) {
			'c' => {
				if (optKeyword(p, "class") != null) return parseClass(p, file, false);
				if (optKeyword(p, "component") != null) return parseComponent(p, file, false);
			}
			'i' => {
				var importToken = optKeyword(p, "import");
				if (importToken != null) {
					var importName = parseOptString(p);
					if (reqKeyword(p, "component") != null) {
						var id = parseIdentVoid(p).name;
						var members = parseMembers(p, true);
						if (importName == null) importName = id;
						var decl = VstComponent.new(false, importName, id, members);
						file.components.put(decl);
						return true;
					}
				}
			}
			'v' => if (optKeyword(p, "var") != null) {
				var synthetic = file.getSyntheticComponent();
				synthetic.members = PUBLIC_VAR.parseVar(p, synthetic.members);
				return true;
			}
			'd' => if (optKeyword(p, "def") != null) {
				var synthetic = file.getSyntheticComponent();
				synthetic.members = PUBLIC_DEF.parseDef(p, synthetic.members, null);
				return true;
			}
			't' => {
				if (optKeyword(p, "type") != null) return parseVariant(p, file, false);
			}
			'e' => {
				if (optKeyword(p, "enum") != null) return parseEnum(p, file, false);
				if (optKeyword(p, "export") != null) return parseExport(p, file);
			}
			'p' => {
				if (optKeyword(p, "private") != null) {
					if (optKeyword(p, "class") != null) return parseClass(p, file, true);
					if (optKeyword(p, "component") != null) return parseComponent(p, file, true);
					if (optKeyword(p, "type") != null) return parseVariant(p, file, true);
					if (optKeyword(p, "enum") != null) return parseEnum(p, file, true);
					if (optKeyword(p, "packing") != null) return parsePacking(p, file, true);
				}
				if (optKeyword(p, "packing") != null) return parsePacking(p, file, false);
			}
			'l' => {
				if (optKeyword(p, "layout") != null) return parseLayout(p, file);
			}
		}
		p.error("expected type, variable, or method declaration");
		return false;
	}
	def parseClass(p: ParserState, file: VstFile, isPrivate: bool) -> bool {
		var id = parseIdent(p, parseTypeParam);
		var params = parseOptionalParams(p, parseClassParam);
		var parent = if(optKeyword(p, "extends") != null, parseTypeRef(p));
		var superclause: SuperClause;
		if (p.curByte == '(') {
			var args = parseTupleExpr(p);
			superclause = SuperClause.new(args.point(), args);
		}
		var repHints = parseRepHints(p);
		var members = parseMembers(p, false);
		var decl = VstClass.new(isPrivate, id.name, id.list(), params, parent, superclause, members);
		decl.repHints = repHints;
		file.classes.put(decl);
		return true;
	}
	def parseComponent(p: ParserState, file: VstFile, isPrivate: bool) -> bool {
		var id = parseIdentVoid(p).name;
		var members = parseMembers(p, false);
		var decl = VstComponent.new(isPrivate, null, id, members);
		file.components.put(decl);
		return true;
	}
	def parseVariant(p: ParserState, file: VstFile, isPrivate: bool) -> bool {
		var id = parseIdent(p, parseTypeParam);
		var params = parseOptionalParams(p, parseVariantCaseParam);
		var desugar = VariantDesugaring.new(isPrivate, id, params);
		var repHints = parseRepHints(p);
		var decl = desugar.synthesizeTopLevelClass(parseVariantCases(p, desugar));
		decl.repHints = repHints;
		file.classes.put(decl);
		// lift case classes to top-level of file
		for (cdecl in decl.cases) {
			if (cdecl.decl != decl) file.classes.put(cdecl.decl);
		}
		return true;
	}
	def parsePackingParam(p: ParserState) -> PackingParamDecl {
		var param = parseIdentVoid(p).name;
		p.req1(':');

		var sizeLiteral = parseIntLiteral(p);
		return PackingParamDecl.new(param, sizeLiteral);
	}
	def parsePackingExprs(p: ParserState) -> VstList<VstPackingExpr> {
		if (p.curByte == '(') {
			return Parser.parseList<VstPackingExpr>(0, p, '(', Parser.COMMA, ')', parsePackingExpr(_, false, true));
		} else {
			var start = p.point();
			var expr = parsePackingExpr(p, false, true);
			return VstList<VstPackingExpr>.new(p.end(start), List<VstPackingExpr>.new(expr, null));
		}
	}
	def parsePackingExpr(p: ParserState, inDecl: bool, allowSolve: bool) -> VstPackingExpr {
		var s = p.curPos, q = p.curPos;
		var isPattern = false; // is a bit pattern, not an ordinary binary literal
		
		var result: VstPackingExpr;
		if (p.peek(0) == '0' && (p.peek(1) == 'b' || p.peek(1) == 'B')) {
			// could be a bit pattern, try parsing it
			q += 2;
			var bits = Vector<(int, PackingBit)>.new();
			while (q < p.input.length) {
				var c = p.input[q];
				var offset = q - s;
				if (c == '0') bits.put(offset, PackingBit.Fixed(0));
				else if (c == '1') bits.put(offset, PackingBit.Fixed(1));
				else if (c == '?') { isPattern = true; bits.put(offset, PackingBit.Unassigned); }
				else if (Char.isIdentStart(c)) { isPattern = true; bits.put(offset, PackingBit.Assigned(c)); }
				else if (c != '_') break;
				q++;
			}

			if (isPattern) {
				var token = p.token(q - s);
				return VstPackingExpr.Bits(token, bits.reverse().extract());
			}
		} else if (p.curByte == '#') {
			p.eat1();
			if (optKeyword(p, "solve") != null) {
				if (inDecl) p.error("solve expressions are not supported in packing declarations");
				else if (!allowSolve) p.error("nested solve expressions are not supported");
				return VstPackingExpr.Solve(parseList(0, p, '(', COMMA, ')', parsePackingExpr(_, inDecl, false)));
			} else if (optKeyword(p, "concat") != null) {
				return VstPackingExpr.Concat(parseList(0, p, '(', COMMA, ')', parsePackingExpr(_, inDecl, false)));
			}
			p.error("invalid function in packing expression");
		} else if (Char.isIdentStart(p.curByte)) {
			// Application or Field or Concat
			var id = parseIdent(p, parseTypeRef);
			var varExpr = VarExpr.new(null, null, id);
			if (p.curByte == '(') return VstPackingExpr.App(varExpr, parseList(0, p, '(', COMMA, ')', parsePackingExpr(_, inDecl, true)));
			else return VstPackingExpr.Field(varExpr);
		}
			
		return VstPackingExpr.Literal(parseNumber(p));
	}
	def parsePacking(p: ParserState, file: VstFile, isPrivate: bool) -> bool {
		var id = parseIdentVoid(p).name;
		var params = parseList(0, p, '(', COMMA, ')', parsePackingParam);
		p.req1(':');
		var size = parseIntLiteral(p);
		p.req1('=');
		var expr = parsePackingExpr(p, true, false);
		p.req1(';');
		var decl = VstPacking.new(id, params, expr, size);
		file.packings.put(decl);
		return true;
	}
	def parseRepHints(p: ParserState) -> List<VstRepHint> {
		var list: List<VstRepHint>;
		while (p.curByte == '#') {
			p.eat1();
			if (!Char.isIdentStart(p.curByte)) p.error("identifier expected");
			var d = p.input, q = p.curPos + 1;
			while (q < d.length) {
				var c = d[q];
				if (!Char.isIdentMiddle(c) && c != '-' && c != ':') break; // XXX: ugly difference with parseIdent
				q++;
			}
			var id = extractIdent<void>(p, q);
			var name = id.name.image;
			var result: VstRepHint;
			match (id.kwClass) {
				Keywords.KC_PACKING => {
					var e = parsePackingExprs(p);
					result = VstRepHint.Packing(e);
				}
				0 => {
					if (Strings.equal(name, "boxed")) result = VstRepHint.Boxed;
					else if (Strings.equal(name, "unboxed")) result = VstRepHint.Unboxed;
					else if (Strings.equal(name, "packed")) result = VstRepHint.Packed;
					else if (Strings.equal(name, "big-endian")) result = VstRepHint.BigEndian;
					else result = VstRepHint.Other(name);
				}
				_ => kwError(p, id.name);
			}
			list = List.new(result, list);
		}
		return Lists.reverse(list);
	}
	def parseVariantCases(p: ParserState, desugar: VariantDesugaring) -> List<VstMember> {
		var list = desugar.synthesizeMembers(p.fileName, p.curLine, p.curCol);
		if (p.opt1(';') > 0) return Lists.reverse(list); // empty body

		p.req1('{');
		while (true) {
			if (p.curByte == '}') { p.advance1(); break; }
			var nlist = parseVariantCase(p, desugar, list);
			if (nlist == list) { p.opt1('}'); break; }
			list = nlist;
		}
		return Lists.reverse(list);
	}
	def parseVariantCase(p: ParserState, desugar: VariantDesugaring, prev: List<VstMember>) -> List<VstMember> {
		var kw: FilePoint;
		match (p.curByte) {
			'd' => if (optKeyword(p, "def") != null) {
				return PUBLIC_DEF.parseDef(p, prev, null);
			}
			'c' => if ((kw = optKeyword(p, "case")) != null) {
				if (desugar.params != null) p.errorAt(kw.rangeOf(4), "data type declared with parameters cannot have cases");
				var id = parseIdentVoid(p);
				var params = parseOptionalParams(p, parseVariantCaseParam);
				var members: List<VstMember>;
				var repHints = parseRepHints(p);
				if (p.curByte == ';') p.advance1();
				else members = parseMembers(p, false);
				var decl = desugar.synthesizeVariantCaseMember(id, params, members);
				decl.repHints = repHints;
				decl.decl.repHints = repHints;
				return List.new(decl, prev);
			}
		}
		p.error("invalid start of type case declaration");
		return null;
	}
	def parseExport(p: ParserState, file: VstFile) -> bool {
		if (optKeyword(p, "def") != null) {
			// export def name...
			var synthetic = file.getSyntheticComponent();
			var before = synthetic.members;
			var list = synthetic.members = PUBLIC_DEF.parseDef(p, synthetic.members, null);
			var rev: List<Decl>;
			for (l = list; l != before; l = l.tail) {
				rev = List.new(l.head, rev); // local reversal of newly added members
			}
			// Add exports in the right order.
			for (l = rev; l != null; l = l.tail) {
				var expr = VarExpr.new(null, null, VstIdent<TypeRef>.new(l.head.token, 0, null));
				file.exports.put(ExportDecl.new(l.head.token, l.head.token.image, synthetic, expr));
			}
			return true;
		}
		var id: VstIdent<TypeRef>;
		var token = parseOptString(p);
		if (token == null) {
			id = parseIdent(p, parseTypeRef);
			token = id.name;
		}
		var expr: VarExpr;
		var name = if(token != null, token.image);
		if (id == null || p.curByte == '=') {
			// export name = name(.name)*;
			p.req1('=');
			var id2 = parseIdent(p, parseTypeRef);
			expr = parseDottedVarExpr(p, id2);
		} else {
			// export name;
			expr = VarExpr.new(null, null, id);
		}
		p.req1(';');
		var synthetic = file.getSyntheticComponent();
		file.exports.put(ExportDecl.new(token, name, synthetic, expr));
		return true;
	}
	def parseEnum(p: ParserState, file: VstFile, isPrivate: bool) -> bool {
		var id = parseIdentVoid(p);
		var params = parseOptionalParams(p, parseEnumParam);
		// Synthesize "tag" and "name" members
		var tagToken = Token.new(p.fileName, "tag", p.curLine, p.curCol);
		var nameToken = Token.new(p.fileName, "name", p.curLine, p.curCol);
		var list: List<VstMember>;
		list = List.new(VstVariantTagMember.new(tagToken), list);
		list = List.new(VstVariantNameMember.new(nameToken), list);
		// Parse case members
		var cases = Vector<VstEnumCase>.new();
		p.req1('{');
		while (true) {
			if (p.curByte == '}') { p.advance1(); break; }
			var c = parseEnumCase(p, cases.length);
			if (c == null) { p.opt1('}'); break; }
			cases.put(c);
			list = List.new(c, list);
		}
		var decl = VstEnum.new(isPrivate, id.name, params, cases.extract(), list);
		file.enums.put(decl);
		return true;
	}
	def parseEnumCase(p: ParserState, tag: int) -> VstEnumCase {
		var id = parseIdentVoid(p);
		var args = if(p.curByte == '(', parseList(0, p, '(', COMMA, ')', parseExpr));
		p.opt1(',');
		if (id.name.image.length > 0) return VstEnumCase.new(tag, id.name, args);
		return null;
	}
	def parseLayout(p: ParserState, file: VstFile) -> bool {
		var id = parseIdentVoid(p).name;
		var repHints = parseRepHints(p);
		p.req1('{');
		var list: List<VstMember>;
		while (p.curByte == '+') {
			var nlist = parseLayoutField(p, list);
			if (nlist == list) { p.opt1('}'); break; }
			list = nlist;
		}
		p.req1('=');
		var size = parseIntLiteral(p);
		p.req1(';');
		p.req1('}');
		var decl = VstLayout.new(size, id, null, Lists.reverse(list), repHints);
		file.layouts.put(decl);
		return true;
	}
	def parseLayoutField(p: ParserState, prev: List<VstMember>) -> List<VstMember> {
		p.req1('+');
		var offset = parseIntLiteral(p);
		var id = Parser.parseIdentVoid(p).name;
		p.req1(':');
		var type_ref = parseMemoryTypeRef(p);
		var repHints = parseRepHints(p);
		p.req1(';');
		return List.new(VstLayoutField.new(offset, type_ref, id, repHints), prev);
	}
	def parseMembers(p: ParserState, allowImportName: bool) -> List<VstMember> {
		p.req1('{');
		var list: List<VstMember>;
		while (true) {
			if (p.curByte == '}') { p.advance1(); break; }
			var nlist = parseMember(p, list, allowImportName);
			if (nlist == list) { p.opt1('}'); break; }
			list = nlist;
		}
		return Lists.reverse(list);
	}
	def parseMember(p: ParserState, prev: List<VstMember>, allowImportName: bool) -> List<VstMember> {
		var isPrivate = optKeyword(p, "private") != null;
		var importName = if(allowImportName, parseOptString(p));
		match (p.curByte) {
			'd' => if (optKeyword(p, "def") != null) {
				var parser = if(isPrivate, PRIVATE_DEF, PUBLIC_DEF);
				if (optKeyword(p, "var") != null) {
					if (isPrivate) p.error("invalid access modifier combination");
					parser = PUBLIC_DEFVAR;
				}
				var d = parser.parseDef(p, prev, importName);
				return d;
			}
			'n' => {
				var start = optKeyword(p, "new");
				if (start != null) return List.new(parseNew(p, isPrivate, start), prev);
			}
			'v' => if (optKeyword(p, "var") != null) {
				var parser = if(isPrivate, PRIVATE_VAR, PUBLIC_VAR);
				return parser.parseVar(p, prev);
			}
		}
		p.error("invalid start of member declaration");
		return null;
	}
	def parseNew(p: ParserState, isPrivate: bool, start: FilePoint) -> VstNew {
		var params = parseMethodParams(p);
		var superclause: SuperClause;
		if (p.curByte == ':') {
			p.advance1();
			superclause = SuperClause.new(reqKeyword(p, "super"), parseTupleExpr(p));
		} else if (p.curByte == 's') {
			superclause = SuperClause.new(reqKeyword(p, "super"), parseTupleExpr(p));
		}
		var body = parseBlockStmt(p);
		var token = Token.new(p.fileName, "new", start.beginLine, start.beginColumn);
		return VstNew.new(isPrivate, token, params, superclause, body);
	}
	def parseReturnTypeAndBody(p: ParserState, isDef: bool) -> (ReturnType, Stmt) {
		var rettype: ReturnType, body: Stmt, start: int;
		if (p.optN("->") >= 0) {
			var loc = (p.curLine, p.curCol);
			var str = "this", pt = Parser.optKeyword(p, str);
			if (pt != null) rettype = ReturnType.This(Token.new(p.fileName, str, loc.0, loc.1));
			else rettype = ReturnType.Explicit(Parser.parseTypeRef(p));
			body = if(p.curByte == ';', EmptyStmt.new(p.token(1)), Parser.parseBlockStmt(p));
		} else if (Debug.UNSTABLE && p.enableSimpleBodies && (start = p.optN("=>")) >= 0) {
			var expr = parseExpr(p);
			rettype = ReturnType.Implicit(expr);
			if (isDef) p.req1(';');
			body = ReturnStmt.new(p.tokenAt(start, start + 2).range(), expr); // XXX: rangeAt() ?
		} else {
			rettype = ReturnType.Void;
			body = if(p.curByte == ';', EmptyStmt.new(p.token(1)), Parser.parseBlockStmt(p));
		}
		return (rettype, body);
	}
	def parseOptionalParams(p: ParserState, func: ParserState -> ParamDecl) -> VstList<ParamDecl> {
		return if(p.curByte == '(', Parser.parseList(0, p, '(', Parser.COMMA, ')', func));
	}
	def parseParamCommon(p: ParserState, varAllowed: bool, defReadOnly: bool, typeRequired: bool) -> ParamDecl {
		var isReadOnly = defReadOnly;
		var id = parseIdentCommon<void>(p, null);
		if (id.kwClass == Keywords.KC_VAR) {
			if (!varAllowed) p.error("immutable declaration required here");
			id = parseIdentVoid(p);
			isReadOnly = false;
		} else if (id.kwClass != 0) {
			kwError(p, id.name);
		}
		var tref: TypeRef;
		if (typeRequired) {
			p.req1(':');
			tref = parseTypeRef(p);
		} else if(p.curByte == ':') {
			p.advance1();
			tref = parseTypeRef(p);
		}
		var pd = ParamDecl.new(id.name, tref);
		pd.isReadOnly = isReadOnly;
		return pd;
	}

	def parseTypedMethodParam = parseParamCommon(_, true, false, true);
	def parseTypedMethodParams = Parser.parseList(0, _, '(', Parser.COMMA, ')', Parser.parseTypedMethodParam);
	def parseMethodParam = parseParamCommon(_, true, false, false);
	def parseMethodParams = Parser.parseList(0, _, '(', Parser.COMMA, ')', Parser.parseMethodParam);
	def parseClassParam = parseParamCommon(_, true, true, true);
	def parseEnumParam = parseParamCommon(_, false, true, true);
	def parseVariantCaseParam = parseEnumParam;
	def parseTypeRef(p: ParserState) -> TypeRef {
		var tref: TypeRef;
		if (p.curByte == '(') {
			var list = parseList(0, p, '(', COMMA, ')', parseTypeRef);
			tref = TupleTypeRef.new(list);
		} else {
			var id = parseIdent(p, parseTypeRef);
			var ntref = NamedTypeRef.new(null, id.name, id.params);
			tref = ntref;
			while (p.opt1('.') > 0) {
				var id = parseIdent(p, parseTypeRef);
				tref = ntref = NamedTypeRef.new(ntref, id.name, id.params);
			}
		}
		var arrow = p.optN("->");
		while (arrow >= 0) { // type suffixes ( '->' Type )*
			var rtype = parseTypeRef(p);
			tref = FuncTypeRef.new(tref, rtype);
			arrow = p.optN("->");
		}
		return tref;
	}
	def parseMemoryTypeRef(p: ParserState) -> MemoryTypeRef {
		var tname = parseIdentVoid(p);
		var repeat: Literal;
		if (p.curByte == '[') {
			p.req1('[');
			repeat = parseIntLiteral(p);
			p.req1(']');
		}
		return MemoryTypeRef.new(tname, repeat);
	}
	def parseTypeParam(p: ParserState) -> TypeParamType {
		var id = parseIdentVoid(p).name;
		return TypeUtil.newTypeParam(id, p.typeCache);
	}
	def parseStmt(p: ParserState) -> Stmt {
		match (p.curByte) {
			'{' => return parseBlockStmt(p);
			';' => return parseEmptyStmt(p);
			'i' => return parseIfStmt(p);
			'w' => return parseWhileStmt(p);
			'm' => return parseMatchStmt(p);
			'v' => {
				var start = optKeyword(p, "var");
				if (start != null) return parseVarStmt(p, start);
			}
			'd' => {
				var start = optKeyword(p, "def");
				if (start != null) return parseDefStmt(p, start);
			}
			'b' => return parseBreakStmt(p);
			'c' => return parseContinueStmt(p);
			'r' => return parseReturnStmt(p);
			'f' => return parseForStmt(p);
		}
		return parseExprStmt(p);
	}
	def parseBlockStmt(p: ParserState) -> BlockStmt {
		return BlockStmt.new(parseList(0, p, '{', NONE, '}', parseStmt));
	}
	def parseEmptyStmt(p: ParserState) -> Stmt {
		var src = p.point(), x = p.advance1();
		return EmptyStmt.new(src);
	}
	def parseControlExpr(p: ParserState) -> Expr {
		return (p.req1('('), parseExpr(p), p.req1(')')).1;
	}
	def parseIfStmt(p: ParserState) -> Stmt {
		var start = optKeyword(p, "if");
		if (start != null) {
			var cond = parseControlExpr(p);
			var tblock = parseStmt(p);
			var fblock = if(optKeyword(p, "else") != null, parseStmt(p));
			return IfStmt.new(start, cond, tblock, fblock);
		}
		return parseExprStmt(p);
	}
	def parseWhileStmt(p: ParserState) -> Stmt {
		var start = optKeyword(p, "while");
		if (start != null) {
			var cond = parseControlExpr(p);
			var tblock = parseStmt(p);
			return WhileStmt.new(start, cond, tblock);
		}
		return parseExprStmt(p);
	}
	def parseForStmt(p: ParserState) -> Stmt {
		var start = optKeyword(p, "for");
		if (start != null) {
			p.req1('(');
			var decl = PRIVATE_VAR.parseLocal(p);
			if (p.curByte == '<') {
				var token = p.token(1);
				var limit = parseExpr(p);
				p.req1(')');
				var tblock = parseStmt(p);
				decl.isReadOnly = true;
				return ForLessStmt.new(start, decl, token, limit, tblock);
			} else if (optKeyword(p, "in") != null) {
				// for (vardecl in expr) { ... }
				var expr = parseExpr(p);
				p.req1(')');
				var tblock = parseStmt(p);
				decl.isReadOnly = true;
				return ForeachStmt.new(start, decl, expr, tblock);
			} else {
				// for (vardecl; cond; update) { ... }
				p.req1(';');
				var cond = parseExpr(p);
				p.req1(';');
				var update: Expr, line = p.curLine, col = p.curCol;
				if (p.opt1(')') > 0) { // allow for missing update clause
					var range = FileRange.new(p.fileName, line, col, line, col);
					update = TupleExpr.new(VstList.new(range, null));
				} else {
					update = parseExpr(p);
					p.req1(')');
				}
				var tblock = parseStmt(p);
				return ForStmt.new(start, decl, cond, update, tblock);
			}
		}
		return parseExprStmt(p);
	}
	def parseMatchStmt(p: ParserState) -> Stmt {
		var start = optKeyword(p, "match");
		if (start != null) {
			var key = parseControlExpr(p);
			var list = parseList(0, p, '{', NONE, '}', parseMatchCase);
			var stmt = MatchStmt.new(start, key, list);
			var default = optKeyword(p, "else");
			if (default != null) stmt.defcase = MatchCase.new(default, null, parseStmt(p));
			return stmt;
		}
		return parseExprStmt(p);
	}
	def parseMatchCase(p: ParserState) -> MatchCase {
		if (p.curByte == '_') {
			if (Char.isIdentMiddle(p.peek(1))) {
				p.error("default match case expected");
				return null;
			}
			var default = p.token(1);
			p.reqN("=>");
			var stmt = parseStmt(p);
			return MatchCase.new(default, null, stmt);
		}
		var start = p.point();
		var list: List<MatchPattern>;
		var range: FileRange;
		while (true) {
			var lastPos = p.curPos;
			var item = parseMatchPattern(p);
			if (p.curPos == lastPos) {
				// didn't parse anything (error)
				range = p.end(start);
				break;
			}
			list = List.new(item, list);
			match (p.curByte) {
				'=' => {  // new-style "=>" end of pattern
					var endLine = p.curLine;
					var endColumn = p.curCol + 2;
					p.reqN("=>");
					range = FileRange.new(p.fileName, start.beginLine, start.beginColumn, endLine, endColumn);
					break;
				}
				',' => {  // comma-separated patterns
					p.advance1();
				}
				_ => {  // stray character
					p.error("\',\' or \'=>\' expected");
					range = p.end(start);
					break;
				}
			}
		}
		var stmt = parseStmt(p);
		return MatchCase.new(null, VstList.new(range, Lists.reverse(list)), stmt);
	}
	def parseMatchPattern(p: ParserState) -> MatchPattern {
		var expr: Expr;
		var ch = p.curByte;
		if (Char.isIdentStart(ch)) {
			return parseIdMatchPattern(p);
		} else if (ch == '\'') {
			expr = parseByteLiteral(p);
		} else if (ch == '-') {
			expr = parseNumber(p);
		} else if (Char.isDecimal(ch)) {
			expr = parseNumber(p);
		} else {
			p.error("match pattern expected");
		}
		return MatchPattern.new(expr, null);
	}
	def parseDottedVarExpr(p: ParserState, id: VstIdent<TypeRef>) -> VarExpr {
		var expr = VarExpr.new(null, null, id);
		while (p.curByte == '.') {
			var pos = p.point();
			p.advance1();
			if (Char.isIdentStart(p.curByte)) {
				expr = VarExpr.new(expr, pos, parseIdent(p, parseTypeRef));
			} else {
				p.error("identifier expected");
			}
		}
		return expr;
	}
	def parseIdMatchPattern(p: ParserState) -> MatchPattern {
		var id = parseIdentCommon(p, parseTypeRef);
		var lit: Literal;
		match (id.kwClass) {
			Keywords.KC_TRUE =>  return MatchPattern.new(newLiteralFromIdent(p, id, Bool.TRUE, Bool.TYPE), null);
			Keywords.KC_FALSE => return MatchPattern.new(newLiteralFromIdent(p, id, Bool.FALSE, Bool.TYPE), null);
			Keywords.KC_NULL =>  return MatchPattern.new(newLiteralFromIdent(p, id, Values.BOTTOM, Null.TYPE), null);
			Keywords.KC_OTHER => kwError(p, id.name);
		}
		if (p.curByte == ':') {
			p.advance1();
			var pat = MatchPattern.new(VarExpr.new(null, null, id), null);
			pat.vdecl = VarDecl.new(id.name, parseTypeRef(p), null);
			pat.vdecl.isReadOnly = true;
			return pat;
		}
		var expr = parseDottedVarExpr(p, id);
		var params = if(p.curByte == '(', Parser.parseList(0, p, '(', Parser.COMMA, ')', parseMatchParam));
		return MatchPattern.new(expr, params);
	}
	def parseMatchParam(p: ParserState) -> VarDecl {
		var token: Token;
		if (p.curByte == '_') token = p.token(1);
		else token = parseIdentVoid(p).name;
		var v = VarDecl.new(token, null, null);
		v.isReadOnly = true;
		return v;
	}
	def parseVarStmt(p: ParserState, start: FilePoint) -> Stmt {
		var id = parseIdentVoid(p);
		var vars = Lists.reverse(PUBLIC_VAR.parseVars(p, id));
		return LocalStmt.new(start, vars);
	}
	def parseDefStmt(p: ParserState, start: FilePoint) -> Stmt {
		var id = Parser.parseIdentVoid(p);
		if (p.curByte == '(') { // nested function
			var params = parseTypedMethodParams(p);
			var t = parseReturnTypeAndBody(p, true);
			var init = FunExpr.new(start, id.name, params, t.0, t.1);
			var v = VarDecl.new(id.name, null, init);
			return LocalStmt.new(start, List.new(v, null));
		}
		var vars = Lists.reverse(PUBLIC_DEF.parseVars(p, id));
		return LocalStmt.new(start, vars);
	}
	def parseBreakStmt(p: ParserState) -> Stmt {
		var start = optKeyword(p, "break");
		if (start != null) return BreakStmt.new(term1(p, start, ';'));
		return parseExprStmt(p);
	}
	def parseContinueStmt(p: ParserState) -> Stmt {
		var start = optKeyword(p, "continue");
		if (start != null) return ContinueStmt.new(term1(p, start, ';'));
		return parseExprStmt(p);
	}
	def parseReturnStmt(p: ParserState) -> Stmt {
		var start = optKeyword(p, "return");
		if (start != null) {
			if (p.curByte == ';') return ReturnStmt.new(term1(p, start, ';'), null);
			var expr = parseExpr(p);
			return ReturnStmt.new(term1(p, start, ';'), expr);
		}
		return parseExprStmt(p);
	}
	def parseExprStmt(p: ParserState) -> Stmt {
		var expr = parseExpr(p);
		if (expr == null) return null;
		return ExprStmt.new(term1(p, expr.range(), ';'), expr);
	}
	def parseExpr(p: ParserState) -> Expr {
		var subExpr = parseSubExpr(p);
		if (p.curByte == '=' && p.peek(1) != '=') {
			var pos = p.token(1);
			var rhs = parseExpr(p);
			return AssignExpr.new(subExpr, null, pos, rhs);
		}
		return addBinOpSuffixes(p, subExpr);
	}
	def parseSubExpr(p: ParserState) -> Expr {
		return addTermSuffixes(p, parseTerm(p));
	}
	def parseTerm(p: ParserState) -> Expr {
		var ch = p.curByte;
		if (ch == 'i') {
			var start = optKeyword(p, "if");
			if (start != null) {
				var args = parseList(1, p, '(', COMMA, ')', parseExpr);
				return IfExpr.new(start, args);
			}
			return parseVarExpr(p);
		}
		if (Debug.UNSTABLE && p.enableFunExprs && ch == 'f') {
			var start = optKeyword(p, "fun");
			if (start != null) {
				var id = if(Char.isIdentStart(p.curByte), parseIdentVoid(p).name);
				var params = parseMethodParams(p); // TODO: make parameters optional
				var t = parseReturnTypeAndBody(p, false);
				return FunExpr.new(start, id, params, t.0, t.1);
			}
			return parseVarExpr(p);
		}

		if (Char.isIdentStart(ch)) return parseVarExpr(p);
		if (Char.isDecimal(ch)) return parseNumber(p);

		match (ch) {
			'\'' => return parseByteLiteral(p);
			'\"' => return parseStringLiteral(p);
			'(' =>  return parseTupleExpr(p);
			'[' =>  return parseArrayLiteral(p);
			'!' =>  return parseNestedExpr(p, NotExpr.new);
			'~' =>  return parseNestedExpr(p, BitwiseNegExpr.new);
			'_' =>  return parseParamExpr(p);
			'-' =>  {
				var next = p.peek(1);
				match (next) {
					'-' => return AutoExpr.new(p.token(2), parseSubExpr(p), V3Infix.Sub, false);
					'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => return parseNumber(p);
					_ => return parseNestedExpr(p, NegExpr.new);
				}
			}
			'+' =>  {
				if (p.peek(1) == '+') return AutoExpr.new(p.token(2), parseSubExpr(p), V3Infix.Add, false);
			}
		}
		p.error("invalid start of expression");
		return null;
	}
	def parseParamExpr(p: ParserState) -> Expr {
		// only "_" is allowed, not "__" or "_id"
		if (Char.isIdentMiddle(p.peek(1))) {
			p.error("identifier expected");
			return null;
		}
		return ParamExpr.new(p.token(1));
	}
	def parseNestedExpr(p: ParserState, f: (FilePoint, Expr) -> Expr) -> Expr {
		var point = p.point();
		var start = p.advance1();
		return f(point, parseSubExpr(p));
	}
	def parseByteLiteral(p: ParserState) -> Literal {
		var result = Chars.parseLiteral(p.input, p.curPos);
		if (result.0 > 0) {
			var token = p.token(result.0);
			return Literal.new(token, Byte.box(result.1), Byte.TYPE);
		}
		p.error("invalid character literal");
		return null;
	}
	def parseStringLiteral(p: ParserState) -> StringExpr {
		var result = Strings.parseLiteral(p.input, p.curPos);
		if (result.0 > 0) {
			var token = p.token(result.0);
			return StringExpr.new(token, result.1);
		}
		p.error("invalid string literal");
		return null;
	}
	def parseOptString(p: ParserState) -> Token {
		if (p.curByte != '\"') return null;
		var result = Strings.parseLiteral(p.input, p.curPos);
		if (result.0 > 0) return p.token(result.0);
		return null;
	}
	def parseTupleExpr(p: ParserState) -> TupleExpr {
		return TupleExpr.new(parseList(0, p, '(', COMMA, ')', parseExpr));
	}
	def parseArrayLiteral(p: ParserState) -> ArrayExpr {
		return ArrayExpr.new(parseList(0, p, '[', COMMA, ']', parseExpr));
	}
	def parseRedefField(p: ParserState) -> VstRedefField {
		var receiver: VstIdent<void>;
		var ident = parseIdentVoid(p);
		if (p.curByte == '.') {
			receiver = ident;
			var pos = p.point();
			p.advance1();
			ident = parseIdentVoid(p);
		}
		p.req1('=');
		var lit: Literal;
		if (p.curByte == '-' || Chars.isDecimal(p.curByte)) lit = parseNumber(p);
		else if (p.curByte == '\'') lit = parseByteLiteral(p);
		else {
			var id = parseIdentCommon<void>(p, null);
			match (id.kwClass) {
				Keywords.KC_TRUE =>  lit = Literal.new(id.name, Bool.TRUE, Bool.TYPE);
				Keywords.KC_FALSE => lit = Literal.new(id.name, Bool.FALSE, Bool.TYPE);
				Keywords.KC_NULL =>  lit = Literal.new(id.name, Values.BOTTOM, Null.TYPE);
				Keywords.KC_OTHER => kwError(p, id.name);
			}
		}
		return VstRedefField.new(receiver, ident, lit);
	}
	def parseNumber(p: ParserState) -> Literal {
		var np = NumberParser.new(p.input[p.curPos ... ]);
		np.accept_width = true;
		if (np.parse()) {
			var len = np.pos;
			if (np.is_binary) {
				return BinLiteral.new(p.token(len), np.val, np.vtype, np.l_suffix, np.u_suffix, np.digits);
			} else if (np.is_hex) {
				return HexLiteral.new(p.token(len), np.val, np.vtype, np.l_suffix, np.u_suffix, np.digits);
			} else if (np.is_float) {
				return FloatLiteral.new(p.token(len), np.val, np.vtype);
			} else {
				return DecLiteral.new(p.token(len), np.val, np.vtype, np.l_suffix, np.u_suffix, np.is_negative);
			}
		} else {
			p.errorAtOffset(np.error_pos, np.error_msg);
			p.advance(np.pos);
			return null;
		}
	}
	def parseIntLiteral(p: ParserState) -> IntLiteral {
		var lit = parseNumber(p);
		match (lit) {
			x: IntLiteral => return x;
			_ => if (lit != null) p.errorAt(lit.token.range(), "expected integer literal");
		}
		return null;
	}
	def newLiteralFromIdent(p: ParserState, id: VstIdent<TypeRef>, val: Val, t: Type) -> Literal {
		if (id.params != null) p.error1("value \'%s\' cannot be parameterized", id.name.image);
		return Literal.new(id.name, val, t);
	}
	def parseVarExpr(p: ParserState) -> Expr {
		var id = parseIdentCommon(p, parseTypeRef);
		match (id.kwClass) {
			0 => ; // not a keyword
			Keywords.KC_TRUE =>  return newLiteralFromIdent(p, id, Bool.TRUE, Bool.TYPE);
			Keywords.KC_FALSE => return newLiteralFromIdent(p, id, Bool.FALSE, Bool.TYPE);
			Keywords.KC_NULL =>  return newLiteralFromIdent(p, id, Values.BOTTOM, Null.TYPE);
			_ => kwError(p, id.name);
		}
		return VarExpr.new(null, null, id);
	}
	def addTermSuffixes(p: ParserState, expr: Expr) -> Expr {
		while (true) {
			match (p.curByte) {
				'.' => { // expr.
					if (p.peek(1) == '.') break; // possibly ...
					var pos = p.point();
					p.advance1();
					expr = addMemberSuffix(p, pos, expr);
				}
				'(' => { // expr(
					expr = AppExpr.new(expr, parseTupleExpr(p));
				}
				'[' => { // expr[
					expr = parseIndexSuffix(p, expr);
				}
				'+' => if (p.peek(1) == '+') { // expr++
					return AutoExpr.new(p.token(2), expr, V3Infix.Add, true);
				} else break;
				'-' => if (p.peek(1) == '-') { // expr--
					return AutoExpr.new(p.token(2), expr, V3Infix.Sub, true);
				} else break;
			} else {
				break;
			}
		}
		return expr;
	}
	def parseIndexSuffix(p: ParserState, expr: Expr) -> Expr {
		var start = p.point();
		p.req1('[');
		if (p.opt1(']') > 0) return IndexExpr.new(expr, VstList.new(p.end(start), null));

		var first = parseExpr(p);
		if (optKeyword(p, "...") != null) { // start ... end?
			var end = if (p.curByte != ']', parseExpr(p));
			p.req1(']');
			return RangeExpr.new(expr, first, false, end);
		} else if (optKeyword(p, "..+") != null) { // start ..+ length
			var length = parseExpr(p);
			p.req1(']');
			return RangeExpr.new(expr, first, true, length);
		}
		var list = List.new(first, null);
		while (p.opt1(',') > 0) {
			var lastPos = p.curPos;
			var item = parseExpr(p);
			if (p.curPos == lastPos) break; // didn't parse anything
			list = List.new(item, list);
		}
		p.req1(']');
		var exprs = VstList.new(p.end(start), Lists.reverse(list));
		return IndexExpr.new(expr, exprs);
	}
	def addMemberSuffix(p: ParserState, pos: FilePoint, expr: Expr) -> Expr {
		var ch = p.curByte;
		if (Char.isIdentStart(ch)) {
			// expr.ident
			return VarExpr.new(expr, pos, parseIdentUnchecked(p, parseTypeRef));
		}
		if (ch == '!' || ch == '?') {
			// expr.! or expr.?
			if (p.peek(1) != '=') {
				var hasParams = p.peek(1) == '<', t = p.token(1);
				var typeParams = if(hasParams, parseList(0, p, '<', COMMA, '>', parseTypeRef));
				return VarExpr.new(expr, pos, VstIdent.new(t, 0, typeParams));
			}
		}
		var op = parseInfix(p);
		if (op != null) {
			// expr.infix
			return VarExpr.new(expr, pos, VstIdent<TypeRef>.new(op.token, 0, null));
		}
		if (Char.isDecimal(ch)) {
			// expr.decimal
			var end = p.plus(0, Char.isDecimal);
			var token = p.token(end - p.curPos);
			return VarExpr.new(expr, pos, VstIdent<TypeRef>.new(token, 0, null));
		}
		if (ch == '~') {
			// expr.~
			return VarExpr.new(expr, pos, VstIdent<TypeRef>.new(p.token(1), 0, null));
		}
		if (ch == '[') {
			var start: int;
			if ((start = p.optN("[]=")) >= 0) { // expr.[]=
				return VarExpr.new(expr, pos, VstIdent<TypeRef>.new(p.tokenAt(start, start + 3), 0, null));
			}
			if ((start = p.optN("[]")) >= 0) { // expr.[]
				return VarExpr.new(expr, pos, VstIdent<TypeRef>.new(p.tokenAt(start, start + 2), 0, null));
			}
		}
		p.error("member expected");
		return expr;
	}
	def addBinOpSuffixes(p: ParserState, expr: Expr) -> Expr {
		var op = parseInfix(p);
		if (op == null) return expr;
		var exprStack = ListStack<Expr>.new();  // XXX: reuse temporary expr / infix stack
		var operStack = ListStack<InfixOp>.new();
		exprStack.push(expr);
		while (op != null) {
			if (operStack.top != null && operStack.peek().prec >= op.prec) { // LR reduction
				reduce(p, exprStack, operStack, op.prec);
			}
			operStack.push(op);
			exprStack.push(parseSubExpr(p));
			op = parseInfix(p);
		}
		reduce(p, exprStack, operStack, -1);
		return exprStack.pop();
	}
	def reduce(p: ParserState, exprStack: ListStack<Expr>, operStack: ListStack<InfixOp>, prec: int) {
		while (!operStack.empty() && operStack.peek().prec >= prec) {
			var right = exprStack.pop(), left = exprStack.pop();
			var binop = operStack.pop();
			var expr = if (binop.assign, AssignExpr.new(left, binop, binop.token, right), BinOpExpr.new(left, binop, right));
			exprStack.push(expr);
		}
	}
	def parseList<T>(min: int, p: ParserState, begDelim: byte, sepByte: byte, endDelim: byte, f: ParserState -> T) -> VstList<T> {
		var start = p.point();
		if (p.curByte != begDelim) {
			if (begDelim != NONE) {
				p.error1("\'%c\' expected", begDelim);
				return VstList<T>.new(p.point().rangeOf(0), null);
			}
		} else {
			p.advance1();
		}
		if (min == 0 && p.curByte == endDelim) {
			// zero length list
			return VstList<T>.new(eatEnd(p, start), null);
		}
		var list: List<T>;
		var range: FileRange;
		while (true) {
			var lastPos = p.curPos;
			var item = f(p);
			if (p.curPos == lastPos) {
				// didn't parse anything
				p.opt1(endDelim);
				return VstList.new(p.end(start), Lists.reverse(list));
			}
			list = List<T>.new(item, list);
			if (p.curByte == endDelim) {
				// end of list
				range = eatEnd(p, start);
				break;
			}
			if (sepByte == NONE) continue;
			if (p.curByte == sepByte) {
				// separator character
				p.advance1();
			} else {
				var msg = Strings.format2("\'%c\' or \'%c\' expected", sepByte, endDelim);
				p.error(msg);
				range = p.end(start);
				break;
			}
		}
		return VstList.new(range, Lists.reverse(list));
	}
	def eatEnd(p: ParserState, start: FilePoint) -> FileRange {
		var endLine = p.curLine;
		var endColumn = p.curCol + 1;
		p.advance1();
		return FileRange.new(p.fileName, start.beginLine, start.beginColumn, endLine, endColumn);
	}
	def kwError(p: ParserState, id: Token) {
		p.errorAt(id.range(), Strings.format1("keyword \"%s\" cannot be used as identifier", id.image));
	}
	def parseIdentVoid(p: ParserState) -> VstIdent<void> {
		var id = parseIdentCommon<void>(p, null);
		if (id.kwClass != 0) kwError(p, id.name);
		return id;
	}
	def parseIdent<T>(p: ParserState, parse: ParserState -> T) -> VstIdent<T> {
		var id = parseIdentCommon(p, parse);
		if (id.kwClass != 0) kwError(p, id.name);
		return id;
	}
	def parseIdentUnchecked<T>(p: ParserState, parse: ParserState -> T) -> VstIdent<T> {
		return parseIdentCommon(p, parse);
	}
	// parse a parameterized identifier with the supplied parameter parsing function
	def parseIdentCommon<T>(p: ParserState, parse: ParserState -> T) -> VstIdent<T> {
		if (Char.isIdentStart(p.curByte)) {
			var d = p.input;
			for (q = p.curPos + 1; q < d.length; q++) {
				var c = d[q];
				if (c == '<') { // parse parameters, if allowed
					if (parse == null) {
						p.error("identifier cannot be parameterized here");
						return extractIdent(p, q);
					}
					var id = extractIdent<T>(p, q);
					var list = parseList(1, p, '<', COMMA, '>', parse);
					return VstIdent<T>.new(id.name, id.kwClass, list);
				}
				// if the character is part of the middle continue
				if (!Char.isIdentMiddle(c)) return extractIdent(p, q);
			}
			// end of input
			return extractIdent(p, d.length);
		}
		p.error("identifier expected");
		return extractIdent(p, p.curPos);
	}
	// extract an unparameterized identifier and advance the parser
	def extractIdent<T>(p: ParserState, end: int) -> VstIdent<T> {
		var token = p.token(end - p.curPos), kc = '\x00';
		var id = token.image;
		if (id.length >= 2) {
			var index = Keywords.kwIndex(id), kw = Keywords.kwKeys[index];
			if (kw != null && Strings.equal(kw, id)) kc = Keywords.kwClass[index];
		}
		return VstIdent<T>.new(token, kc, null);
	}
	def boundOp(p: ParserState, infix: V3Infix, op: Operator) -> InfixOp {
		var i = InfixOp.new(p.token(infix.syntax.length), infix, infix.prec, false);
		i.op = op;
		return i;
	}
	// parse an infix or member operator
	def parseInfix(p: ParserState) -> InfixOp {
		var op = V3Infix.None;
		match (p.curByte) {
			'=' => if (p.peek(1) == '=') op = V3Infix.EqEq;
			'!' => if (p.peek(1) == '=') op = V3Infix.NotEq;
			'|' => {
				if (p.peek(1) == '|') return boundOp(p, V3Infix.OrOr, V3Op.opBoolOr);
				op = V3Infix.Or;
			}
			'&' => {
				if (p.peek(1) == '&') return boundOp(p, V3Infix.AndAnd, V3Op.opBoolAnd);
				op = V3Infix.And;
			}
			'<' => {
				var nch = p.peek(1);
				if (nch == '=') op = V3Infix.LtEq;
				else if (nch == '<') op = V3Infix.Shl;
				else op = V3Infix.Lt;
			}
			'>' => {
				var nch = p.peek(1);
				if (nch == '=') op = V3Infix.GtEq;
				else if (nch == '>') {
					var nnch = p.peek(2);
					op = if(nnch == '>', V3Infix.Shr, V3Infix.Sar);
				}
				else op = V3Infix.Gt;
			}
			'+' => op = V3Infix.Add;
			'-' => op = V3Infix.Sub;
			'*' => op = V3Infix.Mul;
			'/' => op = V3Infix.Div;
			'%' => op = V3Infix.Mod;
			'^' => op = V3Infix.Xor;
		}
		if (op == V3Infix.None) return null;
		var len = op.syntax.length;
		var assign = false;
		var prec = op.prec;
		if (p.peek(len) == '=') {
			len++;
			assign = true;
			prec = 0;
			if (!op.compound) p.error("illegal compound assignment");
		}
		return InfixOp.new(p.token(len), op, prec, assign);
	}
	def reqKeyword(p: ParserState, kw: string) -> FilePoint {
		var start = optKeyword(p, kw);
		if (start == null) p.error1("\"%s\" expected", kw);
		return start;
	}
	def optKeyword(p: ParserState, kw: string) -> FilePoint {
		if (p.curByte != kw[0]) return null;
		var i = p.curPos, d = p.input, max = i + kw.length;
		if (max > d.length) return null;
		for (j < kw.length) {
			if (d[i + j] != kw[j]) return null;
		}
		if (max < d.length && Char.isIdentMiddle(d[max])) return null;
		var pt = FilePoint.new(p.fileName, p.curLine, p.curCol);
		p.advance(kw.length);
		return pt;
	}
	def term1(p: ParserState, start: FilePoint, ch: byte) -> FileRange {
		var endLine = p.curLine;
		var endColumn = p.curCol;
		if (p.curByte == ch) {
			p.advance1();
			endColumn++;
		} else {
			p.error1("\"%c\" expected", ch);
		}
		return FileRange.new(p.fileName, start.beginLine, start.beginColumn, endLine, endColumn);
	}
	// Skip forward over whitespace and comments, to the beginning of the next token.
	def skipToNextToken(p: ParserState) {
		var curPos = p.curPos, curLine = p.curLine, curCol = p.curCol;
		var input = p.input, max = input.length;
		while (curPos < max) {
			var ch = input[curPos];
			match (ch) {
				' ' => { curCol++; }
				'\t' => { curCol = 1 + (((curCol + 8) >>> 3) << 3); }
				'\n' => {
					p.lineEnds.put(curPos);
					curCol = 1;
					curLine++;
				}
				'/' => {
					if (curPos >= max - 1) break;
					var ch = input[curPos + 1];
					if (ch == '/') {
						// skip line comment
						curPos += 2;
						while (curPos < max) {
							if (input[curPos] == '\n') {
								p.lineEnds.put(curPos);
								curCol = 1;
								curLine++;
								break;
							}
							curPos++;
						}
					} else if (ch == '*') {
						// skip multi-line comment
						curPos += 2;
						curCol += 2;
						while (curPos < max) {
							var ch = input[curPos];
							if (ch == '\n') {
								p.lineEnds.put(curPos);
								curCol = 1;
								curLine++;
								curPos++;
							} else if (ch == '*' && curPos < max - 1 && input[curPos + 1] == '/') {
								curCol += 2;
								curPos++;
								break;
							} else {
								curCol++;
								curPos++;
							}
						}
					} else {
						break;
					}
				}
			} else {
				if (ch < ' ' || ch > '~') {
					// illegal character!
					p.setPos(curPos, curLine, curCol);
					p.error1("invalid character valued %x", ch);
					curCol++;
				} else {
					// non-whitespace character, break
					break;
				}
			}
			curPos++;
		}
		// reached the end or a non-whitespace character
		p.setPos(curPos, curLine, curCol);
	}
	// Skip to the last character on the current line (irrespective of comments).
	def skipToEndOfLine(p: ParserState) {
		var curPos = p.curPos, curCol = p.curCol;
		var input = p.input, max = input.length;
		var ch: byte;
		while (curPos < max) {
			ch = input[curPos++];
			match (ch) {
				'\t' => { curCol = 1 + (((curCol + 8) >>> 3) << 3); } // maintain column
				'\n' => { curPos--; break; }
			}
		}
		p.curCol = curCol;
		p.curPos = curPos;
		p.curByte = ch;
	}
	// Skip to the first character on the next line, or the end of the file (irrespective of comments).
	def skipToNextLine(p: ParserState) {
		var start = p.curPos;
		var curPos = start;
		var input = p.input, max = input.length;
		while (curPos < max) {
			if (input[curPos++] == '\n') {
				p.lineEnds.put(curPos);
				p.curCol = 1;
				p.curLine++;
				p.curPos = curPos;
				p.curByte = if(curPos < max, input[curPos]);
				return;
			}
		}
		// no newline, skip to end of the file, but maintain column.
		skipToEndOfLine(p);
	}
	def skipNone(p: ParserState) {
		// don't skip any characters
	}
}
// a small closure for parsing var/def declarations
class VarDefParser(isPrivate: bool, writability: Writability) {
	def parseLocal(p: ParserState) -> VarDecl {
		var id = Parser.parseIdentVoid(p).name;
		var tref = if(p.curByte == ':', Parser.parseTypeRef(p.advance1()));
		var init = if(p.curByte == '=', Parser.parseExpr(p.advance1()));
		var decl = VarDecl.new(id, tref, init);
		decl.isReadOnly = writability == Writability.READ_ONLY;
		return decl;
	}
	def parseVars(p: ParserState, id: VstIdent<void>) -> List<VarDecl> {
		var list: List<VarDecl>;
		while (true) {
			var tref = if(p.curByte == ':', Parser.parseTypeRef(p.advance1()));
			var init = if(p.curByte == '=', Parser.parseExpr(p.advance1()));
			var decl = VarDecl.new(id.name, tref, init);
			decl.isReadOnly = writability == Writability.READ_ONLY;
			list = List.new(decl, list);
			if (p.curByte == ',') {
				p.advance1();
				id = Parser.parseIdentVoid(p);
			} else if (p.curByte == ';') {
				p.advance1();
				break;
			} else {
				p.error("\',\' or \';\' expected");
				break;
			}
		}
		return list;
	}
	def parseDef(p: ParserState, prev: List<VstMember>, importName: Token) -> List<VstMember> {
		if (p.curByte == '[') return parseIndexed(p, prev);
		var id = Parser.parseIdent(p, Parser.parseTypeParam);
		if (p.curByte == '(' || id.params != null) {
			if (writability == Writability.PRIVATE_WRITEABLE) p.error("invalid access modifiers for method declaration");
			var params = Parser.parseTypedMethodParams(p);
			var t = Parser.parseReturnTypeAndBody(p, true);
			var m = VstMethod.new(isPrivate, id.name, id.list(), params, t.0, t.1);
			m.importName = importName;
			return List.new(m, prev);
		}
		var n = VstIdent<void>.new(id.name, id.kwClass, null);
		return parseFieldSuffix(p, n, prev);
	}
	def parseIndexed(p: ParserState, prev: List<VstMember>) -> List<VstMember> {
		if (writability == Writability.PRIVATE_WRITEABLE) p.error("invalid access modifiers for indexing method declaration");
		var params = Parser.parseList(0, p, '[', Parser.COMMA, ']', Parser.parseTypedMethodParam);
		if (p.curByte == '=' && p.peek(1) != '>') {
			p.req1('=');
			var val = Parser.parseTypedMethodParam(p);
			var rtype = ReturnType.Void;
			var l = List.new(val, Lists.reverse(params.list));
			params = VstList.new(params.src, Lists.reverse(l));
			var r = params.range();
			var token = Token.new(r.fileName, "[]=", r.beginLine, r.beginColumn);
			var body = if(p.curByte == ';', EmptyStmt.new(p.token(1)), Parser.parseBlockStmt(p));
			var m = VstMethod.new(isPrivate, token, null, params, rtype, body);
			return List.new(m, prev);
		} else {
			var t = Parser.parseReturnTypeAndBody(p, true);
			var r = params.range();
			var token = Token.new(r.fileName, "[]", r.beginLine, r.beginColumn);
			var m = VstMethod.new(isPrivate, token, null, params, t.0, t.1);
			return List.new(m, prev);
		}
	}
	def parseVar(p: ParserState, prev: List<VstMember>) -> List<VstMember> {
		var id = Parser.parseIdentVoid(p);
		return parseFieldSuffix(p, id, prev);
	}
	private def parseFieldSuffix(p: ParserState, id: VstIdent<void>, prev: List<VstMember>) -> List<VstMember> {
		while (true) { // XXX: reduce duplication with parseVars()
			var tref = if(p.curByte == ':', Parser.parseTypeRef(p.advance1()));
			var init = if(p.curByte == '=', Parser.parseExpr(p.advance1()));
			var repHints = Parser.parseRepHints(p);
			var decl = VstField.new(isPrivate, writability, id.name, tref, init, repHints);
			prev = List.new(decl, prev);
			if (p.curByte == ',') {
				p.advance1();
				id = Parser.parseIdentVoid(p);
			} else if (p.curByte == ';') {
				p.advance1();
				break;
			} else {
				p.error("\',\' or \';\' expected after field declaration");
				break;
			}
		}
		return prev;
	}
}
