// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Performs verification on class and component declarations, including
// resolving all references, enforcing overriding and inheritance rules,
// and typechecking all code
class Verifier(compiler: Compiler, prog: Program) {
	def ERROR = prog.ERROR;
	var typeCache: TypeCache;
	var mainMethod: VstMethod;
	def env = VarEnvironment.new();
	def ir = prog.ir = IrModule.new();
	var exportMap: PartialMap<string, ExportDecl>;

	def forAll<T>(vec: Vector<T>, do: T -> void) {
		for (i < vec.length) {
			if (!ERROR.notTooMany) break;
			do(vec[i]);
		}
	}
	def verify() {
		var vst = prog.vst;
		for (f in vst.files) buildFile(f);
		forAll(vst.classes, resolveSuperClass);
		forAll(vst.components, verifyComponent);
		forAll(vst.classes, verifyClass);
		forAll(vst.enums, verifyEnum);
		forAll(vst.structs, verifyStruct);
		forAll(vst.exports, verifyExport);
		forAll<VstComponent>(vst.components, typeCheckVstCompound);
		forAll<VstClass>(vst.classes, typeCheckVstCompound);
		forAll<VstEnum>(vst.enums, typeCheckVstCompound);
		forAll<VstStruct>(vst.structs, typeCheckVstCompound);

		typeCache = null; // typeCache for type vars is now dead
		if (ERROR.noErrors) {
			vst.components.apply(addInitFor);
			vst.classes.apply(addInitFor);
			vst.enums.apply(addEnumVals);
		}
		vst.files = null; // file contents not needed any more
		if (mainMethod != null) {
			var spec = ir.fromVstMemberAndType(mainMethod.receiver.getDeclaredType(), mainMethod);
			prog.mainRootIndex = ir.addRoot(null, spec);
		}
		if (ERROR.noErrors) forAll(vst.exports, addExport);
	}
	def buildFile(file: VstFile) {
		if (file == null) return;
		prog.vst.components.putv(file.components);
		file.typeEnv = TypeEnv.new(prog.typeEnv, null, null);
		for (i < file.components.length) {
			var componentDecl = file.components[i];
			componentDecl.recordIndex = prog.vst.numComponents++;
			componentDecl.typeCon = V3Component_TypeCon.new(componentDecl, prog.typeCache);
			makeVerifier(componentDecl, componentDecl.getDeclaredType(), file);
			if (!componentDecl.isSynthetic) bindTypeCon(componentDecl, file);
			buildMembers(componentDecl, false);
		}
		prog.vst.classes.putv(file.classes);
		for (i < file.classes.length) {
			var classDecl = file.classes[i];
			classDecl.typeCon = V3Class_TypeCon.new(classDecl, prog.typeCache);
			makeVerifier(classDecl, classDecl.getDeclaredType(), file);
			if (!classDecl.isSynthetic) bindTypeCon(classDecl, file);
			buildMembers(classDecl, classDecl.superclass != null);
		}
		prog.vst.enums.putv(file.enums);
		for (i < file.enums.length) {
			var enumDecl = file.enums[i];
			makeVerifier(enumDecl, enumDecl.getDeclaredType(), file);
			bindTypeCon(enumDecl, file);
			buildMembers(enumDecl, false);
		}
		prog.vst.structs.putv(file.structs);
		for (i < file.structs.length) {
			var structDecl = file.structs[i];
			structDecl.typeCon = V3Ref_TypeCon.new(structDecl, true, prog.typeCache);
			structDecl.readonlyType = V3Ref_TypeCon.new(structDecl, false, prog.typeCache).create0();
			makeVerifier(structDecl, structDecl.getDeclaredType(), file);
			buildMembers(structDecl, false);
			if (prog.structs == null) prog.structs = Strings.newMap();
			var name = structDecl.name();
			var prev = prog.structs[name];
			if (prev != null) structDecl.verifier.TypeRedefined(structDecl.token);
			prog.structs[name] = structDecl;
		}
		prog.vst.exports.putv(file.exports);
	}
	def addInitFor(decl: VstCompound) {
		var ctype = decl.getDeclaredType();
		decl.verifier = null;
		var ic = ir.makeIrClass(ctype);
		var constructor = ic.methods[0];
		if (constructor != null && VstComponent.?(decl)) addInit(constructor);
	}
	def addEnumVals(decl: VstEnum) {
		if (decl.params == null) return;
		for (l = decl.params.list; l != null; l = l.tail) {
			var field = VstField.!(l.head.member);
			var arrayType = V3Array.newType(field.getType());
			field.enumVals = prog.newRecord(arrayType, decl.cases.length);
		}
		var ic = prog.ir.makeIrClass(decl.getDeclaredType());
		var constructor = ic.methods[0];
		if (constructor != null) addInit(constructor);
	}
	def addInit(meth: IrMethod) {
		var decl = VstNew.!(meth.source);
		decl.initIndex = ir.init.length;
		ir.init.put(meth);
	}
	def makeVerifier(decl: VstCompound, thisType: Type, file: VstFile) {
		var cv = decl.verifier = VstCompoundVerifier.new(decl, thisType, this, file);
		if (decl.typeParams != null) decl.typeEnv = cv.buildTypeEnv(file.typeEnv, decl.typeParams);
		else decl.typeEnv = file.typeEnv;
	}
	def bindTypeCon(decl: VstCompound, file: VstFile) {
		var typeEnv = if (decl.isPrivate, file.typeEnv, prog.typeEnv);
		var prev = typeEnv.lookup(decl.name());
		if (prev != null) decl.verifier.TypeRedefined(decl.token);
		typeEnv.add(decl.typeCon);
	}
	def buildMembers(decl: VstCompound, hasSuper: bool) {
		decl.memberMap = Strings.newMap();
		for (list = Lists.reverse(decl.getParams()); list != null; list = list.tail) {
			// add synthetic fields for each parameter (classes only)
			var p = list.head;
			var writability = if(p.isReadOnly, Writability.READ_ONLY, Writability.WRITEABLE);
			var field = VstField.new(false, writability, p.token, p.tref, null);
			field.synthetic = true;
			p.member = field;
			decl.members = List.new(field, decl.members);
		}
		for (list = decl.members; list != null; list = list.tail) {
			// process each member, checking for duplicates
			var mdecl = list.head;
			if (VstNew.?(mdecl)) {
				// do not put new in the member map, check the constructor field
				var newDecl = VstNew.!(mdecl);
				if (decl.constructor != null) decl.verifier.MemberRedefined(mdecl.token);
				else decl.constructor = newDecl;
				mdecl.receiver = decl;
				continue;
			}
			// look for a previous definition of the member in the map
			var prev = decl.memberMap[mdecl.token.image];
			if (prev != null) decl.verifier.MemberRedefined(mdecl.token);
			else decl.memberMap[mdecl.token.image] = mdecl;
			mdecl.receiver = decl;
		}
		var constructor = decl.constructor;
		if (constructor == null && !VstStruct.?(decl)) {
			// fill in a default constructor if one wasn't declared
			var name = Token.new(decl.token.fileName, "new", decl.token.beginLine, decl.token.beginColumn);
			var superclause = decl.superclause;
			if(hasSuper && superclause == null) superclause = newSuperClause(name.rangeOf(0));
			var params = VstList.new(name.range(), decl.getParams());
			constructor = VstNew.new(name, params, superclause, BlockStmt.new(VstList<Stmt>.new(name.rangeOf(0), null)));
			constructor.isSynthetic = true;
			constructor.typeEnv = decl.typeEnv;
			constructor.receiver = decl;
			decl.constructor = constructor;
			decl.members = List.new(constructor, decl.members);
			return;
		}
		if (decl.params != null) {
			// class has parameters; copy them to the constructor
			if (constructor.params.length() > 0) decl.verifier.ConstructorError(decl.token, "additional constructor cannot have parameters");
			else constructor.params = decl.params;
		}
		if (decl.superclause != null) {
			// class has superclause; copy it to constructor
			if (constructor.superclause != null) decl.verifier.ConstructorError(decl.token, "super clause already defined");
			else constructor.superclause = decl.superclause;
		}
	}
	def newSuperClause(where: FileRange) -> SuperClause {
		return SuperClause.new(where, TupleExpr.new(VstList<Expr>.new(where, null)));
	}
	def resolveSuperClass(decl: VstClass) {
		var cv = decl.verifier;
		if (cv.onstack) {
			// if this class is on the stack, then there is circular inheritance.
			cv.InheritanceError(cv.compound.token, "cyclic inheritance detected");
		} else {
			// the class has not been verified yet.
			if (decl.superclass != null) {
				// bind the super class first.
				var stype = cv.resolveType(decl.superclass, decl.typeEnv);
				if (stype != null) {
					cv.onstack = true;
					if (stype.typeCon.kind == decl.typeCon.kind) resolveSuperClass(ClassType.!(stype).classDecl);
					else cv.InheritanceError(decl.superclass.range(), "cannot extend non-class type");
					cv.onstack = false;
				}
			}
		}
	}
	def checkStructCycle(decl: VstStruct){
		var cv = decl.verifier;
		if (cv.onstack) {
			cv.FieldDeclError2(decl.token.range(), "cyclic field declaration detected");
		} else {
			cv.onstack = true;
			for (l = decl.members; l != null; l = l.tail) {
				var structName = VstStructField.!(l.head).mtref.tname.name.image;
				var strct = prog.structs[structName];
				if (strct != null) checkStructCycle(strct);
			}
			cv.onstack = false;
		}
	}
	def verifyComponent(decl: VstComponent) {
		decl.verifier.verify();
		// look for the main method
		var main = decl.memberMap["main"];
		if (VstMethod.?(main) && mainMethod == null) {
			mainMethod = VstMethod.!(main);
			if (compiler.target != null) compiler.target.verifyMain(mainMethod, decl.verifier.MainMethodError);
		}
	}
	def verifyClass(decl: VstClass) {
		var cv = decl.verifier;
		if (!cv.verified && !cv.onstack) {
			// the class has not been verified, and is not involved in circular inheritance.
			if (decl.superclass != null) {
				var stype = decl.superclass.getType();
				if (ClassType.?(stype)) {
					cv.superType = ClassType.!(stype);
					cv.onstack = true;
					verifyClass(cv.superType.classDecl);
					cv.onstack = false;
					cv.setSuperOrder();
				}
			}
			cv.verify();
		}
	}
	def verifyEnum(decl: VstEnum) {
		var cv = decl.verifier;
		cv.verify();
	}
	def verifyStruct(decl: VstStruct) {
		var cv = decl.verifier;
		var size = tryUnboxPositiveInt(decl.size, -1);
		if (size < 0) cv.error(decl.size.range(), "StructDeclError", Strings.format1("invalid struct size %q", decl.size.token.image));
		decl.byteSize = size;
		cv.verify();
		verifyFieldOverlapping(decl);
		checkStructCycle(decl);
	}
	def verifyFieldOverlapping(decl: VstStruct) {
		var fields = Vector<VstStructField>.new();
		for (l = decl.members; l != null; l = l.tail) {
			match (l.head) {
				x: VstStructField => if (x.byteOffset >= 0 && x.mtref.byteSize >= 0) fields.put(x);
			}
		}
		var length = fields.length;
		var a = Arrays.sort(fields.extract(), 0, length, compareFieldOffset);
		for (i < a.length - 1) {
			var f = a[i], g = a[i + 1];
			if ((f.byteOffset + f.mtref.byteSize) > g.byteOffset) decl.verifier.FieldDeclError(f, Strings.format2("field %q overlaps field %q", f.render, g.render));
		}
	}
	def compareFieldOffset(a: VstStructField, b: VstStructField) -> bool {
		return a.byteOffset < b.byteOffset;
	}
	def verifyExport(decl: ExportDecl) {
		var cv = decl.synthetic.verifier;
		if (exportMap == null) {
			exportMap = Strings.newMap();
		} else {
			var prev = exportMap[decl.token.image];
			if (prev != null) {
				cv.ExportDeclError(decl, formatPrev("export redefined", prev.token));
				return;
			}
		}
		exportMap[decl.token.image] = decl;
		var tc = TypeChecker.new(ERROR, cv.file);
		var methodEnv = MethodEnv.new(decl.synthetic, null, null, cv, env);
		tc.enterMethod(methodEnv);
		tc.visitVar(decl.expr, null);
		if (!VarBinding.ComponentMethod.?(decl.expr.varbind)) {
			cv.ExportDeclError(decl, "export must be a component or top-level method");
		}
	}
	def addExport(decl: ExportDecl) {
		var binding = VarBinding.ComponentMethod.!(decl.expr.varbind);
		var spec = VstIr.specOf(ir, binding.member.receiver.getDeclaredType(), binding.member, binding.typeArgs);
		ir.addRoot(decl.expname, spec);
	}
	def typeCheckVstCompound(decl: VstCompound) {
		var tc = TypeChecker.new(ERROR, decl.verifier.file);
		for (members = decl.members; members != null; members = members.tail) {
			match (members.head) {
				x: VstNew => {
					typeCheckNew(decl, x, tc);
				}
				x: VstMethod => {
					var cv = decl.verifier;
					var env = MethodEnv.new(decl, x, cv.newThisParam(), cv, env);
					if (!EmptyStmt.?(x.body)) {
						tc.enterMethod(env);
						tc.typeCheckBody(x.body);
					}
				}
				x: VstEnumCase => {
					var cv = decl.verifier;
					var env = MethodEnv.new(decl, null, null, cv, env);
					tc.enterMethod(env);
					typeCheckEnumCase(VstEnum.!(decl), x, tc);
				}
			}
		}
	}
	def typeCheckNew(decl: VstCompound, cdecl: VstNew, tc: TypeChecker) {
		var cv = decl.verifier, thisParam = cv.newThisParam();
		var initEnv: MethodEnv;
		if (VstClass.?(decl) || VstEnum.?(decl)) {
			// track field initialization state for class constructors
			initEnv = MethodEnv.new(decl, null, thisParam, cv, env);
		} else {
			initEnv = MethodEnv.new(decl, cdecl, thisParam, cv, env);
			if (cdecl.params.length() > 0) cv.ParamDeclError(cdecl.params.first().token, "components cannot have constructor parameters");
		}
		// check parameters
		tc.enterMethod(initEnv);
		for (params = cdecl.params.list; params != null; params = params.tail) {
			var f = params.head.member;
			if (f != null) {
				var dest = f.getType();
				var from = params.head.vtype;
				if (dest == null) dest = ERROR.getErrorType();
				if (!tc.isAssignable(from, dest)) {
					cv.TypeError(params.head.token.range(), dest, from, "implicit field initialization");
				}
			}
		}
		// check field initializers
		for (list = decl.members; list != null; list = list.tail) {
			var m = list.head;
			if (VstField.?(m)) {
				var fdecl = VstField.!(m);
				if (fdecl.init != null) {
					initEnv.initOrder = fdecl.initOrder;
					initEnv.initField = fdecl;
					if (fdecl.tref != null) tc.typeCheckExpr(fdecl.init, fdecl.tref.getType(), "field initialization");
					else if (fdecl.vtype == null) inferFieldType(fdecl, initEnv, tc);
				}
			}
		}
		// check super clause
		initEnv = MethodEnv.new(decl, cdecl, thisParam, cv, env);
		tc.enterMethod(initEnv);
		if (cv.superType != null) {
			initEnv.initOrder = cv.superInitOrder;
			var typeArgs = cv.superType.getTypeArgs();
			var funcType = cv.superType.classDecl.constructor.getType().substitute(typeArgs);
			var argTypes = Function.getParamTypeList(funcType);
			tc.typeCheckExprs(cdecl.superclause.args, argTypes, "super constructor");
		}
		// check constructor body
		initEnv.initOrder = 0; // all fields can be used in the constructor
		tc.typeCheckBody(cdecl.body);
	}
	def typeCheckEnumCase(decl: VstEnum, c: VstEnumCase, tc: TypeChecker) {
		var paramTypes: List<Type>;
		if (decl.params != null) {
			// extract parameter types.
			for (params = decl.params.list; params != null; params = params.tail) {
				paramTypes = List.new(params.head.vtype, paramTypes);
			}
			paramTypes = Lists.reverse(paramTypes);
		}
		if (c.args != null) {
			// typecheck arguments to enum.
			var args = c.args.list;
			var what = "case declaration";
			for (i = 0; args != null; (args = args.tail, paramTypes = paramTypes.tail)) {
				if (paramTypes != null) {
					tc.typeCheckExpr(args.head, paramTypes.head, what);
				} else {
					tc.ArityMismatch(args.head.range(), what, decl.params.length(), c.args.length());
					return;
				}
			}
			if (paramTypes != null) tc.ArityMismatch(c.token.range(), what, decl.params.length(), c.args.length());
		} else {
			// expected parameters, but none were provided.
			if (paramTypes != null) decl.verifier.CaseDeclError(c, "expected case arguments, but none provided");
		}
	}
	def inferFieldType(fdecl: VstField, initEnv: MethodEnv, tc: TypeChecker) -> Type {
		var decl = fdecl.receiver, cv = decl.verifier;
		fdecl.initEnv = initEnv;
		initEnv.initField = fdecl;
		fdecl.vtype = tc.inferClosedType(fdecl.init);
		fdecl.initEnv = null;
		return fdecl.vtype;
	}
	def isNonTrivialInitializer(fdecl: VstField) -> bool {
		return fdecl.writability != Writability.READ_ONLY || !Literal.?(fdecl.init);
	}
	def isNonTrivialSuperclause(superclause: SuperClause) -> bool {
		if (superclause == null) return false;
		for (l = superclause.args.exprs.list; l != null; l = l.tail) {
			var expr = l.head;
			if (Literal.?(expr)) continue;
			if (VarExpr.?(expr) && VarExpr.!(expr).isLocal()) continue;
			return true;
		}
		return false;
	}
}
def formatPrev(msg: string, prev: FilePoint) -> string {
	return if (prev != null, Strings.format3("%s (previous at %d:%d)", msg, prev.beginLine, prev.beginColumn), msg);
}
class VstCompoundVerifier {
	def compound: VstCompound;
	def thisType: Type;
	def verifier: Verifier;
	def file: VstFile;
	var typeEnv: TypeEnv;
	var ERROR: ErrorGen;
	var classDecl: VstClass;
	var classType: ClassType;
	var superType: ClassType;

	var memberinits: List<VstField>;
	var fields: List<VstField>;
	var thisParam: ParamDecl;
	var initMax: int;
	var superInitOrder: int;

	var onstack: bool;
	var verified: bool;
	var isImport: bool;

	new(compound, thisType, verifier, file) {
		ERROR = verifier.ERROR;
		if (VstClass.?(compound)) {
			classDecl = VstClass.!(compound);
			classType = ClassType.!(thisType);
		} else if (VstComponent.?(compound)) {
			isImport = VstComponent.!(compound).isImport;
		}
	}
	def setSuperOrder() {
		superInitOrder = superType.classDecl.verifier.initMax;
		classDecl.numFields = superType.classDecl.numFields;
		classDecl.numMethods = superType.classDecl.numMethods;
	}
	def verify() {
		if (VstEnum.?(compound)) {
			if (VstEnum.!(compound).cases.length == 0) {
				error(compound.token.range(), "EnumDeclError", "enum requires at least 1 case");
			}
		}
		Lists.apply(compound.members, checkMember);
		if (compound.constructor != null) {
			compound.constructor.memberinits = Lists.reverse(memberinits);
		}
		verified = true;
		if (classType != null) {
			initMax = 1 + superInitOrder;
			for (l = fields; l != null; l = l.tail) {
				l.head.initOrder = initMax++;
			}
			for (l = compound.constructor.params.list; l != null; l = l.tail) {
				var p = l.head;
				if (p.member != null) p.member.initOrder = initMax;
			}
		}
	}
	def buildTypeEnv(parent: TypeEnv, typeParams: List<TypeParamType>) -> TypeEnv {
		var typeEnv = TypeEnv.new(parent, typeParams, null);
		for (plist = typeParams; plist != null; plist = plist.tail) {
			var tparam = plist.head;
			if (typeEnv.typecons[tparam.token.image] != null) TypeParamRedefined(tparam);
			typeEnv.add(tparam.typeCon);
		}
		return typeEnv;
	}
	def checkMember(decl: VstMember) {
		match (decl) {
			x: VstNew => checkNew(x);
			x: VstField => checkField(x);
			x: VstMethod => checkMethod(x);
			x: VstStructField => checkStructField(x);
		}
	}
	def checkField(decl: VstField) {
		if (isImport) ImportError(decl, "imported components cannot contain field declarations");
		if (decl.tref != null) {
			decl.vtype = resolveType(decl.tref, compound.typeEnv);
		} else if (decl.init == null) {
			FieldDeclError(decl, "must have a declared type or an initializer");
			decl.vtype = getErrorType();
		}
		decl.index = compound.numFields++;
		if (classDecl != null) {
			var binding = lookupSuperMember(decl.name());
			if (binding != null && !binding.member.isPrivate) MemberRedefined(decl.token);
		}
		fields = List.new(decl, fields);
		if (decl.init != null) {
			memberinits = List.new(decl, memberinits);
			if (verifier.isNonTrivialInitializer(decl)) {
				if (compound.constructor != null) compound.constructor.markNontrivial();
			}
		}
		if (compound.isVariant() && !decl.synthetic) FieldDeclError(decl, "type cannot have an explicit field");
	}
	def checkNew(decl: VstNew) {
		typeEnv = compound.typeEnv;
		var map: Map<string, Decl> = Strings.newMap();
		Lists.apply(decl.params.list, checkNewParam(_, decl, map));
		if (classDecl != null) {
			if (superType != null) {
				if (decl.superclause == null) decl.superclause = verifier.newSuperClause(decl.params.range());
				var superCons = superType.classDecl.constructor;
				decl.superclause.constructor = superCons;
				if (superCons.nontrivial()) decl.markNontrivial();
			} else if (decl.superclause != null) {
				InheritanceError(decl.superclause.point, "class has no super class");
			}
		} else if (decl.superclause != null) {
			InheritanceError(decl.superclause.point, "component constructor cannot have super() call");
		}
		decl.root = decl;
		if (BlockStmt.!(decl.body).stmts.list != null || verifier.isNonTrivialSuperclause(decl.superclause)) {
			decl.markNontrivial();
		}
		if (compound.isVariant() && !decl.isSynthetic) ConstructorError(decl.token, "type cannot have a constructor");
	}
	def checkMethod(decl: VstMethod) {
		if (isImport) {
			if (decl.isImport = EmptyStmt.?(decl.body)) {
				if (decl.typeParams != null) ImportError(decl, "imported methods cannot have type parameters");
			}
		}
		typeEnv = compound.typeEnv;
		if (decl.isIndexed() && VstComponent.?(compound)) {
			var msg = if (compound.isFileScope,
				"index operation cannot be declared at top level",
				"index operation cannot be declared in component");
			IndexDeclError(decl, msg);
		}
		if (compound.isVariantCase() && EmptyStmt.?(decl.body)) {
			UnimplementedError(decl.body, "variant method must have a body");
		}
		if (decl.typeParams != null) typeEnv = decl.typeEnv = buildTypeEnv(typeEnv, decl.typeParams);
		if (decl.params.list != null) {
			var map = Strings.newMap<Decl>();
			Lists.apply(decl.params.list, checkMethodParam(_, map));
		}
		match (decl.rettype) {
			Explicit(tref) => resolveType(tref, typeEnv);
			Implicit(expr) => ; // TODO
			_ => ;
		}
		var binding = lookupSuperMember(decl.name());
		if (binding != null) return checkMethodOverride(decl, binding);
		decl.root = decl;
		decl.index = compound.numMethods++;
	}
	def checkStructField(decl: VstStructField) {
		if (isImport) ImportError(decl, "imported structs cannot contain field declarations");

		var mtref = decl.mtref;
		mtref.repeatCount = tryUnboxPositiveInt(decl.mtref.repeat, 1);
		if (mtref.repeatCount <= 0) FieldDeclError2(decl.mtref.repeat.range(), "expected integer repeat count > 0");
		var map = verifier.prog.structs;
		var st = if(map != null, map[decl.mtref.tname.name.image]);
		var scale = 1;
		if (st != null) {
			mtref.mtstruct = RefType.!(st.getDeclaredType());
			scale = Int.unbox(st.size.val);
		} else {
			var tref = NamedTypeRef.new(null, decl.mtref.tname.name, null);
			var t = decl.mtref.mttype = resolveType(tref, compound.typeEnv);
			if (t != null) match (t) {
				x: IntType => scale = x.packedByteSize();
				x: FloatType => scale = x.byteSize();
				x: EnumType => scale = x.packedByteSize();
				_ => {
					match (t.typeCon.kind) {
						V3Kind.BOOL => scale = 1;
						_ => FieldDeclError2(decl.mtref.tname.range(), Strings.format1("expected primitive struct field type, found \"%q\"", t.render));
					}
				}

			}
		}
		mtref.scale = scale;
		var size64 = mtref.repeatCount * long.view(scale);
		if (size64 > int.max) FieldDeclError2(decl.mtref.range(), Strings.format2("struct field size of %d exceeds internal limitation of %d", size64, int.max));
		mtref.byteSize = mtref.repeatCount * scale;
		var offset = decl.byteOffset = tryUnboxPositiveInt(decl.offset, 0);
		var structSize = VstStruct.!(compound).byteSize;
		if (offset > structSize) FieldDeclError2(decl.offset.range(), Strings.format2("struct field \"%s\" offset out-of-bounds for struct size %d", decl.name(), structSize));
		else if ((offset + long.view(mtref.byteSize)) > structSize) FieldDeclError2(decl.offset.range(), Strings.format2("struct field \"%s\" reaches out-of-bounds for struct size %d", decl.name(), structSize));
		// TODO: check overlapping of fields, build IrField?
		decl.index = compound.numFields++;
	}
	def lookupSuperMember(name: string) -> ResolvedMember {
		if (superType == null) return null;
		var classType = superType;
		while (true) {
			// lookup a field or method
			var member = classType.classDecl.memberMap[name];
			if (member != null) {
				if (member.isPrivate) return null;
				var memberType = member.getType();
				if (memberType != null) memberType = memberType.substitute(classType.getTypeArgs());
				return ResolvedMember.new(classType, member, null, memberType);
			}
			// member was not found in this type
			classType = classType.getSuperType();
			if (classType == null) return null;
		}
		return null;
	}
	def checkMethodOverride(decl: VstMethod, binding: ResolvedMember) {
		if (VstMethod.?(binding.member)) {
			var superDecl = VstMethod.!(binding.member);
			var superMethodType = binding.memberType;
			var methodType = decl.getType();
			decl.index = superDecl.index;
			decl.root = superDecl.root;
			if (superDecl.typeEnv != null) {
				// substitute super method's type parameters with overriden method's
				if (decl.typeEnv == null || decl.typeEnv.paramArray.length != superDecl.typeEnv.paramArray.length) {
					return InheritanceError(decl.token, "cannot override method type parameters");
				}
				var typeArgs = TypeArgs.new(superDecl.typeEnv, decl.typeEnv.paramArray);
				superMethodType = superMethodType.substitute(typeArgs);
				// the overriden method's complete type must be subtype of the super
				// use the same vtable index as the parent.
			} else if (decl.typeEnv != null) {
				return InheritanceError(decl.token, "cannot override method type parameters");
			}
			if (superDecl.returnThis) {
				if (!decl.returnThis) return InheritanceError(decl.token, "super method returns this");
			} else {
				if (decl.returnThis) return InheritanceError(decl.token, "super method does not return this");
			}

			if (!TypeSystem.isSubtype(methodType, superMethodType)) {
				InheritanceError2(decl.token, "method signature %q cannot override %q", methodType, superMethodType);
			}
		} else {
			InheritanceError(decl.token, "cannot override non-method member");
			decl.root = decl;
		}
	}
	def checkParam(param: ParamDecl, map: Map<string, Decl>) {
		if (map[param.name()] != null) ParamDeclError(param.token, Strings.format1("parameter \"%s\" redefined", param.name()));
		map[param.name()] = param;
	}
	def checkNewParam(param: ParamDecl, mdecl: VstNew, map: Map<string, Decl>) {
		checkParam(param, map);
		var member = compound.memberMap[param.name()];
		if (VstField.?(member)) {
			param.member = VstField.!(member);
			mdecl.markNontrivial();
			if (param.tref == null) {
				var decl = VstField.!(member);
				if (decl.tref != null) param.vtype = resolveType(decl.tref, compound.typeEnv);
				else {
					FieldDeclError(decl, "parameter must refer to a field with a declared type");
					param.vtype = getErrorType();
				}
				if (decl.init != null) FieldDeclError(decl, "parameter cannot refer to a field with an initializer");
			}
		}
		if (param.vtype == null) {
			if (param.tref == null) {
				ParamDeclError(param.token, "parameter must have a declared type or refer to a field");
				param.vtype = getErrorType();
			}
			else param.vtype = resolveType(param.tref, compound.typeEnv);
		}
	}
	def checkMethodParam(param: ParamDecl, map: Map<string, Decl>) {
		checkParam(param, map);
		param.vtype = resolveType(param.tref, typeEnv);
	}
	def resolveType(tref: TypeRef, typeEnv: TypeEnv) -> Type {
		if (tref.binding != null) return tref.binding;
		match (tref) {
			x: FuncTypeRef => {
				var paramType = resolveType(x.paramType, typeEnv);
				var returnType = resolveType(x.returnType, typeEnv);
				return x.binding = Function.newType(paramType, returnType);
			}
			x: TupleTypeRef => {
				var nested = if(x.nested != null, Lists.map(x.nested.list, resolveType(_, typeEnv)));
				return x.binding = Tuple.newType(nested);
			}
			x: NamedTypeRef => {
				var leftType = if(x.left != null, resolveType(x.left, typeEnv));
				if (V3.isVariant(leftType)) {
					// Variant.Case resolution.
					var member = ClassType.!(leftType).classDecl.memberMap[x.name.image];
					if (VstCaseMember.?(member)) {
						var typeCon = VstCaseMember.!(member).decl.typeCon;
						if (x.nested != null) {
							TypeParamArityError(x.name.range(), "variant case type",
								x.name.image, 0, x.nested.length());
						}
						return x.binding = typeCon.create(leftType.nested);
					}
				} else if (EnumType.?(leftType)) {
					// Enum.set resolution.
					var enumType = EnumType.!(leftType);
					if (Strings.equal(x.name.image, "set")) {
						if (x.nested != null) {
							TypeParamArityError(x.name.range(), "enum set type",
								x.name.image, 0, x.nested.length());
						}
						return getEnumSetType(x, enumType);
					}
				}
				if (x.left != null) {
					error(x.name.range(), "UnresolvedType", Strings.format2("type \"%q\" has no member type \"%s\"", x.left.render, x.name.image));
					return x.binding = getErrorType();
				}
				var typeCon = typeEnv.lookup(x.name.image);
				if (typeCon == null) {
					UnresolvedType(x);
					return x.binding = ERROR.getErrorTypeNamed(x.name.image);
				}
				if (typeCon.kind == V3Kind.REF) return resolveRefType(V3Ref_TypeCon.!(typeCon), x);

				var nested = if(x.nested != null, Lists.map(x.nested.list, resolveType(_, typeEnv)));
				var arity = typeCon.arity;
				if (arity >= 0 && arity != Lists.length(nested)) {
					var range = x.range().end();
					TypeParamArityError(range, "type", x.name.image, arity, Lists.length(nested));
					nested = Lists.pad(nested, getErrorType(), arity);
				}
				return x.binding = typeCon.create(nested);
			}
			_ => return V3.fail("unknown unbound type");
		}
	}
	def resolveRefType(typeCon: V3Ref_TypeCon, tref: NamedTypeRef) -> Type {
		var arity = if(tref.nested != null, tref.nested.length());
		if (arity != 1) {
			TypeParamArityError(tref.range().end(), "type", tref.name.image, 1, arity);
			return tref.binding = getErrorType();
		}
		var arg = tref.nested.list.head;
		match (arg) {
			x: NamedTypeRef => {
				if (x.nested == null && verifier.prog.structs != null) {
					var st = verifier.prog.structs[x.name.image];
					if (st != null) {
						if (typeCon.writeable) return tref.binding = st.getDeclaredType();
						return tref.binding = st.readonlyType;
					}
					error(arg.range(), "UnresolvedStruct", Strings.format1("struct \"%s\" cannot be found", x.name.image));
					return tref.binding = getErrorType();
				}
			}
			_ => ; // fall through
		}
		error(arg.range(), "TypeError", Strings.format2("%s expects a struct name, found \"%q\"", tref.name.image, arg.render));
		return tref.binding = getErrorType();
	}
	def getEnumSetType(tref: TypeRef, enumType: EnumType) -> Type {
		if (enumType.setType == null) EnumSetTooLarge(enumType, tref, enumType.enumDecl.cases.length);
		return tref.binding = enumType.setType;
	}
	def newThisParam() -> ParamDecl {
		if (thisParam != null) return thisParam;
		var old: FilePoint;
		if (compound.constructor != null) old = compound.constructor.token;
		else old = compound.token;
		// create a "this" parameter
		var token = Token.new(old.fileName, "this", old.beginLine, old.beginColumn);
		thisParam = ParamDecl.new(token, TypeUtil.typeRefOf(thisType));
		thisParam.vtype = thisType;
		thisParam.isReadOnly = true;
		return thisParam;
	}
	// -- Utility methods to generate errors -----------------------------------
	def TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		// TODO: this method is duplicated in both verifier and type checker
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%s requires type %q and found %q", op, t1.render, t2.render));
		}
	}
	def EnumSetTooLarge(t: Type, tref: TypeRef, size: int) {
		error(tref.range(), "EnumSetTooLarge", Strings.format2("enum \"%q\" has too many cases to build a set (%d)", t.render, size));
	}
	def UnresolvedType(tref: TypeRef) {
		error(tref.range(), "UnresolvedType", Strings.format1("type \"%q\" cannot be found", tref.render));
	}
	def MainMethodError(range: FileRange, msg: string) {
		error(range, "MainMethodError", msg);
	}
	def TypeRedefined(tref: Token) {
		error(tref.range(), "TypeRedefined", Strings.format1("type \"%s\" redefined", tref.image));
	}
	def ParamDeclError(name: Token, msg: string) {
		error(name.rangeOf(0), "ParamDeclError", msg);
	}
	def VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	def FieldDeclError(f: VstMember, msg: string) {
		error(f.token.range(), "FieldDeclError", msg);
	}
	def FieldDeclError2(r: FileRange, msg: string) {
		error(r, "FieldDeclError", msg);
	}
	def ExportDeclError(e: ExportDecl, msg: string) {
		error(e.token.range(), "ExportDeclError", msg);
	}
	def ImportError(m: VstMember, msg: string) {
		error(m.token.range(), "ImportError", msg);
	}
	def IndexDeclError(m: VstMethod, msg: string) {
		error(m.token.rangeOf(0), "IndexDeclError", msg);
	}
	def CaseDeclError(f: VstEnumCase, msg: string) {
		error(f.token.range(), "CaseDeclError", msg);
	}
	def UnimplementedError(body: Stmt, msg: string) {
		error(body.range(), "UnimplementedError", msg);
	}
	def TypeParamArityError(point: FilePoint, kind: string, name: string, expect: int, got: int) {
		var decl = Strings.format2("%s \"%s\"", kind, name), msg: string;
		if (expect == 0) msg = Strings.format1("%s cannot have type arguments", decl);
		else msg = Strings.format3("%s expects %d type arguments and found %d", decl, expect, got);
		error(point.rangeOf(0), "TypeError", msg);
	}
	def InheritanceError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "InheritanceError", msg);
	}
	def InheritanceError2(point: FilePoint, msg: string, t1: Type, t2: Type) {
		error(point.rangeOf(0), "InheritanceError", Strings.format2(msg, t1.render, t2.render));
	}
	def MemberRedefined(decl: Token) {
		error(decl.range(), "MemberRedefined", Strings.format1("member \"%s\" redefined", decl.image));
	}
	def ConstructorError(decl: Token, msg: string) {
		error(decl.range(), "ConstructorError", msg);
	}
	def TypeParamRedefined(tparam: TypeParamType) {
		error(tparam.token.range(), "TypeParamRedefined", Strings.format1("type parameter \"%s\" redefined", tparam.token.image));
	}
	def TypeExprError(range: FileRange, t1: Type) {
		error(range, "TypeError", Strings.format1("type \"%q\" cannot be used as an expression", t1.render));
	}
	def PtrAtFieldError(range: FileRange) {
		error(range, "TypeError",
				"operator \"Pointer.atField\" must be applied to a class or component field reference");
	}
	def MemberNotInitialized(range: FileRange, msg: string) {
		error(range, "MemberNotInitialized", msg);
	}
	def InvalidThisUse(range: FileRange) {
		error(range, "InvalidThisUse", "\"this\" cannot be used in a field initializer");
	}
	def TypeCastError(range: FileRange, fromType: Type, toType: Type, msg: string) {
		error(range, "TypeError", Strings.format3("type cast %q.!(%q) %s", toType.render, fromType.render, msg));
	}
	def TypeQueryError(range: FileRange, fromType: Type, toType: Type, msg: string) {
		error(range, "TypeError", Strings.format3("type query %q.?(%q) %s", toType.render, fromType.render, msg));
	}
	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def getErrorType() -> Type {
		return ERROR.getErrorType();
	}
}

def FLOW_THRU = 0;
def FLOW_END  = 1;
def FLOW_RET  = 2;
def FLOW_NONE = 3;

// Typechecks VST code, resolving all references and types
class TypeChecker(ERROR: ErrorGen, file: VstFile) extends VstVisitor<Type, Type> {
	var methodEnv: MethodEnv;
	var flow: int;			// used to detect unreachable code
	var loopStack: List<int>;	// stack of nested loops
	var elimError: TypeVarEliminator;

	new() {
		elimError = TypeVarEliminator.new(TypeParamInferError);
	}
	def enterMethod(m: MethodEnv) {
		methodEnv = m;
		loopStack = null;
		flow = FLOW_THRU;
	}
	def mergeFlow(a: int, b: int) -> int {
		if (a == FLOW_NONE) return b;
		if (b == FLOW_NONE) return a;
		if (a == FLOW_THRU || b == FLOW_THRU) return FLOW_THRU;
		if (a == FLOW_END || b == FLOW_END) return FLOW_END;
		return a;
	}
	def visitIf(stmt: IfStmt, outer: Type) -> Type {
		typeCheckExpr(stmt.cond, Bool.TYPE, "if condition");
		var tf = typeCheckStmtWithNewScope(stmt.tbranch);
		flow = FLOW_THRU;
		var ff = typeCheckStmtWithNewScope(stmt.fbranch);
		flow = mergeFlow(tf, ff);
		return Void.TYPE;
	}
	def visitBlock(stmt: BlockStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		for (l = stmt.stmts.list; l != null; l = l.tail) typeCheckStmt(l.head);
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def visitWhile(stmt: WhileStmt, outer: Type) -> Type {
		stmt.loopNum = pushLoop();
		typeCheckExpr(stmt.cond, Bool.TYPE, "while condition");
		typeCheckStmtWithNewScope(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		return Void.TYPE;
	}
	def visitFor(stmt: ForStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		checkVarDecl(stmt.varDecl);
		stmt.loopNum = pushLoop();
		typeCheckExpr(stmt.cond, Bool.TYPE, "for condition");
		inferClosedType(stmt.update);
		typeCheckStmtWithNewScope(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def visitForeach(stmt: ForeachStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		var varDecl = stmt.varDecl;
		if (varDecl.init != null) VarDeclError(stmt.varDecl, "foreach variable cannot have an initializer");
		if (varDecl.tref != null) varDecl.vtype = methodEnv.resolveType(varDecl.tref);
		methodEnv.bindVar(varDecl);
		stmt.loopNum = pushLoop();
		stmt.loopVar = VstSsaVar.new(); // synthesize new loop variable
		setAssigned(stmt.loopVar);
		var elemType = getForeachElemType(stmt.expr);
		if (varDecl.tref == null) varDecl.vtype = elemType;
		else if (!isAssignable(elemType, varDecl.vtype)) TypeError(stmt.expr.range(), varDecl.vtype, elemType, "foreach");
		typeCheckStmtWithNewScope(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def getForeachElemType(expr: Expr) -> Type {
		if (VarExpr.?(expr)) {
			// Check for special case of "for (x in Enum)"
			var ve = VarExpr.!(expr);
			if (ve.expr == null) {
				match (methodEnv.lookupVar(VarExpr.!(expr))) {
					Type(t) => {
						if (EnumType.?(t)) return elim(t);
						error(expr.range(), "TypeError", Strings.format1("foreach requires iterable expression and found %s", TYPE(elim(t))));
						return getErrorType();
					}
					_ => ;
				}
			}
		}
		var exprType = inferClosedType(expr);
		if (V3.isArray(exprType) || V3.isRange(exprType)) {
			// an iteration over the elements of an array or range.
			return V3Array.elementType(exprType);
		} else if (EnumSetType.?(exprType)) {
			// an iteration over the contents of an enum set.
			return EnumSetType.!(exprType).enumDecl.getDeclaredType();
		} else {
			// an unknown type.
			error(expr.range(), "TypeError", Strings.format1("foreach requires iterable expression and found %s", TYPE(exprType)));
			return getErrorType();
		}
	}
	def visitForLess(stmt: ForLessStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		var varDecl = stmt.varDecl;
		if (varDecl.init != null) VarDeclError(stmt.varDecl, "foreach variable cannot have an initializer");
		if (varDecl.tref != null) varDecl.vtype = methodEnv.resolveType(varDecl.tref);
		stmt.loopNum = pushLoop();
		var exprType = varDecl.vtype;
		if (exprType != null) {
			typeCheckExpr(stmt.expr, exprType, "foreach limit");
		} else {
			varDecl.vtype = exprType = inferClosedType(stmt.expr);
		}
		if (!IntType.?(exprType)) {
			error(stmt.expr.range(), "TypeError", Strings.format1("foreach requires integral expression and found %s", TYPE(exprType)));
		}
		methodEnv.bindVar(varDecl);
		setAssigned(varDecl.ssa);
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def pushLoop() -> int {
		var loopNum = methodEnv.mdecl.numLoops++;
		loopStack = List.new(loopNum, loopStack);
		return loopNum;
	}
	def popLoop() {
		loopStack = loopStack.tail;
	}
	def visitLocal(stmt: LocalStmt, outer: Type) -> Type {
		Lists.apply(stmt.vars, checkVarDecl);
		return Void.TYPE;
	}
	def checkVarDecl(varDecl: VarDecl) {
		if (varDecl.tref != null) {
			varDecl.vtype = methodEnv.resolveType(varDecl.tref);
			if (varDecl.init != null) {
				typeCheckExpr(varDecl.init, varDecl.vtype, "var initialization");
			}
		} else {
			if (varDecl.init == null) {
				VarDeclError(varDecl, "must have a declared type or an initializer");
				varDecl.vtype = getErrorType();
			} else {
				varDecl.vtype = inferClosedType(varDecl.init);
			}
		}
		methodEnv.bindVar(varDecl);
	}
	def visitBreak(stmt: BreakStmt, outer: Type) -> Type {
		if (loopStack == null) LoopError(stmt.range(), "break must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	def visitContinue(stmt: ContinueStmt, outer: Type) -> Type {
		if (loopStack == null) LoopError(stmt.range(), "continue must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	def visitExpr(stmt: ExprStmt, outer: Type) -> Type {
		var e = stmt.expr;
		inferClosedType(e);
		if (AppExpr.?(e)) return Void.TYPE;
		if (AssignExpr.?(e)) return Void.TYPE;
		if (AutoExpr.?(e)) return Void.TYPE;
		StatementError(e.range());
		return Void.TYPE;
	}
	def visitMatch(stmt: MatchStmt, outer: Type) -> Type {
		var mv = MatchStmtVerifier.new(inferClosedType(stmt.expr), this);
		var bf = FLOW_NONE;
		for (cases = stmt.cases.list; cases != null; cases = cases.tail) {
			var c = cases.head;
			if (c.default != null) { // check default case last
				mv.addDefaultCase(c);
				stmt.defcase = c;
				continue;
			}
			var count = 0;
			for (p = c.patterns.list; p != null; p = p.tail) {
				visitMatchPattern(mv, p.head);
				count++;
			}
			var pat = if(count == 1, c.patterns.list.head);
			flow = FLOW_THRU;
			var bindings = pat != null && (pat.vdecl != null || pat.params != null);
			if (bindings) {
				var prev = methodEnv.env.enterScope();
				bindPatternVariables(mv, pat);
				bf = mergeFlow(bf, typeCheckStmt(c.stmt));
				methodEnv.env.exitScope(prev);
			} else {
				bf = mergeFlow(bf, typeCheckStmt(c.stmt));
			}
		}
		if (stmt.defcase != null) {
			flow = FLOW_THRU;
			mv.addDefaultCase(stmt.defcase);
			flow = mergeFlow(bf, typeCheckStmt(stmt.defcase.stmt));
		} else {
			flow = if(mv.allCovered(), bf, FLOW_THRU);
		}
		mv.end(stmt);
		return Void.TYPE;
	}
	def visitMatchPattern(mv: MatchStmtVerifier, pat: MatchPattern) {
		if (pat.vdecl != null) {
			if (pat.params != null) MatchError(pat.params.range(), "match type cannot have parameters");
			var ttype = methodEnv.resolveType(pat.vdecl.tref);
			pat.vdecl.vtype = ttype;
			return mv.addTypePattern(pat, ttype);
		}
		var e = pat.expr;
		if (Literal.?(e)) {
			typeCheckExpr(e, mv.etype, "match case");
			return assignPatternVal(mv, pat, Literal.!(e).val);
		}
		if (mv.variantType != null) return checkVariantPattern(mv, pat);
		if (mv.enumType != null) return checkEnumPattern(mv, pat);
		if (pat.params != null) return MatchError(pat.params.range(), "match pattern cannot have parameters");
		typeCheckExpr(e, mv.etype, "match case");
		if (!VarExpr.?(e)) return MatchError(e.range(), "match expression is not a constant");
		var ve = VarExpr.!(e);
		match (ve.varbind) {
			ComponentField(field) => {
				if (Literal.?(field.init) && field.writability == Writability.READ_ONLY) {
					return assignPatternVal(mv, pat, Literal.!(field.init).val);
				}
			}
			Const(val, vtype) => {
				return assignPatternVal(mv, pat, val);
			}
			_ => ;
		}
		MatchError(ve.range(), "match expression is not a value");
	}
	def assignPatternVal(mv: MatchStmtVerifier, pat: MatchPattern, val: Val) {
		if (pat.expr.implicitType != null) {
			// perform an implicit conversion of the value if necessary
			var r = Eval.doCast0(pat.expr.exactType, pat.expr.implicitType, val);
			if (r.0) val = r.1;
		}
		mv.addValue(pat, val);
	}
	def bindPatternVariables(mv: MatchStmtVerifier, pat: MatchPattern) {
		if (pat.vdecl != null) return methodEnv.bindVar(pat.vdecl);
		if (pat.variantCase == null) return;  // already an error
		var vt = mv.variantType;
		if (vt == null) return;
		if (pat.decl().params == null) {
			MatchError(pat.params.range(), Strings.format2("case %q.%s has no declared parameters", vt.render, pat.decl().name()));
			return;
		}
		var ll = pat.params.list, pl = pat.decl().params.list;
		var typeArgs = vt.getTypeArgs();
		while (ll != null) {
			if (pl == null) {
				var msg = Strings.format2("case %q.%s", vt.render, pat.decl().name());
				ArityMismatch(ll.head.token.range(), msg, Lists.length(pat.decl().params.list), Lists.length(pat.params.list));
				return;
			}
			ll.head.vtype = pl.head.vtype.substitute(typeArgs);
			methodEnv.bindVar(ll.head);
			ll = ll.tail;
			pl = pl.tail;
		}
		if (pl != null) {
			var msg = Strings.format2("case %q.%s", vt.render, pat.decl().name());
			ArityMismatch(pat.params.range().lastByte(), msg, Lists.length(pat.decl().params.list), Lists.length(pat.params.list));
		}
	}
	def checkVariantPattern(mv: MatchStmtVerifier, pat: MatchPattern) {
		if (!VarExpr.?(pat.expr)) return;
		var ve = VarExpr.!(pat.expr), vt = mv.variantType;
		if (ve.expr != null) {
			return MatchError(ve.range(), Strings.format1("match on type %q requires unqualified case", vt.render));
		}
		var vc = pat.variantCase = vt.lookupCase(ve.ident.name.image);
		if (vc == null) {
			return MatchError(ve.range(), Strings.format2("unresolved case %q.%s", vt.render, ve.ident.name.image));
		}
		mv.addVariantPattern(pat, vc);
	}
	def checkEnumPattern(mv: MatchStmtVerifier, pat: MatchPattern) {
		if (!VarExpr.?(pat.expr)) return;
		var ve = VarExpr.!(pat.expr), vt = mv.enumType;
		if (ve.expr != null) {
			return MatchError(ve.range(), Strings.format1("match on type %q requires unqualified case", vt.render));
		}
		var vc = vt.lookupCase(ve.ident.name.image);
		if (vc == null) {
			return MatchError(ve.range(), Strings.format2("unresolved case %q.%s", vt.render, ve.ident.name.image));
		}
		mv.addEnumPattern(pat, vc);
	}
	def visitEmpty(stmt: EmptyStmt, outer: Type) -> Type {
		return Void.TYPE;
	}
	def visitReturn(stmt: ReturnStmt, outer: Type) -> Type {
		var returnType: Type;
		match (methodEnv.mdecl.rettype) {
			Implicit(expr) => {
				inferClosedType(stmt.expr); // TODO: recurse on member initialization
				flow = FLOW_RET;
				return Void.TYPE;
			}
			Void, This => returnType = Void.TYPE;
			Explicit(tref) => returnType = tref.getType();
		}
		if (stmt.expr != null) typeCheckExpr(stmt.expr, returnType, "return statement");
		else if (returnType != Void.TYPE) TypeError(stmt.src, returnType, Void.TYPE, "return statement");
		flow = FLOW_RET;
		return Void.TYPE;
	}
	def visitTuple(expr: TupleExpr, outer: Type) -> Type {
		var etypes: List<Type>;
		if (outer == null || !V3.isTuple(outer)) {
			// infer the expressions' types if the outer is a not a tuple type
			etypes = expr.exprs.mapList(inferClosedType);
		} else {
			// type check the expressions if the outer is a tuple type
			etypes = Lists.reduce(expr.exprs.list, outer.nested, typeCheckTupleElem);
		}
		typeCheckExprs(expr, etypes, "tuple creation");
		var ttype = Tuple.newType(etypes);
		return ttype;
	}
	def typeCheckTupleElem(e: Expr, t: Type) -> Type {
		typeCheckExpr(e, t, "tuple creation");
		if (e.implicitType != null) return e.implicitType;
		return e.exactType;
	}
	def visitParamExpr(expr: ParamExpr, outer: Type) -> Type {
		ParamExprError(expr.range(), "param expression can only be function call argument");
		return if(outer == null, getErrorType(), outer);
	}
	def visitAutoExpr(expr: AutoExpr, outer: Type) -> Type {
		var t = checkWrite(expr.expr);
		if (IndexExpr.?(expr.expr)) t = visitIndexedRead(IndexExpr.!(expr.expr), outer);
		var op = expr.op;
		if (op == null) op = methodEnv.lookupInfix(expr.infix, t, t);
		if (op == null) {
			UnresolvedOp(expr.token, t, null);
			return t;
		}
		expr.op = op;
		typeCheckExpr(expr.expr, op.sig.returnType(), "auto expression");
		return t;
	}
	def visitArray(expr: ArrayExpr, outer: Type) -> Type {
		var se = expr.exprs.list;
		var etype = Void.TYPE;
		if (outer != null && V3.isArray(outer) || V3.isRange(outer)) {
			etype = outer.nested.head; // element type is first type parameter to array type
		} else {
			if (se == null) {
				TypeInferError(expr.range(), "cannot infer empty array type");
			} else {
				etype = inferClosedType(se.head);
				for (rest = se.tail; rest != null; rest = rest.tail) {
					etype = TypeSystem.widen(etype, inferClosedType(rest.head));
					if (etype == null) {
						TypeInferError(rest.head.range(), "cannot infer type of array");
						return getErrorType();
					}
				}
			}
		}

		Lists.apply(expr.exprs.list, typeCheckExpr(_, etype, "array expression"));

		return V3Array.newType(etype);
	}
	def visitVar(expr: VarExpr, outer: Type) -> Type {
		var binding = lookupBinding(expr, outer);
		match (binding) {
			None => return if(outer == null, getErrorType(), outer);
			PtrAtField(t) => methodEnv.verifier.PtrAtFieldError(expr.range());
//			RefStructRepeatedField,
//			RefStructRepeatedNested => methodEnv.verifier.error(expr.range(), "RepeatedFieldExpr", "repeated field used as an expression");
			Type(t) => methodEnv.verifier.TypeExprError(expr.range(), t);
			_ => ;
		}
		if (outer != null) TypeSystem.unifyWiden(expr.exactType, outer);
		return expr.exactType;
	}
	def visitLiteral(expr: Literal, outer: Type) -> Type {
		return expr.exactType;
	}
	def lookupBinding(expr: VarExpr, outer: Type) -> VarBinding {
		var binding = expr.varbind;
		if (binding.ok()) return binding;  // already bound
		if (expr.expr == null) {
			// "var" -- top level variable
			binding = methodEnv.lookupVar(expr);
			if (binding.none()) UnresolvedIdentifier(expr.ident.name);
			return binding;
		}
		// "expr.var" -- a member expression
		var etype: Type, inType: bool;
		if (VarExpr.?(expr.expr)) {
			// "var.var" -- a member of another var
			binding = lookupBinding(VarExpr.!(expr.expr), outer);
			match (binding) {
				None => ;
				Void => {
					etype = Void.TYPE; inType = true;
					binding = methodEnv.lookupTypeMember(expr, etype);
				}
				Type(t) => {
					etype = t; inType = true;
					binding = methodEnv.lookupTypeMember(expr, etype);
				}
				VariantCase(receiver, vcase) => {
					etype = V3.getSyntheticVariantType(receiver, vcase);
					binding = methodEnv.lookupVariantCaseMember(expr, ClassType.!(etype));
				}
				EnumConst(member) => {
					etype = member.receiver.getDeclaredType();
					binding = methodEnv.lookupEnumConstMember(expr, EnumType.!(etype), member);
				}
				StructName(structName) => {
					binding = methodEnv.lookupStructMember(expr, structName);
				}
				_ => {
					etype = expr.expr.exactType;
					if (etype == null) etype = expr.expr.exactType = getErrorType();
					else binding = methodEnv.lookupExprMember(expr, etype, false);
				}
			}
		} else {
			// "expr.var" -- a member of some other kind of expression
			etype = inferClosedType(expr.expr);
			binding = methodEnv.lookupExprMember(expr, etype, false);
		}
		if (binding.none()) UnresolvedMember(expr.ident.name, inType, etype);
		return binding;
	}
	def visitString(expr: StringExpr, outer: Type) -> Type {
		var vst = methodEnv.verifier.verifier.prog.vst;
		expr.recordIndex = vst.numStrings++;
		return V3.stringType;
	}
	def visitApp(expr: AppExpr, outer: Type) -> Type {
		var funcType: Type;
		match (expr.func) { // pattern-match on function, because Pointer.atField is a syntactic operator
			x: VarExpr => match (lookupBinding(x, null)) {
				None => funcType = getErrorType();
				Void => {
					expr.appbind = AppBinding.Void;
					for (l = expr.args.exprs.list; l != null; l = l.tail) inferClosedType(l.head);
					return expr.exactType = Void.TYPE;
				}
				PtrAtField(t) => return visitPtrAtField(expr, t, outer);
				Type(t) => methodEnv.verifier.TypeExprError(expr.range(), t);
				_ => funcType = x.exactType;
			}
			_ => {
				funcType = inferType(expr.func, null);
			}
		}

		if (!V3.isFunction(funcType)) {
			TypeError(expr.func.range(), getErrorFunctionType(), funcType, "call");
			return getErrorType();
		}
		var partialParamTypes = typeCheckArgs("call", expr.args.exprs, funcType, outer);
		var resultType = Function.getReturnType(funcType);
		if (partialParamTypes != null) {
			// this is a partial application, result is a function
			var boundMap = Vector<int>.new(), i = 1;
			boundMap.put(0);
			var paramTypes: List<Type>;
			for (el = expr.args.exprs.list; el != null; (el = el.tail, i++)) {
				if (ParamExpr.?(el.head)) continue;
				boundMap.put(i);
			}
			resultType = Function.newType(Tuple.newType(Lists.reverse(partialParamTypes)), resultType);
			if (outer != null) TypeSystem.unifyWiden(resultType, outer);
			expr.boundMap = boundMap.extract();
			expr.appbind = AppBinding.Partial(expr.boundMap);
		} else {
			// this is a complete application, its result is the return type
			var varbind: VarBinding, obj: Expr;
			if (VarExpr.?(expr.func)) {
				var v = VarExpr.!(expr.func);
				varbind = v.varbind;
				obj = v.receiver;
			}
			match (varbind) {
				ObjectMethod(receiver, method, typeArgs) => {
					expr.target = obj;
					expr.appbind = AppBinding.CallObjectMethod(receiver, method, typeArgs);
				}
				ComponentMethod(method, typeArgs) => {
					expr.target = obj;
					expr.appbind = AppBinding.CallComponentMethod(method.receiver.getDeclaredType(), method, typeArgs);
				}
				ClassMethod(receiver, method, typeArgs) => {
					expr.target = null;
					expr.appbind = AppBinding.CallClassMethod(receiver, method, typeArgs);
				}
				ClassNew(receiver, member, funcType) => {
					expr.target = null;
					expr.appbind = AppBinding.ClassNew(receiver, member);
				}
				Inst(comp, facts) => {
					expr.target = null;
					expr.appbind = AppBinding.Apply(comp, facts);
				}
				Partial(comp, facts) => {
					expr.target = obj;
					expr.appbind = AppBinding.Apply(comp, facts);
				}
				VariantCase(receiver, member) => {
					if (member.decl.params != null) {
						var variant = V3.getSyntheticVariantType(receiver, member);
						expr.target = null;
						expr.appbind = AppBinding.ClassNew(variant, member.decl.constructor);
					} else {
						expr.appbind = AppBinding.CallClosure(elim(funcType));
					}
				}
				_ => {
					expr.appbind = AppBinding.CallClosure(elim(funcType));
				}
			}
		}

		expr.func.exactType = elim(funcType);
		return elim(resultType);
	}
	def visitPtrAtField(expr: AppExpr, ptrType: Type, outer: Type) -> Type {
		if (expr.args.exprs.length() != 1) {
			methodEnv.verifier.PtrAtFieldError(expr.args.range());
			return getErrorType();
		}
		var arg = expr.args.exprs.first();
		inferClosedType(arg);
		match (arg) {
			x: VarExpr => match (x.varbind) {
				ComponentField(member) => {
					var receiver = member.receiver.getDeclaredType();
					expr.appbind = AppBinding.PtrAtComponentField(receiver, member, ptrType);
					expr.args = TupleExpr.new(VstList.new(expr.args.range(), null));
					expr.target = null;
					return expr.exactType = ptrType;
				}
				ObjectField(receiver, member) => {
					expr.appbind = AppBinding.PtrAtObjectField(receiver, member, ptrType);
					expr.args = TupleExpr.new(VstList.new(expr.args.range(), null));
					expr.target = x.receiver;
					return expr.exactType = ptrType;
				}
				_ => {
					methodEnv.verifier.PtrAtFieldError(arg.range());
				}
			}
			_ => {
				methodEnv.verifier.PtrAtFieldError(arg.range());
			}
		}
		return getErrorType();
	}
	def visitIndex(expr: IndexExpr, outer: Type) -> Type {
		return visitIndexedRead(expr, outer);
	}
	def visitRange(expr: RangeExpr, outer: Type) -> Type {
		if (V3.isArray(outer)) outer = V3Range.newType(V3Array.elementType(outer));
		var exprType = inferType(expr.expr, outer);
		inferIntegralType(expr.start, "range start");
		if (expr.end != null) inferIntegralType(expr.end, "range end");
		if (V3.isArray(exprType)) {
			exprType = V3Range.newType(V3Array.elementType(exprType));
			expr.expr.implicitType = exprType;
		}
		if (!V3.isRange(exprType)) {
			error(expr.expr.range(), "RangeError", Strings.format1("type %s has no range [...] operator", TYPE(exprType)));
			return getErrorType();
		}
		return exprType;
	}
	def getIndexedWriteType(receiver: Type, member: VstMethod) -> Type {
		// trim last parameter, which is the written value
		var rev = Lists.reverse(member.params.list);
		var list = Lists.reverse(rev.tail);
		var typeList = Lists.map(list, TypeUtil.getParamType);
		var funcType = Function.newType(Tuple.newType(typeList), rev.head.vtype);
		var typeArgs = V3.getTypeArgs(receiver);
		if (typeArgs != null) funcType = funcType.substitute(typeArgs);
		return funcType;
	}
	def visitIndexedRead(expr: IndexExpr, outer: Type) -> Type {
		var arrayType = if(outer != null, V3Array.newType(outer)); // try using array type for outer
		var exprType = inferType(expr.expr, arrayType);
		if (V3.isArray(exprType) || V3.isRange(exprType)) {
			return visitArrayIndex(expr, exprType);
		} else if (ClassType.?(exprType)) {
			var varExpr = VarExpr.new(expr, null, VstIdent<TypeRef>.new(null, 0, null));
			var member = methodEnv.resolveClassMember(varExpr, ClassType.!(exprType), "[]");
			if (member != null) {
				var funcType = member.memberType;
				expr.read = AppBinding.CallObjectMethod(member.receiver, member.getMethod(), null);
				typeCheckArgs("indexing", expr.exprs, funcType, outer);
				return Function.getReturnType(funcType);
			}
		} else if (VarExpr.?(expr.expr)) {
			var left = VarExpr.!(expr.expr);
			match (left.varbind) {
				RefStructRepeatedNested(receiver, member) => {
					var mtref = member.mtref;
					expr.receiver = left.expr;
					expr.read = AppBinding.Apply(V3Op.newRefStructAtRepeatedField(
						receiver, member.byteOffset, mtref.scale, mtref.repeatCount, mtref.mtstruct),
						Facts.NONE);
					visitRepeatedIndex(expr.exprs);
					return mtref.getType();
				}
				RefStructRepeatedField(receiver, member) => {
					var mtref = member.mtref;
					expr.receiver = left.expr;
					expr.read = AppBinding.Apply(V3Op.newRefStructGetRepeatedField(
						receiver, member.byteOffset, mtref.scale, mtref.repeatCount, mtref.getType()),
						Facts.NONE);
					visitRepeatedIndex(expr.exprs);
					return mtref.getType();
				}
				_ => ;
			}
		}
		error(expr.exprs.range(), "TypeError", Strings.format1("type %s has no [] operator", TYPE(exprType)));
		return getErrorType();
	}
	def visitIndexedWrite(expr: IndexExpr, outer: Type) -> Type {
		var arrayType = if(outer != null, V3Array.newType(outer)); // try using array type for outer
		var exprType = inferType(expr.expr, arrayType);
		if (V3.isArray(exprType) || V3.isRange(exprType)) {
			return visitArrayIndex(expr, exprType);
		} else if (ClassType.?(exprType)) {
			var varExpr = VarExpr.new(expr, null, VstIdent<TypeRef>.new(null, 0, null));
			var member = methodEnv.resolveClassMember(varExpr, ClassType.!(exprType), "[]=");
			if (member != null) {
				var method = member.getMethod();
				var funcType = getIndexedWriteType(member.receiver, method);
				expr.write = AppBinding.CallObjectMethod(member.receiver, method, null);
				typeCheckArgs("indexing", expr.exprs, funcType, outer);
				return Function.getReturnType(funcType);
			}
		} else if (VarExpr.?(expr.expr)) {
			var left = VarExpr.!(expr.expr);
			match (left.varbind) {
				RefStructRepeatedField(receiver, member) => {
					var mtref = member.mtref;
					expr.receiver = left.expr;
					expr.write = AppBinding.Apply(V3Op.newRefStructSetRepeatedField(
						receiver, member.byteOffset, mtref.scale, mtref.repeatCount, mtref.getType()),
						Facts.NONE);
					visitRepeatedIndex(expr.exprs);
					return mtref.getType();
				}
				_ => ;
			}
		}
		error(expr.exprs.range(), "AssignError", Strings.format1("type %s has no [] assignment operator", TYPE(exprType)));
		return getErrorType();
	}
	def visitArrayIndex(expr: IndexExpr, arrayType: Type) -> Type {
		if (expr.exprs.length() != 1) {
			error(expr.exprs.range(), "TypeError",
				Strings.format1("indexing requires 1 expression, found %d", expr.exprs.length()));
		} else {
			inferIntegralType(expr.exprs.first(), "indexing");
		}
		arrayType = elim(arrayType);
		return arrayType.nested.head;
	}
	def inferIntegralType(expr: Expr, op: string) -> IntType {
		var it = inferClosedType(expr);
		match (it) {
			x: IntType => return x;
			_ => error(expr.range(), "TypeError",
				Strings.format2("%s requires integral type, found %s", op, TYPE(it)));
		}
		return Int.TYPE;
	}
	def visitRepeatedIndex(exprs: VstList<Expr>) {
		if (exprs.length() != 1) {
			error(exprs.range(), "TypeError",
				Strings.format1("indexing requires 1 expression, found %d", exprs.length()));
		} else {
			typeCheckExpr(exprs.first(), Int.TYPE, "indexing"); // TODO: allow any integral type?
		}
	}
	def typeCheckArgs(op: string, args: VstList<Expr>, funcType: Type, outer: Type) -> List<Type> {
		// get the parameter type and parameter type list
		var paramType = Function.getParamType(funcType), ptlist: List<Type>;
		var argList = args.list;
		if (argList == null || argList.tail != null) ptlist = Tuple.toTypeList(paramType);
		else ptlist = List.new(paramType, null); // one arg -> use tuple type

		// infer argument expressions' types, including parameter expressions '_'
		var checkList: List<(Expr, Type)>, tl = ptlist, partialParamTypes: List<Type>;
		for (el = argList; el != null; el = el.tail) {
			var arg = el.head;
			if (tl == null) {
				// too many parameters
				inferClosedType(arg);
				ArityMismatch(arg.range(), op, Lists.length(ptlist), args.length());
				continue;
			}
			var paramType = tl.head;
			if (ParamExpr.?(arg)) {
				var param = ParamExpr.!(arg);
				partialParamTypes = List.new(paramType, partialParamTypes);
			} else if (paramType.hasTypeVars()) {
				// parameter type has type variables
				TypeSystem.unifyWiden(paramType, inferClosedType(arg));
				checkList = List.new((arg, paramType), checkList);
			} else {
				// no type variables; use parameter type to help infer inner types
				typeCheckExpr(arg, paramType, op);
			}
			tl = tl.tail;
		}
		if (tl != null) {
			// too few parameters
			ArityMismatch(args.range().lastByte(), op, Lists.length(ptlist), args.length());
		}
		// Unify the return type with the expected type
		if (partialParamTypes == null && outer != null) {
			TypeSystem.unifyWiden(Function.getReturnType(funcType), outer);
		}
		// typecheck expressions that where the corresponding param type was not closed
		for (cl = checkList; cl != null; cl = cl.tail) {
			typeCheckExpr(cl.head.0, elim(cl.head.1), op);
		}
		return partialParamTypes;
	}
	def visitNot(expr: NotExpr, outer: Type) -> Type {
		typeCheckExpr(expr.expr, Bool.TYPE, "boolean not operator");
		return Bool.TYPE;
	}
	def visitNeg(expr: NegExpr, outer: Type) -> Type {
		if (outer != null) typeCheckExpr(expr.expr, outer, "unary negate operator");
		else inferClosedType(expr.expr);
		var t = expr.expr.implicitType;
		if (t == null) t = expr.expr.exactType;
		if (t != null) expr.op = methodEnv.lookupInfix(V3Infix.Sub, t, null);

		if (expr.op == null) {
			error(expr.expr.range(), "TypeError", Strings.format1("unary negate requires numeric type, found %s", TYPE(t)));
			return Int.TYPE;
		}
		return t;
	}
	def visitBitwiseNeg(expr: BitwiseNegExpr, outer: Type) -> Type {
		if (outer != null) typeCheckExpr(expr.expr, outer, "bitwise negate operator");
		else inferClosedType(expr.expr);
		var t = expr.expr.exactType;
		if (t.typeCon.kind != V3Kind.INT) {
			error(expr.expr.range(), "TypeError", Strings.format1("bitwise negate requires integral type, found %s", TYPE(t)));
			return Int.TYPE;
		}
		return t;
	}
	def checkWrite(left: Expr) -> Type {
		if (IndexExpr.?(left)) {
			var t = visitIndexedWrite(IndexExpr.!(left), null);
			left.exactType = t;
			return t;
		}
		var result = inferClosedType(left);
		var expr: VarExpr;
		if (VarExpr.?(left) && (expr = VarExpr.!(left)).isAssignable(methodEnv.compound)) {
			match (expr.varbind) {
				Local(decl) => setAssigned(decl.ssa);
				_ => ;
			}
			return result;
		}
		AssignError(left.range());
		return result;
	}
	def visitAssign(expr: AssignExpr, outer: Type) -> Type {
		var left = expr.target;
		var ltype = checkWrite(left);
		var infix = expr.infix;
		if (infix != null) {
			if (IndexExpr.?(left)) ltype = visitIndexedRead(IndexExpr.!(left), outer);
			if (infix.op == null) infix.op = methodEnv.lookupInfix(infix.infix, ltype, null);
			if (infix.op == null) {
				UnresolvedOp(infix.token, ltype, null);
				return getErrorType();
			}
			typeCheckExpr(expr.expr, infix.op.sig.paramTypes[1], "compound assignment");
			return infix.op.sig.returnType();
		} else {
			typeCheckExpr(expr.expr, ltype, "assignment");
			return expr.expr.exactType;
		}
	}
	def setAssigned(ssa: VstSsaVar) {
		// update info for an assigned var variable
		if (ssa.index < 0) ssa.index = methodEnv.mdecl.numNonSsa++;
		for (l = loopStack; l != null; l = l.tail) {
			ssa.setWrittenInLoop(l.head);
		}
	}
	def visitBinOp(expr: BinOpExpr, outer: Type) -> Type {
		var ltype = inferClosedType(expr.left), rtype = inferClosedType(expr.right);
		var op = methodEnv.lookupInfix(expr.op.infix, ltype, rtype);
		if (op == null) {
			if (expr.op.infix == V3Infix.EqEq || expr.op.infix == V3Infix.NotEq) ComparisonError(expr.range(), ltype, rtype);
			else UnresolvedOp(expr.op.token, ltype, null);
			return getErrorType();
		}
		expr.set(op);
		if (op.sig == null) return V3.fail("sig null");
		if (op.sig.paramTypes == null) return V3.fail1("paramtypes null %q", op.render);
		typeCheckExpr(expr.left, op.sig.paramTypes[0], "infix operator");
		typeCheckExpr(expr.right, op.sig.paramTypes[1], "infix operator");
		return op.sig.returnType();
	}
	def visitIfExpr(expr: IfExpr, outer: Type) -> Type {
		var args = expr.exprs.asArray(), what = "if expression", len = args.length;
		// 2 or 3 expressions required
		if (len < 2 || len > 3) {
			ArityMismatch(expr.range(), what, 3, len);
			return getErrorType();
		}
		typeCheckExpr(args[0], Bool.TYPE, what);
		var a = args[1], atype = outer;
		if (outer != null) typeCheckExpr(a, outer, what);
		else atype = inferClosedType(a);

		// 1 alternative => Value.BOTTOM for false
		if (len == 2) return atype;

		// 2 alternatives => unify types if necessary
		var b = args[2];
		if (outer != null) {
			typeCheckExpr(b, outer, what);
			return outer;
		}

		// typecheck and unify
		var btype = inferClosedType(b);
		var wtype = TypeSystem.widen(atype, btype);
		if (wtype != null) {
			if (a.exactType != wtype) typeCheckExpr(a, wtype, what);
			if (b.exactType != wtype) typeCheckExpr(b, wtype, what);
			return wtype;
		} else {
			TypeError(expr.range(), atype, btype, what);
			return atype;
		}
	}
	def visitFuncExpr(expr: FuncExpr, outer: Type) -> Type {
		var pl: List<Type>;
		if (FuncType.?(outer)) {
			var el = Function.getParamTypeList(outer);
			for (l = expr.params.list; l != null; l = l.tail) {
				var p = l.head;
				if (p.tref == null) {
					if (el == null) error(p.token.range(), "ParamDeclError", "cannot infer parameter type");
					else p.vtype = el.head;
					pl = List.new(el.head, pl);
				} else {
					pl = List.new(methodEnv.resolveType(p.tref), pl);
				}
			}
		} else {
			for (l = expr.params.list; l != null; l = l.tail) {
				var p = l.head;
				if (p.tref == null) {
					error(p.token.range(), "ParamDeclError", "cannot infer parameter type");
					pl = List.new(getErrorType(), pl);
				} else {
					pl = List.new(p.vtype = methodEnv.resolveType(p.tref), pl);
				}
			}
		}
		var rt: Type;
		match (expr.rettype) {
			Void => {
				rt = typeCheckFuncExprBody(expr.body, Void.TYPE);
			}
			This => {
				rt = typeCheckFuncExprBody(expr.body, methodEnv.compound.getDeclaredType());
			}
			Implicit(expr) => {
				var expected = if(FuncType.?(outer), Function.getReturnType(outer));
				rt = inferFuncExprBodyType(expr, expected);
			}
			Explicit(tref) => {
				rt = typeCheckFuncExprBody(expr.body, methodEnv.resolveType(tref));
			}
		}
		return expr.exactType = Function.newType(Tuple.newType(Lists.reverse(pl)), rt);
	}
	def inferFuncExprBodyType(expr: Expr, expected: Type) -> Type {  // TODO
		return if(expected == null, getErrorType(), expected);
	}
	def typeCheckFuncExprBody(stmt: Stmt, expected: Type) -> Type { // TODO
		return expected;
	}
	def typeCheckExpr(expr: Expr, outerType: Type, op: string) {
		var exactType = expr.exactType;
		if (exactType == null) {
			exactType = expr.accept(this, outerType);
			exactType = elim(exactType);
			expr.exactType = exactType;
		}
		if (exactType != outerType) {
			if (IntLiteral.?(expr)) {
				var rtype = TryRepresentationChangeOfLiteral(IntLiteral.!(expr), outerType);
				if (rtype == outerType) { expr.exactType = rtype; return; }
				if (rtype == null) return;  // error already reported
			}
			if (TypeSystem.isPromotable(exactType, outerType)) expr.implicitType = outerType;
			else TypeError(expr.range(), outerType, exactType, op);
		}
	}
	// Try representation changes of integer literals.
	def TryRepresentationChangeOfLiteral(lit: IntLiteral, outer: Type) -> Type {
		if (FloatType.?(outer)) return TryRepresentationChangeToFloat(lit, outer);
		if (!IntType.?(outer)) return lit.exactType;
		var tt = IntType.!(outer);
		// For all integer literals, suffixes force the type and only allow the normal implicit conversions.
		if (lit.usuffix || lit.lsuffix) return lit.exactType;
		var error: string = null;
		if (HexLiteral.?(lit)) {
			var hex = HexLiteral.!(lit);
			// If the literal is short enough, check whether it is properly sign or zero extended as written.
			// Sign extend the upper bits if necessary.
			var rt = Int.getType(tt.signed, (tt.width + 3) & (-1 ^ 3));  // round up
			if (hex.width * 4 > rt.width) {
				error = "too many hex digits";
			} else {
				var fail: bool;
				if (tt.width <= 32) {
					var o = Int.unbox(hex.val), t = Eval.doIntTrunc32(tt, o);
					if (rt.width > tt.width) fail = (t != Eval.doIntTrunc32(rt, o));
					hex.val = Int.box(t);
				} else {
					var o = Long.unboxSU(hex.val, tt.signed), t = Eval.doIntTrunc64(tt, o);
					if (rt.width > tt.width) fail = (t != Eval.doIntTrunc64(rt, o));
					hex.val = Box.new(t);
				}
				// sign extend or change Box representation if necessary
				if (fail) error = Strings.format1("improperly %s-extended hex literal", if(tt.signed, "sign", "zero"));
			}
		} else if (BinLiteral.?(lit)) {
			// Check the binary literal is short enough to fit in the outer type.
			var bin = BinLiteral.!(lit);
			if (bin.width <= tt.width) {
				// sign extend or change Box representation
				bin.val = Eval.doIntView(IntType.!(bin.exactType), tt, bin.val);
			} else {
				error = "too many binary digits";
			}
		} else if (DecLiteral.?(lit)) {
			// Check that the decimal literal fits in the [min,max] value range.
			var dec = DecLiteral.!(lit), range_error = "decimal out of range";
			var v = dec.val, fsigned = IntType.!(dec.exactType).signed;
			if (dec.negative && !tt.signed) {
				error = "negative decimal used as unsigned";
			} else if (v == null) {
				// == 0, always fits.
			} else if (tt.width <= 32) {
				if (!Box<int>.?(v)) return dec.exactType;
				var i = Int.unbox(v);
				if (tt.width < 32) {
					if (i < Int.unbox(tt.min) || i > Int.unbox(tt.max)) error = range_error;
				} else if (i < 0 && tt.signed != fsigned) {
					error = range_error;;
				}
			} else if (tt.width <= 64) {
				def u = Long.unboxSU, l = u(v, fsigned);
				if (tt.width < 64) {
					if (l < u(tt.min, tt.signed) || l > u(tt.max, tt.signed)) error = range_error;
				} else if (l < 0 && tt.signed != fsigned) {
					error = range_error;
				}
				dec.val = Box.new(l);
			}
		}
		if (error == null) return outer;
		this.error(lit.token.range(), "TypeError", Strings.format3("\"%s\" cannot be %s (%s)", lit.token.image, TYPE(outer), error));
		return null;
	}
	def TryRepresentationChangeToFloat(lit: IntLiteral, outer: Type) -> Type {
		var tt = FloatType.!(outer);
		var ft = IntType.!(lit.exactType);
		var nv: Val;
		if (ft.signed) {
			var v = Long.unboxSU(lit.val, true);
			nv = tt.tryPromoteS(v);
		} else {
			var v = Long.unboxSU(lit.val, false);
			nv = tt.tryPromoteU(0, u64.view(v));
		}
		if (nv == null) {
			this.error(lit.token.range(), "TypeError",
				Strings.format2("\"%s\" cannot be represented in type %s due to rounding",
					lit.token.image, TYPE(outer)));
			return null;
		} else {
			lit.val = nv;
			lit.exactType = outer;
			return outer;
		}
	}
	def typeCheckExprs(args: TupleExpr, types: List<Type>, op: string) {
		var tl = types;
		for (el = args.exprs.list; el != null; el = el.tail) {
			if (tl == null) {
				ArityMismatch(el.head.range(), op, Lists.length(types), args.exprs.length());
				break;
			} else {
				typeCheckExpr(el.head, tl.head, op);
				tl = tl.tail;
			}
		}
		if (tl != null) ArityMismatch(args.exprs.range().lastByte(), op, Lists.length(types), args.exprs.length());
	}
	def inferClosedType(expr: Expr) -> Type {
		if (expr.exactType != null) return expr.exactType;
		return expr.exactType = elim(expr.accept(this, null));
	}
	def inferType(expr: Expr, outerType: Type) -> Type {
		return expr.exactType = expr.accept(this, outerType);
	}
	def typeCheckStmtWithNewScope(stmt: Stmt) -> int {
		if (BlockStmt.?(stmt)) {
			stmt.accept(this, Void.TYPE); // optimization to save an extra scope
		} else if (stmt != null) {
			var prev = methodEnv.env.enterScope();
			stmt.accept(this, Void.TYPE); // assume unreachable code check already performed
			methodEnv.env.exitScope(prev);
		}
		return flow;
	}
	def typeCheckStmt(stmt: Stmt) -> int {
		if (stmt != null) {
			if (flow == FLOW_THRU) stmt.accept(this, Void.TYPE);
			else UnreachableCode(stmt.range());
		}
		return flow;
	}
	def typeCheckBody(stmt: Stmt) {
		if (typeCheckStmt(stmt) != FLOW_RET) {
			match (methodEnv.mdecl.rettype) {
				Void, This, Implicit => ; // do nothing
				Explicit(tref) => if (tref.getType() != Void.TYPE) MissingReturn(stmt.range());
			}
		}
	}
	def elim(vtype: Type) -> Type {
		if (vtype == null) return null;
		return vtype.substitute(elimError);
	}
	def isAssignable(src: Type, dest: Type) -> bool {
		return src == dest || TypeSystem.isPromotable(src, dest);
	}
	// -- Utility methods to generate errors ----------------------------------
	def TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%s requires type %s and found %s", op, TYPE(t1), TYPE(t2)));
		}
	}
	def ComparisonError(range: FileRange, t1: Type, t2: Type) {
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "ComparisonError", Strings.format2("%s cannot be compared to %s", TYPE(t1), TYPE(t2)));
		}
	}
	def TypeParamInferError(tvar: TypeVarType) -> Type {
		if (tvar.error) return getErrorType(); // prevent multiple errors for same type var
		tvar.error = true;
		var msg = tvar.error_msg;
		if (msg == null) {
			msg = Strings.format2("cannot infer type parameter %s of \"%s\"",
				tvar.typeParam.token.image, tvar.token.image);
		}
		error(tvar.token.range().end().rangeOf(0), "TypeError", msg);
		return getErrorType();
	}
	def TypeInferError(range: FileRange, reason: string) {
		error(range, "TypeInferError", reason);
	}
	def VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	def UnresolvedIdentifier(token: Token) {
		error(token.range(), "UnresolvedIdentifier", Strings.format1("identifier \"%s\" cannot be found", token.image));
	}
	def UnresolvedOp(token: Token, t1: Type, t2: Type) {
		var buf = StringBuilder.new().put1("operator \"%s\" cannot be found", token.image);
		if (t1 != null) buf.put1(" for type \"%q\"", t1.render);
		if (t2 != null && t2 != t1) buf.put1(" or type \"%q\"", t2.render);
		error(token.range(), "UnresolvedOp", buf.toString());
	}
	def UnresolvedMember(token: Token, inType: bool, tref: Type) {
		var msg = "expression of type %s has no such member \"%s\"";
		if (inType) msg = "type %s has no such member \"%s\"";
		error(token.range(), "UnresolvedMember", Strings.format2(msg, TYPE(tref), token.image));
	}
	def StatementError(range: FileRange) {
		error(range, "StatementError", "not a statement");
	}
	def UnreachableCode(point: FilePoint) {
		error(point.rangeOf(0), "UnreachableCode", "unreachable code");
	}
	def MissingReturn(point: FilePoint) {
		error(point.rangeOf(0), "MissingReturn", "method does not end in a return statement");
	}
	def AssignError(range: FileRange) {
		error(range, "AssignError", "expression is not assignable");
	}
	def MatchError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "MatchError", msg);
	}
	def LoopError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "LoopError", msg);
	}
	def ParamExprError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "ParamExprError", msg);
	}
	def ArityMismatch(range: FileRange, op: string, expect: int, found: int) {
		if (expect == 1) error(range, "TypeError", Strings.format2("%s requires 1 argument and found %d", op, found));
		else error(range, "TypeError", Strings.format3("%s requires %d arguments and found %d", op, expect, found));
	}
	def getErrorType() -> Type {
		return ERROR.getErrorType();
	}
	def getErrorFunctionType() -> Type {
		return TypeCon.new("function", V3Kind.CLOSURE, 0, methodEnv.verifier.verifier.prog.typeCache).create0();
	}
	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def TYPE(tref: Type) -> string {
		if (tref == null) return "<null>";
		return tref.render(StringBuilder.new()).toString();
	}
}
class ResolvedMember(receiver: Type, member: VstMember, typeArgs: TypeArgs, memberType: Type) {
	def getField() -> VstField { return VstField.!(member); }
	def getMethod() -> VstMethod { return VstMethod.!(member); }
}

// A stateful helper to check various statement-wide properties (e.g. coverage)
// for match statements.
class MatchStmtVerifier(etype: Type, tc: TypeChecker) {
	var variantType: ClassType;
	var enumType: EnumType;
	var valueMap: PartialMap<Val, MatchPattern>;
	var covered: Array<MatchPattern>;
	var default: MatchCase;
	new() {
		if (V3.isVariant(etype)) {
			var vt = ClassType.!(etype);
			while (vt.classDecl.isVariantCase()) vt = vt.getSuperType();
			variantType = vt;
			covered = Array.new(variantType.classDecl.cases.length);
		} else if (EnumType.?(etype)) {
			enumType = EnumType.!(etype);
			covered = Array.new(enumType.enumDecl.cases.length);
		}
	}
	def addValue(pat: MatchPattern, val: Val) {
		if (valueMap == null) {
			valueMap = HashMap.new(Val.hash, Val.equals);
		} else if (valueMap.has(val)) {
			MatchError(pat.expr.range(), "duplicate value", valueMap[val].expr.range());
		}
		pat.val = val;
		valueMap[val] = pat;
	}
	def addVariantPattern(pat: MatchPattern, vc: VstCaseMember) {
		if (covered[vc.tag] != null) {
			MatchError(pat.expr.range(), "duplicate variant pattern", covered[vc.tag].expr.range());
		}
		covered[vc.tag] = pat;
		pat.val = Int.box(vc.tag);
	}
	def addEnumPattern(pat: MatchPattern, vc: VstEnumCase) {
		if (covered[vc.tag] != null) {
			MatchError(pat.expr.range(), "duplicate case", covered[vc.tag].expr.range());
		}
		covered[vc.tag] = pat;
		pat.val = Int.box(vc.tag);
	}
	def addTypePattern(pat: MatchPattern, t: Type) {
		var cast = TypeSystem.newTypeCast(etype, t);
		match (cast) {
			THROW, THROW_IF_NOT_NULL => {
				MatchError(pat.vdecl.tref.range(),
					Strings.format2("key of type %q can never match type %q", etype.render, t.render), null);
			}
			_ => ;
		}
		if (V3.isVariant(t) && variantType != null) {
			var ct = ClassType.!(t);
			if (ct.classDecl.isVariantCase() && TypeSystem.isSubtype(ct, variantType)) {
				var tag = ct.classDecl.variantTag;
				var vc = variantType.classDecl.cases[tag];
				pat.variantCase = vc;
				return addVariantPattern(pat, vc);
			}
		}
	}
	def addDefaultCase(c: MatchCase) {
		if (default != null && default != c) {
			MatchError(c.range(), "duplicate default case", c.range());
		}
		default = c;
	}
	def end(stmt: MatchStmt) {
		if (covered == null) return;
		if (default != null) {
			for (p in covered) {
				if (p == null) return;
			}
			tc.error(default.range(), "UnreachableCode", "unreachable default case");
			return;
		}
		var buf: StringBuilder;
		for (i < covered.length) {
			if (covered[i] == null) {
				var t = if(variantType == null, enumType, variantType);
				if (buf == null) buf = StringBuilder.new().put1("match on type %q does not cover:", t.render);
				var name = if(variantType == null,
					enumType.enumDecl.cases[i].name(),
					variantType.classDecl.cases[i].name());
				buf.puts(" ").puts(name);
			}
		}
		if (buf != null) MatchError(stmt.range(), buf.toString(), null);
	}
	def isVariant() -> bool {
		return variantType != null;
	}
	def isEnum() -> bool {
		return enumType != null;
	}
	def allCovered() -> bool {
		if (covered == null) return false;
		for (p in covered) if (p == null) return false;
		return true;
	}
	def MatchError(range: FileRange, msg: string, prev: FilePoint) {
		msg = formatPrev(msg, prev);
		tc.error(range, "MatchError", msg);
	}
}
def tryUnboxPositiveInt(lit: Literal, nullVal: int) -> int {
	if (lit	== null) return nullVal;
	match (lit.val) {
		x: Box<int> => return x.val;
		x: Box<long> => return if(int.view(x.val) == x.val, int.view(x.val), -1);
		_ => return -1;
	}
}
