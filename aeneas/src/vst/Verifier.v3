// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Performs verification on class and component declarations, including
// resolving all references, enforcing overriding and inheritance rules,
// and typechecking all code
def INDEX_00 = [0];
def N = Facts.NONE;
class Verifier(compiler: Compiler, prog: Program) {
	def ERROR = prog.ERROR;
	var typeCache: TypeCache;
	var mainMethod: VstMethod;
	def env = VarEnvironment.new();

	new() {
		prog.ir = IrModule.new();
	}
	def forAll<T>(vec: Vector<T>, do: T -> void) {
		for (i < vec.length) {
			if (!ERROR.notTooMany) break;
			do(vec[i]);
		}
	}
	def verify() {
		var vst = prog.vst;
		for (f in vst.files) buildFile(f);
		forAll(vst.classes, resolveSuperClass);
		forAll(vst.components, verifyComponent);
		forAll(vst.classes, verifyClass);
		if (vst.exports.length > 0) {
			forAll(vst.exports, verifyExport(Strings.newMap<ExportDecl>(), _));
		}
		forAll<VstComponent>(vst.components, typeCheckVstCompound);
		forAll<VstClass>(vst.classes, typeCheckVstCompound);

		typeCache = null; // typeCache for type vars is now dead
		if (ERROR.noErrors) {
			vst.components.apply(addInitFor);
			vst.classes.apply(addInitFor);
		}
		vst.files = null; // file contents not needed any more
		if (mainMethod != null) {
			var spec = prog.ir.fromVstMemberAndType(mainMethod.receiver.getDeclaredType(), mainMethod);
			prog.mainRootIndex = prog.ir.addRoot(null, spec);
		}
		if (ERROR.noErrors) forAll(vst.exports, addExport);
	}
	def buildFile(file: VstFile) {
		if (file == null) return;
		prog.vst.components.putv(file.components);
		for (i < file.components.length) {
			var componentDecl = file.components[i];
			componentDecl.recordIndex = prog.vst.numComponents++;
			componentDecl.typeCon = V3Component_TypeCon.new(componentDecl, prog.typeCache);
			buildCompound(componentDecl, componentDecl.getDeclaredType(), file, false);
		}
		prog.vst.classes.putv(file.classes);
		for (i < file.classes.length) {
			var classDecl = file.classes[i];
			classDecl.typeCon = V3Class_TypeCon.new(classDecl, prog.typeCache);
			buildCompound(classDecl, classDecl.getDeclaredType(), file, classDecl.superclass != null);
		}
		prog.vst.exports.putv(file.exports);
	}
	def addInitFor(compound: VstCompound) {
		var ctype = compound.getDeclaredType();
		compound.verifier = null;
		var ic = prog.ir.makeIrClass(ctype);
		var constructor = ic.methods[0], init = false;
		if (constructor != null && VstComponent.?(compound)) addInit(constructor);
		if (compound.isEnum() && compound.params != null) {
			createEnumParamArrays(VstClass.!(compound));
			addInit(constructor);
		}
	}
	def addInit(meth: IrMethod) {
		var decl = VstNew.!(meth.source);
		decl.initIndex = prog.ir.init.length;
		prog.ir.init.put(meth);
	}
	def buildCompound(compound: VstCompound, thisType: Type, file: VstFile, hasSuper: bool) {
		compound.verifier = VstCompoundVerifier.new(compound, thisType, this, file);
		if (compound.typeParams != null) compound.typeEnv = compound.verifier.buildTypeEnv(prog.typeEnv, compound.typeParams);
		else compound.typeEnv = prog.typeEnv;
		if (!compound.isSynthetic) bindTypeCon(compound, compound.typeCon);
		buildMembers(compound, hasSuper);
	}
	def buildMembers(compound: VstCompound, hasSuper: bool) {
		compound.memberMap = Strings.newMap();
		for (list = Lists.reverse(compound.getParams()); list != null; list = list.tail) {
			// add synthetic fields for each parameter (classes only)
			var p = list.head;
			var writability = if(p.isReadOnly, Writability.READ_ONLY, Writability.WRITEABLE);
			var field = VstField.new(false, writability, p.token, p.tref, null);
			field.synthetic = true;
			p.member = field;
			compound.members = List.new(field, compound.members);
		}
		for (list = compound.members; list != null; list = list.tail) {
			// process each member, checking for duplicates
			var decl = list.head;
			if (VstNew.?(decl)) {
				// do not put new in the member map, check the constructor field
				var newDecl = VstNew.!(decl);
				if (compound.constructor != null) compound.verifier.MemberRedefined(decl.token);
				else compound.constructor = newDecl;
				decl.receiver = compound;
				continue;
			}
			// look for a previous definition of the member in the map
			var prev = compound.memberMap[decl.token.image];
			if (prev != null) compound.verifier.MemberRedefined(decl.token);
			else compound.memberMap[decl.token.image] = decl;
			decl.receiver = compound;
		}
		var constructor = compound.constructor;
		if (constructor == null) {
			// fill in a default constructor if one wasn't declared
			var name = Token.new(compound.token.fileName, "new", compound.token.beginLine, compound.token.beginColumn);
			var superclause = compound.superclause;
			if(hasSuper && superclause == null) superclause = newSuperClause(compound, name.rangeOf(0));
			var params = VstList.new(name.range(), compound.getParams());
			constructor = VstNew.new(name, params, superclause, BlockStmt.new(VstList<Stmt>.new(name.rangeOf(0), null)));
			constructor.isSynthetic = true;
			constructor.typeEnv = compound.typeEnv;
			constructor.receiver = compound;
			compound.constructor = constructor;
			compound.members = List.new(constructor, compound.members);
			return;
		}
		if (compound.params != null) {
			// class has parameters; copy them to the constructor
			if (constructor.params.length() > 0) compound.verifier.ConstructorError(compound.token, "additional constructor cannot have parameters");
			else constructor.params = compound.params;
		}
		if (compound.superclause != null) {
			// class has superclause; copy it to constructor
			if (constructor.superclause != null) compound.verifier.ConstructorError(compound.token, "super clause already defined");
			else constructor.superclause = compound.superclause;
		}
	}
	def createEnumParamArrays(decl: VstClass) {
		for (l = decl.params.list; l != null; l = l.tail) {
			var field = VstField.!(l.head.member);
			var arrayType = V3Array.newType(field.getType());
			field.enumVals = prog.newRecord(arrayType, decl.cases.length);
		}
	}
	def newSuperClause(compound: VstCompound, where: FileRange) -> SuperClause {
		return SuperClause.new(where, TupleExpr.new(VstList<Expr>.new(where, null)));
	}
	def resolveSuperClass(decl: VstClass) {
		var verifier = decl.verifier;
		if (verifier.onstack) {
			// if this class is on the stack, then there is circular inheritance.
			verifier.InheritanceError(verifier.compound.token, "cyclic inheritance detected");
		} else {
			// the class has not been verified yet.
			if (decl.superclass != null) {
				// bind the super class first.
				var stype = verifier.resolveType(decl.superclass, decl.typeEnv);
				if (stype != null) {
					verifier.onstack = true;
					if (ClassType.?(stype)) resolveSuperClass(ClassType.!(stype).classDecl);
					else verifier.InheritanceError(decl.superclass.token, "cannot extend non-class type");
					verifier.onstack = false;
				}
			}
		}
	}
	def bindTypeCon(decl: VstCompound, typeCon: TypeCon) {
		var prev = prog.typeEnv.lookup(decl.name());
		if (prev != null) decl.verifier.TypeRedefined(decl.token);
		prog.typeEnv.add(typeCon);
	}
	def verifyComponent(decl: VstComponent) {
		decl.verifier.verify();
		// look for the main method
		var main = decl.memberMap["main"];
		if (VstMethod.?(main) && mainMethod == null) {
			mainMethod = VstMethod.!(main);
			if (compiler.target != null) compiler.target.verifyMain(mainMethod, decl.verifier.MainMethodError);
		}
	}
	def verifyClass(decl: VstClass) {
		var verifier = decl.verifier;
		if (!verifier.verified && !verifier.onstack) {
			// the class has not been verified, and is not involved in circular inheritance.
			if (decl.superclass != null) {
				var stype = decl.superclass.getType();
				if (ClassType.?(stype)) {
					verifier.superType = ClassType.!(stype);
					verifier.onstack = true;
					verifyClass(verifier.superType.classDecl);
					verifier.onstack = false;
					verifier.setSuperOrder();
				}
			}
			verifier.verify();
		}
	}
	def verifyExport(map: HashMap<string, ExportDecl>, decl: ExportDecl) {
		var verifier = decl.synthetic.verifier;
		var prev = map[decl.token.image];
		if (prev != null) {
			verifier.ExportDeclError(decl, formatPrev("export redefined", prev.token));
			return;
		}
		map[decl.token.image] = decl;
		var cv = decl.synthetic.verifier;
		var tc = TypeChecker.new(ERROR, cv.file);
		var methodEnv = MethodEnv.new(decl.synthetic, null, null, cv, env);
		tc.enterMethod(methodEnv);
		tc.visitVar(decl.expr, null);
		if (!VarBinding.ComponentMethod.?(decl.expr.varbind)) {
			verifier.ExportDeclError(decl, "export must be a component or top-level method");
		}
	}
	def addExport(decl: ExportDecl) {
		var binding = VarBinding.ComponentMethod.!(decl.expr.varbind);
		var spec = VstIr.specOf(prog.ir, binding.member.receiver.getDeclaredType(), binding.member, binding.typeArgs);
		prog.ir.addRoot(decl.token.image, spec);
	}
	def typeCheckVstCompound(compound: VstCompound) {
		var tc = TypeChecker.new(ERROR, compound.verifier.file);
		for (members = compound.members; members != null; members = members.tail) {
			match (members.head) {
				x: VstNew => {
					typeCheckNew(compound, x, tc);
				}
				x: VstMethod => {
					var cv = compound.verifier;
					var env = MethodEnv.new(compound, x, cv.newThisParam(), cv, env);
					if (!EmptyStmt.?(x.body)) {
						tc.enterMethod(env);
						tc.typeCheckBody(x.body);
					}
				}
				x: VstCaseMember => {
					var env = MethodEnv.new(compound, null, null, compound.verifier, env);
					tc.enterMethod(env);
					typeCheckCaseMember(VstClass.!(compound), x, tc);
				}
			}
		}
	}
	def typeCheckNew(compound: VstCompound, cdecl: VstNew, tc: TypeChecker) {
		var cv = compound.verifier, thisParam = cv.newThisParam();
		var initEnv: MethodEnv;
		if (VstClass.?(compound)) {
			// track field initialization state for class constructors
			initEnv = MethodEnv.new(compound, null, thisParam, cv, env);
		} else {
			initEnv = MethodEnv.new(compound, cdecl, thisParam, cv, env);
			if (cdecl.params.length() > 0) compound.verifier.ParamDeclError(cdecl.params.first().token, "components cannot have constructor parameters");
		}
		// check parameters
		tc.enterMethod(initEnv);
		for (params = cdecl.params.list; params != null; params = params.tail) {
			var f = params.head.member;
			if (f != null) {
				var dest = f.getType();
				var from = params.head.vtype;
				if (dest == null) dest = ERROR.getErrorType();
				if (!tc.isAssignable(from, dest)) {
					compound.verifier.TypeError(params.head.token.range(), dest, from, "implicit field initialization");
				}
			}
		}
		// check field initializers
		for (list = compound.members; list != null; list = list.tail) {
			var m = list.head;
			if (VstField.?(m)) {
				var fdecl = VstField.!(m);
				if (fdecl.init != null) {
					initEnv.initOrder = fdecl.initOrder;
					initEnv.initField = fdecl;
					if (fdecl.tref != null) tc.typeCheckExpr(fdecl.init, fdecl.tref.getType(), "field initialization");
					else if (fdecl.vtype == null) inferFieldType(fdecl, initEnv, tc);
				}
			}
		}
		// check super clause
		initEnv = MethodEnv.new(compound, cdecl, thisParam, cv, env);
		tc.enterMethod(initEnv);
		if (cv.superType != null) {
			initEnv.initOrder = cv.superInitOrder;
			var typeArgs = cv.superType.getTypeArgs();
			var funcType = cv.superType.classDecl.constructor.getType().substitute(typeArgs);
			var argTypes = Function.getParamTypeList(funcType);
			tc.typeCheckExprs(cdecl.superclause.args, argTypes, "super constructor");
		}
		// check constructor body
		initEnv.initOrder = 0; // all fields can be used in the constructor
		tc.typeCheckBody(cdecl.body);
	}
	def typeCheckCaseMember(classDecl: VstClass, c: VstCaseMember, tc: TypeChecker) {
		var paramTypes: List<Type>;
		if (classDecl.params != null) {
			// extract parameter types.
			for (params = classDecl.params.list; params != null; params = params.tail) {
				paramTypes = List.new(params.head.vtype, paramTypes);
			}
			paramTypes = Lists.reverse(paramTypes);
		}
		if (c.args != null) {
			// typecheck arguments to enum.
			var args = c.args.list;
			var what = "case declaration";
			for (i = 0; args != null; (args = args.tail, paramTypes = paramTypes.tail)) {
				if (paramTypes != null) {
					tc.typeCheckExpr(args.head, paramTypes.head, what);
				} else {
					tc.ArityMismatch(args.head.range(), what, classDecl.params.length(), c.args.length());
					return;
				}
			}
			if (paramTypes != null) tc.ArityMismatch(c.token.range(), what, classDecl.params.length(), c.args.length());
		} else {
			// expected parameters, but none were provided.
			if (paramTypes != null) classDecl.verifier.CaseDeclError(c, "expected case arguments, but none provided");
		}
	}
	def inferFieldType(fdecl: VstField, initEnv: MethodEnv, tc: TypeChecker) -> Type {
		var compound = fdecl.receiver, cv = compound.verifier;
		fdecl.initEnv = initEnv;
		initEnv.initField = fdecl;
		fdecl.vtype = tc.inferClosedType(fdecl.init);
		fdecl.initEnv = null;
		return fdecl.vtype;
	}
	def isNonTrivialInitializer(fdecl: VstField) -> bool {
		return fdecl.writability != Writability.READ_ONLY || !Literal.?(fdecl.init);
	}
	def isNonTrivialSuperclause(superclause: SuperClause) -> bool {
		if (superclause == null) return false;
		for (l = superclause.args.exprs.list; l != null; l = l.tail) {
			var expr = l.head;
			if (Literal.?(expr)) continue;
			if (VarExpr.?(expr) && VarExpr.!(expr).isLocal()) continue;
			return true;
		}
		return false;
	}
}
def formatPrev(msg: string, prev: FilePoint) -> string {
	return if (prev != null, Strings.format3("%1 (previous at %2:%3)", msg, prev.beginLine, prev.beginColumn), msg);
}
class VstCompoundVerifier {
	def compound: VstCompound;
	def thisType: Type;
	def verifier: Verifier;
	def file: VstFile;
	var typeEnv: TypeEnv;
	var ERROR: ErrorGen;
	var classDecl: VstClass;
	var classType: ClassType;
	var superType: ClassType;

	var memberinits: List<VstField>;
	var fields: List<VstField>;
	var thisParam: ParamDecl;
	var initMax: int;
	var superInitOrder: int;

	var onstack: bool;
	var verified: bool;
	var isImport: bool;

	new(compound, thisType, verifier, file) {
		ERROR = verifier.ERROR;
		if (VstClass.?(compound)) {
			classDecl = VstClass.!(compound);
			classType = ClassType.!(thisType);
		} else if (VstComponent.?(compound)) {
			isImport = VstComponent.!(compound).isImport;
		}
	}
	def setSuperOrder() {
		superInitOrder = superType.classDecl.verifier.initMax;
		classDecl.numFields = superType.classDecl.numFields;
		classDecl.numMethods = superType.classDecl.numMethods;
	}
	def verify() {
		Lists.apply(compound.members, checkMember);
		if (compound.constructor != null) {
			compound.constructor.memberinits = Lists.reverse(memberinits);
		}
		verified = true;
		if (classType != null) {
			initMax = 1 + superInitOrder;
			for (l = fields; l != null; l = l.tail) {
				l.head.initOrder = initMax++;
			}
			for (l = compound.constructor.params.list; l != null; l = l.tail) {
				var p = l.head;
				if (p.member != null) p.member.initOrder = initMax;
			}
		}
	}
	def buildTypeEnv(parent: TypeEnv, typeParams: List<TypeParam>) -> TypeEnv {
		var typeEnv = TypeEnv.new(parent, typeParams, null);
		for (plist = typeParams; plist != null; plist = plist.tail) {
			var tparam = plist.head;
			if (typeEnv.typecons[tparam.token.image] != null) TypeParamRedefined(tparam);
			typeEnv.add(tparam.typeCon);
		}
		return typeEnv;
	}
	def checkMember(decl: VstMember) {
		if (VstNew.?(decl)) checkNew(VstNew.!(decl));
		else if (VstField.?(decl)) checkField(VstField.!(decl));
		else if (VstMethod.?(decl)) checkMethod(VstMethod.!(decl));
	}
	def checkField(decl: VstField) {
		if (isImport) ImportError(decl, "imported components cannot contain field declarations");
		if (decl.tref != null) {
			decl.vtype = resolveType(decl.tref, compound.typeEnv);
		} else if (decl.init == null) {
			FieldDeclError(decl, "must have a declared type or an initializer");
			decl.vtype = getErrorType();
		}
		decl.index = compound.numFields++;
		if (classDecl != null) {
			var binding = lookupSuperMember(decl.name());
			if (binding != null && !binding.member.isPrivate) MemberRedefined(decl.token);
		}
		fields = List.new(decl, fields);
		if (decl.init != null) {
			memberinits = List.new(decl, memberinits);
			if (verifier.isNonTrivialInitializer(decl)) {
				if (compound.constructor != null) compound.constructor.markNontrivial();
			}
		}
		if (compound.isVariant() && !decl.synthetic) FieldDeclError(decl, "type cannot have an explicit field");
	}
	def checkNew(decl: VstNew) {
		typeEnv = compound.typeEnv;
		var map: Map<string, Decl> = Strings.newMap();
		Lists.apply(decl.params.list, checkNewParam(_, decl, map));
		if (classDecl != null) {
			if (superType != null) {
				if (decl.superclause == null) decl.superclause = verifier.newSuperClause(compound, decl.params.range());
				var superCons = superType.classDecl.constructor;
				decl.superclause.constructor = superCons;
				if (superCons.nontrivial()) decl.markNontrivial();
			} else if (decl.superclause != null) {
				InheritanceError(decl.superclause.point, "class has no super class");
			}
		} else if (decl.superclause != null) {
			InheritanceError(decl.superclause.point, "component constructor cannot have super() call");
		}
		decl.root = decl;
		if (BlockStmt.!(decl.body).stmts.list != null || verifier.isNonTrivialSuperclause(decl.superclause)) {
			decl.markNontrivial();
		}
		if (compound.isVariant() && !decl.isSynthetic) ConstructorError(decl.token, "type cannot have a constructor");
	}
	def checkMethod(decl: VstMethod) {
		if (isImport) {
			if (decl.isImport = EmptyStmt.?(decl.body)) {
				if (decl.typeParams != null) ImportError(decl, "imported methods cannot have type parameters");
			}
		}
		typeEnv = compound.typeEnv;
		if (decl.isIndexed() && VstComponent.?(compound)) {
			var msg = if (compound.isFileScope,
				"index operation cannot be declared at top level",
				"index operation cannot be declared in component");
			IndexDeclError(decl, msg);
		}
		if (compound.isVariantCase() && EmptyStmt.?(decl.body)) {
			UnimplementedError(decl.body, "variant method must have a body");
		}
		if (decl.typeParams != null) typeEnv = decl.typeEnv = buildTypeEnv(typeEnv, decl.typeParams);
		if (decl.params.list != null) {
			var map = Strings.newMap<Decl>();
			Lists.apply(decl.params.list, checkMethodParam(_, map));
		}
		resolveType(decl.rettype, typeEnv);
		var binding = lookupSuperMember(decl.name());
		if (binding != null) return checkMethodOverride(decl, binding);
		decl.root = decl;
		decl.index = compound.numMethods++;
	}
	def lookupSuperMember(name: string) -> ResolvedMember {
		// XXX: reduce duplicated code with MethodEnv.lookupClassMember
		if (superType == null) return null;
		var classType = superType;
		while (true) {
			// lookup a field or method
			var member = classType.classDecl.memberMap[name];
			if (member != null) {
				if (member.isPrivate) return null;
				var memberType = member.getType();
				if (memberType != null) memberType = memberType.substitute(classType.getTypeArgs());
				return ResolvedMember.new(classType, member, null, memberType);
			}
			// member was not found in this type
			classType = classType.getSuperType();
			if (classType == null) return null;
		}
		return null;
	}
	def checkMethodOverride(decl: VstMethod, binding: ResolvedMember) {
		if (VstMethod.?(binding.member)) {
			var superDecl = VstMethod.!(binding.member);
			var superMethodType = binding.memberType;
			var methodType = decl.getType();
			decl.index = superDecl.index;
			decl.root = superDecl.root;
			if (superDecl.typeEnv != null) {
				// substitute super method's type parameters with overriden method's
				if (decl.typeEnv == null || decl.typeEnv.paramArray.length != superDecl.typeEnv.paramArray.length) {
					return InheritanceError(decl.token, "cannot override method type parameters");
				}
				var typeArgs = TypeArgs.new(superDecl.typeEnv, decl.typeEnv.paramArray);
				superMethodType = superMethodType.substitute(typeArgs);
				// the overriden method's complete type must be subtype of the super
				// use the same vtable index as the parent.
			} else if (decl.typeEnv != null) {
				return InheritanceError(decl.token, "cannot override method type parameters");
			}
			if (superDecl.returnThis) {
				if (!decl.returnThis) return InheritanceError(decl.token, "super method returns this");
			} else {
				if (decl.returnThis) return InheritanceError(decl.token, "super method does not return this");
			}

			if (!TypeSystem.isSubtype(methodType, superMethodType)) {
				InheritanceError2(decl.token, "method signature %1 cannot override %2", methodType, superMethodType);
			}
		} else {
			InheritanceError(decl.token, "cannot override non-method member");
			decl.root = decl;
		}
	}
	def checkParam(param: ParamDecl, map: Map<string, Decl>) {
		if (map[param.name()] != null) ParamDeclError(param.token, Strings.format1("parameter \"%1\" redefined", param.name()));
		map[param.name()] = param;
	}
	def checkNewParam(param: ParamDecl, mdecl: VstNew, map: Map<string, Decl>) {
		checkParam(param, map);
		var member = compound.memberMap[param.name()];
		if (VstField.?(member)) {
			param.member = VstField.!(member);
			mdecl.markNontrivial();
			if (param.tref == null) {
				var decl = VstField.!(member);
				if (decl.tref != null) param.vtype = resolveType(decl.tref, compound.typeEnv);
				else {
					FieldDeclError(decl, "parameter must refer to a field with a declared type");
					param.vtype = getErrorType();
				}
				if (decl.init != null) FieldDeclError(decl, "parameter cannot refer to a field with an initializer");
			}
		}
		if (param.vtype == null) {
			if (param.tref == null) {
				ParamDeclError(param.token, "parameter must have a declared type or refer to a field");
				param.vtype = getErrorType();
			}
			else param.vtype = resolveType(param.tref, compound.typeEnv);
		}
	}
	def checkMethodParam(param: ParamDecl, map: Map<string, Decl>) {
		checkParam(param, map);
		param.vtype = resolveType(param.tref, typeEnv);
	}
	def resolveType(tref: TypeRef, typeEnv: TypeEnv) -> Type {
		if (tref.rtype != null) return tref.rtype;
		if (tref.left != null) {
			var leftType = resolveType(tref.left, typeEnv);
			if (V3.isVariant(leftType)) {
				// Variant.Case resolution.
				var member = ClassType.!(leftType).classDecl.memberMap[tref.token.image];
				if (VstCaseMember.?(member)) {
					tref.typeCon = VstCaseMember.!(member).decl.typeCon;
					if (tref.typeRefs != null) {
						TypeParamArityError(tref.token.range(), "variant case type", tref.token.image, 0, Lists.length(tref.typeRefs));
					}
					return tref.rtype = tref.typeCon.create(leftType.nested);
				}
			} else if (leftType.typeCon.kind == V3Kind.ENUM) {
				// Enum.set resolution.
				if (Strings.equal(tref.token.image, "set")) {
					var classType = ClassType.!(leftType);
					return getEnumSetType(tref, classType);
				}
			}
			UnresolvedType(tref);
			return SetErrorType(tref);
		}
		if (tref.typeCon == null) {
			if ((tref.typeCon = typeEnv.lookup(tref.token.image)) == null) {
				UnresolvedType(tref);
				SetErrorType(tref);
			}
		}
		var nested: List<Type>;
		if (tref.typeRefs != null) nested = Lists.map(tref.typeRefs, resolveType(_, typeEnv));
		var arity = tref.typeCon.arity;
		if (arity >= 0 && arity != Lists.length(nested)) {
			var range = tref.range().end();
			TypeParamArityError(range, "type", tref.token.image, arity, Lists.length(nested));
			nested = Lists.pad(nested, getErrorType(), arity);
		}
		return tref.rtype = tref.typeCon.create(nested);
	}
	def getEnumSetType(tref: TypeRef, classType: ClassType) -> Type {
		var decl = classType.classDecl;
		if (decl.enumSetTypeCon == null) {
			if (decl.cases.length > Int.MAX_WIDTH) {
				EnumSetTooLarge(classType, tref, decl.cases.length);
				return SetErrorType(tref);
			}
			decl.enumSetTypeCon = V3EnumSet_TypeCon.new(decl, verifier.prog.typeCache);
		}
		return tref.rtype = decl.enumSetTypeCon.create0();
	}
	def SetErrorType(tref: TypeRef) -> Type {
		tref.typeCon = ERROR.getErrorTypeCon(tref.token.image);
		return tref.rtype = tref.typeCon.create(null);
	}
	def newThisParam() -> ParamDecl {
		if (thisParam != null) return thisParam;
		var old: FilePoint;
		if (compound.constructor != null) old = compound.constructor.token;
		else old = compound.token;
		// create a "this" parameter
		var token = Token.new(old.fileName, "this", old.beginLine, old.beginColumn);
		thisParam = ParamDecl.new(token, TypeUtil.typeRefOf(thisType));
		thisParam.vtype = thisType;
		thisParam.isReadOnly = true;
		return thisParam;
	}
	// -- Utility methods to generate errors -----------------------------------
	def TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		// TODO: this method is duplicated in both verifier and type checker
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%1 requires type %2 and found %3", op, t1.render, t2.render));
		}
	}
	def EnumSetTooLarge(t: Type, tref: TypeRef, size: int) {
		error(tref.range(), "EnumSetTooLarge", Strings.format2("enum \"%1\" has too many cases to build a set (%2)", t.render, size));
	}
	def UnresolvedType(tref: TypeRef) {
		error(tref.range(), "UnresolvedType", Strings.format1("type \"%1\" cannot be found", tref.render));
	}
	def MainMethodError(range: FileRange, msg: string) {
		error(range, "MainMethodError", msg);
	}
	def TypeRedefined(tref: Token) {
		error(tref.range(), "TypeRedefined", Strings.format1("type \"%1\" redefined", tref.image));
	}
	def ParamDeclError(name: Token, msg: string) {
		error(name.rangeOf(0), "ParamDeclError", msg);
	}
	def VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	def FieldDeclError(f: VstField, msg: string) {
		error(f.token.range(), "FieldDeclError", msg);
	}
	def ExportDeclError(e: ExportDecl, msg: string) {
		error(e.token.range(), "ExportDeclError", msg);
	}
	def ImportError(m: VstMember, msg: string) {
		error(m.token.range(), "ImportError", msg);
	}
	def IndexDeclError(m: VstMethod, msg: string) {
		error(m.token.rangeOf(0), "IndexDeclError", msg);
	}
	def CaseDeclError(f: VstCaseMember, msg: string) {
		error(f.token.range(), "CaseDeclError", msg);
	}
	def UnimplementedError(body: Stmt, msg: string) {
		error(body.range(), "UnimplementedError", msg);
	}
	def TypeParamArityError(point: FilePoint, kind: string, name: string, expect: int, got: int) {
		var decl = Strings.format2("%1 \"%2\"", kind, name), msg: string;
		if (expect == 0) msg = Strings.format1("%1 cannot have type arguments", decl);
		else msg = Strings.format3("%1 expects %2 type arguments and found %3", decl, expect, got);
		error(point.rangeOf(0), "TypeError", msg);
	}
	def InheritanceError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "InheritanceError", msg);
	}
	def InheritanceError2(point: FilePoint, msg: string, t1: Type, t2: Type) {
		error(point.rangeOf(0), "InheritanceError", Strings.format2(msg, t1.render, t2.render));
	}
	def MemberRedefined(decl: Token) {
		error(decl.range(), "MemberRedefined", Strings.format1("member \"%1\" redefined", decl.image));
	}
	def ConstructorError(decl: Token, msg: string) {
		error(decl.range(), "ConstructorError", msg);
	}
	def TypeParamRedefined(tparam: TypeParam) {
		error(tparam.token.range(), "TypeParamRedefined", Strings.format1("type parameter \"%1\" redefined", tparam.token.image));
	}
	def TypeExprError(range: FileRange, t1: Type) {
		error(range, "TypeError", Strings.format1("type \"%1\" cannot be used as an expression", t1.render));
	}
	def MemberNotInitialized(range: FileRange, msg: string) {
		error(range, "MemberNotInitialized", msg);
	}
	def InvalidThisUse(range: FileRange) {
		error(range, "InvalidThisUse", "\"this\" cannot be used in a field initializer");
	}
	def TypeCastError(range: FileRange, fromType: Type, toType: Type, msg: string) {
		error(range, "TypeError", Strings.format3("type cast %2.!(%1) %3", fromType.render, toType.render, msg));
	}
	def TypeQueryError(range: FileRange, fromType: Type, toType: Type, msg: string) {
		error(range, "TypeError", Strings.format3("type query %2.?(%1) %3", fromType.render, toType.render, msg));
	}
	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def getErrorType() -> Type {
		return ERROR.getErrorType();
	}
}

class MethodEnv {
	def compound: VstCompound;
	def mdecl: VstMethod;
	def verifier: VstCompoundVerifier;
	def thisParam: ParamDecl;
	def env: VarEnvironment;

	var typeEnv: TypeEnv;
	var initField: VstField;
	var initPrev: MethodEnv;
	var initOrder: int;

	new(compound, mdecl, thisParam, verifier, env) {
		if (mdecl != null) {
			typeEnv = mdecl.typeEnv;
			if (typeEnv == null) typeEnv = compound.typeEnv;
		} else {
			typeEnv = compound.typeEnv;
		}

		env.reset();
		env.enterScope();
		if (mdecl != null) {
			var count = 1;
			if (compound.isFileScope) thisParam.ssa = VstSsaVar.new(); // XXX: move to VstSsaBuilder
			else bindVar(thisParam); // "this" for methods and fields in components and classes
			mdecl.thisParam = thisParam;
			for (params = mdecl.params.list; params != null; params = params.tail) {
				params.head.index = count;
				bindVar(params.head);
				count++;
			}
			mdecl.numParams = count;
		}
	}
	def objExpr(useThis: bool, token: Token, expr: VarExpr) -> Expr {
		if (!useThis) return expr.expr;
		var thisExpr = VarExpr.new(null, token.copy(""), expr.ident);
		thisExpr.varbind = VarBinding.Local(thisParam);
		thisExpr.exactType = verifier.thisType;
		return thisExpr;
	}

	// =============================================================================
	// === Array members ===========================================================
	def lookupArrayTypeMember(expr: VarExpr, arrayType: Type) -> VarBinding {
		// lookup (type: array).name
		var name = expr.ident.name;
		if (Strings.equal("new", name.image)) return newCompBinding(expr, V3Op.newArrayAlloc(arrayType));
		if (Strings.equal("length", name.image)) return newCompBinding(expr, V3Op.newArrayGetLength(arrayType));
		return VarBinding.None;
	}
	def lookupArrayExprMember(expr: VarExpr, arrayType: Type) -> VarBinding {
		// lookup (expr: array).name
		var name = expr.ident.name;
		if (Strings.equal("length", name.image)) {
			var op = V3Op.newArrayGetLength(arrayType);
			return expr.bind(expr.expr, VarBinding.Apply(op, N), op.sig.returnType());
		}
		return VarBinding.None;
	}

	// =============================================================================
	// === Component members =======================================================
	def lookupComponentTypeMember(expr: VarExpr, etype: Type) -> VarBinding {
		// lookup (type: component).name
		var name = expr.ident.name;
		var binding = lookupComponentMember(expr, null, etype, name.image);
		return binding;
	}
	def lookupComponentExprMember(expr: VarExpr, etype: Type, useThis: bool) -> VarBinding {
		// lookup (expr: component).name
		var name = expr.ident.name;
		var binding = lookupComponentMember(expr, expr.expr, etype, name.image);
		if (binding.ok()) expr.receiver = objExpr(useThis, name, expr);
		return binding;
	}

	// =============================================================================
	// === Class members ===========================================================
	def lookupClassTypeMember(expr: VarExpr, classType: ClassType) -> VarBinding {
		// lookup (type: class).name
		var name = expr.ident.name;
		if (Strings.equal("new", name.image)) {
			// found constructor
			var member = classType.classDecl.constructor;
			var typeArgs = classType.getTypeArgs();
			var memberType = inferMemberType(member).substitute(typeArgs);
			var param = Function.getParamType(memberType);
			var newType = Function.newType(param, classType);
			return expr.bind(null, VarBinding.ClassNew(classType, VstNew.!(member), newType), newType);
		}
		var member = resolveClassMember(expr, classType, name.image);
		if (member == null) return VarBinding.None;
		if (VstField.?(member.member)) {
			var memberType = Function.newType(member.receiver, member.memberType);
			return expr.bind(null, VarBinding.ClassField(member.receiver, member.getField()), memberType);
		}
		if (VstMethod.?(member.member)) {
			var memberType = Function.prependParamType(member.receiver, member.memberType);
			return expr.bind(null, VarBinding.ClassMethod(member.receiver, member.getMethod(), member.typeArgs), memberType);
		}
		return VarBinding.None;
	}
	def lookupClassExprMember(expr: VarExpr, classType: ClassType, useThis: bool) -> VarBinding {
		// lookup (expr: class).name
		var name = expr.ident.name;
		var member = resolveClassMember(expr, classType, name.image);
		if (member == null) return VarBinding.None;
		var receiver = objExpr(useThis, name, expr);
		if (VstField.?(member.member)) {
			return expr.bind(receiver, VarBinding.ObjectField(member.receiver, member.getField()), member.memberType);
		}
		if (VstMethod.?(member.member)) {
			var m = VstMethod.!(member.member);
			return expr.bind(receiver, VarBinding.ObjectMethod(member.receiver, member.getMethod(), member.typeArgs), member.memberType);
		}
		return VarBinding.None;
	}
	def resolveClassMember(expr: VarExpr, classType: ClassType, name: string) -> ResolvedMember {
		var exprType = classType;
		var member = classType.classDecl.memberMap[name];
		// keep searching up the hierarchy until found
		while (member == null) {
			// member was not found in this type
			classType = classType.getSuperType();
			if (classType == null) return null;
			member = classType.classDecl.memberMap[name];
		}
		if (isNotAccessible(member)) return null;
		var typeArgs = classType.getTypeArgs();
		var memberType = inferMemberType(member).substitute(typeArgs);
		if (VstField.?(member)) {
			makeTypeArgsList("field", expr, null);  // check no explicit type args
			return ResolvedMember.new(classType, member, null, memberType);
		}
		if (VstMethod.?(member)) {
			var meth = VstMethod.!(member);
			if (meth.returnThis) {
				var paramType = Function.getParamType(memberType);
				memberType = Function.newType(paramType, exprType);
			}
			var result = ResolvedMember.new(classType, meth, null, memberType);
			var list = makeTypeArgsList("method", expr, meth.typeParams);
			if (list != null) {
				var ta = TypeArgs.new(meth.typeEnv, Lists.toArray(list));
				memberType = memberType.substitute(ta);
				result = ResolvedMember.new(classType, meth, ta, memberType);
			}
			return result;
		}
		return if(member != null, ResolvedMember.new(classType, member, typeArgs, memberType));
	}

	// =============================================================================
	// === Tuple members ===========================================================
	def lookupTupleExprMember(expr: VarExpr, tupleType: Type) -> VarBinding {
		// lookup (expr: tuple).name
		var name = expr.ident.name;
		var ival: Box<int>, len = Lists.length(tupleType.nested);
		if (Strings.equal("last", name.image)) ival = Int.box(len - 1);
		else ival = Int.parseDecimal(name.image);
		if (ival != null && ival.val >= 0 && ival.val < len) {
			return newApplyCompBinding(expr, expr.expr, V3Op.newTupleGetElem(tupleType, ival.val));
		}
		return VarBinding.None;
	}

	// =============================================================================
	// === Variant members =========================================================
	def lookupVariantTypeMember(expr: VarExpr, variantType: ClassType) -> VarBinding {
		// lookup (type: variant).name
		var name = expr.ident.name;
		var member = resolveClassMember(expr, variantType, name.image);
		if (member == null) return VarBinding.None;
		match (member.member) {
			x: VstField => {
				var memberType = Function.newType(variantType, member.memberType);
				return expr.bind(null, VarBinding.ClassField(variantType, x), memberType);
			}
			x: VstMethod => {
				var memberType = Function.prependParamType(variantType, member.memberType);
				return expr.bind(null, VarBinding.ClassMethod(variantType, x, member.typeArgs), memberType);
			}
			x: VstVariantTagMember => {
				return newCompBinding(expr, V3Op.newVariantGetTag(variantType));
			}
			x: VstVariantNameMember => {
				return newCompBinding(expr, ClassType.!(member.receiver).getNameOperator());
			}
			x: VstCaseMember => {
				var memberType = member.memberType;
				if (x.decl.params != null) {
					var ptypes = Lists.map(x.decl.params.list, TypeUtil.getParamType);
					var ptype = Tuple.newType(ptypes).substitute(member.typeArgs);
					memberType = Function.newType(ptype, member.memberType);
				}
				return expr.bind(null, VarBinding.VariantCase(variantType, x), memberType);
			}
		}
		return VarBinding.None;
	}
	def lookupVariantExprMember(expr: VarExpr, variantType: ClassType, useThis: bool) -> VarBinding {
		// lookup (expr: variant).name
		var name = expr.ident.name;
		var member = resolveClassMember(expr, variantType, name.image);
		if (member == null) return VarBinding.None;
		var receiver = objExpr(useThis, name, expr);
		match (member.member) {
			x: VstField => {
				return expr.bind(receiver, VarBinding.VariantField(variantType, x), member.memberType);
			}
			x: VstMethod => {
				return expr.bind(receiver, VarBinding.ObjectMethod(variantType, x, member.typeArgs), member.memberType);
			}
			x: VstVariantTagMember => {
				return newApplyCompBinding(expr, receiver, V3Op.newVariantGetTag(variantType));
			}
			x: VstVariantNameMember => {
				return newApplyCompBinding(expr, receiver, ClassType.!(member.receiver).getNameOperator());
			}
		}
		return VarBinding.None;
	}
	def lookupVariantCaseMember(expr: VarExpr, variantType: ClassType) -> VarBinding {
		// lookup (type: variant.case).name
		var binding = lookupCastOrEqual(expr, variantType);
		if (binding.ok()) return binding;
		var name = expr.ident.name;
		var member = resolveClassMember(expr, variantType, name.image);
		if (member != null) {
			if (VstVariantTagMember.?(member.member)) {
				var tagType = V3.getVariantTagType(variantType);
				return expr.bind(null, VarBinding.Const(Int.box(V3.getVariantTag(variantType)), tagType), tagType);
			}
			if (VstVariantNameMember.?(member.member)) {
				var names = V3Class_TypeCon.!(V3.getRootType(variantType).typeCon).getNames(verifier.verifier.prog);
				var name = names.values[V3.getVariantTag(variantType)];
				return expr.bind(null, VarBinding.Const(name, V3.stringType), V3.stringType);
			}
		}
		if (variantType.classDecl.params != null) return lookupVariantTypeMember(expr, variantType);
		return lookupVariantExprMember(expr, variantType, false);
	}

	// =============================================================================
	// === Enum members ============================================================
	def lookupEnumTypeMember(expr: VarExpr, enumType: ClassType) -> VarBinding {
		// lookup (type: enum).name
		var name = expr.ident.name.image;
		if (Strings.equal(name, "set")) {
			var tref = TypeRef.new(TypeUtil.typeRefOf(enumType), expr.ident.name, null, null, null);
			verifier.getEnumSetType(tref, enumType);
			return expr.bind(null, VarBinding.Type(tref.rtype), tref.rtype);
		}
		if (Strings.equal(name, "|")) {
			if (enumType.classDecl.enumSetTypeCon == null) {
				var tref = TypeRef.new(TypeUtil.typeRefOf(enumType), expr.ident.name, null, null, null);
				verifier.getEnumSetType(tref, enumType);
				if (tref.rtype == null) return VarBinding.None;
			}
			var op = enumType.classDecl.enumSetTypeCon.lookupInfix(V3Infix.Or, null);
			return newCompBinding(expr, op);
		}
		var member = resolveClassMember(expr, enumType, name);
		if (member == null) return VarBinding.None;
		match (member.member) {
			x: VstField => {
				var memberType = Function.newType(enumType, member.memberType);
				return expr.bind(null, VarBinding.Inst(enumType.enumGetParamOperator(x), N), memberType);
			}
			x: VstVariantTagMember => {
				return newCompBinding(expr, V3Op.newVariantGetTag(enumType));
			}
			x: VstVariantNameMember => {
				return newCompBinding(expr, enumType.getNameOperator());
			}
			x: VstCaseMember => {
				return expr.bind(null, VarBinding.EnumConst(x), enumType);
			}
		}
		return VarBinding.None;
	}
	def lookupEnumExprMember(expr: VarExpr, enumType: ClassType, useThis: bool) -> VarBinding {
		// lookup (expr: enum).name
		var name = expr.ident.name;
		var member = resolveClassMember(expr, enumType, name.image);
		if (member == null) return VarBinding.None;
		match (member.member) {
			x: VstField => {
				return expr.bind(expr.expr, VarBinding.Apply(enumType.enumGetParamOperator(x), N), member.memberType);
			}
			x: VstVariantTagMember => {
				return newApplyCompBinding(expr, expr.expr, V3Op.newVariantGetTag(enumType));
			}
			x: VstVariantNameMember => {
				return newApplyCompBinding(expr, expr.expr, enumType.getNameOperator());
			}
		}
		return VarBinding.None;
	}
	def lookupEnumConstMember(expr: VarExpr, enumType: ClassType, vc: VstCaseMember) -> VarBinding {
		// lookup (expr: enum.val).name
		var name = expr.ident.name;
		var member = resolveClassMember(expr, enumType, name.image);
		if (member == null) return lookupEnumExprMember(expr, enumType, false);
		match (member.member) {
			x: VstField => {
				// bind literal fields
				if (x.index > vc.args.length()) return VarBinding.None;
				var arg = vc.args.asArray()[x.index];
				if (Literal.?(arg)) {
					var val = Literal.!(arg).val;
					return expr.bind(null, VarBinding.Const(val, x.getType()), x.getType());
				}
			}
			x: VstVariantTagMember => {
				var tagType = VstClass.!(vc.receiver).tagType;
				return expr.bind(null, VarBinding.Const(Int.box(vc.tag), tagType), tagType);
			}
			x: VstVariantNameMember => {
				var names = V3Class_TypeCon.!(V3.getRootType(enumType).typeCon).getNames(verifier.verifier.prog);
				var name = names.values[vc.tag];
				return expr.bind(null, VarBinding.Const(name, V3.stringType), V3.stringType);
			}
		}
		return lookupEnumExprMember(expr, enumType, false);
	}


	// =============================================================================
	// === Other members ===========================================================
	def lookupTypeMember(expr: VarExpr, etype: Type) -> VarBinding {
		// match casts, queries, and equality operators.
		var binding = lookupCastOrEqual(expr, etype);
		if (binding.ok()) return binding;
		// match specific kinds of types.
		match (etype.typeCon.kind) {
			V3Kind.ARRAY => binding = lookupArrayTypeMember(expr, etype);
			V3Kind.COMPONENT => binding = lookupComponentTypeMember(expr, etype);
			V3Kind.CLASS => binding = lookupClassTypeMember(expr, ClassType.!(etype));
			V3Kind.VARIANT => binding = lookupVariantTypeMember(expr, ClassType.!(etype));
			V3Kind.ENUM => binding = lookupEnumTypeMember(expr, ClassType.!(etype));
		}
		if (binding.ok()) return binding;
		// lookup a type member in a general type.
		var typeCon = etype.typeCon;
		if (Member_TypeCon.?(typeCon)) {
			var name = expr.ident.name.image;
			var mt = Member_TypeCon.!(typeCon);
			// try to look up a member.
			var result = mt.lookupMember(etype, name, false);
			if (result.tag != LookupResult.None.tag) return bindShape(expr, null, etype, result);
			// try to look up an infix operator in the type.
			var infix = V3Infix.parse(name);
			if (infix != '\x00') {
				var op = mt.lookupInfix(infix, etype);
				if (op != null) return newCompBinding(expr, op);
			}
		}
		return VarBinding.None;
	}
	def lookupExprMember(expr: VarExpr, etype: Type, useThis: bool) -> VarBinding {
		var binding: VarBinding;
		// match for specific types.
		match (etype.typeCon.kind) {
			V3Kind.ARRAY => binding = lookupArrayExprMember(expr, etype);
			V3Kind.COMPONENT => binding = lookupComponentExprMember(expr, etype, useThis);
			V3Kind.CLASS => binding = lookupClassExprMember(expr, ClassType.!(etype), useThis);
			V3Kind.TUPLE => binding = lookupTupleExprMember(expr, etype);
			V3Kind.VARIANT => binding = lookupVariantExprMember(expr, ClassType.!(etype), useThis);
			V3Kind.ENUM => binding = lookupEnumExprMember(expr, ClassType.!(etype), useThis);
		}
		if (binding.ok()) return binding;
		// lookup a member in a general type
		var name = expr.ident.name;
		if (Member_TypeCon.?(etype.typeCon)) {
			var mt = Member_TypeCon.!(etype.typeCon);
			var receiver = objExpr(useThis, name, expr);
			var result = mt.lookupMember(etype, name.image, true);
			if (result.tag != LookupResult.None.tag) return bindShape(expr, receiver, etype, result);
		}
		return VarBinding.None;
	}
	def lookupCastOrEqual(expr: VarExpr, etype: Type) -> VarBinding {
		var name = expr.ident.name.image;
		match (name[0]) {
			'?' => if (name.length == 1) {

				var typeParam = TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN,
						verifier.verifier.prog.typeCache,
						false, checkTypeQueryTypeArg(_, _, etype));
				var list = makeTypeArgsList("type query", expr, List.new(typeParam, null));
				var ft = list.head;
				return newCompBinding(expr, V3Op.newVstSugar(VstOperator.TypeQuery, [ft, etype], [ft], Bool.TYPE));
			}
			'!' => if (name.length == 1) {
				var typeParam = TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN,
						verifier.verifier.prog.typeCache,
						false, checkTypeCastTypeArg(_, _, etype));
				var list = makeTypeArgsList("type cast", expr, List.new(typeParam, null));
				var ft = list.head;
				return newCompBinding(expr, V3Op.newVstSugar(VstOperator.TypeCast, [ft, etype], [ft], etype));
			} else if (name.length == 2 && name[1] == '=') {
				return newCompBinding(expr, newNotEqual(etype));
			}
			'=' => if (name.length == 2 && name[1] == '=') {
				return newCompBinding(expr, V3Op.newEqual(etype));
			}
		}
		return VarBinding.None;
	}

	def bindShape(expr: VarExpr, receiver: Expr, etype: Type, result: LookupResult) -> VarBinding {
		match (result) {
			Const(vtype, val) => {
				return expr.bind(receiver, VarBinding.Const(val, vtype), vtype);
			}
			Inst(comp, typeParams) => {
				var typeArgs = makeTypeArgs("member", expr, typeParams);
				var rop = if(typeArgs != null, comp.subst(typeArgs.substitute), comp);
				return expr.bind(receiver, VarBinding.Inst(rop, N), rop.sig.funcType());
			}
			Partial(comp, typeParams) => {
				var typeArgs = makeTypeArgs("member", expr, typeParams);
				var rop = if(typeArgs != null, comp.subst(typeArgs.substitute), comp);
				var resultType = rop.getResidualType(INDEX_00);
				return expr.bind(receiver, VarBinding.Partial(rop, N), resultType);
			}
			Apply(gen, typeParams, facts) => {
				var typeArgs = makeTypeArgs("member", expr, typeParams);
				var rgen = if(typeArgs != null, gen.subst(typeArgs.substitute), gen);
				expr.receiver = receiver;
				return expr.bind(receiver, VarBinding.Apply(rgen, facts), rgen.sig.returnType());
			}
			_ => return VarBinding.None;
		}
	}
	def lookupComponentMember(expr: VarExpr, receiver: Expr, etype: Type, name: string) -> VarBinding {
		var member = V3Component_TypeCon.!(etype.typeCon).componentDecl.memberMap[name];
		if (member == null || isNotAccessible(member)) return VarBinding.None;
		var memberType = inferMemberType(member);
		if (VstMethod.?(member)) {
			var meth = VstMethod.!(member);
			if (meth.returnThis) {
				var paramType = Function.getParamType(memberType);
				memberType = Function.newType(paramType, etype);
			}
			var r = asResolvedMethod(expr, etype, meth, memberType);
			return expr.bind(receiver, VarBinding.ComponentMethod(r.getMethod(), r.typeArgs), r.memberType);
		}
		if (VstField.?(member)) {
			makeTypeArgsList("field", expr, null); // check no type args were supplied
			return expr.bind(receiver, VarBinding.ComponentField(VstField.!(member)), memberType);
		}
		return VarBinding.None;
	}
	def asResolvedMethod(expr: VarExpr, receiver: Type, meth: VstMethod, memberType: Type) -> ResolvedMember {
		var result = ResolvedMember.new(receiver, meth, null, memberType);
		var list = makeTypeArgsList("method", expr, meth.typeParams);
		if (list != null) {
			var ta = TypeArgs.new(meth.typeEnv, Lists.toArray(list));
			memberType = memberType.substitute(ta);
			result = ResolvedMember.new(receiver, meth, ta, memberType);
		}
		return result;
	}
	def isNotAccessible(member: VstMember) -> bool {
		return member.isPrivate && member.receiver != compound;
	}
	def newCompBinding(expr: VarExpr, comp: Operator) -> VarBinding {
		return expr.bind(null, VarBinding.Inst(comp, N), comp.sig.funcType());
	}
	def newApplyCompBinding(expr: VarExpr, receiver: Expr, comp: Operator) -> VarBinding {
		return expr.bind(receiver, VarBinding.Apply(comp, N), comp.sig.returnType());
	}
	def bindVar(varDecl: VarDecl) {
		var name = varDecl.token.image;
		if (env.lookupVar(name, env.scopeStart) != null) {
			verifier.VarDeclError(varDecl, Strings.format1("variable \"%1\" redefined", varDecl.token.image));
		}
		env.bindVar(name, varDecl);
		varDecl.ssa = VstSsaVar.new(); // XXX: move to VstSsaBuilder
	}
	def lookupVar(expr: VarExpr) -> VarBinding {
		var i = expr.ident, token = i.name, name = token.image;
		var varDecl = env.lookupVar(name, 0);
		if (varDecl != null) {
			expr.bind(null, VarBinding.Local(varDecl), varDecl.vtype);
			if (i.parameterized()) verifier.TypeParamArityError(i.params.range(), "local", name, 0, i.params.length());
			if (initOrder > 0 && thisParam == varDecl) verifier.InvalidThisUse(expr.range());
			return expr.varbind;
		}
		var binding: VarBinding;
		// lookup a member in the implicit "this" parameter
		if (thisParam != null) {
			binding = lookupExprMember(expr, verifier.thisType, true);
			if (binding.ok()) {
				if (initOrder > 0) checkMemberInit(expr, binding);
				return binding;
			}
		}
		// lookup a member in the current file
		var synthetic = verifier.file.synthetic;
		if (synthetic != null) {
			var binding = lookupComponentMember(expr, null, synthetic.getDeclaredType(), name);
			if (binding.ok()) return binding;
		}
		// lookup a type
		var typecon = typeEnv.lookup(name);
		if (typecon != null) {
			var typeRefs = expr.ident.list();
			if (typeRefs == null) {
				if (V3Class_TypeCon.?(typecon)) {
					var ctycon = V3Class_TypeCon.!(typecon);
					var list = makeTypeArgsList("class type", expr, ctycon.classDecl.typeParams);
					typeRefs = Lists.map(list, TypeUtil.typeRefOf);
				} else if (typecon == V3Array.TYPECON) {
					// introduce a type variable for the element type
					var list = makeTypeArgsList("array type", expr, TypeUtil.ONE_TYPE_PARAM);
					typeRefs = Lists.map(list, TypeUtil.typeRefOf);
				}
			}

			var typeRef = TypeRef.new(null, token, typeRefs, null, null);
			var ttype = resolveType(typeRef);
			return expr.bind(null, VarBinding.Type(ttype), ttype);
		}
		return VarBinding.None;
	}
	def checkMemberInit(expr: VarExpr, binding: VarBinding) -> VarBinding {
		var member: VstMember;
		match (binding) {
			ObjectField(receiver, m) => member = m;
			ComponentField(m) => member = m;
			ObjectMethod(receiver, m, t) => member = m;
			_ => return binding;
		}
		// check if the member referred to this binding has been initialized
		if (VstMethod.?(member)) verifier.MemberNotInitialized(expr.range(), "instance method cannot be referenced outside method body");
		if (VstField.?(member)) {
			var f = VstField.!(member);
			if (f.initOrder <= initOrder) {
				verifier.MemberNotInitialized(expr.range(), "field used before initialized");
			}
		}
		return binding;
	}
	def makeTypeArgsList(str: string, expr: VarExpr, typeParams: List<TypeParam>) -> List<Type> {
		if (expr.ident.params == null) {
			// no type refs and no type params == OK
			if (typeParams == null) return null;
			// no type refs for type params, introduce type variables
			return Lists.map(typeParams, newTypeVar(_, expr.ident.name));
		}
		// type refs are specified
		var t = typeParams, l = expr.ident.list();
		var r: List<Type>;
		while (t != null && l != null) {
			var arg = resolveType(l.head), param = t.head;
			if (param.hard) {  // check hard constraints
				var tv = TypeVar.!(newTypeVar(param, expr.ident.name));
				tv.setType(arg);
				if (tv.error_msg != null) {
					verifier.error(l.head.range(), "TypeError", tv.error_msg);
				}
				if (tv.vtype != null) arg = tv.vtype;
			}
			t = t.tail;
			l = l.tail;
			r = List.new(arg, r);
		}
		if (l != null || t != null) {
			var expected = Lists.length(typeParams);
			var got = Lists.length(expr.ident.list());
			verifier.TypeParamArityError(expr.range(), str, expr.ident.name.image, expected, got);
			return Lists.pad(Lists.reverse(r), verifier.getErrorType(), expected);
		}
		return Lists.reverse(r);
	}
	def makeTypeArgs(str: string, expr: VarExpr, typeParams: List<TypeParam>) -> TypeArgs {
		var list = makeTypeArgsList(str, expr, typeParams);
		if (list == null) return null;
		return TypeArgs.new(TypeEnv.new(null, typeParams, null), Lists.toArray(list));
	}
	def newTypeVar(typeParam: TypeParam, token: Token) -> Type {
		var typeCache = verifier.verifier.typeCache;
		if (typeCache == null) typeCache = verifier.verifier.typeCache = TypeCache.new();
		return TypeVar_TypeCon.new(token, typeParam, typeCache).create0();
	}
	def resolveType(tref: TypeRef) -> Type {
		return verifier.resolveType(tref, typeEnv);
	}
	def inferMemberType(member: VstMember) -> Type {
		var memberType = member.getType();
		if (memberType == null) {
			if (VstField.?(member)) return inferFieldType(VstField.!(member));
			else return Void.ERROR_TYPE;
		}
		return memberType;
	}
	def inferFieldType(fdecl: VstField) -> Type {
		if (fdecl.initEnv != null) return fdecl.vtype = cyclicFieldTypeInference(fdecl);
		var compound = fdecl.receiver, cv = compound.verifier;
		var methodEnv = MethodEnv.new(compound, null, cv.newThisParam(), cv, VarEnvironment.new());
		fdecl.initEnv = methodEnv;
		methodEnv.initField = fdecl;
		methodEnv.initOrder = fdecl.initOrder;
		if (initField != null) methodEnv.initPrev = this;
		var tc = TypeChecker.new(verifier.verifier.ERROR, cv.file);
		tc.enterMethod(methodEnv);
		fdecl.vtype = tc.inferClosedType(fdecl.init);
		fdecl.initEnv = null;
		return fdecl.vtype;
	}
	def cyclicFieldTypeInference(fdecl: VstField) -> Type {
		// render a more useful error message by including the fields involved in the cycle
		var compound = fdecl.receiver;
		var msg = Strings.toBuffer("cannot infer type of field (cycle in ");
		var list = List.new(VstMember.!(fdecl), null), p = this;
		while (p != null && p.initField != null) {
			list = List.new(p.initField, list);
			p = p.initPrev;
		}
		for (l = list; l != null; l = l.tail) {
			l.head.render(msg);
			if (l.tail != null) msg.puts(" -> ");
		}
		msg.puts(")");
		compound.verifier.FieldDeclError(fdecl, msg.toString());
		return Void.ERROR_TYPE;
	}
}

def checkTypeQueryTypeArg(tv: TypeVar, t: Type, toType: Type) -> Type {
	var msg: string;
	var r = TypeSystem.newTypeQuery(t, toType);
	match (r.approx) {
		TRUE =>		msg = "type query is always true";
		FALSE_X_NULL =>	msg = "type query is always false except for null";
		FALSE =>	msg = "type query is always false";
		_ => return t;
	}
	if (tv.error_msg == null) tv.error_msg = msg;
	return t;
}
def checkTypeCastTypeArg(tv: TypeVar, t: Type, toType: Type) -> Type {
	if (tv.error) return t;
	var msg: string;
	var r = TypeSystem.newTypeCast(t, toType);
	match (r.approx) {
		FALSE_X_NULL =>	msg = "type cast always fails except for null";
		FALSE =>	msg = "type cast always fails";
		_ => return t;
	}
	if (tv.error_msg == null) tv.error_msg = msg;
	return t;
}

// a constraint on type variables introduced in T.? and T.! constructs
class TypeVarConstraint {
	def verifier: VstCompoundVerifier;
	def toType: Type;
	def varExpr: VarExpr;
	new(verifier, varExpr, toType) { }
	def checkTypeQuery(typeVar: TypeVar, t: Type) -> Type {
		var msg: string;
		var r = TypeSystem.newTypeQuery(t, toType);
		match (r.approx) {
			TRUE =>		msg = "is always true";
			FALSE_X_NULL =>	msg = "is always false except for null";
			FALSE =>		msg = "is always false";
			_ => ;
		}
		if (msg != null) verifier.TypeQueryError(varExpr.range(), t, toType, msg);
		return t;
	}
	def checkTypeCast(typeVar: TypeVar, t: Type) -> Type {
		var msg: string;
		var r = TypeSystem.newTypeCast(t, toType);
		match (r.approx) {
			FALSE_X_NULL =>	msg = "always fails except for null";
			FALSE =>	msg = "always fails";
			_ => ;
		}
		if (msg != null) verifier.TypeCastError(varExpr.range(), t, toType, msg);
		return t;
	}
}

def FLOW_THRU = 0;
def FLOW_END  = 1;
def FLOW_RET  = 2;
def FLOW_NONE = 3;

// Typechecks VST code, resolving all references and types
class TypeChecker(ERROR: ErrorGen, file: VstFile) extends VstVisitor<Type, Type> {
	var methodEnv: MethodEnv;
	var flow: int;			// used to detect unreachable code
	var loopStack: List<int>;	// stack of nested loops
	var elimError: TypeVarEliminator;

	new() {
		elimError = TypeVarEliminator.new(TypeParamInferError);
	}
	def enterMethod(m: MethodEnv) {
		methodEnv = m;
		loopStack = null;
		flow = FLOW_THRU;
	}
	def mergeFlow(a: int, b: int) -> int {
		if (a == FLOW_NONE) return b;
		if (b == FLOW_NONE) return a;
		if (a == FLOW_THRU || b == FLOW_THRU) return FLOW_THRU;
		if (a == FLOW_END || b == FLOW_END) return FLOW_END;
		return a;
	}
	def visitIf(stmt: IfStmt, outer: Type) -> Type {
		typeCheckExpr(stmt.cond, Bool.TYPE, "if condition");
		var tf = typeCheckStmt(stmt.tbranch);
		flow = FLOW_THRU;
		var ff = typeCheckStmt(stmt.fbranch);
		flow = mergeFlow(tf, ff);
		return Void.TYPE;
	}
	def visitBlock(stmt: BlockStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		for (l = stmt.stmts.list; l != null; l = l.tail) typeCheckStmt(l.head);
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def visitWhile(stmt: WhileStmt, outer: Type) -> Type {
		stmt.loopNum = pushLoop();
		typeCheckExpr(stmt.cond, Bool.TYPE, "while condition");
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		return Void.TYPE;
	}
	def visitFor(stmt: ForStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		checkVarDecl(stmt.varDecl);
		stmt.loopNum = pushLoop();
		typeCheckExpr(stmt.cond, Bool.TYPE, "for condition");
		inferClosedType(stmt.update);
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def visitForeach(stmt: ForeachStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		var varDecl = stmt.varDecl;
		if (varDecl.init != null) VarDeclError(stmt.varDecl, "foreach variable cannot have an initializer");
		if (varDecl.tref != null) varDecl.vtype = methodEnv.resolveType(varDecl.tref);
		methodEnv.bindVar(varDecl);
		stmt.loopNum = pushLoop();
		stmt.loopVar = VstSsaVar.new(); // synthesize new loop variable
		setAssigned(stmt.loopVar);
		var elemType = getForeachElemType(stmt.expr);
		if (varDecl.tref == null) varDecl.vtype = elemType;
		else if (!isAssignable(elemType, varDecl.vtype)) TypeError(stmt.expr.range(), varDecl.vtype, elemType, "foreach");
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def getForeachElemType(expr: Expr) -> Type {
		if (VarExpr.?(expr)) {
			// Check for special case of "for (x in Enum)"
			var ve = VarExpr.!(expr);
			if (ve.expr == null) {
				match (methodEnv.lookupVar(VarExpr.!(expr))) {
					Type(t) => {
						if (t.typeCon.kind == V3Kind.ENUM) return elim(t);
						error(expr.range(), "TypeError", Strings.format1("foreach requires iterable expression and found %1", TYPE(elim(t))));
						return getErrorType();
					}
					_ => ;
				}
			}
		}
		var exprType = inferClosedType(expr);
		if (V3.isArray(exprType)) {
			// an iteration over the elements of an array.
			return V3Array.elementType(exprType);
		} else if (exprType.typeCon.kind == V3Kind.ENUM_SET) {
			// an iteration over the contents of an enum set.
			return V3EnumSet_TypeCon.!(exprType.typeCon).classDecl.getDeclaredType();
		} else {
			// an unknown type.
			error(expr.range(), "TypeError", Strings.format1("foreach requires iterable expression and found %1", TYPE(exprType)));
			return getErrorType();
		}
	}
	def visitForLess(stmt: ForLessStmt, outer: Type) -> Type {
		var prev = methodEnv.env.enterScope();
		var varDecl = stmt.varDecl;
		if (varDecl.init != null) VarDeclError(stmt.varDecl, "foreach variable cannot have an initializer");
		if (varDecl.tref != null) varDecl.vtype = methodEnv.resolveType(varDecl.tref);
		methodEnv.bindVar(varDecl);
		stmt.loopNum = pushLoop();
		setAssigned(varDecl.ssa);
		var exprType = varDecl.vtype;
		if (exprType != null) {
			typeCheckExpr(stmt.expr, exprType, "foreach limit");
		} else {
			varDecl.vtype = exprType = inferClosedType(stmt.expr);
		}
		if (!IntType.?(exprType)) {
			error(stmt.expr.range(), "TypeError", Strings.format1("foreach requires integral expression and found %1", TYPE(exprType)));
		}
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.env.exitScope(prev);
		return Void.TYPE;
	}
	def pushLoop() -> int {
		var loopNum = methodEnv.mdecl.numLoops++;
		loopStack = List.new(loopNum, loopStack);
		return loopNum;
	}
	def popLoop() {
		loopStack = loopStack.tail;
	}
	def visitLocal(stmt: LocalStmt, outer: Type) -> Type {
		Lists.apply(stmt.vars, checkVarDecl);
		return Void.TYPE;
	}
	def checkVarDecl(varDecl: VarDecl) {
		if (varDecl.tref != null) {
			varDecl.vtype = methodEnv.resolveType(varDecl.tref);
			if (varDecl.init != null) {
				typeCheckExpr(varDecl.init, varDecl.vtype, "var initialization");
			}
		} else {
			if (varDecl.init == null) {
				VarDeclError(varDecl, "must have a declared type or an initializer");
				varDecl.vtype = getErrorType();
			} else {
				varDecl.vtype = inferClosedType(varDecl.init);
			}
		}
		methodEnv.bindVar(varDecl);
	}
	def visitBreak(stmt: BreakStmt, outer: Type) -> Type {
		if (loopStack == null) LoopError(stmt.range(), "break must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	def visitContinue(stmt: ContinueStmt, outer: Type) -> Type {
		if (loopStack == null) LoopError(stmt.range(), "continue must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	def visitExpr(stmt: ExprStmt, outer: Type) -> Type {
		var e = stmt.expr;
		inferClosedType(e);
		if (AppExpr.?(e)) return Void.TYPE;
		if (AssignExpr.?(e)) return Void.TYPE;
		if (AutoExpr.?(e)) return Void.TYPE;
		StatementError(e.range());
		return Void.TYPE;
	}
	def visitMatch(stmt: MatchStmt, outer: Type) -> Type {
		var mv = MatchStmtVerifier.new(inferClosedType(stmt.expr), this);
		var bf = FLOW_NONE;
		for (cases = stmt.cases.list; cases != null; cases = cases.tail) {
			var c = cases.head;
			if (c.default != null) { // check default case last
				mv.addDefaultCase(c);
				stmt.defcase = c;
				continue;
			}
			var count = 0;
			for (p = c.patterns.list; p != null; p = p.tail) {
				visitMatchPattern(mv, p.head);
				count++;
			}
			var pat = if(count == 1, c.patterns.list.head);
			flow = FLOW_THRU;
			var bindings = pat != null && (pat.vdecl != null || pat.params != null);
			if (bindings) {
				var prev = methodEnv.env.enterScope();
				bindPatternVariables(mv, pat);
				bf = mergeFlow(bf, typeCheckStmt(c.stmt));
				methodEnv.env.exitScope(prev);
			} else {
				bf = mergeFlow(bf, typeCheckStmt(c.stmt));
			}
		}
		if (stmt.defcase != null) {
			flow = FLOW_THRU;
			mv.addDefaultCase(stmt.defcase);
			flow = mergeFlow(bf, typeCheckStmt(stmt.defcase.stmt));
		} else {
			flow = if(mv.allCovered(), bf, FLOW_THRU);
		}
		mv.end(stmt);
		return Void.TYPE;
	}
	def visitMatchPattern(mv: MatchStmtVerifier, pat: MatchPattern) {
		if (pat.vdecl != null) {
			if (pat.params != null) MatchError(pat.params.range(), "match type cannot have parameters");
			var ttype = methodEnv.resolveType(pat.vdecl.tref);
			pat.vdecl.vtype = ttype;
			return mv.addTypePattern(pat, ttype);
		}
		var e = pat.expr;
		if (Literal.?(e)) {
			typeCheckExpr(e, mv.etype, "match case");
			return assignPatternVal(mv, pat, Literal.!(e).val);
		}
		if (mv.variantType != null) return checkVariantPattern(mv, pat);
		if (pat.params != null) return MatchError(pat.params.range(), "match pattern cannot have parameters");
		typeCheckExpr(e, mv.etype, "match case");
		if (!VarExpr.?(e)) return MatchError(e.range(), "match expression is not a constant");
		var ve = VarExpr.!(e);
		match (ve.varbind) {
			ComponentField(field) => {
				if (Literal.?(field.init) && field.writability == Writability.READ_ONLY) {
					return assignPatternVal(mv, pat, Literal.!(field.init).val);
				}
			}
			Const(val, vtype) => {
				return assignPatternVal(mv, pat, val);
			}
			_ => ;
		}
		MatchError(ve.range(), "match expression is not a value");
	}
	def assignPatternVal(mv: MatchStmtVerifier, pat: MatchPattern, val: Val) {
		if (pat.expr.implicitType != null) {
			// perform an implicit conversion of the value if necessary
			var r = TypeSystem.evalTypeCast(pat.expr.exactType, pat.expr.implicitType, val);
			if (r.approx == CastOp.VALUE) val = r.result;
		}
		mv.addValue(pat, val);
	}
	def bindPatternVariables(mv: MatchStmtVerifier, pat: MatchPattern) {
		if (pat.vdecl != null) return methodEnv.bindVar(pat.vdecl);
		if (pat.variantCase == null) return;  // already an error
		var vt = mv.variantType;
		if (vt == null) return;
		if (pat.decl().params == null) {
			MatchError(pat.params.range(), Strings.format2("case %1.%2 has no declared parameters", vt.render, pat.decl().name()));
			return;
		}
		var ll = pat.params.list, pl = pat.decl().params.list;
		var typeArgs = vt.getTypeArgs();
		while (ll != null) {
			if (pl == null) {
				var msg = Strings.format2("case %1.%2", vt.render, pat.decl().name());
				ArityMismatch(ll.head.token.range(), msg, Lists.length(pat.decl().params.list), Lists.length(pat.params.list));
				return;
			}
			ll.head.vtype = pl.head.vtype.substitute(typeArgs);
			methodEnv.bindVar(ll.head);
			ll = ll.tail;
			pl = pl.tail;
		}
		if (pl != null) {
			var msg = Strings.format2("case %1.%2", vt.render, pat.decl().name());
			ArityMismatch(pat.params.range().lastByte(), msg, Lists.length(pat.decl().params.list), Lists.length(pat.params.list));
		}
	}
	def checkVariantPattern(mv: MatchStmtVerifier, pat: MatchPattern) {
		if (!VarExpr.?(pat.expr)) return;
		var ve = VarExpr.!(pat.expr), vt = mv.variantType;
		if (ve.expr != null) {
			return MatchError(ve.range(), Strings.format1("match on type %1 requires unqualified case", vt.render));
		}
		var vc = pat.variantCase = vt.lookupCase(ve.ident.name.image);
		if (vc == null) {
			return MatchError(ve.range(), Strings.format2("unresolved case %1.%2", vt.render, ve.ident.name.image));
		}
		mv.addVariantPattern(pat, vc);
	}
	def visitEmpty(stmt: EmptyStmt, outer: Type) -> Type {
		return Void.TYPE;
	}
	def visitReturn(stmt: ReturnStmt, outer: Type) -> Type {
		var returnType = methodEnv.resolveType(methodEnv.mdecl.rettype);
		if (stmt.expr != null) typeCheckExpr(stmt.expr, returnType, "return statement");
		else if (returnType != Void.TYPE) TypeError(stmt.src, returnType, Void.TYPE, "return statement");
		flow = FLOW_RET;
		return Void.TYPE;
	}
	def visitTuple(expr: TupleExpr, outer: Type) -> Type {
		var etypes: List<Type>;
		if (outer == null || !V3.isTuple(outer)) {
			// infer the expressions' types if the outer is a not a tuple type
			etypes = expr.exprs.mapList(inferClosedType);
		} else {
			// type check the expressions if the outer is a tuple type
			etypes = Lists.reduce(expr.exprs.list, outer.nested, typeCheckTupleElem);
		}
		typeCheckExprs(expr, etypes, "tuple creation");
		var ttype = Tuple.newType(etypes);
		return ttype;
	}
	def typeCheckTupleElem(e: Expr, t: Type) -> Type {
		typeCheckExpr(e, t, "tuple creation");
		if (e.implicitType != null) return e.implicitType;
		return e.exactType;
	}
	def visitParamExpr(expr: ParamExpr, outer: Type) -> Type {
		ParamExprError(expr.range(), "param expression can only be function call argument");
		return if(outer == null, getErrorType(), outer);
	}
	def visitAutoExpr(expr: AutoExpr, outer: Type) -> Type {
		var t = checkWrite(expr.expr);
		if (IndexExpr.?(expr.expr)) t = visitIndexReadOrWrite(IndexExpr.!(expr.expr), outer, false);
		var op = expr.op;
		if (Member_TypeCon.?(t.typeCon)) {
			op = Member_TypeCon.!(t.typeCon).lookupInfix(expr.infix, t);
		}
		if (op == null) {
			UnresolvedOp(expr.token, t, null);
			return t;
		}
		expr.op = op;
		typeCheckExpr(expr.expr, op.sig.returnType(), "auto expression");
		return t;
	}
	def visitArray(expr: ArrayExpr, outer: Type) -> Type {
		var se = expr.exprs.list;
		var etype = Void.TYPE;
		if (outer != null && V3.isArray(outer)) {
			etype = outer.nested.head; // element type is first type parameter to array type
		} else {
			if (se == null) {
				TypeInferError(expr.range(), "cannot infer empty array type");
			} else {
				etype = inferClosedType(se.head);
				for (rest = se.tail; rest != null; rest = rest.tail) {
					etype = TypeSystem.widen(etype, inferClosedType(rest.head));
					if (etype == null) {
						TypeInferError(rest.head.range(), "cannot infer type of array");
						return getErrorType();
					}
				}
			}
		}

		Lists.apply(expr.exprs.list, typeCheckExpr(_, etype, "array expression"));

		return V3Array.newType(etype);
	}
	def visitVar(expr: VarExpr, outer: Type) -> Type {
		var binding = lookupBinding(expr, outer, false);
		if (binding.none()) return if(outer == null, getErrorType(), outer);
		if (outer != null) TypeSystem.unifyWiden(expr.exactType, outer);
		return expr.exactType;
	}
	def visitLiteral(expr: Literal, outer: Type) -> Type {
		return expr.exactType;
	}
	def lookupBinding(expr: VarExpr, outer: Type, nested: bool) -> VarBinding {
		var binding = expr.varbind;
		if (binding.ok()) return binding;  // already bound
		if (expr.expr == null) {
			// "var" -- top level variable
			binding = methodEnv.lookupVar(expr);
			if (binding.none()) UnresolvedIdentifier(expr.ident.name);
			if (!nested && VarBinding.Type.?(binding)) {
				methodEnv.verifier.TypeExprError(expr.range(), VarBinding.Type.!(binding).t);
			}
			return binding;
		}
		// "expr.var" -- a member expression
		var etype: Type, inType: bool;
		if (VarExpr.?(expr.expr)) {
			// "var.var" -- a member of another var
			binding = lookupBinding(VarExpr.!(expr.expr), outer, true);
			match (binding) {
				None => ;
				Type(t) => {
					etype = t; inType = true;
					binding = methodEnv.lookupTypeMember(expr, etype);
				}
				VariantCase(receiver, vcase) => {
					etype = V3.getSyntheticVariantType(receiver, vcase);
					binding = methodEnv.lookupVariantCaseMember(expr, ClassType.!(etype));
				}
				EnumConst(member) => {
					etype = member.receiver.getDeclaredType();
					binding = methodEnv.lookupEnumConstMember(expr, ClassType.!(etype), member);
				}
				_ => {
					etype = expr.expr.exactType;
					binding = methodEnv.lookupExprMember(expr, etype, false);
				}
			}
		} else {
			// "expr.var" -- a member of some other kind of expression
			etype = inferClosedType(expr.expr);
			binding = methodEnv.lookupExprMember(expr, etype, false);
		}
		if (binding.none()) UnresolvedMember(expr.ident.name, inType, etype);
		return binding;
	}
	def visitString(expr: StringExpr, outer: Type) -> Type {
		var vst = methodEnv.verifier.verifier.prog.vst;
		expr.recordIndex = vst.numStrings++;
		return V3.stringType;
	}
	def visitApp(expr: AppExpr, outer: Type) -> Type {
		// infer an open type for the function or array
		var funcType = inferType(expr.func, null);
		if (V3.isFunction(funcType)) return typeCheckMethodApp(expr, funcType, outer);
		TypeError(expr.func.range(), getErrorFunctionType(), funcType, "application");
		return getErrorType();
	}
	def visitIndex(expr: IndexExpr, outer: Type) -> Type {
		return visitIndexReadOrWrite(expr, outer, false);
	}
	def getIndexedWriteType(receiver: Type, member: VstMethod) -> Type {
		// trim last parameter, which is the written value
		var rev = Lists.reverse(member.params.list);
		var list = Lists.reverse(rev.tail);
		var typeList = Lists.map(list, TypeUtil.getParamType);
		var funcType = Function.newType(Tuple.newType(typeList), rev.head.vtype);
		var typeArgs = V3.getTypeArgs(receiver);
		if (typeArgs != null) funcType = funcType.substitute(typeArgs);
		return funcType;
	}
	def visitIndexReadOrWrite(expr: IndexExpr, outer: Type, write: bool) -> Type {
		// infer an open type for the array
		var arrayType = if(outer != null, V3Array.newType(outer));
		var exprType = inferType(expr.expr, arrayType);
		if (V3.isArray(exprType)) {
			if (expr.exprs.length() != 1) {
				error(expr.exprs.range(), "TypeError", Strings.format1("type %1 must be indexed by a single expression", TYPE(exprType)));
			} else {
				var iexpr = expr.exprs.first();
				var it = inferClosedType(iexpr);
				if (it.typeCon.kind != V3Kind.INT) {
					error(iexpr.range(), "TypeError", Strings.format1("index expression requires integral type, found %1", TYPE(exprType)));
				}
			}
			exprType = elim(exprType);
			return V3Array.elementType(exprType);
		} else if (ClassType.?(exprType)) {
			var varExpr = VarExpr.new(expr, null, VstIdent<TypeRef>.new(null, 0, null));
			var member = methodEnv.resolveClassMember(varExpr, ClassType.!(exprType), if(write, "[]=", "[]"));
			if (member != null) {
				if (write) {
					var method = member.getMethod();
					var funcType = getIndexedWriteType(member.receiver, method);
					expr.write = AppBinding.CallObjectMethod(member.receiver, method, null);
					typeCheckArgs("index expression", expr.exprs, funcType, outer);
					return Function.getReturnType(funcType);
				} else {
					var funcType = member.memberType;
					expr.read = AppBinding.CallObjectMethod(member.receiver, member.getMethod(), null);
					typeCheckArgs("index expression", expr.exprs, funcType, outer);
					return Function.getReturnType(funcType);
				}
			}
		}
		var err = if(write, "AssignError", "TypeError");
		var msg = if(write, "type %1 has no [] assignment operator", "type %1 has no [] operator");
		error(expr.exprs.range(), err, Strings.format1(msg, TYPE(exprType)));
		return getErrorType();
	}
	def typeCheckArgs(op: string, args: VstList<Expr>, funcType: Type, outer: Type) -> List<Type> {
		// get the parameter type and parameter type list
		var paramType = Function.getParamType(funcType), ptlist: List<Type>;
		var argList = args.list;
		if (argList == null || argList.tail != null) ptlist = Tuple.toTypeList(paramType);
		else ptlist = List.new(paramType, null); // one arg -> use tuple type

		// infer argument expressions' types, including parameter expressions '_'
		var checkList: List<(Expr, Type)>, tl = ptlist, partialParamTypes: List<Type>;
		for (el = argList; el != null; el = el.tail) {
			var arg = el.head;
			if (tl == null) {
				// too many parameters
				inferClosedType(arg);
				ArityMismatch(arg.range(), op, Lists.length(ptlist), args.length());
				continue;
			}
			var paramType = tl.head;
			if (ParamExpr.?(arg)) {
				var param = ParamExpr.!(arg);
				partialParamTypes = List.new(paramType, partialParamTypes);
			} else if (paramType.hasTypeVars()) {
				// parameter type has type variables
				TypeSystem.unifyWiden(paramType, inferClosedType(arg));
				checkList = List.new((arg, paramType), checkList);
			} else {
				// no type variables; use parameter type to help infer inner types
				typeCheckExpr(arg, paramType, op);
			}
			tl = tl.tail;
		}
		if (tl != null) {
			// too few parameters
			ArityMismatch(args.range().lastByte(), op, Lists.length(ptlist), args.length());
		}
		// Unify the return type with the expected type
		if (partialParamTypes == null && outer != null) {
			TypeSystem.unifyWiden(Function.getReturnType(funcType), outer);
		}
		// typecheck expressions that where the corresponding param type was not closed
		for (cl = checkList; cl != null; cl = cl.tail) {
			typeCheckExpr(cl.head.0, elim(cl.head.1), op);
		}
		return partialParamTypes;
	}
	def typeCheckMethodApp(expr: AppExpr, funcType: Type, outer: Type) -> Type {
		var partialParamTypes = typeCheckArgs("function application", expr.args.exprs, funcType, outer);
		var resultType = Function.getReturnType(funcType);
		if (partialParamTypes != null) {
			// this is a partial application, result is a function
			var boundMap = Vector<int>.new(), i = 1;
			boundMap.put(0);
			var paramTypes: List<Type>;
			for (el = expr.args.exprs.list; el != null; (el = el.tail, i++)) {
				if (ParamExpr.?(el.head)) continue;
				boundMap.put(i);
			}
			resultType = Function.newType(Tuple.newType(Lists.reverse(partialParamTypes)), resultType);
			if (outer != null) TypeSystem.unifyWiden(resultType, outer);
			expr.boundMap = boundMap.extract();
			expr.appbind = AppBinding.Partial(expr.boundMap);
		} else {
			// this is a complete application, its result is the return type
			var varbind: VarBinding, obj: Expr;
			if (VarExpr.?(expr.func)) {
				var v = VarExpr.!(expr.func);
				varbind = v.varbind;
				obj = v.receiver;
			}
			match (varbind) {
				ObjectMethod(receiver, method, typeArgs) => {
					expr.target = obj;
					expr.appbind = AppBinding.CallObjectMethod(receiver, method, typeArgs);
				}
				ComponentMethod(method, typeArgs) => {
					expr.target = obj;
					expr.appbind = AppBinding.CallComponentMethod(method.receiver.getDeclaredType(), method, typeArgs);
				}
				ClassMethod(receiver, method, typeArgs) => {
					expr.target = null;
					expr.appbind = AppBinding.CallClassMethod(receiver, method, typeArgs);
				}
				ClassNew(receiver, member, funcType) => {
					expr.target = null;
					expr.appbind = AppBinding.ClassNew(receiver, member);
				}
				Inst(comp, facts) => {
					expr.target = null;
					expr.appbind = AppBinding.Apply(comp, facts);
				}
				Partial(comp, facts) => {
					expr.target = obj;
					expr.appbind = AppBinding.Apply(comp, facts);
				}
				VariantCase(receiver, member) => {
					if (member.decl.params != null) {
						var variant = V3.getSyntheticVariantType(receiver, member);
						expr.target = null;
						expr.appbind = AppBinding.ClassNew(variant, member.decl.constructor);
					} else {
						expr.appbind = AppBinding.CallClosure(elim(funcType));
					}
				}
				_ => {
					expr.appbind = AppBinding.CallClosure(elim(funcType));
				}
			}
		}

		expr.func.exactType = elim(funcType);
		return elim(resultType);
	}
	def visitNot(expr: NotExpr, outer: Type) -> Type {
		typeCheckExpr(expr.expr, Bool.TYPE, "boolean not operator");
		return Bool.TYPE;
	}
	def visitBitwiseNeg(expr: BitwiseNegExpr, outer: Type) -> Type {
		if (outer != null) typeCheckExpr(expr.expr, outer, "bitwise negate operator");
		else inferClosedType(expr.expr);
		var t = expr.expr.exactType;
		if (t.typeCon.kind != V3Kind.INT) {
			error(expr.expr.range(), "TypeError", Strings.format1("bitwise negate requires integer type found %1", TYPE(t)));
			return Int.TYPE;
		}
		return t;
	}
	def checkWrite(left: Expr) -> Type {
		if (IndexExpr.?(left)) {
			var t = visitIndexReadOrWrite(IndexExpr.!(left), null, true);
			left.exactType = t;
			return t;
		}
		var result = inferClosedType(left);
		var expr: VarExpr;
		if (VarExpr.?(left) && (expr = VarExpr.!(left)).isAssignable(methodEnv.compound)) {
			match (expr.varbind) {
				Local(decl) => setAssigned(decl.ssa);
				_ => ;
			}
			return result;
		}
		AssignError(left.range());
		return result;
	}
	def visitAssign(expr: AssignExpr, outer: Type) -> Type {
		var left = expr.target;
		var ltype = checkWrite(left);
		var result = ltype;
		var infix = expr.infix;
		if (infix != null) {
			if (IndexExpr.?(left)) ltype = visitIndexReadOrWrite(IndexExpr.!(left), outer, false);
			if (Member_TypeCon.?(ltype.typeCon)) {
				infix.op = Member_TypeCon.!(ltype.typeCon).lookupInfix(infix.infix, null);
			}
			if (infix.op == null) {
				UnresolvedOp(infix.token, ltype, null);
				return getErrorType();
			}
			typeCheckExpr(expr.expr, infix.op.sig.paramTypes[1], "compound assignment");
			result = infix.op.sig.returnType();
		} else {
			typeCheckExpr(expr.expr, result, "assignment");
		}
		return result;
	}
	def setAssigned(ssa: VstSsaVar) {
		// update info for an assigned var variable
		if (ssa.index < 0) ssa.index = methodEnv.mdecl.numNonSsa++;
		for (l = loopStack; l != null; l = l.tail) {
			ssa.setWrittenInLoop(l.head);
		}
	}
	def visitBinOp(expr: BinOpExpr, outer: Type) -> Type {
		var ltype = inferClosedType(expr.left), rtype = inferClosedType(expr.right);
		var op: Operator;
		if (Member_TypeCon.?(ltype.typeCon)) {
			op = Member_TypeCon.!(ltype.typeCon).lookupInfix(expr.op.infix, rtype);
		}
		if (op == null) {
			if (expr.op.infix == V3Infix.Equal) op = equalityOp(expr, ltype, rtype, true);
			else if (expr.op.infix == V3Infix.NotEqual) op = equalityOp(expr, ltype, rtype, false);
		}
		if (op == null) {
			UnresolvedOp(expr.op.token, ltype, null);
			return getErrorType();
		}
		expr.set(op);
		typeCheckExpr(expr.left, op.sig.paramTypes[0], "infix operator");
		typeCheckExpr(expr.right, op.sig.paramTypes[1], "infix operator");
		return op.sig.returnType();
	}
	def equalityOp(expr: Expr, ltype: Type, rtype: Type, eq: bool) -> Operator {
		var wtype = TypeSystem.widen(ltype, rtype);
		if (wtype == null) {
			ComparisonError(expr.range(), ltype, rtype);
			return null;
		}
		return if(eq, V3Op.newEqual(wtype), newNotEqual(wtype));
	}
	def visitIfExpr(expr: IfExpr, outer: Type) -> Type {
		var args = expr.exprs.asArray(), what = "if expression", len = args.length;
		// 2 or 3 expressions required
		if (len < 2 || len > 3) {
			ArityMismatch(expr.range(), what, 3, len);
			return getErrorType();
		}
		typeCheckExpr(args[0], Bool.TYPE, what);
		var a = args[1], atype = outer;
		if (outer != null) typeCheckExpr(a, outer, what);
		else atype = inferClosedType(a);

		// 1 alternative => Value.BOTTOM for false
		if (len == 2) return atype;

		// 2 alternatives => unify types if necessary
		var b = args[2];
		if (outer != null) {
			typeCheckExpr(b, outer, what);
			return outer;
		}

		// typecheck and unify
		var btype = inferClosedType(b);
		var wtype = TypeSystem.widen(atype, btype);
		if (wtype != null) {
			if (a.exactType != wtype) typeCheckExpr(a, wtype, what);
			if (b.exactType != wtype) typeCheckExpr(b, wtype, what);
			return wtype;
		} else {
			TypeError(expr.range(), atype, btype, what);
			return atype;
		}
	}
	def typeCheckExpr(expr: Expr, outerType: Type, op: string) {
		var exactType = expr.exactType;
		if (exactType == null) {
			exactType = expr.accept(this, outerType);
			exactType = elim(exactType);
			expr.exactType = exactType;
		}
		if (exactType != outerType) {
			if (IntLiteral.?(expr)) {
				var rtype = TryRepresentationChangeOfLiteral(IntLiteral.!(expr), outerType);
				if (rtype == outerType) { expr.exactType = rtype; return; }
				if (rtype == null) return;  // error already reported
			}
			if (TypeSystem.isPromotable(exactType, outerType)) expr.implicitType = outerType;
			else TypeError(expr.range(), outerType, exactType, op);
		}
	}
	// Try representation changes of integer literals.
	def TryRepresentationChangeOfLiteral(lit: IntLiteral, outer: Type) -> Type {
		if (outer.typeCon.kind == V3Kind.FLOAT) {
			return TryRepresentationChangeToFloat(lit, outer);
		}
		if (!IntType.?(outer)) return lit.exactType;
		var tt = IntType.!(outer);
		// For all integer literals, suffixes force the type and only allow the normal implicit conversions.
		if (lit.usuffix || lit.lsuffix) return lit.exactType;
		var error: string = null;
		if (HexLiteral.?(lit)) {
			var hex = HexLiteral.!(lit);
			// If the literal is short enough, check whether it is properly sign or zero extended as written.
			// Sign extend the upper bits if necessary.
			var rt = Int.getType(tt.signed, (tt.width + 3) & (-1 ^ 3));  // round up
			if (hex.width * 4 > rt.width) {
				error = "too many hex digits";
			} else {
				var fail: bool;
				if (tt.width <= 32) {
					var o = Int.unbox(hex.val), t = tt.trunc_32(o);
					if (rt.width > tt.width) fail = (t != rt.trunc_32(o));
					hex.val = Int.box(t);
				} else {
					var o = Long.unboxSU(hex.val, tt.signed), t = tt.trunc_64(o);
					if (rt.width > tt.width) fail = (t != rt.trunc_64(o));
					hex.val = Box.new(t);
				}
				// sign extend or change Box representation if necessary
				if (fail) error = Strings.format1("improperly %1-extended hex literal", if(tt.signed, "sign", "zero"));
			}
		} else if (BinLiteral.?(lit)) {
			// Check the binary literal is short enough to fit in the outer type.
			var bin = BinLiteral.!(lit);
			if (bin.width <= tt.width) {
				// sign extend or change Box representation
				bin.val = IntOp.evalTruncate(tt, tt.signed, bin.val);
			} else {
				error = "too many binary digits";
			}
		} else if (DecLiteral.?(lit)) {
			// Check that the decimal literal fits in the [min,max] value range.
			var dec = DecLiteral.!(lit), range_error = "decimal out of range";
			var v = dec.val, fsigned = IntType.!(dec.exactType).signed;
			if (dec.negative && !tt.signed) {
				error = "negative decimal used as unsigned";
			} else if (v == null) {
				// == 0, always fits.
			} else if (tt.width <= 32) {
				if (!Box<int>.?(v)) return dec.exactType;
				var i = Int.unbox(v);
				if (tt.width < 32) {
					if (i < Int.unbox(tt.min) || i > Int.unbox(tt.max)) error = range_error;
				} else if (i < 0 && tt.signed != fsigned) {
					error = range_error;;
				}
			} else if (tt.width <= 64) {
				def u = Long.unboxSU, l = u(v, fsigned);
				if (tt.width < 64) {
					if (l < u(tt.min, tt.signed) || l > u(tt.max, tt.signed)) error = range_error;
				} else if (l < 0 && tt.signed != fsigned) {
					error = range_error;
				}
				dec.val = Box.new(l);
			}
		}
		if (error == null) return outer;
		this.error(lit.token.range(), "TypeError", Strings.format3("\"%1\" cannot be %2 (%3)", lit.token.image, TYPE(outer), error));
		return null;
	}
	def TryRepresentationChangeToFloat(lit: IntLiteral, outer: Type) -> Type {
		var tt = Float_TypeCon.!(outer.typeCon);
		var ft = IntType.!(lit.exactType);
		var nv: Val;
		if (ft.signed) {
			var v = Long.unboxSU(lit.val, true);
			nv = tt.tryPromoteS(v);
		} else {
			var v = Long.unboxSU(lit.val, false);
			nv = tt.tryPromoteU(0, u64.!(v));
		}
		if (nv == null) {
			this.error(lit.token.range(), "TypeError",
				Strings.format2("\"%1\" cannot be represented in type %2 due to rounding",
					lit.token.image, TYPE(outer)));
			return null;
		} else {
			lit.val = nv;
			lit.exactType = outer;
			return outer;
		}
	}
	def typeCheckExprs(args: TupleExpr, types: List<Type>, op: string) {
		var tl = types;
		for (el = args.exprs.list; el != null; el = el.tail) {
			if (tl == null) {
				ArityMismatch(el.head.range(), op, Lists.length(types), args.exprs.length());
				break;
			} else {
				typeCheckExpr(el.head, tl.head, op);
				tl = tl.tail;
			}
		}
		if (tl != null) ArityMismatch(args.exprs.range().lastByte(), op, Lists.length(types), args.exprs.length());
	}
	def inferClosedType(expr: Expr) -> Type {
		if (expr.exactType != null) return expr.exactType;
		return expr.exactType = elim(expr.accept(this, null));
	}
	def inferType(expr: Expr, outerType: Type) -> Type {
		return expr.exactType = expr.accept(this, outerType);
	}
	def typeCheckStmt(stmt: Stmt) -> int {
		if (stmt != null) {
			if (flow == FLOW_THRU) stmt.accept(this, Void.TYPE);
			else UnreachableCode(stmt.range());
		}
		return flow;
	}
	def typeCheckBody(stmt: Stmt) {
		if (typeCheckStmt(stmt) != FLOW_RET) {
			var returnType = methodEnv.resolveType(methodEnv.mdecl.rettype);
			if (returnType != Void.TYPE) MissingReturn(stmt.range());
		}
	}
	def elim(vtype: Type) -> Type {
		if (vtype == null) return null;
		return vtype.substitute(elimError);
	}
	def isAssignable(src: Type, dest: Type) -> bool {
		return src == dest || TypeSystem.isPromotable(src, dest);
	}
	// -- Utility methods to generate errors ----------------------------------
	def TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%1 requires type %2 and found %3", op, TYPE(t1), TYPE(t2)));
		}
	}
	def ComparisonError(range: FileRange, t1: Type, t2: Type) {
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "ComparisonError", Strings.format2("%1 cannot be compared to %2", TYPE(t1), TYPE(t2)));
		}
	}
	def TypeParamInferError(tvar: TypeVar) -> Type {
		if (tvar.error) return getErrorType(); // prevent multiple errors for same type var
		tvar.error = true;
		var msg = tvar.error_msg;
		if (msg == null) {
			msg = Strings.format2("cannot infer type parameter %1 of \"%2\"",
				tvar.typeParam.token.image, tvar.token.image);
		}
		error(tvar.token.range().end().rangeOf(0), "TypeError", msg);
		return getErrorType();
	}
	def TypeInferError(range: FileRange, reason: string) {
		error(range, "TypeInferError", reason);
	}
	def VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	def UnresolvedIdentifier(token: Token) {
		error(token.range(), "UnresolvedIdentifier", Strings.format1("identifier \"%1\" cannot be found", token.image));
	}
	def UnresolvedOp(token: Token, t1: Type, t2: Type) {
		var buf = StringBuffer.new().format1("operator \"%1\" cannot be found", token.image);
		if (t1 != null) buf.format1(" for type \"%1\"", t1.render);
		if (t2 != null && t2 != t1) buf.format1(" or type \"%1\"", t2.render);
		error(token.range(), "UnresolvedOp", buf.toString());
	}
	def UnresolvedMember(token: Token, inType: bool, tref: Type) {
		var msg = "expression of type %1 has no such member \"%2\"";
		if (inType) msg = "type %1 has no such member \"%2\"";
		error(token.range(), "UnresolvedMember", Strings.format2(msg, TYPE(tref), token.image));
	}
	def StatementError(range: FileRange) {
		error(range, "StatementError", "not a statement");
	}
	def UnreachableCode(point: FilePoint) {
		error(point.rangeOf(0), "UnreachableCode", "unreachable code");
	}
	def MissingReturn(point: FilePoint) {
		error(point.rangeOf(0), "MissingReturn", "method does not end in a return statement");
	}
	def AssignError(range: FileRange) {
		error(range, "AssignError", "expression is not assignable");
	}
	def MatchError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "MatchError", msg);
	}
	def LoopError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "LoopError", msg);
	}
	def ParamExprError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "ParamExprError", msg);
	}
	def ArityMismatch(range: FileRange, op: string, expect: int, found: int) {
		if (expect == 1) error(range, "TypeError", Strings.format2("%1 requires 1 argument and found %2", op, found));
		else error(range, "TypeError", Strings.format3("%1 requires %2 arguments and found %3", op, expect, found));
	}
	def getErrorType() -> Type {
		return ERROR.getErrorType();
	}
	def getErrorFunctionType() -> Type {
		return TypeCon.new("function", V3Kind.CLOSURE, 0, methodEnv.verifier.verifier.prog.typeCache).create0();
	}
	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def TYPE(tref: Type) -> string {
		if (tref == null) return "<unknown>";
		return tref.render(StringBuffer.new()).toString();
	}
}
class ResolvedMember(receiver: Type, member: VstMember, typeArgs: TypeArgs, memberType: Type) {
	def getField() -> VstField { return VstField.!(member); }
	def getMethod() -> VstMethod { return VstMethod.!(member); }
}

def newNotEqual(t: Type) -> Operator {
	return V3Op.newVstSugar(VstOperator.NotEqual, [t], [t, t], Bool.TYPE);
}
// A stateful helper to check various statement-wide properties (e.g. coverage)
// for match statements.
class MatchStmtVerifier(etype: Type, tc: TypeChecker) {
	var variantType: ClassType;
	var valueMap: PartialMap<Val, MatchPattern>;
	var covered: Array<MatchPattern>;
	var default: MatchCase;
	new() {
		if (etype.typeCon.kind == V3Kind.VARIANT) {
			var vt = ClassType.!(etype);
			while (vt.classDecl.isVariantCase()) vt = vt.getSuperType();
			variantType = vt;
			covered = Array.new(variantType.classDecl.cases.length);
		} else if (etype.typeCon.kind == V3Kind.ENUM) {
			variantType = ClassType.!(etype);
			covered = Array.new(variantType.classDecl.cases.length);
		}
	}
	def addValue(pat: MatchPattern, val: Val) {
		if (valueMap == null) {
			valueMap = HashMap.new(Val.hash, Val.equals);
		} else if (valueMap.has(val)) {
			MatchError(pat.expr.range(), "duplicate value", valueMap[val].expr.range());
		}
		pat.val = val;
		valueMap[val] = pat;
	}
	def addVariantPattern(pat: MatchPattern, vc: VstCaseMember) {
		if (covered[vc.tag] != null) {
			MatchError(pat.expr.range(), "duplicate variant pattern", covered[vc.tag].expr.range());
		}
		covered[vc.tag] = pat;
		pat.val = Int.box(vc.tag);
	}
	def addTypePattern(pat: MatchPattern, t: Type) {
		var cast = TypeSystem.newTypeCast(etype, t);
		match (cast.approx) {
			FALSE, FALSE_X_NULL => {
				MatchError(pat.vdecl.tref.range(), Strings.format2("key of type %1 can never match type %2", etype.render, t.render), null);
			}
			_ => ;
		}
		if (t.typeCon.kind == V3Kind.VARIANT && variantType != null) {
			var ct = ClassType.!(t);
			if (ct.classDecl.isVariantCase() && TypeSystem.isSubtype(ct, variantType)) {
				var tag = ct.classDecl.variantTag;
				var vc = variantType.classDecl.cases[tag];
				pat.variantCase = vc;
				return addVariantPattern(pat, vc);
			}
		}
	}
	def addDefaultCase(c: MatchCase) {
		if (default != null && default != c) {
			MatchError(c.range(), "duplicate default case", c.range());
		}
		default = c;
	}
	def end(stmt: MatchStmt) {
		if (covered == null) return;
		if (default != null) {
			for (p in covered) {
				if (p == null) return;
			}
			tc.error(default.range(), "UnreachableCode", "unreachable default case");
			return;
		}
		var buf: StringBuffer;
		for (i < covered.length) {
			if (covered[i] == null) {
				if (buf == null) buf = StringBuffer.new().format1("match on type %1 does not cover:", variantType.render);
				buf.puts(" ").puts(variantType.classDecl.cases[i].name());
			}
		}
		if (buf != null) MatchError(stmt.range(), buf.toString(), null);
	}
	def isVariant() -> bool {
		return etype.typeCon.kind == V3Kind.VARIANT;
	}
	def isEnum() -> bool {
		return etype.typeCon.kind == V3Kind.ENUM;
	}
	def allCovered() -> bool {
		if (covered == null) return false;
		for (p in covered) if (p == null) return false;
		return true;
	}
	def MatchError(range: FileRange, msg: string, prev: FilePoint) {
		msg = formatPrev(msg, prev);
		tc.error(range, "MatchError", msg);
	}
}
