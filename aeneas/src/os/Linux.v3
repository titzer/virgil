// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Contains logic to generate a Linux executable (ELF) file.
class LinuxTarget extends Target {
	def space: AddressSpace;
	def intNorm: IntNormalizer;
	def machLoweringConfig: MachLoweringConfig;
	def newBackend: (Compiler, Program, MachProgram, MachDataWriter, Dwarf) -> MachBackend;
	def kernelCallReturnType: Type;
	def linuxComponent = Kernel_TypeCon.new(Kernel.LINUX, kernelCallReturnType);
	def DEFAULT_VADDR_START = 0x08000000;
	def elf_machine: u8;

	new(name: string, space, intNorm, machLoweringConfig, newBackend, elf_machine, kernelCallReturnType) super(name) {
		if (space.addressWidth == 64) refPatterns = ScalarPatterns.TAGGED_PTR_64;
		else refPatterns = ScalarPatterns.TAGGED_PTR_32;
	}

	def configureCompiler(compiler: Compiler) {
		compiler.Reachability = true;
		if (false && space.addressWidth != 32) { // TODO: enable 64-bit range start
			var it = Int.getType(true, space.addressWidth);
			compiler.NormConfig.RangeStartType = it; // XXX: use unsigned for range start type?
			compiler.NormConfig.ArrayIndexType = it;
		}
		compiler.NormConfig.GetScalar = getScalar;
		compiler.NormConfig.GetBitWidth = getBitWidth;
	}
	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {
		if (space.addressWidth == 32) {
			match (t) {
				x: FloatType => return if(x.is64, Scalar.F64 | Scalar.B64, Scalar.F32 | Scalar.B32);
				x: PrimType => return if(x.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R64, once packed refs
				_ => return Scalar.R32;
			}
		} else {
			match (t) {
				x: FloatType => return Scalar.F64 | Scalar.B64;
				x: PrimType => return Scalar.B64; // XXX: Scalar.R64, once packed refs
				_ => return Scalar.R64;
			}
		}
	}
	private def getBitWidth(compiler: Compiler, prog: Program, t: Type) -> byte {
		match (t) {
			x: PrimType => return x.width;
			_ => return space.addressWidth;
		}
	}
	def configureProgram(prog: Program) {
		var mach = MachProgram.new(prog, space, space, intNorm);
		var vaddr_start = long.!(CLOptions.VM_START_ADDR.get()); // TODO(addr64)
		if (vaddr_start == 0) vaddr_start = DEFAULT_VADDR_START;
		if (vaddr_start < 3_000_000_000L) mach.codeRegion.refSize = 4;
		prog.tprog = mach;
		var rt = MachRuntime.new(mach);
		mach.runtime = rt;
		MachModule.install(prog, mach); // installs "Pointer" typecon
		prog.typeEnv.add(linuxComponent);
		prog.typeEnv.add(rt.typeCon); // installs "CiRuntime" component (for RiRuntime code)
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	private def getRuntime(prog: Program) -> MachRuntime {
		return MachProgram.!(prog.tprog).runtime;
	}
	def emit(compiler: Compiler, prog: Program) {
		var rt = getRuntime(prog), mach = rt.mach;
		mach.build(compiler, machLoweringConfig);

		// make an ELF file
		var elf = ElfHeader.new();
		elf.e_machine = elf_machine;

		// allocate section headers for string, symbol table
		def exports = mach.exports;  // may include implicit export of main
		def haveExports = mach.explicitExports;  // only explicit imports
		def haveImports = prog.numImports > 0;   // imports are always explicit
		def emitRel = haveExports | haveImports;  // explicit externals implies relocatable output
		if (emitRel) elf.e_type = ElfType.ET_REL;
		def emitSymbols = emitRel || CLOptions.SYMBOLS.val || compiler.DebugSymbol;
		var sections = if(emitSymbols, ElfSections.new(elf, haveExports, haveImports, compiler.DebugSymbol));
		var dwarf = if(compiler.DebugSymbol, Dwarf.new(elf, sections, prog, mach));

		var pageAlign = mach.code.pageAlign;

		var vaddr_start = long.!(CLOptions.VM_START_ADDR.get()); // TODO(addr64)
		if (vaddr_start == 0) vaddr_start = DEFAULT_VADDR_START;
		var w = MachDataWriter.new(mach.code.pageAlign, vaddr_start, 300);

		// allocate a stack segment if a non-zero stack size is specified
		var stackSize = int.!(pageAlign.alignUp_u64(CLOptions.STACK_SIZE.get()));
		if (stackSize > 0) {
			var stack = elf.addProgramHeader();
			stack.p_type = ElfPhType.PT_LOAD;
			stack.p_filesz = 0;
			stack.p_offset = 0;
			stack.p_memsz = stackSize;
			stack.p_flags = ElfConst.PF_RW;
			stack.p_vaddr = long.!(w.startAddr);		// TODO(addr64)
			rt.recordStackStart(long.!(w.startAddr));	// TODO(addr64)
			w.skipAddr(stackSize);				// TODO(addr64)
			rt.recordStackEnd(long.!(w.startAddr));		// TODO(addr64)
		}

		// fill out the code section
		var code = elf.addProgramHeader();
		code.p_type = ElfPhType.PT_LOAD;
		code.p_offset = 0;
		code.p_filesz = pageAlign.size;
		code.p_memsz = pageAlign.size;
		code.p_flags = ElfConst.PF_RX;

		// ex segment for trapping explicit checks
		var ex = if(rt.src != null, elf.addProgramHeader());

		// fill out the data section
		var data = elf.addProgramHeader();
		data.p_type = ElfPhType.PT_LOAD;
		data.p_filesz = pageAlign.size;
		data.p_memsz = pageAlign.size;
		data.p_flags = ElfConst.PF_RW;

		// reserve a region for runtime code if necessary.
		var runtimeCodeSize = int.!(pageAlign.alignUp_u64(CLOptions.RUNTIME_CODE_SIZE.get())); // runtime code region size
		var rtexe = if(runtimeCodeSize > 0, elf.addProgramHeader());

		// skip over ELF header
		w.skipN(int.!(elf.size()));

		// emit code
		var backend = newBackend(compiler, prog, mach, w, dwarf);
		code.p_vaddr = w.endPageAddr();
		backend.genAllCode();
		var main = prog.getMain();
		rt.recordCodeStart(mach.entryStub.absolute);
		if (main != null) elf.e_entry = mach.entryStub.absolute;
		rt.recordCodeEnd(w.addr_end());

		mach.reserveRuntimeCode(w); // TODO: add .reserved_code symbol

		if (rtexe != null) {
			// TODO: add .runtime_code symbol
			var startAddr = pageAlign.alignUp_i64(w.addr_end());
			rt.recordRuntimeCode(startAddr, runtimeCodeSize);
			rtexe.p_type = ElfPhType.PT_LOAD;
			rtexe.p_filesz = 1; // file size cannot be zero, apparently
			rtexe.p_vaddr = startAddr;
			rtexe.p_memsz = runtimeCodeSize;
			rtexe.p_flags = ElfConst.PF_RWX;
			w.skipN(1);
			w.skipAddr(runtimeCodeSize);
		} else {
			rt.recordRuntimeCode(0, 0);
		}

		// Build list of addresses of imported functions, for replacing references
		// to their Unimplemented stubs.  This is done here so that all later
		// encoding of addresses in MachProgram will record references to the stubs.
		var imports = mach.imports;
		var importLocs = mach.importLocs;
		var importSymNum: Vector<int>;
		// hash set of imported names (as imported)
		var importNames: HashMap<string, void> = Strings.newMap();
		// Flag to track whether a symbol section is needed
		var anySymbols = false;
		if (haveImports) {
			importSymNum = Vector<int>.new().putn(-1, imports.length);
			for (i < imports.length) {
				var imp = imports[i], name = imp.0;
				anySymbols = true;
				importSymNum[i] = sections.queueUndefSymbol(name, long.!(space.addressSize));
			}
		}

		mach.layoutMeta(w);
		mach.layoutRuntime(w);
		code.p_filesz = w.end();
		code.p_memsz = pageAlign.alignUp_i64(code.p_filesz);
		code.p_offset = 0;

		// generate the unmapped "ex" region for trapping explicit checks
		if (ex != null) {
			w.skipPage();
			var exStart = w.endPageAddr();
			var exSize = pageAlign.alignUp_i64(rt.src.layoutExRegion(exStart));
			w.skipAddr(exSize);
			ex.p_vaddr = exStart;
			ex.p_memsz = exSize;
			ex.p_filesz = 0;
			ex.p_offset = 0;
		}

		// emit data
		w.skipPage();
		w.atEnd().align(mach.data.addressSize);
		data.p_vaddr = w.endPageAddr();
		data.p_offset = data.p_vaddr - long.!(w.startAddr); // TODO(addr64)
		mach.layoutData(w);
		rt.addHeapPointers(w);
		data.p_filesz = w.end() - data.p_offset;
		data.p_memsz = pageAlign.alignUp_i64(data.p_filesz + int.view(rt.heapSize + rt.shadowStackSize));

		// patch all addresses in the binary
		w.patchWithCallback(mach, patchImport(elf, sections, code, data, w, mach, _, _, _, _));

		if (sections != null) {
			sections.data.sh_addr = data.p_vaddr;
			sections.data.sh_offset = data.p_offset;
			sections.data.sh_size = data.p_filesz;

			sections.text.sh_addr = code.p_vaddr;
			sections.text.sh_offset = code.p_offset;
			sections.text.sh_size = code.p_filesz;

			sections.startStringSection(w);
			sections.addQueuedUndefs(w);  // do this right away so indices are right

			if (emitRel) {
				var tempAddr = Addr.new(null, null, 0);
				tempAddr.absolute = code.p_vaddr;
				sections.addAbsSymbol(w, ".text.virgil.base", tempAddr);
				tempAddr.absolute = data.p_vaddr;
				sections.addAbsSymbol(w, ".data.virgil.base", tempAddr);
			}

			def exportAddrs = mach.getExportAddrs();
			if (main != null && (exports != null || haveImports || CLOptions.SYMBOLS.val)) {
				sections.addFuncSymbol(w, ".entry", mach.entryStub);
			}
	
			if (exports != null) {
				for (i < exports.length) {
					var exp = exports[i];
					var name = if(exp.name == null, exp.spec.asMethod().source.name(), exp.name);
					var addr = exportAddrs[name];
					if (addr == null) continue;
					anySymbols = true;
					sections.addFuncSymbol(w, name, addr);
				}
			}

			if (haveImports) {
				for (i < importLocs.length) {
					for (node = importLocs[i]; node != null; node = node.tail) {
						def info = node.head, vaddr = info.0, pos = info.1;
						var isDataAddr = (u64.view(vaddr) >= u64.view(data.p_vaddr));
						var index = u32.!(importSymNum[i]);
						var offset = u64.!(vaddr - if(isDataAddr, data.p_vaddr, code.p_vaddr));
						var rtype: u8 = if(elf.is64(), Elf64_R_Type.R_X86_64_64.code, Elf32_R_Type.R_386_32.code);
						var addend: i64 = 0;
						var entries = if(isDataAddr, sections.data_reloc_entries, sections.text_reloc_entries);
						entries.put(ElfReloc.new(offset, index, rtype, addend, pos));
					}
				}
			}

			if (CLOptions.SYMBOLS.val) {
				anySymbols = true;
				if (mach.allocStub != null) sections.addFuncSymbol(w, ".alloc", mach.allocStub);
				if (mach.signalStub != null) sections.addFuncSymbol(w, ".signal", mach.signalStub);

				var buf = StringBuilder.new();
				for (i < prog.ir.methods.length) {
					var m = prog.ir.methods[i];
					if (m.source == null) continue;
					var addr = mach.methodMap[m];
					if (addr == null || addr.absolute < 0) continue;
					var name = m.renderLong(buf).extract();
					if (exportAddrs.has(name) || importNames.has(name)) {
						// a different function is exported or imported under this name, so
						// change the name of this function in the symbol table
						name = Arrays.concat(name, ".hide");
					}
					sections.addFuncSymbol(w, name, addr);
				}
			}
			sections.finishStringSection(w);
			// encode the symbol table entries
			if (anySymbols) sections.encodeSymbolTable(w);
		}

		if (haveImports) sections.encodeRelocs(w);

		if (dwarf != null) {
			dwarf.emit(w);
		}

		// encode ELF header section
		elf.encode(w.at(0));

		var file = compiler.getOutputFileName(prog.name(), if(emitRel, "o", null));
		var fd = System.fileOpen(file, false);
		if (fd < 0) return prog.ERROR.OutputError(file);
		// write the entire file from the buffer array
		System.write(fd, w.alias());
		System.fileClose(fd);
		// change permissions to make binary executable
		if (!emitRel) compiler.makeExecutable(file);
	}
}
def patchImport(elf: ElfHeader, sections: ElfSections, code: ElfProgramHeader, data: ElfProgramHeader,
		w: MachDataWriter, mach: MachProgram, kind: PatchKind, addr: Addr, posAddr: long, pos: int) {
	var isDataAddr = (u64.view(posAddr) >= u64.view(data.p_vaddr));
	var imports = mach.imports;
	var absAddr = addr.absolute;
	var index = u32.!((-absAddr) - 1);  // map -2 to 1, -3 to 2, etc.
	var offset = u64.!(posAddr - if(isDataAddr, data.p_vaddr, code.p_vaddr));
	var rtype: u8;
	var addend: i64;
	// Note: regular patching has already happened ...
	match (kind) {
		RELA_32 => {
			// want S - (P - delta) where delta was value in first byte
			// first, get delta by contents - S, + P
			// use a RELA R_X86_64_PC32 / R_386_PC32 with A = delta
			var curr = DataReaders.read_range_i32(w.data[pos ..+ 4]);
			var delta: i32 = (curr - i32.view(addr.absolute)) + i32.!(posAddr);
			rtype = if(elf.is64(), Elf64_R_Type.R_X86_64_PC32.code, Elf32_R_Type.R_386_PC32.code);
			addend = i64.!(delta);
		}
		ABS_32 => { // want S (32 bits)
			// use R_X86_64_32 / R_386_32 with A = 0
			rtype = if(elf.is64(), Elf64_R_Type.R_X86_64_32.code, Elf32_R_Type.R_386_32.code);
			addend = 0;
		}
		ABS_64 => { // want S (64 bits)
			// use R_X86_64_64 with A = 0
			rtype = Elf64_R_Type.R_X86_64_64.code;
			addend = 0;
		}
		_ => {
			// complain
		}
	}
	var entries = if(isDataAddr, sections.data_reloc_entries, sections.text_reloc_entries);
	entries.put(ElfReloc.new(offset, index, rtype, addend, pos));
}

enum DebugSection(printName: string) {
	str(".debug_str\x00"),
	loclists(".debug_loclists\x00"),
	info(".debug_info\x00"),
	abbrev(".debug_abbrev\x00"),
	line_str(".debug_line_str\x00"),
	line(".debug_line\x00"),
}
def DebugSectionCount = 6;

class ElfSections(elf: ElfHeader, haveExports: bool, haveImports: bool, debugSymbol: bool) {
	def SHN_ABS: u16 = 0xFFF1;
	def SHN_UNDEF: u16 = 0;
	def str = ElfSectionHeader.new();
	def sym = ElfSectionHeader.new();
	def text = ElfSectionHeader.new();
	def data = ElfSectionHeader.new();
	def debugs = Array<ElfSectionHeader>.new(DebugSectionCount);
	def symbols = Vector<ElfSymbol>.new();
	def relocatable = haveExports | haveImports;
	var text_relocs: ElfSectionHeader;
	var data_relocs: ElfSectionHeader;
	// an entry is (offset, symbol index, reloc type, addend, position in writer)
	// these are encoded for 32- and 64-bit as a last step
	def text_reloc_entries = Vector<ElfReloc>.new();
	def data_reloc_entries = Vector<ElfReloc>.new();
	var str_start: int;
	def queuedUndefs = Vector<(string, long)>.new();

	new() {
		elf.sheaders.put(ElfSectionHeader.new());
		str.index = elf.sheaders.length;
		elf.sheaders.put(str);
		def haveSym = haveExports || haveImports || CLOptions.SYMBOLS.val;
		if (haveSym) {
			sym.index = elf.sheaders.length;
			elf.sheaders.put(sym);
		}
		text.index = elf.sheaders.length;
		elf.sheaders.put(text);
		data.index = elf.sheaders.length;
		elf.sheaders.put(data);

		if (haveImports) {
			text_relocs = ElfSectionHeader.new();
			text_relocs.index = elf.sheaders.length;
			elf.sheaders.put(text_relocs);
			data_relocs = ElfSectionHeader.new();
			data_relocs.index = elf.sheaders.length;
			elf.sheaders.put(data_relocs);
		}

		if (debugSymbol) {
			for (e in DebugSection) {
				var section = ElfSectionHeader.new();
				debugs[e.tag] = section;
				section.index = elf.sheaders.length;
				elf.sheaders.put(section);
				section.sh_type = ElfShType.SHT_PROGBITS;
			}
		}

		str.sh_type = ElfShType.SHT_STRTAB;
		if (haveSym) {
			symbols.put(ElfSymbol.new());
			sym.sh_type = ElfShType.SHT_SYMTAB;
			sym.sh_link = str.index;
			sym.sh_entsize = if(elf.is64(), Elf64le_Symbol.size, Elf32le_Symbol.size);
			sym.sh_info = 1;
		}

		if (haveImports) {
			// set up relocs
			// they can be located in the text section and in the data section
			text_relocs.sh_type = if(elf.is64(), ElfShType.SHT_RELA, ElfShType.SHT_REL);
			text_relocs.sh_link = sym.index;
			text_relocs.sh_entsize = if(elf.is64(), Elf64le_Rela.size, Elf32le_Rel.size);
			text_relocs.sh_info = u32.!(text.index);
			text_relocs.sh_flags = ElfConst.SHF_INFO_LINK;

			data_relocs.sh_type = if(elf.is64(), ElfShType.SHT_RELA, ElfShType.SHT_REL);
			data_relocs.sh_link = sym.index;
			data_relocs.sh_entsize = if(elf.is64(), Elf64le_Rela.size, Elf32le_Rel.size);
			data_relocs.sh_info = u32.!(data.index);
			data_relocs.sh_flags = ElfConst.SHF_INFO_LINK;
		}

		elf.e_shstrndx = byte.!(str.index);
		text.sh_type = ElfShType.SHT_PROGBITS;
		text.sh_addralign = 1;
		data.sh_type = ElfShType.SHT_PROGBITS;
		data.sh_addralign = 4;

		text.sh_flags = ElfConst.SHF_ALLOC | ElfConst.SHF_EXECINSTR;
		data.sh_flags = ElfConst.SHF_ALLOC | ElfConst.SHF_WRITE;
	}
	def startStringSection(w: DataWriter) {
		w.atEnd();
		str_start = w.pos;
		w.putb(0);
		str.sh_offset = str_start;
		str.sh_name = w.pos - str_start;
		w.puta(".strtab\x00");

		if (CLOptions.SYMBOLS.val) {
			sym.sh_name = w.pos - str_start;
			w.puta(".symtab\x00");
		}

		text.sh_name = w.pos - str_start;
		w.puta(".text").puta(if(relocatable, ".virgil", null)).putb(0);

		data.sh_name = w.pos - str_start;
		w.puta(".data").puta(if(relocatable, ".virgil", null)).putb(0);

		if (haveImports) {
			text_relocs.sh_name = w.pos - str_start;
			w.puta(if(elf.is64(), ".rela.text", ".rel.text")).putb(0);
			data_relocs.sh_name = w.pos - str_start;
			w.puta(if(elf.is64(), ".rela.data", ".rel.data")).putb(0);
		}

		if (debugSymbol) {
			for (e in DebugSection) {
				var section = debugs[e.tag];
				section.sh_name = w.pos - str_start;
				w.puta(e.printName);
			}
		}
	}
	def finishStringSection(w: DataWriter) {
		str.sh_size = w.pos - str_start;
	}
	def encodeSymbolTable(w: DataWriter) {
		sym.sh_offset = w.pos;
		if (elf.is64()) {
			for (i < symbols.length) symbols[i].encode64(w);
		} else {
			for (i < symbols.length) symbols[i].encode32(w);
		}
		sym.sh_size = w.pos - sym.sh_offset;
	}
	def encodeRelocs(w: DataWriter) {
		text_relocs.sh_offset = w.pos;
		if (elf.is64()) {
			for (i < text_reloc_entries.length) text_reloc_entries[i].encode64(w);
		} else {
			for (i < text_reloc_entries.length) text_reloc_entries[i].encode32(w);
		}
		text_relocs.sh_size = w.pos - text_relocs.sh_offset;

		data_relocs.sh_offset = w.pos;
		if (elf.is64()) {
			for (i < data_reloc_entries.length) data_reloc_entries[i].encode64(w);
		} else {
			for (i < data_reloc_entries.length) data_reloc_entries[i].encode32(w);
		}
		data_relocs.sh_size = w.pos - data_relocs.sh_offset;
	}
	def addAbsSymbol(w: MachDataWriter, str: string, addr: Addr) {
		var entry = ElfSymbol.new();
		symbols.put(entry);
		entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
		entry.st_name = w.pos - str_start;
		entry.st_value = addr.absolute;
		entry.st_size = addr.size;
		entry.st_index = SHN_ABS;
		w.puta(str);
		w.putb(0);
	}
	def queueUndefSymbol(str: string, size: long) -> int {
		var index = symbols.length + queuedUndefs.length;
		queuedUndefs.put((str, size));
		return index;
	}
	def addQueuedUndefs(w: MachDataWriter) {
		for (i < queuedUndefs.length) {
			var info = queuedUndefs[i], name = info.0, size = info.1;
			addUndefSymbol(w, name, size);
		}
	}
	def addUndefSymbol(w: MachDataWriter, str: string, size: long) -> int {
		var entry = ElfSymbol.new();
		var index = symbols.length;
		symbols.put(entry);
		entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
		entry.st_name = w.pos - str_start;
		entry.st_value = 0;
		entry.st_size = size;
		entry.st_index = SHN_UNDEF;
		w.puta(str);
		w.putb(0);
		return index;
	}
	def addFuncSymbol(w: MachDataWriter, str: string, addr: Addr) {
		var entry = ElfSymbol.new();
		symbols.put(entry);
		entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
		entry.st_name = w.pos - str_start;
		entry.st_value = addr.absolute - text.sh_addr;
		entry.st_size = addr.size;
		entry.st_index = u16.!(text.index);
		w.puta(str);
		w.putb(0);
	}
}
