// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Contains logic to generate a Linux executable (ELF) file.
class LinuxTarget extends Target {
	def space: AddressSpace;
	def intNorm: IntNormalizer;
	def machLoweringConfig: MachLoweringConfig;
	def newBackend: (Compiler, Program, MachProgram, MachDataWriter, Dwarf) -> MachBackend;
	def kernelCallReturnType: Type;
	def linuxComponent = Kernel_TypeCon.new(Kernel.LINUX, kernelCallReturnType);
	def DEFAULT_VADDR_START = 0x08000000;
	def elf_machine: u8;

	new(name: string, space, intNorm, machLoweringConfig, newBackend, elf_machine, kernelCallReturnType) super(name) {
		if (space.addressWidth == 64) refPatterns = ScalarPatterns.TAGGED_PTR_64;
		else refPatterns = ScalarPatterns.TAGGED_PTR_32;
	}

	def configureCompiler(compiler: Compiler) {
		compiler.Reachability = true;
		if (false && space.addressWidth != 32) { // TODO: enable 64-bit range start
			var it = Int.getType(true, space.addressWidth);
			compiler.NormConfig.RangeStartType = it; // XXX: use unsigned for range start type?
			compiler.NormConfig.ArrayIndexType = it;
		}
		compiler.NormConfig.GetScalar = getScalar;
		compiler.NormConfig.GetBitWidth = getBitWidth;
	}
	private def getScalar(compiler: Compiler, prog: Program, t: Type) -> Scalar.set {
		if (space.addressWidth == 32) {
			match (t) {
				x: FloatType => return if(x.is64, Scalar.F64 | Scalar.B64, Scalar.F32 | Scalar.B32);
				x: PrimType => return if(x.width <= 32, Scalar.B32 | Scalar.B64, Scalar.B64); // XXX: Scalar.R64, once packed refs
				_ => return Scalar.R32;
			}
		} else {
			match (t) {
				x: FloatType => return Scalar.F64 | Scalar.B64;
				x: PrimType => return Scalar.B64; // XXX: Scalar.R64, once packed refs
				_ => return Scalar.R64;
			}
		}
	}
	private def getBitWidth(compiler: Compiler, prog: Program, t: Type) -> byte {
		match (t) {
			x: PrimType => return x.width;
			_ => return space.addressWidth;
		}
	}
	def configureProgram(prog: Program) {
		var mach = MachProgram.new(prog, space, space, intNorm);
		var vaddr_start = long.!(CLOptions.VM_START_ADDR.get()); // TODO(addr64)
		if (vaddr_start == 0) vaddr_start = DEFAULT_VADDR_START;
		if (vaddr_start < 3_000_000_000L) mach.codeRegion.refSize = 4;
		prog.tprog = mach;
		var rt = MachRuntime.new(mach);
		mach.runtime = rt;
		MachModule.install(prog, mach); // installs "Pointer" typecon
		prog.typeEnv.add(linuxComponent);
		prog.typeEnv.add(rt.typeCon); // installs "CiRuntime" component (for RiRuntime code)
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	private def getRuntime(prog: Program) -> MachRuntime {
		return MachProgram.!(prog.tprog).runtime;
	}
	def emit(compiler: Compiler, prog: Program) {
		var rt = getRuntime(prog), mach = rt.mach;
		mach.build(compiler, machLoweringConfig);

		// make an ELF file
		var elf = ElfHeader.new();
		elf.e_machine = elf_machine;

		// allocate section headers for string, symbol table
		def exports = Vector<IrRoot>.new();
		for (i < prog.ir.roots.length) {
			var root = prog.ir.roots[i];
			if (root.name != null) exports.put(root);
		}
		def haveExports = exports.length > 0;
		def haveImports = prog.numImports > 0;
		def emitRel = haveExports | haveImports;
		if (emitRel) elf.e_type = ElfType.ET_REL;
		def emitSymbols = emitRel || CLOptions.SYMBOLS.val || compiler.DebugSymbol;
		var sections = if(emitSymbols, ElfSections.new(elf, haveExports, haveImports, compiler.DebugSymbol));
		var dwarf = if(compiler.DebugSymbol, Dwarf.new(elf, sections, prog, mach));

		var pageAlign = mach.code.pageAlign;

		var vaddr_start = long.!(CLOptions.VM_START_ADDR.get()); // TODO(addr64)
		if (vaddr_start == 0) vaddr_start = DEFAULT_VADDR_START;
		var w = MachDataWriter.new(mach.code.pageAlign, vaddr_start, 300);

		// allocate a stack segment if a non-zero stack size is specified
		var stackSize = int.!(pageAlign.alignUp_u64(CLOptions.STACK_SIZE.get()));
		if (stackSize > 0) {
			var stack = elf.addProgramHeader();
			stack.p_type = ElfPhType.PT_LOAD;
			stack.p_filesz = 0;
			stack.p_offset = 0;
			stack.p_memsz = stackSize;
			stack.p_flags = ElfConst.PF_RW;
			stack.p_vaddr = long.!(w.startAddr);		// TODO(addr64)
			rt.recordStackStart(long.!(w.startAddr));	// TODO(addr64)
			w.skipAddr(stackSize);				// TODO(addr64)
			rt.recordStackEnd(long.!(w.startAddr));		// TODO(addr64)
		}

		// fill out the code section
		var code = elf.addProgramHeader();
		code.p_type = ElfPhType.PT_LOAD;
		code.p_offset = 0;
		code.p_filesz = pageAlign.size;
		code.p_memsz = pageAlign.size;
		code.p_flags = ElfConst.PF_RX;

		// ex segment for trapping explicit checks
		var ex = if(rt.src != null, elf.addProgramHeader());

		// fill out the data section
		var data = elf.addProgramHeader();
		data.p_type = ElfPhType.PT_LOAD;
		data.p_filesz = pageAlign.size;
		data.p_memsz = pageAlign.size;
		data.p_flags = ElfConst.PF_RW;

		// reserve a region for runtime code if necessary.
		var runtimeCodeSize = int.!(pageAlign.alignUp_u64(CLOptions.RUNTIME_CODE_SIZE.get())); // runtime code region size
		var rtexe = if(runtimeCodeSize > 0, elf.addProgramHeader());

		// skip over ELF header
		w.skipN(int.!(elf.size()));

		// emit code
		var backend = newBackend(compiler, prog, mach, w, dwarf);
		code.p_vaddr = w.endPageAddr();
		backend.genAllCode();
		var main = prog.getMain();
		rt.recordCodeStart(mach.entryStub.absolute);
		if (main != null) elf.e_entry = mach.entryStub.absolute;
		rt.recordCodeEnd(w.addr_end());

		mach.reserveRuntimeCode(w); // TODO: add .reserved_code symbol

		if (rtexe != null) {
			// TODO: add .runtime_code symbol
			var startAddr = pageAlign.alignUp_i64(w.addr_end());
			rt.recordRuntimeCode(startAddr, runtimeCodeSize);
			rtexe.p_type = ElfPhType.PT_LOAD;
			rtexe.p_filesz = 1; // file size cannot be zero, apparently
			rtexe.p_vaddr = startAddr;
			rtexe.p_memsz = runtimeCodeSize;
			rtexe.p_flags = ElfConst.PF_RWX;
			w.skipN(1);
			w.skipAddr(runtimeCodeSize);
		} else {
			rt.recordRuntimeCode(0, 0);
		}

		// Build list of addresses of imported functions, for replacing references
		// to their Unimplemented stubs.  This is done here so that all later
		// encoding of addresses in MachProgram will record references to the stubs.

		// hash set of imported names (as imported)
		var importNames = HashMap<string, void>.new(Strings.hash, Strings.equal);
		// Map from addresses of imported functions to their symbol table indexes
		var importAddrs = HashMap<long, int>.new(int.view, long.==);
		// Map from addresses of imported functions to locations that refer to them;
		// locations are (virtual address, offset in DataWriter)
		var importLocs = HashMap<long, List<(long, int)>>.new(int.view, long.==);
		// Flag to track whether a symbol section is needed
		var anySymbols = false;
		if (haveImports) {
			for (i < prog.ir.classes.length) {
				var cls = prog.ir.classes[i];
				var ctype = cls.ctype;
				// only methods of component can possibly be imported
				if (!V3.isComponent(ctype)) continue;
				var importToken = ComponentType.!(ctype).componentDecl.importName;
				// the component's methods are imported if its importToken is set
				if (importToken == null) continue;
				for (j < cls.methods.length) {
					var meth = cls.methods[j];
					// only specifically defined/named methods can be imported
					if (meth == null || meth.source == null) continue;
					var source = meth.source;
					var methName = source.name();
					var addr = mach.methodMap[meth];
					if (addr == null || addr.absolute < 0) {
						prog.ERROR.addError(source.token.range(), null, "ImportError: imported method is undefined", methName);
						continue;
					}
					// imported name: compImport.methImport, or just methImport if compImport is empty
					var methImportToken = source.importName;
					if (methImportToken != null) methName = methImportToken.image;
					var sep = if(importToken.image.length > 0, ".", "");
					var fullName = StringBuilder.new().puts(importToken.image).puts(sep).puts(methName).extract();
					anySymbols = true;
					importAddrs[addr.absolute] = sections.queueUndefSymbol(fullName, long.!(space.addressSize));
					importLocs[addr.absolute] = null;
					importNames[fullName] = ();
				}
			}
			prog.ERROR.report();
		}
		if (anySymbols) mach.importLocs = importLocs;

		mach.layoutMeta(w);
		mach.layoutRuntime(w);
		code.p_filesz = w.end();
		code.p_memsz = pageAlign.alignUp_i64(code.p_filesz);
		code.p_offset = 0;

		// generate the unmapped "ex" region for trapping explicit checks
		if (ex != null) {
			w.skipPage();
			var exStart = w.endPageAddr();
			var exSize = pageAlign.alignUp_i64(rt.src.layoutExRegion(exStart));
			w.skipAddr(exSize);
			ex.p_vaddr = exStart;
			ex.p_memsz = exSize;
			ex.p_filesz = 0;
			ex.p_offset = 0;
		}

		// emit data
		w.skipPage();
		w.atEnd().align(mach.data.addressSize);
		data.p_vaddr = w.endPageAddr();
		data.p_offset = data.p_vaddr - long.!(w.startAddr); // TODO(addr64)
		mach.layoutData(w);
		rt.addHeapPointers(w);
		data.p_filesz = w.end() - data.p_offset;
		data.p_memsz = pageAlign.alignUp_i64(data.p_filesz + int.view(rt.heapSize + rt.shadowStackSize));

		// patch all addresses in the binary
		w.patch(mach);

		if (sections != null) {
			sections.data.sh_addr = data.p_vaddr;
			sections.data.sh_offset = data.p_offset;
			sections.data.sh_size = data.p_filesz;

			sections.text.sh_addr = code.p_vaddr;
			sections.text.sh_offset = code.p_offset;
			sections.text.sh_size = code.p_filesz;

			sections.startStringSection(w);
			sections.addQueuedUndefs(w);  // do this right away so indices are right

			if (emitRel) {
				var tempAddr = Addr.new(null, null, 0);
				tempAddr.absolute = code.p_vaddr;
				sections.addAbsSymbol(w, ".text.virgil.base", tempAddr);
				tempAddr.absolute = data.p_vaddr;
				sections.addAbsSymbol(w, ".data.virgil.base", tempAddr);
			}

			def exportAddrs = HashMap<string, Addr>.new(Strings.hash, Strings.equal);
			if (main != null && (haveExports || haveImports || CLOptions.SYMBOLS.val)) {
				sections.addFuncSymbol(w, ".entry", mach.entryStub);
			}
	
			if (haveExports) {
				for (i < exports.length) {
					var exp = exports[i];
					var name = exp.name;
					var meth = exp.spec.asMethod();
					var range = if(meth.source != null, meth.source.token.range());
					var addr = mach.methodMap[meth];
					if (addr == null || addr.absolute < 0) {
						prog.ERROR.addError(range, null, "ExportDeclError: exported method is undefined", name);
						continue;
					}
					exportAddrs[name] = addr;
					anySymbols = true;
					sections.addFuncSymbol(w, name, addr);
				}
				prog.ERROR.report();
			}

			if ((haveExports || haveImports) && main != null && !exportAddrs.has("main")) {
				// need to export main, if it exists, for linking purposes
				var mainMeth = main.asMethod();
				var mainAddr = mach.methodMap[mainMeth];
				if (mainAddr != null && mainAddr.absolute >= 0) {
					exportAddrs["main"] = mainAddr;
					anySymbols = true;
					sections.addFuncSymbol(w, "main", mainAddr);
				}
			}

			if (haveImports) {
				for (node = w.patches; node != null; node = node.tail) {
					var patch = node.head;
					var kind: PatchKind = patch.0;  // the kind of relocation at this place
					var addr: Addr = patch.1;       // the virtual address this location should refer to
					var posAddr: long = patch.2;    // the virtual address of pos in the executable
					var isDataAddr = (u64.view(posAddr) >= u64.view(data.p_vaddr));
					var pos: int = patch.3;         // location in the ELF file to update
					if (addr == null || !importAddrs.has(addr.absolute)) continue;
					var index = u32.!(importAddrs[addr.absolute]);
					var offset = u64.!(posAddr - if(isDataAddr, data.p_vaddr, code.p_vaddr));
					var rtype: u8;
					var addend: i64;
					// Note: regular patching has already happened ...
					match (kind) {
						RELA_32 => {
							// want S - (P - delta) where delta was value in first byte
							// first, get delta by contents - S, + P
							// use a RELA R_X86_64_PC32 / R_386_PC32 with A = delta
							var rf = Ref<Layout_i32>.of(w.data[pos ..+ 4]);
							var curr = rf.val;
							var delta: i32 = (curr - i32.view(addr.absolute)) + i32.!(posAddr);
							rtype = if(elf.is64(), Elf64_R_Type.R_X86_64_PC32.code, Elf32_R_Type.R_386_PC32.code);
							addend = i64.!(delta);
						}
						ABS_32 => { // want S (32 bits)
							// use R_X86_64_32 / R_386_32 with A = 0
							var rf = Ref<Layout_i32>.of(w.data[pos ..+ 4]);
							var curr = rf.val;
							rtype = if(elf.is64(), Elf64_R_Type.R_X86_64_32.code, Elf32_R_Type.R_386_32.code);
							addend = 0;
						}
						ABS_64 => { // want S (64 bits)
							// use R_X86_64_64 with A = 0
							var rf = Ref<Layout_i64>.of(w.data[pos ..+ 8]);
							var curr = rf.val;
							rtype = Elf64_R_Type.R_X86_64_64.code;
							addend = 0;
						}
						_ => {
							// complain
						}
					}
					var entries = if(isDataAddr, sections.data_reloc_entries, sections.text_reloc_entries);
					entries.put(RelocInfo(offset, index, rtype, addend, pos));
				}

				for (node = Maps.keyList(importLocs); node != null; node = node.tail) {
					var addr = node.head;  // addr is virtual address of Unimplemented stub
					for (lnode = importLocs[addr]; lnode != null;lnode = lnode.tail) {
						var info = lnode.head, vaddr = info.0, pos = info.1;
						var isDataAddr = (u64.view(vaddr) >= u64.view(data.p_vaddr));
						var index = u32.!(importAddrs[addr]);
						var offset = u64.!(vaddr - if(isDataAddr, data.p_vaddr, code.p_vaddr));
						var rtype: u8 = if(elf.is64(), Elf64_R_Type.R_X86_64_64.code, Elf32_R_Type.R_386_32.code);
						var addend: i64 = 0;
						var entries = if(isDataAddr, sections.data_reloc_entries, sections.text_reloc_entries);
						entries.put(RelocInfo(offset, index, rtype, addend, pos));
					}
				}
			}

			if (CLOptions.SYMBOLS.val) {
				anySymbols = true;
				if (mach.allocStub != null) sections.addFuncSymbol(w, ".alloc", mach.allocStub);
				if (mach.signalStub != null) sections.addFuncSymbol(w, ".signal", mach.signalStub);

				var buf = StringBuilder.new();
				for (i < prog.ir.methods.length) {
					var m = prog.ir.methods[i];
					if (m.source == null) continue;
					var addr = mach.methodMap[m];
					if (addr == null || addr.absolute < 0) continue;
//					var name = m.source.renderLong(buf).extract();
					var name = m.renderLong(buf).extract();
					if (exportAddrs.has(name) || importNames.has(name)) {
						// a different function is exported or imported under this name, so
						// change the name of this function in the symbol table
						name = Arrays.concat(name, ".hide");
					}
					sections.addFuncSymbol(w, name, addr);
				}
			}
			sections.finishStringSection(w);
			// encode the symbol table entries
			if (anySymbols) sections.encodeSymbolTable(w);
		}

		if (haveImports) sections.encodeRelocs(w);

		if (dwarf != null) {
			dwarf.emit(w);
		}

		// encode ELF header section
		elf.encode(w.at(0));

		var file = compiler.getOutputFileName(prog.name(), if(emitRel, "o", null));
		var fd = System.fileOpen(file, false);
		if (fd < 0) return prog.ERROR.OutputError(file);
		// write the entire file from the buffer array
		System.write(fd, w.alias());
		System.fileClose(fd);
		// change permissions to make binary executable
		if (!emitRel) compiler.makeExecutable(file);
	}
}

enum DebugSection(printName: string) {
	str(".debug_str\x00"),
	loclists(".debug_loclists\x00"),
	info(".debug_info\x00"),
	abbrev(".debug_abbrev\x00"),
	line_str(".debug_line_str\x00"),
	line(".debug_line\x00"),
}
def DebugSectionCount = 6;

type RelocInfo(offset: u64, index: u32, rtype: u8, addend: i64, pos: int);

class ElfSections(elf: ElfHeader, haveExports: bool, haveImports: bool, debugSymbol: bool) {
	def str = ElfSectionHeader.new();
	def sym = ElfSectionHeader.new();
	def text = ElfSectionHeader.new();
	def data = ElfSectionHeader.new();
	def debugs = Array<ElfSectionHeader>.new(DebugSectionCount);
	def symbols = Vector<ElfSymbol>.new();
	def relocatable = haveExports | haveImports;
	def text_relocs = ElfSectionHeader.new();
	def data_relocs = ElfSectionHeader.new();
	// an entry is (offset, symbol index, reloc type, addend, position in writer)
	// these are encoded for 32- and 64-bit as a last step
	def text_reloc_entries = Vector<RelocInfo>.new();
	def data_reloc_entries = Vector<RelocInfo>.new();
	var str_start: int;
	def queuedUndefs = Vector<(string, long)>.new();

	new() {
		elf.sheaders.put(ElfSectionHeader.new());
		str.index = elf.sheaders.length;
		elf.sheaders.put(str);
		def haveSym = haveExports || haveImports || CLOptions.SYMBOLS.val;
		if (haveSym) {
			sym.index = elf.sheaders.length;
			elf.sheaders.put(sym);
		}
		text.index = elf.sheaders.length;
		elf.sheaders.put(text);
		data.index = elf.sheaders.length;
		elf.sheaders.put(data);

		if (haveImports) {
			text_relocs.index = elf.sheaders.length;
			elf.sheaders.put(text_relocs);
			data_relocs.index = elf.sheaders.length;
			elf.sheaders.put(data_relocs);
		}

		if (debugSymbol) {
			for (e in DebugSection) {
				var section = ElfSectionHeader.new();
				debugs[e.tag] = section;
				section.index = elf.sheaders.length;
				elf.sheaders.put(section);
				section.sh_type = ElfShType.SHT_PROGBITS;
			}
		}

		str.sh_type = ElfShType.SHT_STRTAB;
		if (haveSym) {
			symbols.put(ElfSymbol.new());
			sym.sh_type = ElfShType.SHT_SYMTAB;
			sym.sh_link = str.index;
			sym.sh_entsize = if(elf.is64(), Elf64le_Symbol.size, Elf32le_Symbol.size);
			sym.sh_info = 1;
		}

		if (haveImports) {
			// set up relocs
			// they can be located in the text section and in the data section
			text_relocs.sh_type = if(elf.is64(), ElfShType.SHT_RELA, ElfShType.SHT_REL);
			text_relocs.sh_link = sym.index;
			text_relocs.sh_entsize = if(elf.is64(), Elf64le_Rela.size, Elf32le_Rel.size);
			text_relocs.sh_info = u32.!(text.index);
			text_relocs.sh_flags = ElfConst.SHF_INFO_LINK;

			data_relocs.sh_type = if(elf.is64(), ElfShType.SHT_RELA, ElfShType.SHT_REL);
			data_relocs.sh_link = sym.index;
			data_relocs.sh_entsize = if(elf.is64(), Elf64le_Rela.size, Elf32le_Rel.size);
			data_relocs.sh_info = u32.!(data.index);
			data_relocs.sh_flags = ElfConst.SHF_INFO_LINK;
		}

		elf.e_shstrndx = byte.!(str.index);
		text.sh_type = ElfShType.SHT_PROGBITS;
		text.sh_addralign = 1;
		data.sh_type = ElfShType.SHT_PROGBITS;
		data.sh_addralign = 4;

		text.sh_flags = ElfConst.SHF_ALLOC | ElfConst.SHF_EXECINSTR;
		data.sh_flags = ElfConst.SHF_ALLOC | ElfConst.SHF_WRITE;
	}
	def startStringSection(w: DataWriter) {
		w.atEnd();
		str_start = w.pos;
		w.putb(0);
		str.sh_offset = str_start;
		str.sh_name = w.pos - str_start;
		w.puta(".strtab\x00");

		if (CLOptions.SYMBOLS.val) {
			sym.sh_name = w.pos - str_start;
			w.puta(".symtab\x00");
		}

		text.sh_name = w.pos - str_start;
		w.puta(".text").puta(if(relocatable, ".virgil", null)).putb(0);

		data.sh_name = w.pos - str_start;
		w.puta(".data").puta(if(relocatable, ".virgil", null)).putb(0);

		if (haveImports) {
			text_relocs.sh_name = w.pos - str_start;
			w.puta(if(elf.is64(), ".rela.text", ".rel.text")).putb(0);
			data_relocs.sh_name = w.pos - str_start;
			w.puta(if(elf.is64(), ".rela.data", ".rel.data")).putb(0);
		}

		if (debugSymbol) {
			for (e in DebugSection) {
				var section = debugs[e.tag];
				section.sh_name = w.pos - str_start;
				w.puta(e.printName);
			}
		}
	}
	def finishStringSection(w: DataWriter) {
		str.sh_size = w.pos - str_start;
	}
	def encodeSymbolTable(w: DataWriter) {
		sym.sh_offset = w.pos;
		if (elf.is64()) {
			for (i < symbols.length) symbols[i].encode64(w);
		} else {
			for (i < symbols.length) symbols[i].encode32(w);
		}
		sym.sh_size = w.pos - sym.sh_offset;
	}
	def encodeReloc32(w: DataWriter, reloc: RelocInfo) {
		match (reloc.rtype) {
			Elf32_R_Type.R_386_32.code => {
				var entry = Ref<Elf32le_Rel>.of(w.acquire(Elf32le_Rel.size));
				entry.r_offset = u32.!(reloc.offset);
				entry.r_info = ElfLayouts.Elf32_R_Info(reloc.index, reloc.rtype);
				var save = w.pos;
				w.at(reloc.pos);
				w.put_b32(0);
				w.at(save);
			}
			Elf32_R_Type.R_386_PC32.code => {
				var entry = Ref<Elf32le_Rel>.of(w.acquire(Elf32le_Rel.size));
				entry.r_offset = u32.!(reloc.offset);
				entry.r_info = ElfLayouts.Elf32_R_Info(reloc.index, reloc.rtype);
				var save = w.pos;
				w.at(reloc.pos);
				w.put_b32(int.!(reloc.addend));
				w.at(save);
			}
			_ => {
				// complain
			}
		}
	}
	def encodeReloc64(w: DataWriter, reloc: RelocInfo) {
		match (reloc.rtype) {
			Elf64_R_Type.R_X86_64_64.code => {
				var entry = Ref<Elf64le_Rela>.of(w.acquire(Elf64le_Rela.size));
				entry.r_offset = reloc.offset;
				entry.r_info = ElfLayouts.Elf64_R_Info(reloc.index, reloc.rtype);
				entry.r_addend = reloc.addend;
				// clearing the original position may not be necessary, but 0 is usual there
				var save = w.pos;
				w.at(reloc.pos);
				w.put_b64(0);
				w.at(save);
			}
			Elf64_R_Type.R_X86_64_PC32.code => {
				var entry = Ref<Elf64le_Rela>.of(w.acquire(Elf64le_Rela.size));
				entry.r_offset = reloc.offset;
				entry.r_info = ElfLayouts.Elf64_R_Info(reloc.index, reloc.rtype);
				entry.r_addend = reloc.addend;
				// clearing the original position may not be necessary, but 0 is usual there
				var save = w.pos;
				w.at(reloc.pos);
				w.put_b32(0);
				w.at(save);
			}
			Elf64_R_Type.R_X86_64_32.code => {
				var entry = Ref<Elf64le_Rela>.of(w.acquire(Elf64le_Rela.size));
				entry.r_offset = reloc.offset;
				entry.r_info = ElfLayouts.Elf64_R_Info(reloc.index, reloc.rtype);
				entry.r_addend = reloc.addend;
				// clearing the original position may not be necessary, but 0 is usual there
				var save = w.pos;
				w.at(reloc.pos);
				w.put_b32(0);
				w.at(save);
			}
			_ => {
				// complain
			}
		}
	}
	def encodeRelocs(w: DataWriter) {
		text_relocs.sh_offset = w.pos;
		for (i < text_reloc_entries.length) {
			var reloc = text_reloc_entries[i];
			if (elf.is64()) {
				encodeReloc64(w, reloc);
			} else {	
				encodeReloc32(w, reloc);
			}
		}
		text_relocs.sh_size = w.pos - text_relocs.sh_offset;

		data_relocs.sh_offset = w.pos;
		for (i < data_reloc_entries.length) {
			var reloc = data_reloc_entries[i];
			if (elf.is64()) {
				encodeReloc64(w, reloc);
			} else {
				encodeReloc32(w, reloc);
			}
		}
		data_relocs.sh_size = w.pos - data_relocs.sh_offset;
	}
	def SHN_ABS: u16 = 0xFFF1;
	def addAbsSymbol(w: MachDataWriter, str: string, addr: Addr) {
		var entry = ElfSymbol.new();
		symbols.put(entry);
		entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
		entry.st_name = w.pos - str_start;
		entry.st_value = addr.absolute;
		entry.st_size = addr.size;
		entry.st_index = SHN_ABS;
		w.puta(str);
		w.putb(0);
	}
	def queueUndefSymbol(str: string, size: long) -> int {
		var index = symbols.length + queuedUndefs.length;
		queuedUndefs.put((str, size));
		return index;
	}
	def addQueuedUndefs(w: MachDataWriter) {
		for (i < queuedUndefs.length) {
			var info = queuedUndefs[i], name = info.0, size = info.1;
			addUndefSymbol(w, name, size);
		}
	}
	def SHN_UNDEF: u16 = 0;
	def addUndefSymbol(w: MachDataWriter, str: string, size: long) -> int {
		var entry = ElfSymbol.new();
		var index = symbols.length;
		symbols.put(entry);
		entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
		entry.st_name = w.pos - str_start;
		entry.st_value = 0;
		entry.st_size = size;
		entry.st_index = SHN_UNDEF;
		w.puta(str);
		w.putb(0);
		return index;
	}
	def addFuncSymbol(w: MachDataWriter, str: string, addr: Addr) {
		var entry = ElfSymbol.new();
		symbols.put(entry);
		entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
		entry.st_name = w.pos - str_start;
		entry.st_value = addr.absolute - text.sh_addr;
		entry.st_size = addr.size;
		entry.st_index = u16.!(text.index);
		w.puta(str);
		w.putb(0);
	}
}
