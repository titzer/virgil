// Copyright 2024 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Regs: Arm64Regs;
def MRegs: Arm64RegSet;

component Arm64Common {
	def LOWERING = makeMachLoweringConfig();
	def makeMachLoweringConfig() -> MachLoweringConfig {
		var config = MachLoweringConfig.new();
		config.Int32Arith = true;
		config.Int64Arith = true;
		config.ExplicitDivChecks = true;
		config.ExplicitModChecks = true;
		config.IntConvertFUnsigned = false;
		config.IntConvertFMapsNanToZero = false;
		config.IntConvertFPosSaturates = false;
		config.FloatConvertIUnsigned = false;
		return config;
	}

	def KERNEL_PARAM_REGS: Array<Arm64Reg> = [];
	def KERNEL_RETURN_REGS: Array<Arm64Reg> = [];
}

// TODO: negative object headers
class Arm64Backend extends MachBackend {
	var asm: Arm64MacroAssembler; // TODO
	def test: bool;
	var codegen: SsaArm64Gen;
	var allocateRegs: void -> void;
	var allocateRegsGlobal: void -> void;

	// memory allocator configuration
	var objReg: Arm64Gpr;
	var sizeReg: Arm64Gpr;
	var ipReg: Arm64Gpr;
	var spReg: Arm64Gpr;
	var allocStubAddr: Addr;

	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, dwarf: Dwarf, test)
		super(compiler, prog, mach, w) {

		asm = Arm64MacroAssembler.new(w);
		if (ri_gc != null) {
			// call the RiRuntime.gc() method
			prog.ERROR.unimplemented();
		} else {
			// there is no appropriate RiRuntime.gc() method
			objReg = Arm64Regs.R0;
			sizeReg = Arm64Regs.R0;
		}
		codegen = SsaArm64Gen.new(context, mach, asm, w, dwarf);
		if (compiler.useGlobalRegAllocMatcher != VstMatcher.None) allocateRegsGlobal = GlobalRegAlloc.new(MRegs.SET, codegen).allocate;
		if (compiler.LocalRegAlloc) allocateRegs = LocalRegAlloc.new(MRegs.SET, codegen).allocate;
		else allocateRegs = SimpleRegAlloc.new(MRegs.SET, codegen).allocate;
	}

	def unimplemented() {
		mach.fail("unimplemented");
	}

	// Override MachBackend	

	def genEntryStub() {
		asm_exit_code(0);
	}

	def genAllocStub() {
		unimplemented();
	}

	def genCodeFromSsa() {}

	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int) {
		unimplemented();
	}

	def genSignalHandlerStub() {
		unimplemented();
	}

	def genFatalStub(ex: string, addr: Addr) {
		unimplemented();
	}

	// Methods overridden for each OS target
	def genSigHandlerInstall(signo: int, handler: Addr);
	def asm_exit_r(r: Arm64Gpr);
	def asm_exit_code(code: int);
	def genTestOutput(main: IrMethod, frame: MachFrame);

	// Helper functions

	// Returns call frame for an SsaGraph
	def getFrame(ssa: SsaGraph) -> MachFrame {
		return MachFrame.new(Arm64VirgilCallConv.getForGraph(mach, ssa), mach.data.addrAlign, mach.refSize);
	}

	// Adds Arm64 specific frame size to MachFrame
	// XXX 64 -bits for ever local, optimize?. Addition for return address?
	def computeFrameSize(frame: MachFrame) -> MachFrame {
		frame.frameSize = mach.alignTo(frame.slots() * mach.refSize + mach.code.addressSize, mach.stackAlign);
		return frame;
	}

	def genMainInit(frame: MachFrame) {
		unimplemented();
	}
}