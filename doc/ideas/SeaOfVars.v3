def NO_VARS: Array<Var> = [];
def TRUE = ControlValue.new(true);
def FALSE = ControlValue.new(false);
component Uid {
	var next: u32;
}

// A list, to make this file self-contained.
class List<T>(head: T, tail: List<T>) { }

// Values, with null representing bottom _|_; language extensible. 
class Value {
	def equals(that: Value) => this == that;
}
class ControlValue(on: bool) extends Value {
	def equals(that: Value) => ControlValue.?(that) && ControlValue.!(that).on == this.on;
}

// Params; language extensible.
class Param(t: Type) { }

// Types; language extensible.
class Type { }
class ControlType extends Type { }

// Operators; language extensible.
class Operator(outputs: Array<Type>, inputs: Array<Type>) { }

// Base class of all instructions.
class Instr(outputs: Array<Var>, inputs: Array<Var>) {
	new() {
		for (i < outputs.length) outputs[i] = Var.new(Def(this, u15.!(i)));
		for (i < inputs.length) {
			var v = inputs[i];
			v.uses = List.new(Use(this, u15.!(i)), v.uses);
		}
	}
}

// {Def} connects a variables to its definition.
type Def(instr: Instr, index: u15) #unboxed;
// {Use} connects a variable to an instruction that uses it.
type Use(instr: Instr, index: u15) #unboxed;

// Variables represent named computations.
class Var(var definition: Def) {
	var name: string;
	def uid: u32 = Uid.next++;
	var uses: List<Use>;
}

// Instruction that produces a constant value.
class ConstInstr extends Instr {
	new(val: Value) super(Array<Var>.new(1), NO_VARS) { }
}

// Parameter to a program.
class ParamInstr extends Instr {
	new(param: Param) super(Array<Var>.new(1), NO_VARS) { }
}

// If instruction.
class IfInstr extends Instr {
	new(cond: Var, tvar: Var, fvar: Var) super(Array<Var>.new(1), [cond, tvar, fvar]) { }
}

// Instruction to apply an operator.
class ApplyInstr extends Instr {
	new(op: Operator, inputs: Array<Var>) super(Array<Var>.new(op.outputs.length), inputs) { }
}

// Goal instruction.
class GoalInstr extends Instr {
	new(inputs: Array<Var>) super(NO_VARS, inputs) { }
}

class LoopInstr extends Instr {
	def var body: List<Instr>;
	def var next: Array<Var>;
	
	new(inputs: Array<Var>, body) super(Array<Var>.new(inputs.length), inputs) {
		next = Array<Var>.new(inputs.length);
	}
}

// A language uses the sea of variables by extending the values, types, params, and operators.
// class LangValue extends Value { }
// class LangParam extends Param { }
// class LangType extends Type { }
// class LangOperator extends Operator { }
