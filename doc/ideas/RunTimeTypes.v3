// For writing things like interpreters, it can be useful to add more types at
// run time, understood by the GC, etc.

// There are two kinds of run-time types (RTTs): class-like and (pure) arrays.
// A class-like RTT consists of one or more fixed fields, possibly followed by
// an array part.  A type with both fixed fields and an array part is called a
// hybrid type.

// A pure array, or the array part of a hybrid, consists of a repeating
// sequence of one or more fields.  If it is more than one field, the array is
// called mixed.

// Class-like RTTs have a Virgil supertype.  That Virgil type roots a
// hierarchy of class-like RTTs, and there is a separate RTT hierarchy for
// each Virgil class type.  Instances of a class-like RTT appear in Virgil as
// instances of their Virgil supertype.

// Instances of array-like RTTs will appear as instances of RTArray, since
// arrays in Virgil currently do not subtype (and RTTs are inherently mutable,
// so would not subtype anyway).

// The type RTTField is used to describe the fields of an RTT.  When an RTT is
// formed, the RTType object for it analyzes the requested fields and builds
// RTTFieldInfo values which describe the field layout in more detail, to
// simplify access to fields in instances.  It also builds RTTAccessor
// functions to support access to instance fields.

// Special functions we add to the Virgil implementation:
//   Note: "uninitialized" means "all fields have their default value".
//
//   CiRuntime.getTag<T>() -> int
//	Obtains the type tag for class-like type T, to pass to the run-time
//
//   CiRuntime.callNew<T, A>(obj: T, args: A)
//      Calls T.new(obj, args), that is, the internal T.new that initializes
//      an object rather than the usual one that allocates then initializes.
//      T must be class-like and A must match the argument type of T.new.
//
//
//   RiRuntime.newRTClass(superTag: int, fixedFields: Array<RTTField>, arrayFields: Array<RTTField>) -> RTType
//     Creates a new class-like (or hybrid) RTType.  The Virgil supertype's
//     tag is superTag, and fixedFields and arrayFields indicate the fields
//     or the fixed part and the fields of the array elements.  fixedFields
//     may be null or empty, indicating no fields.  arrayFields may be null
//     or empty, indicating a non-hybrid object.  An array only class with a
//     Virgil supertype is fine - it is hybrid but does not add fields to those
//     of the Virgil supertype.  If arrayFields has length greater than one,
//     then the array part is a mixed array.  If the Virgil supertype is not
//     appropriate or the tag is not found, returns null.
//
//   RiRuntime.newRTSubclass(superclass: RTType, newFixed: Array<RTTField>, newArray: Array<RTTField>) -> RTType
//     Creates a new class-like RTT from superclass, which must be a class-like RTT.
//     The fields in newFixed are appended to those of the superclass.  newArray must
//     be null or empty unless superclass has no array fields.  Returns null if
//     necessary criteria are not met.
//
//   RiRuntime.newRTArrayType(arrayFields: Array<RTTField>) -> RTType
//     Creates a new array-like RTType.  arrayFields must be non-null and have
//     length at least one.  The arrays are mixed if the length of arrayFields
//     is more than one.
//
//   RiRuntime.createRTTInstance<T>(rtt: RTType) -> T
//     For a class-like RTT, this creates an uninitialized instance.  The
//     type T must match the Virgil supertype.
//
//   RiRuntime.createRTTHybridInstance<T>(rtt: RTType, length: int) -> T
//     For a class-like RTT that is hybrid, this creates an uninitialized
//     instance with an array part of length elements.  The type T must match
//     the Virgil supertype.
//
//   RiRuntime.createRTTArray(rtt: RTType, length: int) -> RTArray
//     For array-like RTT rtt, creates an uninitialized instance with
//     length elements.
//
//   RiRuntime.getRTType<T>(obj: T) -> RTType
//     If an object is of run-time type, this returns its type.  If it is
//     not of run-time type or is null, it returns null.

class RTType {
	def superTag: int;  // tag of the supertype; -1 for array types
	def superSize: int;  // size of supertype instances
	def fixedSize: int;  // size of our fixed part (rounds up to size of Pointer)
	def eltSize: int; // size of array elements, in bytes; 0 if not array part

	// These record info about the fields and their byte offsets.  For
	// bit fields, the offset is the byte offset of their container.
	private def fixedFields: Array<(RTTFieldInfo, int)>;
	private def arrayFields: Array<(RTTFieldInfo, int)>;

	new(superTag, superSize, fixedSize, eltSize, fixedFields, arrayFields) { }

	def numFixedFields() -> int { return fixedFields.length; }
	def numArrayFields() -> int { return ArrayFields.length; }
	def fixedField(i: int) -> RTTFieldInfo { return fixedFields[i]; }
	def arrayField(i: int) -> RTTFieldInfo { return arrayFields[i]; }

	// Creates an instance; the Virgil supertype is T and A is the type
	// of the arguments to T.new (likely a tuple type).
	def createObject<T, A>(args: A) -> T {
		if (CiRuntime.getTag<T>() != superTag) { var x: T; return x; }
		var obj = RiRuntime.createRTTInstance<T>(this);
		CiRuntime.callNew<T, A>(obj, args);
		return obj;
	}
	def createHybridObject<T, A>(args: A, length: int) -> T {
		if (CiRuntime.getTag<T>() != superTag) { var x: T; return x; }
		var obj = RiRuntime.createRTTHybridInstance<T>(this, length);
		CiRuntime.callNew<T, A>(obj, args);
		return obj;
	}
	def createArrayObject(length: int) -> RTArray {
 		return RiRuntime.createRTTArray(this, length);
	}
	def createSubtype(newFixedFields: Array<RTTField>, newArrayFields: Array<RTTField>) -> RTType {
		return RiRuntime.newRtSubclass(this, newFixedFields, newArrayFields);
	}
}

component RTTypes {
	def newClassType<T>(fixedFields: Array<RTTField>, arrayFields: Array<RTTField>) -> RTType {
		return RiRuntime.newRTClass(CiRuntime.getTag<T>(), fixedFields, arrayFields);
	}
	def newArrayType(arrayFields: Array<RTTField>) -> RTType {
		return RiRuntime.newRTArrayType(arrayFields);
	}
}

component RTObjects {
	def getRTType<T>(obj: T) -> RTType {
		return RiRuntime.getRTType<T>(obj)
	}
	def getFieldPtr<T>(obj: T, index: int) -> (Pointer, RTFieldInfo) {
		var rtt = getRTType(obj);
		if (rtt == null || index >= rtt.fixedFields.length) return (Pointer.NULL, RTFieldInfo.Byte);
		var entry = rtt.fixedFields[index], info = entry.0, offset = entry.1;
		return (Pointer.atContents(obj) + offset, info);
	}
	def loadChecked<FT, F>(p: Pointer) -> F {
		var x: FT = p.load<FT>();
		if (F.?(x)) return F.!(x);
		var f: F;
		return f;
	}
	def loadField<F>(p: Pointer, info: RTFieldInfo) -> F {
		var f: F;
		if (p == Pointer.NULL) return f;
		match (info) {
			Byte   => return loadChecked<i8, F>(p)
			UByte  => return loadChecked<u8, F>(p)
			Short  => return loadChecked<i16, F>(p)
			UShort => return loadChecked<u16, F>(p)
			Int    => return loadChecked<i32, F>(p)
			UInt   => return loadChecked<u32, F>(p)
			Long   => return loadChecked<i64, F>(p)
			ULong  => return loadChecked<u64, F>(p)
			_ => { var f: F; return f; }
		}
	}
	def storeChecked<FT, F>(p: Pointer, f: F) -> bool {
		if (FT.?(f)) {
			p.store<FT>(FT.!(f));
			return true;
		}
		return false;
	}
	def storeField<F>(p: Pointer, info: RTFieldInfo, f: F) -> bool {
		if (p == Pointer.NULL) return false;
		match (info) {
			Byte   => return storeChecked<i8, F>(p, f)
			UByte  => return storeChecked<u8, F>(p, f)
			Short  => return storeChecked<i16, F>(p, f)
			UShort => return storeChecked<u16, F>(p, f)
			Int    => return storeChecked<i32, F>(p, f)
			UInt   => return storeChecked<u32, F>(p, f)
			Long   => return storeChecked<i64, F>(p, f)
			ULong  => return storeChecked<u64, F>(p, f)
			_ => return false;
		}
	}
	def getField<T, F>(obj: T, index: int) -> F {
		var fp = getFieldPtr<T>(obj, index), p = fp.0, info = fp.1;
		return loadField<F>(p, info);
	}
	def setField<T, F>(obj: T, index: int, f: F) -> bool {
		var fp = getFieldPtr<T>(obj, index), p = fp.0, info = fp.1;
		return storeField<F>(p, info, f);
	}
	def extractSigned<FT, F>(p: Pointer, bits: int, offset: int, width: int, info: RTFieldInfo) -> F {
		var v = loadField<FT>(p, info);
		v = v << (width - (bits + offset));
		v = v >> (width - bits);
		return F.!(v);
	}
	def extractUnsigned<FT, F>(p: Pointer, bits: int, offset: int, width: int, info: RTFieldInfo) -> F {
		var v = loadField<FT>(p, info);
		v = v << (width - (bits + offset));
		v = v >>> (width - bits);
		return F.!(v);
	}
	def loadBitField<F>(p: Pointer, info: RTFieldInfo) -> F {
		var f: F;
		if (p == Pointer.NULL || !RTFieldInfo.Bits.?(info)) return f;
		var binfo = RTFieldInfo.Bits.!(info);
		var bits = binfo.bits, offset = binfo.offset;
		match (binfo.container) {
			Byte   => return extractSigned<i8, F>(p, bits, offset, 8, binfo.container);
			UByte  => return extractUnsigned<u8, F>(p, bits, offset, 8, binfo.container);
			Short  => return extractSigned<i16, F>(p, bits, offset, 16, binfo.container);
			UShort => return extractUnsigned<u16, F>(p, bits, offset, 16, binfo.container);
			Int    => return extractSigned<i32, F>(p, bits, offset, 32, binfo.container);
			UInt   => return extractUnsigned<u32, F>(p, bits, offset, 32, binfo.container);
			Long   => return extractSigned<i64, F>(p, bits, offset, 64, binfo.container);
			ULong  => return extractUnsigned<i8u64, F>(p, bits, offset, 64, binfo.container);
			_ => return f;
		}
	}
	def getBitField<T, F>(obj: T, index: int) -> F {
		var fp = getFieldPtr<T>(obj, index), p = fp.0, info = fp.1;	
		return loadBitField<F>(p, info);
	}
	def updateBits<FT, F>(p: Pointer, bits: int, offset: int, f: F, info: RTFieldInfo) -> bool {
		// What about signed vs unsigned F and FT?  The cast may always fail ...
		if (!FT.?(f)) return false;
		var v = loadField<FT>(p, info);
		var mask = ((FT.!(1) << bits) - 1) << offset;
		var f0 = FT.!(f) << offset
		var v0 = (v & ~mask) | (f0 & mask);
		storeField<FT>(p, info, v0);
		return true;
	}
	def updateBitField<F>(p: Pointer, info: RTFieldInfo, f: F) -> bool {
		if (p == Pointer.NULL || !RTFieldInfo.Bits.?(info)) return false;
		var binfo = RTFieldInfo.Bits.!(info);
		var bits = binfo.bits, offset = binfo.bitOffset;
		match (binfo.container) {
			Byte   => return updateBits<i8, F>(p, bits, offset, f);
			UByte  => return updateBits<u8, F>(p, bits, offset, f);
			Short  => return updateBits<i16, F>(p, bits, offset, f);
			UShort => return updateBits<u16, F>(p, bits, offset, f);
			Int    => return updateBits<i32, F>(p, bits, offset, f);
			UInt   => return updateBits<u32, F>(p, bits, offset, f);
			Long   => return updateBits<i64, F>(p, bits, offset, f);
			ULong  => return updateBits<u64, F>(p, bits, offset, f);
			_ => return false;
		}
	}
	def setBitField<T, F>(obj: T, index: int, f: F) -> bool {
		var rtt = getRTType(obj);
		if (rtt == null || index >= rtt.fixedFields.length) return false;
		var entry = rtt.fixedFields[index], info = entry.0, offset = entry.1;
		p = Pointer.atContents(obj) + offset;
		return updateBitField<F>(p, info, f);
	}
	def getLength<T>(obj: T) -> int {
		var rtt = getRTType(obj);
		if (rtt == null || rtt.arrayField == null || rtt.arrayFields.length == 0) return 0;
		var p = Pointer.atContents(obj) + rtt.fixedSize;
		return p.load<int>();
	}
	def getIndexedFieldPtr<T>(obj: T, findex: int, index: int) -> (Pointer, RTFieldInfo) {
		var rtt = getRTType(obj);
		if (rtt == null || findex >= rtt.arrayFields.length) return Pointer.NULL;
		if (index >= getLength(obj)) return Pointer.NULL;
		var entry = rtt.arrayFields[findex], info = entry.0, offset = entry.1;
		return (Pointer.atContents(obj) + rtt.fixedSize + 4 + index * rtt.eltSize + offset, info);
	}
	def getIndexedField<T, F>(obj: T, findex: int, index: int) -> F {
		var fp = getIndexedFieldPtr<T>(obj, findex, index), p = fp.0, info = fp.1;
		return loadField<F>(p, info);
	}
	def setIndexedField<T, F>(obj: T, findex: int, index: int, f: F) -> bool {
		var fp = getIndexedFieldPtr<T>(obj, findex, index), p = fp.0, info = fp.1;
		return storeField<F>(p, info, f);
	}
	def getIndexedBitField<T, F>(obj: T, findex: int, index: int) -> F {
		var fp = getIndexedFieldPtr<T>(obj, findex, index), p = fp.0, info = fp.1;
		return loadBitField<F>(p, info);
	}
	def setIndexedBitField<T, F>(obj: T, findex: int, index: int, f: F) -> bool {
		var fp = getIndexedFieldPtr<T>(obj, findex, index), p = fp.0, info = fp.1;
		return updateBitField<F>(p, info, f);
	}
}

type RTTField {
	case Int(signed: bool, bits: int, align: int);
		// bits is the width in bits; align is the power of two for alignment, in bits;
		// thus, align 3 means byte aligned; the idea is to support packing int fields;
		// they are required to pack in a way that does not require fetching or storing
		// more than one machine unit, but may require shifting/masking
	case Float;  // size 32, alignment according to target (at least byte)
	case Double;  // size 64, alignment according to target (at least byte)
	case Reference;  // Pointer size, and aligned to that size
}

// Detailed layout may vary depending on target alignment requirements
type RTTFieldInfo {
	// Non-packed cases of integers are pulled out
	case Byte;  //  8 bits, signed
	case UByte;  //  8 bits, unsigned
	case Short;  // 16 bits, signed
	case UShort;  // 16 bits, unsigned
	case Int;  // 32 bits, signed
	case UInt;  // 32 bits, unsigned
	case Long;  // 64 bits, signed
	case ULong;  // 64 bits, unsigned
	// The packed case
	case Bits( signed: bool, bits: int, bitOffset: int, container: RTTFieldInfo);
		// a packed bit field; container indicates an Byte/Short/Int/Long that
		// contains the bit field, bitOffset gives the index of the low order bit,
		// and bits is the number of bits in the field
	case Float;
	case Double;
	case Reference;
}
