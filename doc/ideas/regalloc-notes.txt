pred0:
  ...
  parmove [def (x, 0) ... use(y, 0) ...]
  goto block


pred1:
  ...
  parmove [def (x, 0) ... use(z, 0) ...]
  goto block

block:
  ...
  instr [... use x]


==========================
=== after pre-spilling ===
==========================

x.spill = slot

pred0:
  ...
  parmove [def (x, 0) ... use(y, 0) ...]
  goto block


pred1:
  ...
  parmove [def (x, 0) ... use(z, 0) ...]
  goto block

block:
  ...
  restore [def (x, 0) use(_, slot)]
  instr [... use x]

(relies on regalloc to insert save slot <- x at defs)


======================================
=== suppose gcra computes liveness ===
======================================

x.spill = slot

pred0:
  ...
  parmove [def (x, 0) ... use(y, 0) ...]
  <x is not live out>
  goto block


pred1:
  ...
  parmove [def (x, 0) ... use(z, 0) ...]
  <x is not live out>
  goto block

block:
  ...
  <x is not live in>
  restore [def (x, 0) use(_, slot)]
  <x is live>
  instr [... use x]
  ...
  <x maybe no longer live>

x.use = true

======================================
=== suppose gcra sets x.reg = r1 =====
======================================

pred0:
  ...
  parmove [def (x, 0) ... use(y, 0) ...]
  !!! r1 should not be written, may interfere with other live vars
  <x is not live out>
  goto block


pred1:
  ...
  parmove [def (x, 0) ... use(z, 0) ...]
  !!! r1 should not be written, may interfere with other live vars
  <x is not live out>
  goto block

block:
  ...
  <x is not live in>
  restore [def (x, 0) use(_, slot)]
  <x is live>
  instr [... use x]
  ...
  <x maybe no longer live>


Options:
   - during graph building, if a def is a vreg that is not live,
     - if the vreg is spilled, either:
       a.) replace with def of (null, slot)
       b.) make new tmp, replace with def of (tmp, constraint)  and insert move [def (null, slot), use(tmp, 0)], set tmp.hint = reg(constraint)
     - if the vreg is not spilled, replace with def (DEAD, scratch)
   - be careful to never use DEAD
   - precolor DEAD1, DEAD2, etc to scratch of appropriate regclass
   - what about cycle-breaking in parmoves?

======================================
=== suppose gcra spills x ============
======================================

x.spill = slot

pred0:
  ...
  parmove [def (x, 0) ... use(y, 0) ...]
  <x is not live out>
  goto block


pred1:
  ...
  parmove [def (x, 0) ... use(z, 0) ...]
  <x is not live out>
  goto block

block:
  ...
  <x is not live in>
  restore [def (x, 0) use(_, slot)] <--- remove
  <x is not live in>
  reload [def (t, 0), use(_, slot)]
  instr [... use t]
  ...
  <x maybe no longer live>


Actions:
   - allocate new vreg t
   - if parmove [def(y, ys) ... use(x, 0)], then rewrite to parmove [def(y, ys) ... use(_, slot)[
   - otherwise insert reload [def (t, 0), use (_, slot)] before any use
   - remove reload of def that is not live-in
   - otherwise if a def is a vreg that is not live,
     - if the vreg is spilled (this round?), either:
       a.) replace with def of (null, slot)
       b.) make new tmp, replace with def of (tmp, constraint)  and insert move [def (null, slot), use(tmp, 0)], set tmp.hint = reg(constraint)
     - if the vreg is not spilled, replace with def (DEAD, scratch)
   - be careful to never use DEAD
   - precolor DEAD1, DEAD2, etc to scratch of appropriate regclass
   - what about cycle-breaking in parmoves?

- Maybe reload should not have a use, but only a spill slot?

- liveness round:
  case Use(vreg, constraint)
    if vreg.spillRound == this.spillRound
      - if constraint == 0
          # instruction is prepared for any location, just use spill
	  # don't use a vreg because that interferes with later liveness
	  use = (null, vreg.spill)
      - if constraint is reg
          # instruction requires a specific register
	  # use a new nvreg (with a hint) and insert a restore
	  nvreg = dup(vreg)
	  use = (nvreg, constraint)
	  and nvreg.hint = constraint
      - if constraint is regset
          nvreg = dup(vreg)
	  use = (nvreg, constraint)

  case Def(vreg, constraint)
    if vreg.spillRound == this.spillRound
     - if constraint == 0
         if opcode == RESTORE
            nvreg = dup(vreg)
	    def = (nvreg, 0)
	 else
	    def = (nvreg, spill)
    - if constraint is reg
         if opcode == RESTORE
            nvreg = dup(vreg)
	    def = (nvreg, reg)
	    nvreg.hint = reg
	 else
	    def = (nvreg, spill)
	    TODO
    - if constraint is reg set
        TOD


- build round:
  case Def(vreg, constraint)
    if !live[vreg]
      if opcode == RESTORE
        remove
      else if vreg.spillRound == this.spillRound
        if constraint == 0
	  nvreg = alloc_dead(vreg.regClass)
	  nvreg.colorable = false
	  nvreg.from = vreg
          def = (nvreg, vreg.spill)
        if constraint is reg
	  nvreg = alloc_dead(vreg.regClass)
	  nvreg.hint = reg
	  nvreg.interfere.add(live)
          def = (nvreg, constraint)
	if constraint is stack
	  nvreg = alloc_dead(vreg.regClass)
	  nvreg.colorable = false
          def = (nvreg, constraint)
	if constraint is regset
	  nvreg = alloc_dead(vreg.regClass)
	  nvreg.interfere.add(live)
          def = (nvreg, constraint)


x86-64 constraints
- NOT_RDX
- NOT_RAX
- RAX
- RDX
- RCX
- RSI
- NOT_RDX_RAX
- NOT_PARAM
- NOT_RCX
- SCRATCH

Problems:
- parallel move of spill to spill no longer has any vreg, no regclass.

- defs on stack
  - parameters:
    - codegen assigns vreg.spill = caller#N
    - global regalloc inserts restore after def
    - if an explicit load is inserted, spilling will allocate redundant spill slot

- Too many live outs of a call with lots of returns, nothing to spill
  - solution? load explicitly from callee frame

- (all allocators): returning values in caller frame slots may overwrite incoming parameters
  => order using parallel move to return? (constrained def but unconstrained use)
  - need to involve arguments that are not constrained to stack



== current ======================================================================================
entry def:v0@rax  def:callerSave1@rbx
 restore v1, caller#0   ; v1.spill = caller#0
 restore v2, caller#1   ; v2.spill = caller#1


  stackWrite callee#0 <- v3
  stackWrite callee#1 <- v4
call def:v7@rax kill{all} use:v5@rax use:v6@rbx
  restore v8
  restore v9

  stackWrite caller#0 <- v10    # error because may overwrite v11
  stackWrite caller#1 <- v11
ret use:v12@rax use:callerSave1@rbx



== future ======================================================================================
entry def:v0@rax  def:callerSave1@rbx
 restore v1, caller#0   ; v1.spill = caller#0
 restore v2, caller#1   ; v2.spill = caller#1


parallel-move     # doesn't really need to be parallel move?
  callee#0 <- v3
  callee#1 <- v4
call def:v7@rax kill{all} use:v5@rax use:v6@rbx
parallel-move     # parallel move allows deleting dead defs
  v8 <- callee#0
  v9 <- callee#1


parallel-move     # needs to be parallel because v10, v11 may have spill = caller#N
  caller#0 <- v10
  caller#1 <- v11
ret use:v12@rax use:callerSave1@rbx

== future ======================================================================================
entry
parallel-move
 v0 <- rax
 callerSave1 <- rbx
 v1 <- caller#0   ; v1.spill = caller#0
 v2 <- caller#1   ; v2.spill = caller#1

(saves)
parallel-move     # shuffle arguments into proper locations
  callee#0 <- v3
  callee#1 <- v4
  rax <- v5
  rbx <- v6
--no gap--
call kill{all}
--no gap--
parallel-move    # extract results out of proper locations
  v8 <- callee#0
  v9 <- callee#1
  v7 <- rax
(restores)

parallel-move     # shuffle return values into proper locations
  caller#0 <- v10
  caller#1 <- v11
  rax <- v12
  rbx <- callerSave1
--no gap--
ret
