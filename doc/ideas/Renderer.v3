// Idea:
// Support extensible formatting by allowing a StringBuilder to have additional
// formatters that are added to it for specific format specifiers (%n) and user-defined types.
//
// E.g. instead of:
//    buf.put1("and the value is %q", myval.render);
// We can write:
//    buf.put1("and the value is %v", myval);

// The {Formatter} class collects together several of handlers, which are functions
// that render various user-defined types.
class Formatter {
	private var map = Array<FormatHandler>.new(256); // map from format specifier to handler

	// StringBuilder.putXYZ calls this method when a value doesn't match any known formatter.
	def format<V>(buf: StringBuilder, ch: byte, val: V) -> (bool, StringBuilder) {
		if (map != null) {
			var handler = map[ch];
			if (handler != null && handler.handles(val)) return (true, handler.handle(val, buf));
		}
		return (false, buf);
	}
	// This method is called to add a format handler for a specific format specifier (%ch).
	def add(ch: byte, handler: FormatHandler) -> this {
		map[ch] = handler;
	}
	// Convenience method for render method pattern.
	def addRenderer<T>(ch: byte, render: (T, StringBuilder) -> StringBuilder) -> this {
		map[ch] = FormatHandlerFor<T>.new(render);
	}
}
// Internally, the {Formatter} makes use of these classes to store the handlers, using the
// typical strategy of a subclass to hide a polymorphic parameter.
class FormatHandler {
	def handles<V>(v: V) => false;
	def handle<V>(v: V, buf: StringBuilder) -> StringBuilder;
}
class FormatHandlerFor<T>(render: (T, StringBuilder) -> StringBuilder) extends FormatHandler {
	def handles<V>(v: V) => T.?(v);
	def handle<V>(v: V, buf: StringBuilder) => render(T.!(v), buf);
}

// User-defined classes that follow the typical render method pattern.
class MyClass {
	def render(buf: StringBuilder) -> StringBuilder {
		return buf.puts("I am a MyClass!");
	}
	def renderLong(buf: StringBuilder) => render(buf);
}
class MySubClass extends MyClass {
	def render(buf: StringBuilder) -> StringBuilder { // override
		return buf.puts("I am a MySubClass!");
	}
	def renderLong(buf: StringBuilder) -> StringBuilder { // override
		return buf.puts("I am a MySubClass that likes strawberries!");
	}
}

// Now we define a formatter we can reuse over and over with different StringBuilders.
def MyFormatter = Formatter.new()
	.addRenderer('t', MyClass.render)		// render a terse version for %t
	.addRenderer('v', MyClass.renderLong);		// render a verbose version for %v

// A demo of how we can make use of a formatter.
def demo() {
	// A StringBuilder object will have a list of formatters inside, which are consulted
	// for types that don't match any of the built-in support (like int, bool, string, etc).
	var buf = StringBuilder.new();
	//TODO buf.addFormatter(MyFormatter);
	
	var c = MyClass.new();
	var d = MySubClass.new();
	buf.put2("MyClasses: %v and %t", c, c).ln();
	// Note that class inheritance works properly!
	buf.put2("MySubClasses: %v and %t", d, d).ln();
}
