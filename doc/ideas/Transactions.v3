//
// Transactional Virgil: Software Transactional Memory for Virgil
//

// Goals of this design:

// - Minimal additions to existing Virgil in terms of syntax and compilation
// - Usable but not fancy in terms of transactions features
// - Easy targeting to WASM GC, simple transactions extension
// - Easy targeting to a (hypothetical) STM run-time
// - Easy extensibility to persistence

// Major design concepts

// - Shared mutable state always updated transactionally
//   -- Unlike WASM Simple Transactions, which allows mutable non-transactional
//      state, as long as it is not accessed within a transaction
//   -- Certainly applies to ordinary heap objects and to top-level vars
//   -- Desirable for def (versus var) fields to be considered immutable and not
//      necessarily require transactional work
//   -- Questions arise about off-heap memory, use of Pointers, etc.
//   -- For single variables / fields, can perhaps be implemented with CAS
// - Methods transactional by default
//   -- "main" non-transactional, other methods can be marked non-transactional
//   -- Non-transactional method may have a transactional block
//   -- Desirable if transactional blocks have an optional else / failure handler
//   -- Desirable if a newly created object can be returned by a failing transaction
// - Implicit transactions created for accesses to mutable data in non-transactional code
// - GC remains transparent
// - Concurrency control between threads (stacks), whether or not concurrent
//   -- Concurrency control elided if a single threaded system
// - Rollback (all or nothing) semantics regardless of number of threads
// - Granularity of concurrency control is not specified (but it is ok to do it
//   per-object in the heap, and perhaps for groups of top-level variables)

// Syntax suggestions

// Optional "nonatomic" keyword on methods
// - Following the Simple Transactions proposal, nonatomic methods may be called only by
//   nonatomic methods.
// - "main" is implicitly nonatomic.
// - New threads may usually have their starting method be nonatomic, but either is ok.

nonatomic def foo(i: int) { ... }

// "atomic" keyword for atomic blocks within nonatomic methods:

atomic { ... code ... }


// Atomic block may have "else" code:

atomic { ... code ... } else { ... failure case code ... }


// The "else" code may allow an object, similar to a "throw" in other languages:

atomic { ... code ... } else(v: t) { ... failure case code ... }

// The failure code may refer to v.  The type t may be required to be a specific
// pre-defined type, e.g., TransactionResult.  Then the "t" will be dropped and
// all failure throws just have to match TransactionResult.  TransactionResult
// can be a class type, which gives suitable extensibility.


// Questions:

// How are threads spawned?  May they be spawned by a transaction (what would
// that mean?) or only from nonatomic code?

// Are there any trickinesses to initialization, either of components or of
// newly created objects?  It may be difficult to initialize all the def fields
// of a new object in the TSTRUCT_NEW - so maybe we can't promise that def
// fields will always avoid concurrency control.  (Perhaps ok, since we are
// talking about an optimization, since after initialization the fields won't
// change so there will be no actual conflicts.)

// How challenging is it to support failure generally and failure handlers in
// particular?  What about register/locals state, etc., across an atomic block?

// What other transactional language designs should be research for ideas?

// For implementation/run-time purposes, do we want to allow some kind of escape
// mechanism, such as nonatomic blocks with atomic methods, or maybe something
// marked "unsafe" as in Rust?  How would that work in WASM Simple Transactions?
// (Maybe it would use some kind of host function "magic"?)
