// For writing things like interpreters, it can be useful to add more types at
// run time, understood by the GC, etc.  The proposal described here is more
// low-level than the Extensible Types proposal and makes fewer changes to the
// compiler and run-time system.

// A run-time type (RTT) is either a direct run-time subtype of a given Virgil
// class or a run-time subtype of another run-time subtype.

// An RTT may add additional class fields to its supertype.  It may also add
// an array part to its supertype.  If an RTT r has an array part, then
// subtypes of r may not add fields.

// Run-time type objects include hidden fields that the run-time uses to
// support allocation, GC, etc.

// We add a new built-in class:

class RTType<C> { ... }

// Instances of this class are run-time classes that extend Virgil type C,
// which must be a class type.

// RTType<C> provides a new(...) that allows adding more fixed fields, and
// adding an array part, to C:

  new(fixedFields: Array<bool>, elementSize: int, arrayFields: Array<bool>);

// If fixedFields is empty or null, then no fixed (non-array) fields are
// added.  The length of fiexdFields indicates the number of fixed fields
// being added, and the boolean values indicate whether each added field (in
// order) is a reference (true) or primitive (false).

// The elementSize argument allows adding a byte/short/etc. array.  If
// elementSize is non-zero, then arrayFields is ignored and the elements are
// necessarily primitive (non-reference) values.  The legal non-zero sizes are
// 1, 2, 4, and 8.  If elementSize is 0, then arrayFields, if non-empty,
// defines an array addition.  An arrayFields of length 1 defines a
// homogeneous array part with either all references (true) or all
// pointer-size primitives (false).  An arrayFields of length greater than one
// defines a mixed array addition.

// RTType<C> provides newInstance to create instances of the run-time type:

  def newInstance<P>(size: int, parameters: P) -> C;

// Here the size parameter is for giving the size of an array part.  It is
// ignored if the RTT has no array part.  The parameters are a tuple of
// arguments to pass to C.new(..), and must match the parameters of that
// method.  newInstance allocates an instance large enough to hold all of C's
// fields plus any added ones.  Next it initializes the length of any array
// part, then invokes C.new(...), and lastly returns the result.  The added
// fields / array elements are initialized to zero / null.

// The instances created with newInstance will respond "true" to C.?() queries
// and can be cast successfully with C.!(), etc., to C and its supertypes.

// One may also create new subclasses of a run-time type using newSubclass:

  def newSubclass(fixedFields: Array<bool>, elementSize: int, arrayFields: Array<bool>) -> RTType<C>;

// The parameters are interpreted as for RTType.new(...), and indicate what is
// being added beyond the fields of this run-time type.  As previously noted,
// if the run-time supertype has an array part, then a newSubclass call may
// not add fields of either kind.

// For getting information and testing properties of RTTs and their instances,
// RTType provides these additional methods:

  def isInstance<T>(x: T) -> bool;

// This indicates whether x is an instance of this RTT or of a run-time
// subclass (direct or indirect) of this RTT.

  def isSuperclass(rtt: RTType<C>) -> bool;

// Returns true iff rtt is this RTT or a superclass of this RTT.

  def fixedMap() -> array<bool>;

// Returns a map of *all* fixed fields added to C by this RTT and its run-time
// superclasses.  The length of the array indicates the number of pointer-size
// fields added, and the boolean value is true for each reference field.

  def elementMap() -> (int, array<bool>);

// Returns the elementSize, and a reference / primitive type map of the
// elements if elementSize is 0.

// RTType also provides these convenience methods:

  def fixedSize() -> int;  // number of fields
  def elementSize() -> (int, int);  // elementSize, number of mixed array fields

// RTType also provides this field, which is null for direct run-time subtypes
// of C:

  def supertype: RTType<C>;

// We provide some additional built-in methods:

o.descriptor() -> RTT<C>;

// This built-in is available for o of any class type.  It returns null if o
// is not an instance of an RTT, and otherwise returns o's RTT object.

Pointer.atExtension<C>(o: C) -> Pointer;
Pointer.atExtensionLength<C>(o: C) -> Pointer;
Pointer.atExtensionArray<C>(o: C) -> Pointer;

// These return Pointers to the indicated parts of an RTT instance.  They
// return null if o is not an RTT instance or does not have the indicated part
// (for atExtensionLength and atExtensionArray).


//
// Run-time design
//

// Object headers may be encoded along these lines, where the three low bits
// of a 32-bit typeid word distinguish the cases as indicated:

// typeid  | x00: instance of ordinary class
// typeid  | x01: instance of extensible class ((*) see below)
// typemap | x10: instance of (ordinary) mixed array
// eltsize | 011: instance of ordinary array of primitives
// xxxxxxx | 111: instance of ordinary array of references

// (*) If a class C is used with RTType<C>, then we call C *extensible*.
// Extensible classes are given typeids with the low bit set to 1.  These
// typeids work just like the ones whose low bit is 0, except that indexing
// with them for virtual method dispatch requires a slight adjustment.
// Whether this adjustment is necessary is known statically so is not a big
// issue.  If S is the top-level supertype of C, then all subclasses of S
// require the dispatch adjustment.  An efficient way to do it is to set the
// low bit of the typeid for S and all of its subclasses.  Dispatch works
// according to this calculation: mtable_address + typeid - minClassId, where
// minClassId is the typeid of S.  The calculation mtable_address - minClassId
// is folded at compile time to a constant, mtable_base.  The resulting
// run-time calulation, mtable_base + typeid, is the same for extensible and
// non-extensible classes, though the compile-time calculated mtable_base is
// slightly different.

// Instances of extensible classes (including those of RTTs) include an
// additional word just after the typeid, which points to the RTT object for
// the instance.  This pointer will be null for direct instances of Virgil
// classes since they add no fields.  All classes whose typeid has the low bit
// set will need to provide this field.

// An RTT object will have space reserved (after its own typeid) for the
// typemap information of the fields added to its instances.  On the theory
// that added array parts are less common than added fixed size parts, a
// single pointer-size field can be encoded to give a typemap for common
// cases, or, less commonly, a reference to a heap-allocated object containing
// two typemaps, one for the fixed size addition and one for the array part.
// It would also be easy to encode cases for short fixed part only,
// homoegeneous array part only, and "other" cases embedded in a single
// pointer-size word.  To speed allocation, RTT objects may directly contain
// the size of the fixed fields and the size of the array elements.

// RTType<C> may be subclassed without any issues.  For simplicity, we do not
// allow it or its subclasses to be extensible.
