// Idea: add {pack} and {unpack} operators to integer types.

def y: u8 = 'p';
def x = u32.pack(0b1100, y, 0b0110_0000); // packs bitwise big-endian, i.e. 0b1100_yyyyyyyy_01100000
def z = u24.pack('a', 'b', 'c'); // == 0x616263
def w = u16.pack(0b0000, 0b111111, 0b00, 0b1101) == // 0b00001111_11001101

// The {pack} operator is a member of every integer type (uNN and iNN).
// It is polymorphic and allows an arbitrary number of bit-sized arguments, which it packs together into a single integer value.
// Thus, for a integer type T, T.pack<A, B, C...> has type (A, B, C...) -> T and requires A, B, and C... to be integer types.
// The sum of the widths of the types A, B, and C... must be less than or equal to the width of T.
// If A (the "big" end) is signed, then its corresponding argument is sign-extended if necessary; otherwise it is
// zero-extended.

def pack_bytes = u32.pack<u8, u8, u8, u8>; // packs four bytes A, B, C, D into 0xABCD

def bytes = Array<byte>.new(36);
def xL = u32.pack(a[3], a[2], a[1], a[0]); // little-endian packing of bytes.
def xB = u32.pack(a[0], a[1], a[2], a[3]); // big-endian packing of bytes.

// The type parameters to the pack operator are restricted to be integral types.
def pack_string = u32.pack("mom", 67); // type error, argument


// The {unpack} operator is similarly a member of every integer type.
// It is polymorphic and allows an arbitrary number of bit-sized arguments.
// Thus, for a integer type T, T.pack<A, B, C...> has type (A, B, C...) -> T and requires A, B, and C... to be integer types.
// The sum of the widths of the types A, B, and C... must be less than or equal to the width of T.
// If A (the "big" end) is signed, then its corresponding argument is sign-extended if necessary; otherwise it is
// zero-extended.
// Idea: allow uN.pack() and uN.unpack() operators to simplify bit arithmetic.

def b = u32.unpack<byte, byte, byte, byte>(bL);

def double_unpack(d: double) => u64.unpack<(sign: u1, exp: u11, fraction: u52)>(u64.view(d));

var db = double_unpack(4.445d);
var x = db.sign;
var y = db.exp;
var z = db.fraction;

type Double(sign: u1, exp: u11, fraction: u52) #packed;

var d = u64.unpack<Double>(0x999);
var x = u64.pack(Double(1, 2, 3));
