// Ideas for an alignment helper class.

// The superclass of all alignments hides the alignment value.
class Alignment {
	def get<I: int>() -> I;			// gets the alignment value as integral type <I>
	def alignUp<I: int>(x: I) -> I;		// rounds up the value {x} of type <I>
	def alignDown<I: int>(x: I) -> I;	// rounds down the value {x} of type <I>
}

// Aligns integers to {value} which is a power of two.
class PowerOfTwoAlignmentOf<M: int>(value: M) {
	private def addend: M = value - 1;
	private def mask: M = ~addend;

	// Gets the alignment value as type <I>.
	def get<I: int>() -> I {
		return I.!(value);
	}
	// Rounds the value {x} up to the next multiple of {value} (of type <I>).
	def alignUp<I: int>(x: I) -> I {
		if (I.width > M.width) {
			var mask = ~I.!(this.addend);
			return (x + addend) & mask;
		}
		return I.!((x + addend) & mask);
	}
	// Rounds the value {x} down to a multiple of {value} (of type <I>).
	def alignDown<I: int>(x: I) -> I {
		if (I.width > M.width) {
			var mask = ~I.!(this.addend);
			return x & mask;
		}
		return I.!(mask & x);
	}
}

// Aligns integers to multiples of a positive integer {value}.
class PositiveAlignmentOf<M: int>(value: M) {
	private def addend: M = value - 1;
	
	// Gets the alignment value as type <I>.
	def get<I: int>() -> I {
		return I.!(value);
	}
	// Rounds the value {x} up to the next multiple of {value} (of type <I>).
	def alignUp<I: int>(x: I) -> I {
		if (I.width > M.width) {
			var value = ~I.!(this.value);
			return value * ((x + addend) / value);
		}
		return value * ((x + addend) / value);
	}
	// Rounds the value {x} down to a multiple of {value} (of type <I>).
	def alignDown<I: int>(x: I) -> I {
		if (I.width > M.width) {
			var value = ~I.!(this.value);
			return x - (x % value);
		}
		return x - (x % value);
	}
}
