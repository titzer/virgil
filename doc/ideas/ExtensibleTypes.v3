//
// Extensible types are the language-level feature related to run-time types.
//

// As proposed here, the resulting run-time setup is a little different from
// that of the run-time types idea (as it currenty stands), but it is similar.
// It is also related to the models idea.

// The extensible types idea involves adding two features to Virgil classes,
// giving rise to two new flavors of classes: *extensible* classes and
// *descriptor* classes.

// An *extensible* class is one that may have new subtypes introduced at run
// time.  We keep extensible and non-extensible types in separate class
// hierarchies, requiring that the root (top-level) class of an extensible
// hierarchy have the keyword "extensible", such as:

extensible class A { /* ... */ }

// Subclasses of an extensible class are automatically extensible, and need
// not, but may, be marked with the same keyword.

// The rationale for separating the hierarchies is that type queries, casts,
// and method dispatch require different mechanisms for an extensible
// collection of classes versus Virgil's current mechanisms for a closed world
// of types.  The mechanism for non-extensible types uses a small integer
// typeid in the object header to control dispatch and subtype operations, and
// for GC these integers index a table of GC maps.  The proposed mechanism for
// extensible types puts all that information is a separate descriptor object,
// and instances of the extensible type point to that descriptor.  The
// descriptor will contain the type id of the compile-time-known ancestor of
// the type and the GC map for the specific extensible / extended type. We do
// not want to slow down non-extensible types just to support extensible ones,
// so we make a compile-time distinction between them - hence the separate
// class hierarchies.  Here is an illustration:
//
// Instance of a non-extensible class:
//
// +--------+
// + typeid +
// +--------+
// + other  +
// + fields +
// +  ...   +
// +--------+
//
// Instance of an extensible class:
//
// +---------+           +-------------------+
// + pointer +---------->+ descriptor typeid +
// +---------+           +-------------------+
// +  other  +           + ancestor typeid   +
// +  fields +           +-------------------+
// +   ...   +           + GC map            +
// +---------+           +-------------------+
//                       +    supertype      +
//                       +    descriptor     +
//                       +-------------------+
//                       +  other fields ... +
//                       +-------------------+
// 

//
// Because the compiler / run-time system make assumptions about the special
// fields built in at the beginning of descriptor objects, descriptor classes
// need to be marked specially.  Here is an example:

descriptor class D { /* ... */ }

// There is no problem allowing descriptor classes to themselves be
// extensible; the two effects on object representation are independent.

// Every extensible *class* has a unique descriptor *object*, which must be an
// instance foa descriptor class.

// To accomplish this for a compile-time known (ctk) class, such as A above,
// we give the descriptor *object* as part of the declaration of A:

component DescObjects {
    def ADesc = D.new( /* params */ );
}

extensible class A descriptor DescObjects.ADesc { /* ... */ }

// This construct reuses the "descriptor" keyword in the declaration of the
// extensible class, to denote the class's descriptor object.  The compiler
// + run-time connect the class and descriptor object together, an action
// that must be done exactly once.  If the programmer does not supply a
// descriptor object in the extensible class's declaration, the compiler
// supplies a default object that provides just what the run-time needs.

// Now consider the run-time (rt) subclass case.  For that, we need to know
// the superclass (really, its descriptor) and to have a descriptor object for
// the new class.  CiRuntime.extendClass provides the means to extend a ctk
// class; the return value indicates success;

def extendClass<C, D>(desc: D, fixed: Array<bool>, repeating: Array<bool>) -> bool;

// "fixed" indicates, for each word being *added* in the subtype, whether it
// is a reference (for the GC's use).  "repeating" does the same thing if an
// array part is being added.  So that supertype fields, including the
// possible array length field, do not move, nothing can be added to a
// supertype that has an array part.  Subtypes need not add any new fields.  A
// descriptor object can be used only once to connect with a class.  Each
// extensible / extended class is connected with its descriptor when the class
// itself is made.

// Lastly, we may wish to create an rt subclass of an rt class.  For that we
// need the descriptor of the superclass rt class, for which we can use
// CiRuntime.newSubclass:

def newSubclass<S, D>(superDesc: S, desc: D, fixed: Array<bool>, repeating: Array<bool>) -> bool;

// S is the type of the superclass's descriptor, which must be a descriptor
// class, and D is the class of the descriptor for the new rt class.  "fixed"
// and "repeating" are as for CiRuntime.extendClass.  Again, the return value
// indicates success.

// If an extensible class's descriptor object was supplied explicitly, one can
// just as well use CiRuntime.newSubclass on the descriptor object or
// CiRuntime.extendClass on the extensible class.  The result will be the
// same.

// There is no necessary type relationship between the descriptors of
// subtypes/supertypes in the extensible/rt class hierarchy.  However, it may
// be useful to use the same or related types.


//
// Dealing with instances of rt classes
//

//
// Considerations of the run-time

// 1. Descriptor classes will reserve space for a GC type descriptor (bits to
// identify size and pointer fields) in descriptor instances.  This will need
// an extension mechanism to support descriptions requiring more than the
// fixed space reserved.

// 2. Descriptor instances must allow for a reference to the superclass
// descriptor, to support type queries and casts.  The ctk types of a
// hierarchy can have compiler-assigned ids, stored in their descriptor
// objects, that allow faster checks.

// 3. Descriptor instances indicate the type id of the ctk from which their
// class is derived.  This supports type queries and casts against ctk class
// types and also supports method dispatch.  (Since rt classes do not add
// methods, there is no additional dispatch semantics for them.)

// 4. The run-time can support:

// a) obtaining the descriptor object of an object of extensible / extended
// class

CiRuntime.getDescriptor<C, D>(obj: C) -> D;

// b) checking whether the class of an rt class instance is a subclass of some
// other rt class (casting is not useful):

CiRuntime.subtypeOf<C, D>(obj: C, desc: D) -> bool;

// 4. Creating instances: For ctk classes, one can use the usual new.  For ctk
// classes with known descriptor objects, or rt classes, one can use the
// descriptor object to create a new instance:

CiRuntime.newInstance<C, D, P>(desc: D, params: P) -> C;

// Here, C is a ctk extensible type, the nearest ctk superclass of the class
// that "desc" describes.  D is the type of desc and P are the parameters to
// pass to C.new().  Any fields added by rt subtypes from C down to the class
// describes by D will set to default values.

// Similarly one can create an instance of an rt class that has an array part:

CiRuntime.newArray<C, D, P>(desc: D, params: P, length: int) -> C;

// 5. Accessing in instances of rt classes.  We can accomplish this by adding
// a few ways to get Pointers to parts of an rt instance.  This can be
// prettied up by having the programmer add functionality to descriptor
// classes, which can add suitable bounds checks and a degree of type checking
// on loads and stores.

Pointer.atExtension<C>(obj: C) -> Pointer;  // Pointer to first new fixed field

Pointer.atExtensionLength<C>(obj: C) -> Pointer;  // Pointer to length of array part

Pointer.atExtensionArray<C>(obj: C) -> Pointer;  // Pointer to first array element
