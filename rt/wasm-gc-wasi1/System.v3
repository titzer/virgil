// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Implementation of the "System" component on WASI.
component System {
	def out = NativeFileStream.new(fs_write, STDOUT);
	def err = NativeFileStream.new(fs_write, STDERR);
	var atRunTime = false;

	def initialize() {
		// needs to happen at run time
		out.setIobuf();
		err.setIobuf();
		atRunTime = true;

		numbuf = createBuffer(16);
		iobuf = createBuffer(16);
//		retbuf = createBuffer(32);
		retbuf = CiRuntime.forgeRange<byte>(Pointer.NULL + 0x20, 32);
	}

	// change the permissions of a file
	def chmod(path: string, mode: int) {
		// TODO	wave.fs_chmod(p.0, p.1, mode);
	}
	// open a file
	def fileOpen(path: string, read: bool) -> int {
		var pre_fd = WasiPreopens.find(path);
		if (pre_fd < 0) return -1;
		var rights = (1 << if(read, wasi_rights.fd_read, wasi_rights.fd_write).tag) |
			(1 << wasi_rights.fd_seek.tag);
		var pathBuf = copyString(path);
		var r = wasi_snapshot_preview1.path_open(pre_fd, 0, Pointer.atContents(pathBuf), path.length, 0, rights, rights, 0, Pointer.atContents(retbuf));
		freeBuffer(pathBuf);
		if (r != 0) return -1;
		return Pointer.atContents(retbuf).load<int>();
	}
	// close a file
	def fileClose(fd: int) {
		wasi_snapshot_preview1.fd_close(fd);
	}
	// read a single byte from a file
	def fileRead(fd: int) -> int {
		var buf = Pointer.atContents(iobuf);
		var result = fs_read(fd, buf, 1);
		return if(result == 1, iobuf[0], -1);
	}
	// write some bytes to the file
	def fileWriteK(fd: int, data: Array<byte>, offset: int, len: int) {
		boundsCheck(data, offset, len);
		var buf = createBuffer(len);
		copyRange(data[offset ...], buf);
		fs_write(fd, Pointer.atContents(buf), len);
		freeBuffer(buf);
	}
	// read some bytes from the file
	def fileReadK(fd: int, data: Array<byte>, offset: int, len: int) -> int {
		boundsCheck(data, offset, len);
		var buf = createBuffer(len);
		var result = fs_read(fd, Pointer.atContents(buf), len);
		if (result > 0) copyRange(buf, data[offset ..+ result]);
		freeBuffer(buf);
		return result;
	}
	// calculate bytes remaining to be read from file
	def fileLeft(fd: int) -> int {
		return 0; // TODO return wave.fs_avail(fd);
	}
	// load a file into a byte array
	def fileLoad(path: string) -> Array<byte> {
		var fd = fileOpen(path, true);
		if (fd < 0) return null;
		var sizeptr = aligned_sizeptr();
		var r = wasi_snapshot_preview1.fd_seek(fd, 0, wasi_whence.END.tag, sizeptr);
		if (r < 0) {
			wasi_snapshot_preview1.fd_close(fd);
			return null;
		}
		var len = int.!(sizeptr.load<u64>());
		r = wasi_snapshot_preview1.fd_seek(fd, 0, wasi_whence.SET.tag, sizeptr);
		if (r < 0) {
			wasi_snapshot_preview1.fd_close(fd);
			return null;
		}
		var buf = createBuffer(len);
		var amount = fs_read(fd, Pointer.atContents(buf), len);
		wasi_snapshot_preview1.fd_close(fd);
		var result = Array<byte>.new(amount);
		if (amount > 0) copyRange(buf, result);
		return result;
	}
	// print a character to standard out
	def putc(ch: byte) {
		numbuf[0] = ch;
		fs_write(STDOUT, Pointer.atContents(numbuf), 1);
	}
	// print an integer (in decimal) to standard out
	def puti(val: int) {
		var i = val;
		if (i == 0) {
			putc('0');
			return;
		}
		var negative = true;
		if (i > 0) {
			negative = false;
			i = 0 - i;
		}
		var pos = numbuf.length;
		while (i != 0) { // XXX: use pointer loop instead?
			var digit = byte.!('0' - i % 10);
			numbuf[--pos] = digit;
			i = i / 10;
		}
		if (negative) numbuf[--pos] = '-';
		fs_write(STDOUT, Pointer.atContents(numbuf) + pos, numbuf.length - pos);
	}
	// print a string (as bytes) to standard out
	def puts(str: string) {
		var buf = copyString(str);
		fs_write(STDOUT, Pointer.atContents(buf), buf.length);
		freeBuffer(buf);
	}
	// prints a newline character to standard out
	def ln() {
		putc('\n');
	}
	// output an error, stacktrace, and exit
	def error(ex: string, msg: string) {
		if (false) {
			// should not create buffers here - may cause recursion if memory is full
			def s = copyString(ex), s_len = ex.length;
			def m = if(msg != null, copyString(msg));
			def m_len = if (msg != null, msg.length);
		}
		// TODO	wave.throw_ex(s, s_len, m, m_len);
		// ... well, wasm.something
	}
	// get ticks in milliseconds
	def ticksMs() -> int {
		return int.view(wasiNs() / 1000000u);
	}
	// get ticks in microseconds
	def ticksUs() -> int {
		return int.view(wasiNs() / 1000u);
	}
	// get ticks in nanoseconds
	def ticksNs() -> int {
		return int.view(wasiNs());
	}
	// write some bytes to the file
	def writeRaw(fd: int, data: Range<byte>) -> int {
		// will fail unless data is off-heap
		return fs_write(fd, Pointer.atContents(data), data.length);
	}
	// read some bytes from the file
	def readRaw(fd: int, data: Range<byte>) -> int {
		// will fail unless data is off-heap
		return fs_read(fd, Pointer.atContents(data), data.length);
	}
	// write some bytes to the file
	def write(fd: int, data: Range<byte>) -> int {
		// use memory buffer
		var buf = createBuffer(data.length);
		copyRange(data, buf);
		var result = fs_write(fd, Pointer.atContents(buf), data.length);
		freeBuffer(buf);
		return result;
	}
	// read some bytes from the file
	def read(fd: int, data: Range<byte>) -> int {
		// use memory buffer
		var buf = createBuffer(data.length);
		var result = fs_read(fd, Pointer.atContents(buf), data.length);
		if (result > 0) copyRange(buf, data[0 ..+ result]);
		return result;
	}
	private def wasiNs() -> u64 {
		var sizebuf = aligned_sizeptr(); // TODO: use a proper layout here
		wasi_snapshot_preview1.clock_time_get(0, 10000, sizebuf);
		var tv_nsecs = sizebuf.load<u64>();
		return tv_nsecs;
	}
	// utilities to deal with copying to/from Wasm memory
	def createBuffer(size: int) -> Range<byte> {
		return RiRuntime.allocBytes(size);
	}
	def copyRange(from: Range<byte>, to: Range<byte>) {
		for (i < to.length) to[i] = from[i];
	}
	def copyString(s: string) -> Range<byte> {
		var r = createBuffer(s.length);
		copyRange(s, r);
		return r;
	}
	def freeBuffer(r: Range<byte>) {
		AllocFree.free(Pointer.atContents(r));
	}
}

def STDIN  = 0;
def STDOUT = 1;
def STDERR = 2;
def MAX_PREOPEN = 10;

// @thread-local @lazy buffer for write integers and chars to System.out
var numbuf: Range<byte>;
var iobuf: Range<byte>;
var retbuf: Range<byte>;

def BCE = "BoundsCheckException";
def EMPTY = "";
def boundsCheck<T>(array: Array<T>, start: int, len: int) {
	if (start < 0) System.error(BCE, EMPTY);
	if (start > array.length) System.error(BCE, EMPTY);
	var end = u32.!(start) + u32.!(len);
	if (end > u32.!(array.length)) System.error(BCE, EMPTY);
}
def fs_write(fd: int, data: Pointer, len: int) -> int {
	var p = Pointer.atContents(iobuf);
	(p + 0).store<int>(data - Pointer.NULL);
	(p + 4).store<int>(len);
	var sizeptr = aligned_sizeptr();
	var r = wasi_snapshot_preview1.fd_write(fd, p, 1, sizeptr);
	return if(r == 0, sizeptr.load<int>());
}
def fs_read(fd: int, data: Pointer, len: int) -> int {
	var p = Pointer.atContents(iobuf);
	(p + 0).store<int>(data - Pointer.NULL);
	(p + 4).store<int>(len);
	var sizeptr = aligned_sizeptr();
	var r = wasi_snapshot_preview1.fd_read(fd, p, 1, sizeptr);
	return if(r == 0, sizeptr.load<int>());
}
def aligned_sizeptr() -> Pointer {
	var addr = Pointer.atContents(retbuf) - Pointer.NULL;
	addr = (addr + 7) & ~7;
	return Pointer.NULL + addr;
}
