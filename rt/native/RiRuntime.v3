// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// RiRuntime provides the platform-dependent runtime hooks called by the compiler
// to implement signal handling (and therefore exception handling), GC, and
// initialization of the runtime environment.
component RiRuntime {
	def SIGFPE  = 8;
	def SIGBUS  = 10;
	def SIGSEGV = 11;
	var gcInit: void -> void;
	var gcCollect: (int, Pointer, Pointer) -> Pointer = noCollect;
	var userSignalHandler: (int, Pointer, Pointer) -> bool;
	var stackRedZoneStart: Pointer;
	var stackRedZoneEnd: Pointer;
	var userCodeList: RiUserCode;

	// initialize runtime system from supplied arguments and return remaining args
	def init(c: int, a: Pointer, envp: Pointer) -> Array<string> {
		var argc = c, argp = a;
		// set up stack red zone to catch stack overflow
		var t = RiOs.initStackRedZone(CiRuntime.STACK_START, CiRuntime.STACK_END);
		stackRedZoneStart = t.0;
		stackRedZoneEnd = t.1;
		// install handler for SIGFPE, SIGBUS, and SIGSEGV
		RiOs.installHandler(SIGFPE);
		RiOs.installHandler(SIGBUS);
		RiOs.installHandler(SIGSEGV);

		if (gcInit != null) gcInit();
		if (argp == Pointer.NULL) return null;

		// convert argc, argp into an Array<string> for main, ignoring first arg
		argp = argp + Pointer.SIZE;
		argc--;
		var args = Array<string>.new(argc);
		for (i < argc) {
			args[i] = toString((argp + i * Pointer.SIZE).load<Pointer>());
		}
		return args;
	}
	// handle a signal generated by the program
	def signal(signum: int, siginfo: Pointer, ucontext: Pointer) {
		if (userSignalHandler != null && userSignalHandler(signum, siginfo, ucontext)) return;

		var ip = RiOs.getIp(ucontext), sp = RiOs.getSp(ucontext);
		var userCode = findUserCode(ip);
		if (userCode != null) {
			// call user signal handler first, if installed
			var handled = userCode.handleSignal(signum, siginfo, ucontext, ip, sp);
			if (handled) return;
		}
		match (signum) {
			SIGFPE => return fatalException("DivideByZeroException", null, ip, sp);
			SIGBUS, SIGSEGV => {
				if (ip >= CiRuntime.EX_START && ip < CiRuntime.EX_END) {
					// IP lies in exception region, use exception entry
					var exEntry = CiRuntime.EX_TABLE + (ip - CiRuntime.EX_START);
					var frameWords = NativeStackPrinter.printExEntry(exEntry, true);
					NativeStackPrinter.printStack(RiOs.callerFrame(ip, sp, frameWords));
					return RiOs.exit(255);
				} else {
					var addr = RiOs.getAccessAddress(siginfo, ucontext);
					if (inStackRedZone(addr)) return fatalException("StackOverflow", null, ip, sp);
					if (ip == Pointer.NULL) {
						// assume an indirect call to null, generate NCE
						ip = sp.load<Pointer>() + -1; // return address is on stack
						sp = sp + Pointer.SIZE; // skip return address
					}
					// should be a source entry at this IP
					return fatalException("NullCheckException", null, ip, sp);
				}
			}
			// XXX: SIGILL -> *bad*
			// XXX: SIGQUIT -> stacktrace + quit
			// XXX: SIGKILL -> stacktrace + quit
			// XXX: SIGPROF -> take profiling sample
		}
		System.err.puts("UnexpectedSignal: ").puti(signum).ln();
		NativeStackPrinter.printStack(ip, sp);
		RiOs.exit(255);
	}
	// Called from the generated allocation stub upon allocation failure.
	def gc(size: int, ip: Pointer, sp: Pointer) -> Pointer {
		return gcCollect(size, ip + -1, sp); // adjust caller IP for gc map search
	}
	private def noCollect(size: int, ip: Pointer, sp: Pointer) -> Pointer {
		System.error("HeapOverflow", "no garbage collector installed");
		return Pointer.NULL; // unreachable
	}
	// register new (machine) code with the runtime system
	def registerUserCode(code: RiUserCode) {
		code.next = userCodeList;
		userCodeList = code;
	}
	// un-register code from the runtime system
	def unregisterUserCode(code: RiUserCode) {
		var l = userCodeList, p: RiUserCode;
		while (l != null) {
			if (l == userCodeList) {
				if (p != null) p.next = l.next;
				else userCodeList = l.next;
				code.next = null;
				return;
			}
			p = l;
			l = l.next;
		}
	}
	// find the user code containing {ip}, if any
	def findUserCode(ip: Pointer) -> RiUserCode {
		for (l = userCodeList; l != null; l = l.next) {
			if (ip >= l.start && ip < l.end) return l;
		}
		return null;
	}
	// checks if the given pointer is in the stack red zone
	def inStackRedZone(p: Pointer) -> bool {
		return (p >= stackRedZoneStart && p < stackRedZoneEnd);
	}
	// convert a null-terminated string pointer to a byte array
	private def toString(p: Pointer) -> string {
		for (e = p; true; e = e + 1) {
			if (e.load<byte>() == '\x00') {
				var len = int.!(e - p), str = Array<byte>.new(len);
				for (i < len) str[i] = (p + i).load<byte>();
				return str;
			}
		}
		return null; // unreachable
	}
	def fatalException(ex: string, msg: string, ip: Pointer, sp: Pointer) {
		System.err.putc('!').puts(ex);
		if (msg != null) System.err.puts(": ").puts(msg).ln();
		else System.err.ln();
		NativeStackPrinter.printStack(ip, sp);
		RiOs.exit(255);
	}
}
// Runtime tables are exposed by the compiler as values in a "CiRuntime" component.
// This component provides utilities to the rest of the runtime to traverse these
// tables and serves to separate them from encoding details.
component RiTables {
	def REF_SIZE	  = 4;	  // XXX: platform-dependent reference size
	def INT_SIZE	  = 4;
	def PAGE_SIZE	  = 4096; // XXX: page size from compiler
	def PAGE_SHIFT	  = '\x0c';  // 12
	def PAGE_MASK	  = 0xFFF;
	def EX_ENTRY_SIZE = 6;	  // XXX: ex entry size from compiler

	def findSource(ip: Pointer) -> Pointer {
		return exactMatch(searchTable(CiRuntime.SRC_POINTS_PAGES, CiRuntime.SRC_POINTS_TABLE, ip));
	}
	def findMethod(ip: Pointer) -> Pointer {
		var r = searchTable(CiRuntime.SRC_METHODS_PAGES, CiRuntime.SRC_METHODS_TABLE, ip);
		if (r.0 < CiRuntime.SRC_METHODS_TABLE) return Pointer.NULL;
		return r.0;
	}
	def exactMatch(p: Pointer, q: Pointer) -> Pointer {
		return if(p == q, p, Pointer.NULL);
	}
	// perform a binary search on a table, returning pointers (p, q) to adjacent entries
	// with p.ip <= ip <= q.ip || p == null && q == null
	// assumes 4-byte entries with lower #PAGE_SHIFT bits indicating the page offset
	def searchTable(pageTable: Pointer, table: Pointer, ip: Pointer) -> (Pointer, Pointer) {
		var none = (Pointer.NULL, Pointer.NULL);
		if (ip < CiRuntime.CODE_START) return none; // out of code range
		if (ip >= CiRuntime.CODE_END) return none; // out of code range

		var code_offset = ip - CiRuntime.CODE_START;
		var key_offset = code_offset & PAGE_MASK;
		var code_page = int.!(code_offset >>> PAGE_SHIFT);
		var start_p = loadPage(pageTable, code_page);
		var end_p = loadPage(pageTable, code_page + 1);
		// binary search for the entry
		while (start_p < end_p) {
			var diff = ((end_p - start_p) >> 1) & 0xFFFFFFFC;
			var mid_p = start_p + diff;
			var offset = mid_p.load<int>() & PAGE_MASK;
			if (offset < key_offset) {
				if (start_p == mid_p) return (start_p, end_p);
				else start_p = mid_p;
			} else if (offset == key_offset) {
				return (mid_p, mid_p);
			} else {
				end_p = mid_p;
			}
		}
		return (start_p + -4, end_p); // start_p == end_p
	}
	def loadPage(pageTable: Pointer, num: int) -> Pointer {
		if (Pointer.SIZE == 8) {
			return Pointer.NULL + (pageTable + num * 4).load<int>();
		} else {
			return (pageTable + num * Pointer.SIZE).load<Pointer>();
		}
	}
	def codePages() -> int {
		return int.!((CiRuntime.CODE_END - CiRuntime.CODE_START + (PAGE_SIZE - 1)) >>> PAGE_SHIFT);
	}
}
// Extension point for dynamic code. User applications can extend the runtime system
// by creating subclasses of this class and registering instances with the {RiRuntime}.
class RiUserCode(var start: Pointer, var end: Pointer) {
	var next: RiUserCode; // used internally in RiRuntime for list management

	// Called by the runtime when a fatal error occurs. Should write a description
	// of the frame (typically a single line) to the provided output function,
	// e.g. to print a helpful stack trace.
	def describeFrame(ip: Pointer, sp: Pointer, out: Range<byte> -> void) { }

	// Called when the runtime walks the stack. Should advance the instruction pointer
	// and stack pointer past this frame to the caller frame, returning the instruction
	// and stack pointers for the caller.
	def nextFrame(ip: Pointer, sp: Pointer) -> (Pointer, Pointer);

	// Called when the garbage collector finds a frame on the stack. Should notify
	// the garbage collector via {RiGc} of the location of any roots in the frame.
	def scanFrame(ip: Pointer, sp: Pointer) { }

	// Called when a signal occurs in this code. Should attempt to handle the signal,
	// e.g. by patching the platform-specific {ucontext}. If the signal could not be
	// handled, return {false}.
	def handleSignal(signum: int, siginfo: Pointer, ucontext: Pointer, ip: Pointer, sp: Pointer) -> bool { return false; }
}
