def CTRL_DEFAULT = "\x1B[1;00m"; // XXX: move to Terminal
def CTRL_GREEN	 = "\x1B[0;32m";
def CTRL_YELLOW	 = "\x1B[1;33m";
def CTRL_RED	 = "\x1B[0;31m";
def CTRL_CYAN	 = "\x1B[0;36m";

// Contains all tracing/debugging related code for stack scanning and
// garbage collection. Hooks into the GC algorithm by setting the {RiGc.on*}
// callbacks.
component GcDebug {
	def D = RiGc.D;

	new() {
		RiGc.onUserScan = onUserScan;
		RiGc.onObjectReloc = onObjectReloc;
		RiGc.onObjectCopy = onObjectCopy;
		RiGc.onGcStart = onGcStart;
		RiGc.onGcEnd = onGcEnd;
		RiGc.onScanRefMap = onScanRefMap;
		RiGc.onScanExtMap = onScanExtMap;
		RiGc.onScanExtMapEnd = onScanExtMapEnd;
		RiGc.onScanStack = onScanStack;
		RiGc.onScanShadowStack = onScanShadowStack;
		RiGc.onNoStackmap = onNoStackmap;
		RiGc.onScanGlobalsStart = onScanGlobalsStart;
		RiGc.onScanGlobalsMap = onScanGlobalsMap;
		RiGc.onScanGlobal = onScanGlobal;
		RiGc.onScanGlobalsEnd = onScanGlobalsEnd;
	}

	def onUserScan() {
		D.puts(CTRL_YELLOW);
		D.puts("\n  -- call user scanners ----------------------------\n");
		D.puts(CTRL_DEFAULT);
	}
	def onObjectReloc(ref_loc: Pointer, ref: Pointer, newref: Pointer) {
		D.puts("[").putp(ref_loc)
			 .puts("] = ").putp(ref).puts(" moved to ")
			 .putp(newref).ln();
	}
	def onObjectCopy(ref_loc: Pointer, ref: Pointer, newref: Pointer, size: long) {
		D.puts("[").putp(ref_loc)
			 .puts("] = ").putp(ref).puts(" copied to ")
			 .putp(newref).puts(", ").puti(size).puts(" bytes\n");
	}
	def onGcEnd(used_space: long, diff_us: int) {
		D.puts("End   GC, ").puti(used_space / 1024)
			 .puts("K (").puti(diff_us).puts(" us)\n");
	}
	def onGcStart() {
		D.puts(CTRL_YELLOW);
		D.puts("\n===== begin Semispace.collect() =============================================================\n");
		D.puts(CTRL_DEFAULT);
		// XXX: depends directly on semispace
		D.puts("fromSpace_start = ").putp(Semispace.fromSpace_start).ln();
		D.puts("heapCur         = ").putp(CiRuntime.heapCurLoc.load<Pointer>()).ln();
		D.puts("fromSpace_end   = ").putp(Semispace.fromSpace_end).ln();
		D.puts("toSpace_start   = ").putp(Semispace.toSpace_start).ln();
		D.puts("toSpace_end     = ").putp(Semispace.toSpace_end).ln();
	}
	def onScanRefMap(vmap: int, start: Pointer) {
		D.puts("scanRefMap @ ").putp(start).puts(", map = ").putp(Pointer.NULL + vmap).ln();
	}
	def onScanExtMap(vmap: int) {
		D.puts("scanExtMap = ").putp(Pointer.NULL + vmap).ln();
	}
	def onScanExtMapEnd(size: int) {
		D.puts("extmapsize = ").puti(size).ln();
	}
	def onScanStack(ip: Pointer, sp: Pointer) {
		D.puts(CTRL_DEFAULT)
			 .puts("\nscanStack @ ip = ").putp(ip).puts(" +")
			 .puti(ip - CiRuntime.CODE_START)
			 .puts(", sp = ").putp(sp).putc('\n');
		D.puts(CTRL_CYAN);
		var frameWords = NativeStackPrinter.printLoc(ip); // double-check frame size in debug mode
		D.puts(CTRL_DEFAULT);
	}
	def onScanShadowStack(start: Pointer, cur: Pointer) {
		D.puts(CTRL_DEFAULT)
			 .puts("scanShadowStack [").putp(start)
			 .puts(" - ").putp(cur).puts("]\n");
	}
	def onNoStackmap(ip: Pointer, sp: Pointer, frameWords: int) {
		D.puts("(no stackmap information)\n");
	}
	def onScanGlobalsStart() {
		D.puts(CTRL_DEFAULT).puts("Beginning globals scan...\n");
	}
	def onScanGlobalsMap(offset: int, bits: int) {
		D.puts("rootMap @ data + ").puti(offset);
		D.puts(" = ").putp(Pointer.NULL + bits).ln();
	}
	def onScanGlobal(addr: Pointer) {
		D.puts("@rootref data + ").puti(addr - CiRuntime.DATA_START).ln();
	}
	def onScanGlobalsEnd() {
		D.puts("Ended globals scan.\n");
	}
	// scan the references at the given start address, printing them to the console
	def debugScanMap(v: int, start: Pointer) {
		var vmap = v;
		// TODO: handle extended entries in printing debugging information
		var o = D.puts("stackMap ").putp(Pointer.NULL + vmap).ln();
		if (vmap == 0) return;
		for (p = start; vmap != 1; p = p + RiGc.REF_SIZE) {
			var marked = (vmap & 1) != 0;
			var val = p.load<Pointer>();
			o.puts("@ ").putp(p).puts(" ").putc(if(marked, '*', ' ')).puts(" | ");

			if (val == Pointer.NULL) o.putp(val).puts(" |\n");
			else if (val >= CiRuntime.HEAP_START && val < CiRuntime.HEAP_END) debugScanRef(val, if(marked, CTRL_GREEN, CTRL_YELLOW), "heap");
			else if (val >= CiRuntime.DATA_START && val < CiRuntime.DATA_END) debugScanRef(val, if(marked, CTRL_GREEN, CTRL_YELLOW), "data");
			else if (marked) debugScanRef(val, CTRL_RED, "");
			else o.putp(val).puts(" |\n");

			vmap = vmap >>> 1;
		}
	}
	def debugScanRef(val: Pointer, color: string, region: string) {
		D.puts(color).putp(val).puts(CTRL_DEFAULT).puts(" | ").puts(region).ln();
	}
}