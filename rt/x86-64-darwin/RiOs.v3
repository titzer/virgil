// x86-64-darwin target-specific runtime routines.
component RiOs {
	private def sigaction_buf = Array<long>.new(4);

	def installHandler(signum: int) {
		// fill out sigaction struct
		sigaction_buf[0] = CiRuntime.signalStub - Pointer.NULL; // sa_handler
		sigaction_buf[1] = CiRuntime.signalStub - Pointer.NULL; // sa_handler: imitating genSigHandlerInstall
		sigaction_buf[2] = 0; 					// sa_mask
		sigaction_buf[3] = 0x04000000;				// sa_flags

		var sigbuf = Pointer.atContents(sigaction_buf);
		// (sigbuf + 4).store(CiRuntime.signalStub);
		// install handler
		Darwin.syscall(DarwinConst.SYS_sigaction, (signum, sigbuf, Pointer.NULL, 8));
	}
	def getIp(ucontext: Pointer) -> Pointer {
		return (ucontext + 280).load<Pointer>();
	}
	def getSp(ucontext: Pointer) -> Pointer {
		return (ucontext + 48).load<Pointer>();
	}
	// Get the access address from a siginfo.
	def getAccessAddress(siginfo: Pointer, ucontext: Pointer) -> Pointer {
		return Pointer.NULL; // TODO
	}
	// advance the ip and sp from the current frame to the caller's frame
	def callerFrame(i: Pointer, s: Pointer, frameWords: int) -> (Pointer, Pointer) {
		var ip = i, sp = s;
		sp = sp + (1 + frameWords) * Pointer.SIZE;
		ip = (sp + (0 - Pointer.SIZE)).load<Pointer>() + -1;
		return (ip, sp);
	}
	// exit with the given return code
	def exit(code: int) {
	        Darwin.syscall(DarwinConst.SYS_exit, code);
	}
	// initialize stack red zone for handling stack overflow
	def initStackRedZone(start: Pointer, end: Pointer) -> (Pointer, Pointer) { // TODO
		return (Pointer.NULL, Pointer.NULL);
	}
}
