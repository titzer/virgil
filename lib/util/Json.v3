type JsonValue {
	case String(v: string);
	case Number(v: int); // TODO: float
	case Bool(v: bool);
	case Null;
	case JArray(v: Array<JsonValue>);
	case JObject(v: HashMap<string, JsonValue>);

	def equal(that: JsonValue) -> bool {
		if (this == that) return true;
		if (JsonValue.String.?(this) && JsonValue.String.?(that)) {
			return Strings.equal(JsonValue.String.!(this).v, JsonValue.String.!(that).v);
		}
		if (JsonValue.Number.?(this) && JsonValue.Number.?(that)) {
			return JsonValue.Number.!(this).v == JsonValue.Number.!(that).v;
		}
		if (JsonValue.Bool.?(this) && JsonValue.Bool.?(that)) {
			return JsonValue.Bool.!(this).v == JsonValue.Bool.!(that).v;
		}
		if (JsonValue.Null.?(this) && JsonValue.Null.?(that)) return true;
		if (JsonValue.JArray.?(this) && JsonValue.JArray.?(that)) {
			var x = JsonValue.JArray.!(this).v;
			var y = JsonValue.JArray.!(that).v;
			if (x.length != y.length) return false;
			for (i < x.length) if (!x[i].equal(y[i])) return false;
			return true;
		}
		if (JsonValue.JObject.?(this) && JsonValue.JObject.?(that)) {
			var x_map = JsonValue.JObject.!(this).v;
			var y_map = JsonValue.JObject.!(that).v;
			var x = MapCollector.new(Strings.asciiLt, x_map).extract();
			var y = MapCollector.new(Strings.asciiLt, y_map).extract();
			if (x.length != y.length) return false;
			for (i < x.length) if (x[i].0 != y[i].0 || !x[i].1.equal(y[i].1)) return false;
			return true;
		}

		return false;
	}
}

enum JsonError(desc: string) {
	None("None"),
	EOF("End of file"),
	ParseError("Parse error"),
	EmptySource("Empty source string"),
	KeyNotFound("Key not found"),
	MismatchedValueType("Mismatched value type")
}

type ParseError(kind: JsonError, msg: string, pos: int) {}
def NO_ERR = ParseError(JsonError.None, "", -1);
def ERR_RET = JsonValue.Null;

class JsonParser {
	var source: string;
	var length: int;
	var pc: int;

	var err = NO_ERR;

	def reset(text: string) {
		source = text;
		length = text.length;
		pc = 0;

		err = NO_ERR;
	}

	def parse_value() -> JsonValue {
		skip_white();
		if (is_eof()) return eof_err();

		var at = source[pc];
		if (at == '\"') return parse_string();
		if (at == '-' || at >= '0' && at <= '9') return parse_number();

		// XXX: make stdlib take in {Range<byte>} instead of {string}
		var slice4 = Ranges.dup(source[pc ... pc + 4]);
		var slice5 = Ranges.dup(source[pc ... pc + 5]);
		if (Strings.equal(slice4, "true")) return JsonValue.Bool(true);
		if (Strings.equal(slice4, "null")) return JsonValue.Null;
		if (Strings.equal(slice5, "false")) return JsonValue.Bool(false);

		if (at == '[') return parse_array();
		if (at == '{') return parse_object();

		return err_atpc(
			JsonError.ParseError,
			Strings.format1("expected JSON value, got character '%c'", at)
		);
	}

	def parse_string() -> JsonValue {
		var res = Strings.parseLiteral(source, pc);
		var len = res.0, lit = res.1;
		if (len <= 0) return err_atpc(JsonError.ParseError, "invalid string");
		pc += len;
		return JsonValue.String(lit);
	}

	def parse_number() -> JsonValue {
		var res = Ints.parseDecimal(source, pc);
		var len = res.0, val = res.1;
		if (len <= 0) return err_atpc(JsonError.ParseError, "invalid number");
		pc += len;
		return JsonValue.Number(val);
	}

	private def parse_object_entry() -> (string, JsonValue) {
		var ERR_VAL = ("", ERR_RET);

		var key = parse_string();
		if (!ok() || !expect(':')) return ERR_VAL;
		var val = parse_value();
		if (!ok()) return ERR_VAL;
		return (JsonValue.String.!(key).v, val);
	}

	def parse_object() -> JsonValue {
		var dict = HashMap<string, JsonValue>.new(Strings.hash, Strings.equal);
		var entry: (string, JsonValue);
		if (!expect('{')) return ERR_RET;
		entry = parse_object_entry();
		dict[entry.0] = entry.1;
		if (!ok()) return ERR_RET;
		while (peek(',')) {
			pc++;
			entry = parse_object_entry();
			if (!ok()) return ERR_RET;
			dict[entry.0] = entry.1;
		}
		if (!expect('}')) return ERR_RET;
		return JsonValue.JObject(dict);
	}

	def parse_array() -> JsonValue {
		var vals = Vector<JsonValue>.new();
		if (!expect('[')) return ERR_RET;
		vals.put(parse_value());
		if (!ok()) return ERR_RET;
		while (peek(',')) {
			pc++;
			vals.put(parse_value());
			if (!ok()) return ERR_RET;
		}
		if (!expect(']')) return ERR_RET;
		return JsonValue.JArray(vals.extract());
	}

	def skip_white() {
		while (pc < length && Strings.isWhiteSpace(source[pc])) pc++;
	}

	def ok() -> bool {
		return err.kind == JsonError.None;
	}

	def peek(c: byte) -> bool {
		skip_white();
		if (is_eof()) return false;
		return source[pc] == c;
	}

	def expect(c: byte) -> bool {
		skip_white();
		if (is_eof()) { eof_err(); return false; }
		var at = source[pc];
		if (at != c) {
			err_atpc(JsonError.ParseError, Strings.format2("expected '%c', got '%c'", c, at));
			return false;
		}
		return true;
	}

	def err_atpc(kind: JsonError, msg: string) -> JsonValue {
		err = ParseError(kind, msg, pc);
		return ERR_RET;
	}

	def eof_err() -> JsonValue {
		err = ParseError(JsonError.EOF, "end of file", length);
		return ERR_RET;
	}

	def is_eof() -> bool {
		return pc >= length;
	}
}

class MapCollector<K, V> {
	def cmp: (K, K) -> bool;
	def pairs = Vector<(K, V)>.new();

	new(cmp, map: HashMap<K, V>) { map.apply(collect); }
	def collect(k: K, v: V) { pairs.put((k, v)); }
	def extract() -> Array<(K, V)> {
		var arr = pairs.extract();
		return Arrays.sort(arr, 0, arr.length, cmp_entries);
	}
	private def cmp_entries(a: (K, V), b: (K, V)) -> bool {
		return cmp(a.0, b.0);
	}
}
