type Sexp {
    case Atom(data: string);
    case List(elts: Range<Sexp>); // usually Cons

    def buildString(buf: StringBuilder) {
        match (this) {
            Atom(data) => buf.puts(data);
            List(elts) => {
                buf.putc('(');
                for (i = 0; i < elts.length - 1; i += 1) {
                    elts[i].buildString(buf);
                    buf.sp();
                }
                elts[elts.length - 1].buildString(buf);
                buf.putc(')');
            }
        }
    }
}

type ParseResult<T> {
    case Success(res: T);
    case Expected(str: string);
    case EmptySexp;
}

class SexpParser extends TextReader {
    new(filename: string, data: Array<byte>) super(filename, data) {}

    def atomChar(b: byte) -> bool {
        match (b) {
            ' ' => return false;
            '\t' => return false;
            '\n' => return false;
            ')' => return false;
            _ => return true;
        }
    }

    // can't make it ParseResult<Sexp.Atom>?
    def readAtom() -> ParseResult<Sexp> {
        skipWhitespace();
        def atom_end = star_rel(1, atomChar);
        if (atom_end == -1) return ParseResult.Expected("atom");

        def tok = readToken(atom_end - pos);
        skipWhitespace();
        return ParseResult.Success(Sexp.Atom(tok.image));
    }

    def readSexp() -> ParseResult<Sexp> {
        skipWhitespace();
        if (req1('(') == -1) return ParseResult.Expected("(");
        skipWhitespace();

        def elts = Vector<Sexp>.new();
        while (opt1(')') == -1) {
            skipWhitespace();
            def res: ParseResult<Sexp> = if(peekRel(0) == '(', readSexp(), readAtom());

            match (res) {
                Success(elt) => elts.put(elt);
                _ => return res;
            }
        }

        skipWhitespace();

        match (elts.length) {
            0 => return ParseResult.EmptySexp;
            1 => return ParseResult.Success(elts[0]);
            _ => return ParseResult.Success(Sexp.List(elts.copy()));
        }
    }
}
