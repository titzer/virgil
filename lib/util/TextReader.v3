// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility for reading and matching text, i.e. lexing and parsing. Has routines
// for reading tokens from a stream of characters, match characters, literals,
// etc. Keeps track of the current line, column, and a mapping from lines to
// their ending offsets (for later extracting a line from the text). Stores the
// first (earliest position) error, if any. Automatically skips whitespace when
// extracting tokens with a configurable whitespace skipping routine.
class TextReader {
	def fileName: string;
	def data: Array<byte>;			// array containing data
	def var pos: int;			// current position
	def var limit = data.length;		// limit within array
	def var char: byte;			// current byte
	def var line: int;			// current line number
	def var column: int;			// current column
	def var lineEnds = Vector<int>.new();

	def var ok: bool = true;		// true if no error
	def var error_pos: int = int.max;	// earliest position with error
	def var error_line: int = int.max;	// earliest line with error
	def var error_column: int = int.max;	// earliest column with error
	def var error_msg: string;		// error message

	var skipWs  = TextReader.skipWhitespace;	// configurable whitespace callback
	var onError = TextReader.setFirstError;		// configurable error callback

	new(fileName, data) {
		line = 1;
		column = 1;
		if (data.length > 0) char = data[0];
	}
	// Extract a token of length {len} from the current position and advance.
	def readToken(len: int) -> Token {
		var beginLine = line, beginColumn = column;
		var image = Array<byte>.new(len);
		for (i < len) image[i] = data[pos + i]; // inlined array copy
		advance(len);
		return Token.new(fileName, image, beginLine, beginColumn);
	}
	// Extract a token between positions {start} and {end} and advance.
	def readTokenAt(start: int, end: int) -> Token {
		return tokenFor(start, end, posToLine(start), posToColumn(start));
	}
	private def tokenFor(start: int, end: int, l: int, c: int) -> Token {
		var b = Array<byte>.new(end - start), d = data;
		for (p = start; p < end; p++) { // inlined array copy
			b[p - start] = d[p];
		}
		return Token.new(fileName, b, l, c);
	}
	// Consume {len} bytes and advance past whitespace.
	def advance(len: int) -> int {
		eat(len, 0);
		skipWs(this);
		return pos;
	}
	// Consume 1 byte and advance past whitespace.
	def advance1() -> this {
		eat(1, 0);
		skipWs(this);
	}
	// Consume {len} bytes, but do not advance past whitespace.
	def skip(len: int) -> int {
		eat(len, 0);
		return pos;
	}
	// Consume 1 byte, but do not advance past whitespace.
	def skip1() -> this {
		eat(1, 0);
	}
	// If the current byte matches {ch}, consume it, advance, and return the position.
	def opt1(ch: byte) -> int {
		if (char == ch) { var p = pos; advance1(); return p; }
		return -1;
	}
	// If the current bytes match {s}, consume them and advance.
	def optN(s: string) -> int {
		if (pos + s.length <= limit) {
			var p = pos, d = data, max = s.length;
			for (i < max) {
				if (s[i] != d[i + p]) return -1;
			}
			return advance(s.length);
		}
		return -1;
	}
	// Consume the byte {ch} at the current position and advance; error if no match.
	def req1(ch: byte) -> int {
		if (char == ch) { var p = pos; advance1(); return p; }
		fail(Strings.format1("\"%c\" expected", ch));
		return -1;
	}
	// Consume the bytes {s} at the current position and advance; error if no match.
	def reqN(s: string) -> int {
		if (pos + s.length > limit) return expected(s);
		for (i < s.length) {
			if (data[pos + i] != s[i]) return expected(s);
		}
		advance(s.length);
		return pos;
	}
	// Set the current position, line, and column.
	def at(npos: int, nline: int, ncol: int) -> this {
		var p = pos;
		line = nline;
		column = ncol;
		if (npos == p) return;
		if (npos < limit) { pos = npos; char = data[npos]; }
		else { pos = limit; char = '\x00'; }
	}
	// Convert the current location to a source range.
	def range() -> FileRange {
		return FileRange.new(fileName, line, column, line, column);
	}
	// Return the line number of the specified offset.
	def posToLine(at: int) -> int {
		if (at == pos) return line;
		for (i = lineEnds.length - 1; i >= 0; i--) {
			// XXX: linear search OK for near the end, use binary search for random access
			if (lineEnds[i] <= at) return i + 2;
		}
		return 1;
	}
	// Return the column number of the specified offset.
	def posToColumn(at: int) -> int {
		if (at == pos) return column;
		var q = 0, c = 1, d = data;
		var l = posToLine(at) - 1;
		if (l > 0) q = 1 + lineEnds[l - 1];
		while (q < at) {
			var ch = d[q];
			if (ch == '\t') c = nextTabStop(c);
			else if (ch == '\n') {
				System.error("TextReader", Strings.format2("missed a newline %d:%d", l + 1, c));
				c = 1;
			}
			else c++;
			q++;
		}
		return c;
	}
	// Peek {offset} bytes ahead without advancing.
	def peekRel(offset: int) -> byte {
		var q = pos + offset;
		if (q < limit) return data[q];
		return '\x00';
	}
	// Peek {offset} bytes ahead and match 0 or more bytes that match the given condition {f},
	// returning the position past the last match.
	def star_rel(offset: int, f: byte -> bool) -> int {
		var d = data, max = d.length;
		for (q = pos + offset; q < max; q++) {
			if (!f(d[q])) return q;
		}
		return max;
	}
	// Peek {offset} bytes ahead and match 1 or more bytes that match the given condition {f},
	// returning the position past the last match.
	def plus_rel(offset: int, f: byte -> bool) -> int {
		if (f(peekRel(offset))) {
			var d = data, max = d.length;
			for (q = pos + offset + 1; q < max; q++) {
				if (!f(d[q])) return q;
			}
			return max;
		}
		return -1;
	}
	// Verify that all new line bytes have their positions set in the map.
	def verifyLineEnds() -> bool {
		var j = 0, d = data, max = d.length;
		for (i < pos) {
			if (d[i] == '\n') {
				if (j >= lineEnds.length || lineEnds[j] != i) return false;
				j++;
			}
		}
		return true;
	}
	// Default skip callback: skip spaces, tabs, and newlines.
	def skipWhitespace() {
		eat(limit - pos, STOP_ON_CHAR);
	}
	// Skip spaces and tabs, but not newlines.
	def skipSpacesAndTabs() {
		eat(limit - pos, STOP_ON_CHAR | STOP_ON_NEWLINE);
	}
	// Skip all characters until a newline.
	def skipToEndOfLine() {
		eat(limit - pos, STOP_ON_NEWLINE);
	}
	// Skip all characters until the beginning of the next line.
	def skipToNextLine() {
		eat(limit - pos, STOP_ON_NEWLINE);
		if (char == '\n') eat(1, 0);
	}
	// Skip nothing--no characters.
	def skipNothing() {
	}
	// Eat a maximum of {len} characters, maintaining line and column numbers.
	// Flags in {stops} controls which if any characters will stop eating early.
	private def eat(len: int, stops: int) {
		if (pos >= limit) return void(char = 0);
		var max = pos + len;
		var end = limit;
		if (max < end) end = max;
		while (pos < end) {
			match (data[pos]) {
				' ' => {
					if ((stops & STOP_ON_SPACE) != 0) break;
					column++;
				}
				'\t' => {
					if ((stops & STOP_ON_TAB) != 0) break;
					column = nextTabStop(column);
				}
				'\n' => {
					if ((stops & STOP_ON_NEWLINE) != 0) break;
					lineEnds.put(pos);
					column = 1;
					line++;
				}
				_ => {
					if ((stops & STOP_ON_CHAR) != 0) break;
					column++;
				}
			}
			pos++;
		}
		char = if (pos < limit, data[pos]);
	}
	// Default error callback: record first error.
	def setFirstError(epos: int, eline: int, ecol: int, msg: string) {
		if (epos < error_pos) {
			ok = false;
			error_pos = epos;
			error_line = eline;
			error_column = ecol;
			error_msg = msg;
		}
	}
	private def expected(s: string) -> int {
		fail(Strings.format1("\"%s\" expected", s));
		return -1;
	}
	// Record an error with the specified message.
	def fail(msg: string) -> this {
		failRel(0, msg);
	}
	// Record an error at the given offset with the specified message.
	def failRel(offset: int, msg: string) -> this {
		var epos = pos + offset;
		var eline = posToLine(epos);
		var ecol = posToColumn(epos);
		onError(this, epos, eline, ecol, msg);
	}
	// Compute the next tab stop for the given column.
	def nextTabStop(column: int) -> int {
		return 1 + (((column + 7) >>> 3) << 3);
	}
	// Output the current line of text and a second line, with a caret at the corresponding position.
	def renderCurrentLineWithCaret(buf: StringBuilder, pos: int) -> StringBuilder { // TODO: rename
		var start = pos - 1;
		if (start < 0) start = 0;
		while (start > 0) {
			if (data[start] == '\n') {
				start++;
				break;
			}
			start--;
		}
		var end = start;
		while (end < limit) {
			if (data[end] == '\n') break;
			end++;
		}
		buf.putr(data[start ... end]);
		var column = 1;
		for (i = start; i < end; i++) {
			if (i == pos) break;
			var ch = data[i];
			if (ch == '\t') column = nextTabStop(column);
			else column++;
		}
		if (start <= pos && pos < end) {
			buf.ln();
			for (i < column - 1) buf.sp();
			buf.putc('^');
		}
		return buf;
	}
	// Get the position corresponding to the start of the line.
	def lineStartOffset(line: int) -> int {
		return if(line > 1, lineEnds[line - 2] + 1);
	}
	// Get the position corresponding to the end of the line.
	def lineEndOffset(line: int) -> int {
		if (line - 1 < lineEnds.length) return lineEnds[line - 1];
		for (i = lineStartOffset(line); i < data.length; i++) {
			if (data[i] == '\n') return i;
		}
		return data.length;
	}
	// Extract a string representing the bytes of the given line.
	def extractLine(line: int) -> string {
		if (line == 0) return null;
		var start = lineStartOffset(line), end = lineEndOffset(line);
		var result = Array<byte>.new(end - start);
		for (i < result.length) result[i] = data[start + i]; // inlined array copy
		return result;
	}
}
def STOP_ON_SPACE = 1;
def STOP_ON_NEWLINE = 2;
def STOP_ON_CHAR = 4;
def STOP_ON_TAB = 8;
