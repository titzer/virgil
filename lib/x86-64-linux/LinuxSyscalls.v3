// Copyright 2025 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component LinuxConst {
	// Standard file descriptors.
	def STDIN  = 0;
	def STDOUT = 1;
	def STDERR = 2;
	// Maximum length of a path.
	def MAXPATHLEN = 1024;
	// Constants associated with open().
	def O_RDONLY	= 0;      // open read-only
	def O_WRONLY	= 1;      // open write-only
	def O_RDWR	= 2;      // open read-write
	def O_NONBLOCK  = 0x0800; // no delay
	def O_APPEND    = 0x0400; // set append mode
	def O_SYNC      = 0x1000; // synch I/O file integrity
	def O_ASYNC     = 0x2000; // signal pgrp when data ready
	def O_CREAT     = 0x0040; // create if nonexistent
	def O_TRUNC     = 0x0200; // truncate to zero length
	def O_EXCL      = 0x0080; // error if already exists
	def O_NOCTTY    = 0x0100; // don't assign controlling terminal
        def O_DSYNC	= 0x1000; // synch I/O data integrity
        def O_DIRECTORY	= 0x10000; // error if not a directory

	// Constants for networking
	def AF_UNSPEC		= 0x0;
	def AF_UNIX  		= 0x1;
	def AF_INET  		= 0x2;
	def AF_INET6 		= 0xA;
	def SOCK_STREAM 	= 0x1;
	def SOCK_DGRAM  	= 0x2;
	def SOCK_NONBLOCK 	= 0x0800;
	def SOCK_CLOEXEC  	= 0x8000;
	def SOCKADDR_V4_SIZE   	= 16;
	def SOCKADDR_V6_SIZE   	= 28;
	def SOCKADDR_UNIX_SIZE 	= 110;
	def SOCKADDR_STORAGE_SIZE = 128;

	// Constants for lseek().
	def SEEK_SET = 0;
	def SEEK_CUR = 1;
	def SEEK_END = 2;
	// Constants for mmap.
	def PROT_READ = 0x1;
	def PROT_WRITE = 0x2;
	def PROT_EXEC = 0x4;
	def PROT_NONE = 0x0;
	def MAP_SHARED = 0x1;
	def MAP_PRIVATE = 0x2;
	def MAP_FIXED = 0x10;
	def MAP_ANONYMOUS = 0x20;

	// Constants for selected system call numbers.
	def read		= 0;
	def write		= 1;
	def open		= 2;
	def close		= 3;
	def stat		= 4;
	def fstat		= 5;
	def lstat		= 6;
	def poll	 	= 7;
	def lseek		= 8;
	def mmap		= 9;
	def mprotect	= 10;
	def munmap		= 11;
	def rt_sigaction	= 13;
	def ioctl		= 16;
	def pipe		= 22;
	def select		= 23;
	def dup		= 32;
	def dup2		= 33;
	def socket		= 41;
	def connect		= 42;
	def accept		= 43;
	def sendto		= 44;
	def recvfrom	= 45;
	def bind		= 49;
	def listen		= 50;
	def getsockname	= 51;
	def fork		= 57;
	def vfork		= 58;
	def execve		= 59;
	def exit		= 60;
	def wait4		= 61;
	def chmod		= 90;
	def gettimeofday	= 96;
	def sigaltstack	= 131;

	// TODO: word offset of st_size in statbuf
	def STAT_BUF_SIZE = 144;
	def STAT_WOFF_ST_SIZE = 6;

        // constants for getdents
	def DT_UNKNOWN = 0;
	def DT_FIFO = 1;
	def DT_CHR = 2;
	def DT_DIR = 4;
	def DT_BLK = 6;
	def DT_REG = 8;
	def DT_LNK = 10;
	def DT_SOCK = 12;
	def DT_WHT = 14;
}

private thread component Buffers {
	def zeroTerminatePath(s: string) -> Pointer;
}

def pin<T>(t: T) -> T;
def unpin<T>(t: T) -> T;
def blockingSyscall<T>(num: u32, args: T) -> u64;

// Provides a more convenient interface to Linux system calls by accepting and documenting
// arguments as well as using appropriate data structures in the form of layouts.
// It also offers a higher-level interface that is safer w.r.t. multi-threading and pinning.
component LinuxSyscall {
//	use LinuxConst;

	def read(fd: u32, buf: Range<byte>) -> u64 {
		buf = pin(buf);
		var result = blockingSyscall(SYS_read, (fd, Pointer.atContents(buf), buf.length));
		unpin(buf);
		return result;
	}
	def write(fd: u32, buf: Range<byte>) -> u64 {
		buf = pin(buf);
		var result = blockingSyscall(SYS_write, (fd, Pointer.atContents(buf), buf.length));
		unpin(buf);
		return result;
	}
	def open(filename: string, flags: u32, mode: u32)
		=> Linux.syscall(SYS_open, (zeroTerminatePath(filename), flags, mode)).0;
	def close(fd: u32)
		=> Linux.syscall(SYS_close, (fd)).0;
	def stat(filename: string, statbuf: Ref<stat>)
		=> Linux.syscall(SYS_stat, (Buffers.zeroTerminatePath(filename), Pointer.atRef(statbuf))).0;
	def fstat(fd: u32, statbuf: Ref<stat>)
		=> Linux.syscall(SYS_fstat, (fd, Pointer.atRef(statbuf))).0;
	def lstat(filename: string, statbuf: Ref<stat>)
		=> Linux.syscall(SYS_lstat, (Buffers.zeroTerminatePath(filename), Pointer.atRef(statbuf))).0;
/*
	def poll(struct poll_fd *ufds, u32 nfds, long timeout_msecs) -> u64;
	def lseek(u32 fd, off_t offset, u32 origin) -> u64;
	def mmap(u64 addr, u64 len, u64 prot, u64 flags, u64 fd, u64 off) -> u64;
	def mprotect(u64 start, u64 len, u64 prot) -> u64;
	def munmap(u64 addr, u64 len) -> u64;
	def brk(u64 brk) -> u64;
	def rt_sigaction(int sig, const struct sigaction *act, struct sigaction *oact, u64 sigsetsize) -> u64;
	def rt_sigprocmask(int how, sigset_t *nset, sigset_t *oset, u64 sigsetsize) -> u64;
	def rt_sigreturn(u64 __unused) -> u64;
	def ioctl(u32 fd, u32 cmd, u64 arg) -> u64;
	def pread64(u64 fd, char *buf, u64 count, loff_t pos) -> u64;
	def pwrite64(u32 fd, string buf, u64 count, loff_t pos) -> u64;
	def readv(u64 fd, const struct iovec *vec, u64 vlen) -> u64;
	def writev(u64 fd, const struct iovec *vec, u64 vlen) -> u64;
	def access(string filename, int mode) -> u64;
	def pipe(int *filedes) -> u64;
	def select(int n, fd_set *inp, fd_set *outp, fd_set*exp, struct timeval *tvp) -> u64;
	def sched_yield() -> u64;
	def mremap(u64 addr, u64 old_len, u64 new_len, u64 flags, u64 new_addr) -> u64;
	def msync(u64 start, u64 len, int flags) -> u64;
	def mincore(u64 start, u64 len, unsigned char *vec) -> u64;
	def madvise(u64 start, u64 len_in, int behavior) -> u64;
	def shmget(key_t key, u64 size, int shmflg) -> u64;
	def shmat(int shmid, char *shmaddr, int shmflg) -> u64;
	def shmctl(int shmid, int cmd, struct shmid_ds *buf) -> u64;
	def dup(u32 fildes) -> u64;
	def dup2(u32 oldfd, u32 newfd) -> u64;
	def pause() -> u64;
	def nanosleep(struct timespec *rqtp, struct timespec *rmtp) -> u64;
	def getitimer(int which, struct itimerval *value) -> u64;
	def alarm(u32 seconds) -> u64;
	def setitimer(int which, struct itimerval *value, struct itimerval *ovalue) -> u64;
	def getpid() -> u64;
	def sendfile(int out_fd, int in_fd, off_t *offset, u64 count) -> u64;
	def socket(int family, int type, int protocol) -> u64;
	def connect(int fd, struct sockaddr *uservaddr, int addrlen) -> u64;
	def accept(int fd, struct sockaddr *upeer_sockaddr, int *upeer_addrlen) -> u64;
	def sendto(int fd, void *buff, u64 len, unsigned flags, struct sockaddr *addr, int addr_len) -> u64;
	def recvfrom(int fd, void *ubuf, u64 size, unsigned flags, struct sockaddr *addr, int *addr_len) -> u64;
	def sendmsg(int fd, struct msghdr *msg, unsigned flags) -> u64;
	def recvmsg(int fd, struct msghdr *msg, u32 flags) -> u64;
	def shutdown(int fd, int how) -> u64;
	def bind(int fd, struct sokaddr *umyaddr, int addrlen) -> u64;
	def listen(int fd, int backlog) -> u64;
	def getsockname(int fd, struct sockaddr *usockaddr, int *usockaddr_len) -> u64;
	def getpeername(int fd, struct sockaddr *usockaddr, int *usockaddr_len) -> u64;
	def socketpair(int family, int type, int protocol, int *usockvec) -> u64;
	def setsockopt(int fd, int level, int optname, char *optval, int optlen) -> u64;
	def getsockopt(int fd, int level, int optname, char *optval, int *optlen) -> u64;
	def clone(u64 clone_flags, u64 newsp, void *parent_tid, void *child_tid, u32 tid) -> u64;
	def fork() -> u64;
	def vfork() -> u64;
	def execve(string filename, string const argv[], string const envp[]) -> u64;
	def exit(int error_code) -> u64;
	def wait4(pid_t upid, int *stat_addr, int options, struct rusage *ru) -> u64;
	def kill(pid_t pid, int sig) -> u64;
	def uname(struct old_utsname *name) -> u64;
	def semget(key_t key, int nsems, int semflg) -> u64;
	def semop(int semid, struct sembuf *tsops, unsigned nsops) -> u64;
	def semctl(int semid, int semnum, int cmd, union semun arg) -> u64;
	def shmdt(char *shmaddr) -> u64;
	def msgget(key_t key, int msgflg) -> u64;
	def msgsnd(int msqid, struct msgbuf *msgp, u64 msgsz, int msgflg) -> u64;
	def msgrcv(int msqid, struct msgbuf *msgp, u64 msgsz, long msgtyp, int msgflg) -> u64;
	def msgctl(int msqid, int cmd, struct msqid_ds *buf) -> u64;
	def fcntl(u32 fd, u32 cmd, u64 arg) -> u64;
	def flock(u32 fd, u32 cmd) -> u64;
	def fsync(u32 fd) -> u64;
	def fdatasync(u32 fd) -> u64;
	def truncate(string path, long length) -> u64;
	def ftruncate(u32 fd, u64 length) -> u64;
	def getdents(u32 fd, struct linux_dirent *dirent, u32 count) -> u64;
	def getcwd(char *buf, u64 size) -> u64;
	def chdir(string filename) -> u64;
	def fchdir(u32 fd) -> u64;
	def rename(string oldname, string newname) -> u64;
	def mkdir(string pathname, int mode) -> u64;
	def rmdir(string pathname) -> u64;
	def creat(string pathname, int mode) -> u64;
	def link(string oldname, string newname) -> u64;
	def unlink(string pathname) -> u64;
	def symlink(string oldname, string newname) -> u64;
	def readlink(string path, char *buf, int bufsiz) -> u64;
	def chmod(string filename, mode_t mode) -> u64;
	def fchmod(u32 fd, mode_t mode) -> u64;
	def chown(string filename, uid_t user, gid_t group) -> u64;
	def fchown(u32 fd, uid_t user, gid_t group) -> u64;
	def lchown(string filename, uid_t user, gid_t group) -> u64;
	def umask(int mask) -> u64;
	def gettimeofday(struct timeval *tv, struct timezone *tz) -> u64;
	def getrlimit(u32 resource, struct rlimit *rlim) -> u64;
	def getrusage(int who, struct rusage *ru) -> u64;
	def sysinfo(struct sysinfo *info) -> u64;
	def times(struct tms *tbuf) -> u64;
	def ptrace(long request, long pid, u64 addr, u64 data) -> u64;
	def getuid() -> u64;
	def syslog(int type, char *buf, int len) -> u64;
	def getgid() -> u64;
	def setuid(uid_t uid) -> u64;
	def setgid(gid_t gid) -> u64;
	def geteuid() -> u64;
	def getegid() -> u64;
	def setpgid(pid_t pid, pid_t pgid) -> u64;
	def getppid() -> u64;
	def getpgrp() -> u64;
	def setsid() -> u64;
	def setreuid(uid_t ruid, uid_t euid) -> u64;
	def setregid(gid_t rgid, gid_t egid) -> u64;
	def getgroups(int gidsetsize, gid_t *grouplist) -> u64;
	def setgroups(int gidsetsize, gid_t *grouplist) -> u64;
	def setresuid(uid_t *ruid, uid_t *euid, uid_t *suid) -> u64;
	def getresuid(uid_t *ruid, uid_t *euid, uid_t *suid) -> u64;
	def setresgid(gid_t rgid, gid_t egid, gid_t sgid) -> u64;
	def getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid) -> u64;
	def getpgid(pid_t pid) -> u64;
	def setfsuid(uid_t uid) -> u64;
	def setfsgid(gid_t gid) -> u64;
	def getsid(pid_t pid) -> u64;
	def capget(cap_user_header_t header, cap_user_data_t dataptr) -> u64;
	def capset(cap_user_header_t header, const cap_user_data_t data) -> u64;
	def rt_sigpending(sigset_t *set, u64 sigsetsize) -> u64;
	def rt_sigtimedwait(const sigset_t *uthese, siginfo_t *uinfo, const struct timespec *uts, u64 sigsetsize) -> u64;
	def rt_sigqueueinfo(pid_t pid, int sig, siginfo_t *uinfo) -> u64;
	def rt_sigsuspend(sigset_t *unewset, u64 sigsetsize) -> u64;
	def sigaltstack(const stack_t *uss, stack_t *uoss) -> u64;
	def utime(char *filename, struct utimbuf *times) -> u64;
	def mknod(string filename, umode_t mode, unsigned dev) -> u64;
	def uselib(NOT IMPLEMENTED) -> u64;
	def personality(u32 personality) -> u64;
	def ustat(unsigned dev, struct ustat *ubuf) -> u64;
	def statfs(string pathname, struct statfs *buf) -> u64;
	def fstatfs(u32 fd, struct statfs *buf) -> u64;
	def sysfs(int option, u64 arg1, u64 arg2) -> u64;
	def getpriority(int which, int who) -> u64;
	def setpriority(int which, int who, int niceval) -> u64;
	def sched_setparam(pid_t pid, struct sched_param *param) -> u64;
	def sched_getparam(pid_t pid, struct sched_param *param) -> u64;
	def sched_setscheduler(pid_t pid, int policy, struct sched_param *param) -> u64;
	def sched_getscheduler(pid_t pid) -> u64;
	def sched_get_priority_max(int policy) -> u64;
	def sched_get_priority_min(int policy) -> u64;
	def sched_rr_get_interval(pid_t pid, struct timespec *interval) -> u64;
	def mlock(u64 start, u64 len) -> u64;
	def munlock(u64 start, u64 len) -> u64;
	def mlockall(int flags) -> u64;
	def munlockall() -> u64;
	def vhangup() -> u64;
	def modify_ldt(int func, void *ptr, u64 bytecount) -> u64;
	def pivot_root(string new_root, string put_old) -> u64;
	def _sysctl(struct __sysctl_args *args) -> u64;
	def prctl(int option, u64 arg2, u64 arg3, u64 arg4, , u64 arg5) -> u64;
	def arch_prctl(struct task_struct *task, int code, u64 *addr) -> u64;
	def adjtimex(struct timex *txc_p) -> u64;
	def setrlimit(u32 resource, struct rlimit *rlim) -> u64;
	def chroot(string filename) -> u64;
	def sync() -> u64;
	def acct(string name) -> u64;
	def settimeofday(struct timeval *tv, struct timezone *tz) -> u64;
	def mount(char *dev_name, char *dir_name, char *type, u64 flags, void *data) -> u64;
	def umount2(string target, int flags) -> u64;
	def swapon(string specialfile, int swap_flags) -> u64;
	def swapoff(string specialfile) -> u64;
	def reboot(int magic1, int magic2, u32 cmd, void *arg) -> u64;
	def sethostname(char *name, int len) -> u64;
	def setdomainname(char *name, int len) -> u64;
	def iopl(u32 level, struct pt_regs *regs) -> u64;
	def ioperm(u64 from, u64 num, int turn_on) -> u64;
	def create_module(REMOVED IN Linux 2.6) -> u64;
	def init_module(void *umod, u64 len, string uargs) -> u64;
	def delete_module(const chat *name_user, u32 flags) -> u64;
	def get_kernel_syms(REMOVED IN Linux 2.6) -> u64;
	def query_module(REMOVED IN Linux 2.6) -> u64;
	def quotactl(u32 cmd, string special, qid_t id, void *addr) -> u64;
	def nfsservctl(NOT IMPLEMENTED) -> u64;
	def getpmsg(NOT IMPLEMENTED) -> u64;
	def putpmsg(NOT IMPLEMENTED) -> u64;
	def afs_syscall(NOT IMPLEMENTED) -> u64;
	def tuxcall(NOT IMPLEMENTED) -> u64;
	def security(NOT IMPLEMENTED) -> u64;
	def gettid() -> u64;
	def readahead(int fd, loff_t offset, u64 count) -> u64;
	def setxattr(string pathname, string name, const void *value, u64 size, int flags) -> u64;
	def lsetxattr(string pathname, string name, const void *value, u64 size, int flags) -> u64;
	def fsetxattr(int fd, string name, const void *value, u64 size, int flags) -> u64;
	def getxattr(string pathname, string name, void *value, u64 size) -> u64;
	def lgetxattr(string pathname, string name, void *value, u64 size) -> u64;
	def fgetxattr(int fd, const har *name, void *value, u64 size) -> u64;
	def listxattr(string pathname, char *list, u64 size) -> u64;
	def llistxattr(string pathname, char *list, u64 size) -> u64;
	def flistxattr(int fd, char *list, u64 size) -> u64;
	def removexattr(string pathname, string name) -> u64;
	def lremovexattr(string pathname, string name) -> u64;
	def fremovexattr(int fd, string name) -> u64;
	def tkill(pid_t pid, ing sig) -> u64;
	def time(time_t *tloc) -> u64;
	def futex(u32 *uaddr, int op, u32 val, struct timespec *utime, u32 *uaddr2, u32 val3) -> u64;
	def sched_setaffinity(pid_t pid, u32 len, u64 *user_mask_ptr) -> u64;
	def sched_getaffinity(pid_t pid, u32 len, u64 *user_mask_ptr) -> u64;
	def set_thread_area(NOT IMPLEMENTED. Use arch_prctl) -> u64;
	def io_setup(unsigned nr_events, aio_context_t *ctxp) -> u64;
	def io_destroy(aio_context_t ctx) -> u64;
	def io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event *events) -> u64;
	def io_submit(aio_context_t ctx_id, long nr, struct iocb **iocbpp) -> u64;
	def io_cancel(aio_context_t ctx_id, struct iocb *iocb, struct io_event *result) -> u64;
	def get_thread_area(NOT IMPLEMENTED. Use arch_prctl) -> u64;
	def lookup_dcookie(u64 cookie64, long buf, long len) -> u64;
	def epoll_create(int size) -> u64;
	def epoll_ctl_old(NOT IMPLEMENTED) -> u64;
	def epoll_wait_old(NOT IMPLEMENTED) -> u64;
	def remap_file_pages(u64 start, u64 size, u64 prot, u64 pgoff, u64 flags) -> u64;
	def getdents64(u32 fd, struct linux_dirent64 *dirent, u32 count) -> u64;
	def set_tid_address(int *tidptr) -> u64;
	def restart_syscall() -> u64;
	def semtimedop(int semid, struct sembuf *tsops, unsigned nsops, const struct timespec *timeout) -> u64;
	def fadvise64(int fd, loff_t offset, u64 len, int advice) -> u64;
	def timer_create(const clockid_t which_clock, struct sigevent *timer_event_spec, timer_t *created_timer_id) -> u64;
	def timer_settime(timer_t timer_id, int flags, const struct itimerspec *new_setting, struct itimerspec *old_setting) -> u64;
	def timer_gettime(timer_t timer_id, struct itimerspec *setting) -> u64;
	def timer_getoverrun(timer_t timer_id) -> u64;
	def timer_delete(timer_t timer_id) -> u64;
	def clock_settime(const clockid_t which_clock, const struct timespec *tp) -> u64;
	def clock_gettime(const clockid_t which_clock, struct timespec *tp) -> u64;
	def clock_getres(const clockid_t which_clock, struct timespec *tp) -> u64;
	def clock_nanosleep(const clockid_t which_clock, int flags, const struct timespec *rqtp, struct timespec *rmtp) -> u64;
	def exit_group(int error_code) -> u64;
	def epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout) -> u64;
	def epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) -> u64;
	def tgkill(pid_t tgid, pid_t pid, int sig) -> u64;
	def utimes(char *filename, struct timeval *utimes) -> u64;
	def vserver(NOT IMPLEMENTED) -> u64;
	def mbind(u64 start, u64 len, u64 mode, u64 *nmask, u64 maxnode, unsigned flags) -> u64;
	def set_mempolicy(int mode, u64 *nmask, u64 maxnode) -> u64;
	def get_mempolicy(int *policy, u64 *nmask, u64 maxnode, u64 addr, u64 flags) -> u64;
	def mq_open(string u_name, int oflag, mode_t mode, struct mq_attr *u_attr) -> u64;
	def mq_unlink(string u_name) -> u64;
	def mq_timedsend(mqd_t mqdes, string u_msg_ptr, u64 msg_len, u32 msg_prio, const stuct timespec *u_abs_timeout) -> u64;
	def mq_timedreceive(mqd_t mqdes, char *u_msg_ptr, u64 msg_len, u32 *u_msg_prio, const struct timespec *u_abs_timeout) -> u64;
	def mq_notify(mqd_t mqdes, const struct sigevent *u_notification) -> u64;
	def mq_getsetattr(mqd_t mqdes, const struct mq_attr *u_mqstat, struct mq_attr *u_omqstat) -> u64;
	def kexec_load(u64 entry, u64 nr_segments, struct kexec_segment *segments, u64 flags) -> u64;
	def waitid(int which, pid_t upid, struct siginfo *infop, int options, struct rusage *ru) -> u64;
	def add_key(string _type, string _description, const void *_payload, u64 plen) -> u64;
	def request_key(string _type, string _description, string _callout_info, key_serial_t destringid) -> u64;
	def keyctl(int option, u64 arg2, u64 arg3, u64 arg4, u64 arg5) -> u64;
	def ioprio_set(int which, int who, int ioprio) -> u64;
	def ioprio_get(int which, int who) -> u64;
	def inotify_init() -> u64;
	def inotify_add_watch(int fd, string pathname, u32 mask) -> u64;
	def inotify_rm_watch(int fd, __s32 wd) -> u64;
	def migrate_pages(pid_t pid, u64 maxnode, const u64 *old_nodes, const u64 *new_nodes) -> u64;
	def openat(int dfd, string filename, int flags, int mode) -> u64;
	def mkdirat(int dfd, string pathname, int mode) -> u64;
	def mknodat(int dfd, string filename, int mode, unsigned dev) -> u64;
	def fchownat(int dfd, string filename, uid_t user, gid_t group, int flag) -> u64;
	def futimesat(int dfd, string filename, struct timeval *utimes) -> u64;
	def newfstatat(int dfd, string filename, struct stat *statbuf, int flag) -> u64;
	def unlinkat(int dfd, string pathname, int flag) -> u64;
	def renameat(int oldfd, string oldname, int newfd, string newname) -> u64;
	def linkat(int oldfd, string oldname, int newfd, string newname, int flags) -> u64;
	def symlinkat(string oldname, int newfd, string newname) -> u64;
	def readlinkat(int dfd, string pathname, char *buf, int bufsiz) -> u64;
	def fchmodat(int dfd, string filename, mode_t mode) -> u64;
	def faccessat(int dfd, string filename, int mode) -> u64;
	def pselect6(int n, fd_set *inp, fd_set *outp, fd_set *exp, struct timespec *tsp, void *sig) -> u64;
	def ppoll(struct pollfd *ufds, u32 nfds, struct timespec *tsp, const sigset_t *sigmask, u64 sigsetsize) -> u64;
	def unshare(u64 unshare_flags) -> u64;
	def set_robust_list(struct robust_list_head *head, u64 len) -> u64;
	def get_robust_list(int pid, struct robust_list_head **head_ptr, u64 *len_ptr) -> u64;
	def splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, u64 len, u32 flags) -> u64;
	def tee(int fdin, int fdout, u64 len, u32 flags) -> u64;
	def sync_file_range(long fd, loff_t offset, loff_t bytes, long flags) -> u64;
	def vmsplice(int fd, const struct iovec *iov, u64 nr_segs, u32 flags) -> u64;
	def move_pages(pid_t pid, u64 nr_pages, const void **pages, const int *nodes, int *status, int flags) -> u64;
	def utimensat(int dfd, string filename, struct timespec *utimes, int flags) -> u64;
	def epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask, u64 sigsetsize) -> u64;
	def signalfd(int ufd, sigset_t *user_mask, u64 sizemask) -> u64;
	def timerfd_create(int clockid, int flags) -> u64;
	def eventfd(u32 count) -> u64;
	def fallocate(long fd, long mode, loff_t offset, loff_t len) -> u64;
	def timerfd_settime(int ufd, int flags, const struct itimerspec *utmr, struct itimerspec *otmr) -> u64;
	def timerfd_gettime(int ufd, struct itimerspec *otmr) -> u64;
	def accept4(int fd, struct sockaddr *upeer_sockaddr, int *upeer_addrlen, int flags) -> u64;
	def signalfd4(int ufd, sigset_t *user_mask, u64 sizemask, int flags) -> u64;
	def eventfd2(u32 count, int flags) -> u64;
	def epoll_create1(int flags) -> u64;
	def dup3(u32 oldfd, u32 newfd, int flags) -> u64;
	def pipe2(int *filedes, int flags) -> u64;
	def inotify_init1(int flags) -> u64;
	def preadv(u64 fd, const struct iovec *vec, u64 vlen, u64 pos_l, u64 pos_h) -> u64;
	def pwritev(u64 fd, const struct iovec *vec, u64 vlen, u64 pos_l, u64 pos_h) -> u64;
	def rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *uinfo) -> u64;
	def perf_event_open(struct perf_event_attr *attr_uptr, pid_t pid, int cpu, int group_fd, u64 flags) -> u64;
	def recvmmsg(int fd, struct msghdr *mmsg, u32 vlen, u32 flags, struct timespec *timeout) -> u64;
	def fanotify_init(u32 flags, u32 event_f_flags) -> u64;
	def fanotify_mark(long fanotify_fd, long flags, __u64 mask, long dfd, long pathname) -> u64;
	def prlimit64(pid_t pid, u32 resource, const struct rlimit64 *new_rlim, struct rlimit64 *old_rlim) -> u64;
	def name_to_handle_at(int dfd, string name, struct file_handle *handle, int *mnt_id, int flag) -> u64;
	def open_by_handle_at(int dfd, string name, struct file_handle *handle, int *mnt_id, int flags) -> u64;
	def clock_adjtime(clockid_t which_clock, struct timex *tx) -> u64;
	def syncfs(int fd) -> u64;
	def sendmmsg(int fd, struct mmsghdr *mmsg, u32 vlen, u32 flags) -> u64;
	def setns(int fd, int nstype) -> u64;
	def getcpu(unsigned *cpup, unsigned *nodep, struct getcpu_cache *unused) -> u64;
	def process_vm_readv(pid_t pid, const struct iovec *lvec, u64 liovcnt, const struct iovec *rvec, u64 riovcnt, u64 flags) -> u64;
	def process_vm_writev(pid_t pid, const struct iovec *lvec, u64 liovcnt, const struct iovcc *rvec, u64 riovcnt, u64 flags) -> u64;
	def kcmp(pid_t pid1, pid_t pid2, int type, u64 idx1, u64 idx2) -> u64;
	def finit_module(int fd, const char __user *uargs, int flags) -> u64;
	def sched_setattr(pid_t pid, struct sched_attr __user *attr, u32 flags) -> u64;
	def sched_getattr(pid_t pid, struct sched_attr __user *attr, u32 size, u32 flags) -> u64;
	def renameat2(int olddfd, const char __user *oldname, int newdfd, const char __user *newname, u32 flags) -> u64;
	def seccomp(u32 op, u32 flags, const char __user *uargs) -> u64;
	def getrandom(char __user *buf, u64 count, u32 flags) -> u64;
	def memfd_create(const char __user *uname_ptr, u32 flags) -> u64;
	def kexec_file_load(int kernel_fd, int initrd_fd, u64 cmdline_len, const char __user *cmdline_ptr, u64 flags) -> u64;
	def bpf(int cmd, union bpf_attr *attr, u32 size) -> u64;
	def stub_execveat(int dfd, const char __user *filename, const char __user *const __user *argv, const char __user *const __user *envp, int flags) -> u64;
	def userfaultfd(int flags) -> u64;
	def membarrier(int cmd, int flags) -> u64;
	def mlock2(u64 start, u64 len, int flags) -> u64;
	def copy_file_range(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user * off_out, u64 len, u32 flags) -> u64;
	def preadv2(u64 fd, const struct iovec __user *vec, u64 vlen, u64 pos_l, u64 pos_h, int flags) -> u64;
	def pwritev2(u64 fd, const struct iovec __user *vec, u64 vlen, u64 pos_l, u64 pos_h, int flags) -> u64;
*/
}

// Linux errno codes.
enum LinuxErrno(code: byte, description: string) {
	EPERM(1, "Operation not permitted"),
	ENOENT(2, "No such file or directory"),
	ESRCH(3, "No such process"),
	EINTR(4, "Interrupted system call"),
	EIO(5, "I/O error"),
	ENXIO(6, "No such device or address"),
	E2BIG(7, "Argument list too long"),
	ENOEXEC(8, "Exec format error"),
	EBADF(9, "Bad file number"),
	ECHILD(10, "No child processes"),
	EAGAIN(11, "Try again"),
	ENOMEM(12, "Out of memory"),
	EACCES(13, "Permission denied"),
	EFAULT(14, "Bad address"),
	ENOTBLK(15, "Block device required"),
	EBUSY(16, "Device or resource busy"),
	EEXIST(17, "File exists"),
	EXDEV(18, "Cross-device link"),
	ENODEV(19, "No such device"),
	ENOTDIR(20, "Not a directory"),
	EISDIR(21, "Is a directory"),
	EINVAL(22, "Invalid argument"),
	ENFILE(23, "File table overflow"),
	EMFILE(24, "Too many open files"),
	ENOTTY(25, "Not a typewriter"),
	ETXTBSY(26, "Text file busy"),
	EFBIG(27, "File too large"),
	ENOSPC(28, "No space left on device"),
	ESPIPE(29, "Illegal seek"),
	EROFS(30, "Read-only file system"),
	EMLINK(31, "Too many links"),
	EPIPE(32, "Broken pipe"),
	EDOM(33, "Math argument out of domain of func"),
	ERANGE(34, "Math result not representable"),
	EDEADLK(35, "Resource deadlock would occur"),
	ENAMETOOLONG(36, "File name too long"),
	ENOLCK(37, "No record locks available"),
	ENOSYS(38, "Function not implemented"),
	ENOTEMPTY(39, "Directory not empty"),
	ELOOP(40, "Too many symbolic links encountered"),
	ENOMSG(42, "No message of desired type"),
	EIDRM(43, "Identifier removed"),
	ECHRNG(44, "Channel number out of range"),
	EL2NSYNC(45, "Level 2 not synchronized"),
	EL3HLT(46, "Level 3 halted"),
	EL3RST(47, "Level 3 reset"),
	ELNRNG(48, "Link number out of range"),
	EUNATCH(49, "Protocol driver not attached"),
	ENOCSI(50, "No CSI structure available"),
	EL2HLT(51, "Level 2 halted"),
	EBADE(52, "Invalid exchange"),
	EBADR(53, "Invalid request descriptor"),
	EXFULL(54, "Exchange full"),
	ENOANO(55, "No anode"),
	EBADRQC(56, "Invalid request code"),
	EBADSLT(57, "Invalid slot"),
	EBFONT(59, "Bad font file format"),
	ENOSTR(60, "Device not a stream"),
	ENODATA(61, "No data available"),
	ETIME(62, "Timer expired"),
	ENOSR(63, "Out of streams resources"),
	ENONET(64, "Machine is not on the network"),
	ENOPKG(65, "Package not installed"),
	EREMOTE(66, "Object is remote"),
	ENOLINK(67, "Link has been severed"),
	EADV(68, "Advertise error"),
	ESRMNT(69, "Srmount error"),
	ECOMM(70, "Communication error on send"),
	EPROTO(71, "Protocol error"),
	EMULTIHOP(72, "Multihop attempted"),
	EDOTDOT(73, "RFS specific error"),
	EBADMSG(74, "Not a data message"),
	EOVERFLOW(75, "Value too large for defined data type"),
	ENOTUNIQ(76, "Name not unique on network"),
	EBADFD(77, "File descriptor in bad state"),
	EREMCHG(78, "Remote address changed"),
	ELIBACC(79, "Can not access a needed shared library"),
	ELIBBAD(80, "Accessing a corrupted shared library"),
	ELIBSCN(81, ".lib section in a.out corrupted"),
	ELIBMAX(82, "Attempting to link in too many shared libraries"),
	ELIBEXEC(83, "Cannot exec a shared library directly"),
	EILSEQ(84, "Illegal byte sequence"),
	ERESTART(85, "Interrupted system call should be restarted"),
	ESTRPIPE(86, "Streams pipe error"),
	EUSERS(87, "Too many users"),
	ENOTSOCK(88, "Socket operation on non-socket"),
	EDESTADDRREQ(89, "Destination address required"),
	EMSGSIZE(90, "Message too long"),
	EPROTOTYPE(91, "Protocol wrong type for socket"),
	ENOPROTOOPT(92, "Protocol not available"),
	EPROTONOSUPPORT(93, "Protocol not supported"),
	ESOCKTNOSUPPORT(94, "Socket type not supported"),
	EOPNOTSUPP(95, "Operation not supported on transport endpoint"),
	EPFNOSUPPORT(96, "Protocol family not supported"),
	EAFNOSUPPORT(97, "Address family not supported by protocol"),
	EADDRINUSE(98, "Address already in use"),
	EADDRNOTAVAIL(99, "Cannot assign requested address"),
	ENETDOWN(100, "Network is down"),
	ENETUNREACH(101, "Network is unreachable"),
	ENETRESET(102, "Network dropped connection because of reset"),
	ECONNABORTED(103, "Software caused connection abort"),
	ECONNRESET(104, "Connection reset by peer"),
	ENOBUFS(105, "No buffer space available"),
	EISCONN(106, "Transport endpoint is already connected"),
	ENOTCONN(107, "Transport endpoint is not connected"),
	ESHUTDOWN(108, "Cannot send after transport endpoint shutdown"),
	ETOOMANYREFS(109, "Too many references: cannot splice"),
	ETIMEDOUT(110, "Connection timed out"),
	ECONNREFUSED(111, "Connection refused"),
	EHOSTDOWN(112, "Host is down"),
	EHOSTUNREACH(113, "No route to host"),
	EALREADY(114, "Operation already in progress"),
	EINPROGRESS(115, "Operation now in progress"),
	ESTALE(116, "Stale NFS file handle"),
	EUCLEAN(117, "Structure needs cleaning"),
	ENOTNAM(118, "Not a XENIX named type file"),
	ENAVAIL(119, "No XENIX semaphores available"),
	EISNAM(120, "Is a named type file"),
	EREMOTEIO(121, "Remote I/O error"),
	EDQUOT(122, "Quota exceeded"),
	ENOMEDIUM(123, "No medium found"),
	EMEDIUMTYPE(124, "Wrong medium type"),
	ECANCELED(125, "Operation Canceled"),
	ENOKEY(126, "Required key not available"),
	EKEYEXPIRED(127, "Key has expired"),
	EKEYREVOKED(128, "Key has been revoked"),
	EKEYREJECTED(129, "Key was rejected by service"),
	EOWNERDEAD(130, "Owner died"),
	ENOTRECOVERABLE(131, "State not recoverable"),
}
