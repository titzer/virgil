// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("type:", _, TypeTester.new, _);
def X = [
	T("prims", test_prims),
	T("promote", test_promote),
	T("assign", test_assign),
	T("int_array", test_int_array),
	T("float", test_float),
	T("null_array", test_null_array),
	T("tuple1", test_tuple1),
	T("tuple2", test_tuple2),
	T("class1", test_class1),
	T("class2", test_class2),
	T("closure1", test_closure1),
	T("subst1", test_subst1),
	T("subst2", test_subst2),
	T("common1", test_common1),
	()
];

class TypeTester(t: Tester) {
	def assertSubtype(expected: bool, src: Type, dst: Type) {
		if (expected != TypeSystem.isSubtype(src, dst)) {
			t.fail3("expected %1 == isSubtype(%2, %3)", expected, safeRender(src), safeRender(dst));
		}
	}
	def assertPromotable(expected: bool, src: Type, dst: Type) {
		if (expected != TypeSystem.isPromotable(src, dst)) {
			t.fail3("expected %1 == isPromotable(%2, %3)", expected, safeRender(src), safeRender(dst));
		}
	}
	def assertAssignable(expected: bool, src: Type, dst: Type) {
		if (expected != TypeSystem.isAssignable(src, dst)) {
			t.fail3("expected %1 == isAssignable(%2, %3)", expected, safeRender(src), safeRender(dst));
		}
	}
	def assertUnrelated(a: Type, b: Type) {
		assertNotEqual(a, b);
		assertSubtype(false, a, b);
		assertSubtype(false, b, a);
		assertPromotable(false, a, b);
		assertPromotable(false, b, a);
		assertAssignable(false, a, b);
		assertAssignable(false, b, a);
	}
	def assertUnrelatedA(at: Array<Type>) {
		for (a in at) {
			for (b in at) {
				if (a == b) continue;
				assertUnrelated(a, b);
			}
		}
	}
	def assertUnrelated1(a: Type, at: Array<Type>) {
		for (b in at) {
			assertUnrelated(a, b);
		}
	}
	def assertEqual(a: Type, b: Type) {
		if (a != b) t.fail2("expected %1 == %2", safeRender(a), safeRender(b));
	}
	def assertNotEqual(a: Type, b: Type) {
		if (a == b) t.fail2("expected %1 != %2", safeRender(a), safeRender(b));
	}
	def safeRender(t: Type) -> StringBuffer -> StringBuffer {
		if (t == null) return StringBuffer.puts(_, "<null>");
		return t.render;
	}
}

def INT = IntTypeCache.get(true, 32);
def BYTE = IntTypeCache.get(false, 8);
def LONG = IntTypeCache.get(true, 64);
def BOOL = GlobalTypeCache.BOOL;
def VOID = GlobalTypeCache.VOID;

def ARRAY_INT = ArrayTypeCache.get(INT);
def ARRAY_BYTE = ArrayTypeCache.get(BYTE);
def ARRAY_LONG = ArrayTypeCache.get(LONG);
def ARRAY_BOOL = ArrayTypeCache.get(BOOL);
def ARRAY_VOID = ArrayTypeCache.get(VOID);

def FLOAT = FloatTypeCache.FLOAT;
def DOUBLE = FloatTypeCache.DOUBLE;

def ARRAY_FLOAT = ArrayTypeCache.get(FLOAT);
def ARRAY_DOUBLE = ArrayTypeCache.get(DOUBLE);

def NULL = GlobalTypeCache.NULL;
def INT_INT = TupleTypeCache.get([INT, INT]);
def INT_VOID = TupleTypeCache.get([INT, VOID]);
def BYTE_BYTE = TupleTypeCache.get([BYTE, BYTE]);
def FLOAT_INT = TupleTypeCache.get([FLOAT, INT]);
def FLOAT_DOUBLE = TupleTypeCache.get([FLOAT, DOUBLE]);

def test_prims(t: TypeTester) {
	t.assertSubtype(false, INT, BYTE);
	t.assertSubtype(false, BYTE, INT);
	t.assertSubtype(false, INT, LONG);
	t.assertSubtype(false, LONG, INT);
}

def test_promote(t: TypeTester) {
	t.assertPromotable(false, INT, BYTE);
	t.assertPromotable(false, LONG, BYTE);
	t.assertPromotable(false, LONG, INT);
	t.assertPromotable(true,  BYTE, INT);
	t.assertPromotable(true,  BYTE, LONG);
	t.assertPromotable(true,  INT, LONG);
}

def test_assign(t: TypeTester) {
	t.assertAssignable(false, INT, BYTE);
	t.assertAssignable(false, LONG, BYTE);
	t.assertAssignable(false, LONG, INT);
	t.assertAssignable(true,  BYTE, INT);
	t.assertAssignable(true,  BYTE, LONG);
	t.assertAssignable(true,  INT, LONG);
}

def test_int_array(t: TypeTester) {
	// Integer arrays
	t.assertUnrelatedA([INT, BOOL, VOID]);
	t.assertUnrelatedA([INT, VOID, BOOL, ARRAY_INT, ARRAY_BOOL, ARRAY_VOID]);
}

def test_float(t: TypeTester) {
	t.assertPromotable(true, FLOAT, DOUBLE);
	t.assertPromotable(false, DOUBLE, FLOAT);
	t.assertPromotable(true, BYTE, FLOAT);
	t.assertPromotable(true, BYTE, DOUBLE);

	t.assertUnrelatedA([INT, FLOAT, VOID, ARRAY_FLOAT, ARRAY_DOUBLE]);
}

def test_null_array(t: TypeTester) {
	// Null and arrays
	t.assertSubtype(true, NULL, ARRAY_FLOAT);
	t.assertSubtype(true, NULL, ARRAY_VOID);
	t.assertSubtype(false, ARRAY_FLOAT, NULL);
	t.assertSubtype(false, ARRAY_VOID, NULL);

	t.assertUnrelated1(NULL, [BYTE, INT, FLOAT, VOID]);
}

def test_tuple1(t: TypeTester) {
	t.assertPromotable(true, BYTE_BYTE, INT_INT);
	t.assertPromotable(false, INT_INT, BYTE_BYTE);
	t.assertUnrelated1(INT_INT, [INT, VOID, ARRAY_INT, FLOAT, NULL, INT_VOID]);
}

def out_t(t: Type) {
	System.puts(t.render(StringBuffer.new()).toString());
}

def test_tuple2(t: TypeTester) {
	t.assertEqual(VOID, TupleTypeCache.get([]));
	for (x in [VOID, INT, BOOL, FLOAT, DOUBLE, INT_INT]) {
		t.assertEqual(x, TupleTypeCache.get([x]));

		for (y in [VOID, INT, BOOL, FLOAT, INT_INT]) {
			var xy1 = TupleTypeCache.get([x, y]);
			var xy2 = TupleTypeCache.get([x, y]);
			t.assertEqual(xy1, xy2);
		}
	}
}

def test_class1(t: TypeTester) {
	var A = ClassDecl.new([], null), At = A.getCachedType([]);
	var B = ClassDecl.new([], At), Bt = B.getCachedType([]);
	var C = ClassDecl.new([], At), Ct = C.getCachedType([]);

	t.assertSubtype(true,  Bt, At);
	t.assertSubtype(false, At, Bt);
	t.assertSubtype(true,  Ct, At);
	t.assertSubtype(false, At, Ct);
	t.assertSubtype(false, Bt, Ct);
	t.assertSubtype(false, Ct, Bt);

	t.assertEqual(A.getCachedType([]), A.getCachedType([]));
	t.assertEqual(B.getCachedType([]), B.getCachedType([]));
	t.assertEqual(C.getCachedType([]), C.getCachedType([]));
}

def test_class2(t: TypeTester) {
	var P = TypeParamType.new(0), Q = TypeParamType.new(0);
	var A = ClassDecl.new([P], null), At = A.getCachedType, AtQ = At([Q]);
	var B = ClassDecl.new([Q], AtQ), Bt = B.getCachedType, BtQ = Bt([Q]);

	t.assertSubtype(true,  BtQ, AtQ);
	t.assertSubtype(false, AtQ, BtQ);

	for (x in [VOID, INT, BOOL, FLOAT, DOUBLE, AtQ, BtQ]) {
		t.assertEqual(At([x]), At([x]));
		t.assertEqual(Bt([x]), Bt([x]));
		t.assertSubtype(false, At([x]), Bt([x]));
	}
}

def test_closure1(t: TypeTester) {
	var INT__INT = ClosureTypeCache.get(Signature.new([INT], [INT]));
	var BOOL__INT = ClosureTypeCache.get(Signature.new([BOOL], [INT]));

	t.assertUnrelated(INT__INT, BOOL__INT);
	t.assertAssignable(true, NULL, INT__INT);
	t.assertAssignable(true, NULL, BOOL__INT);
}

def test_subst1(t: TypeTester) {
	var T = TypeParamType.new(0), aT = [T];

	for (x in [INT, BOOL, VOID, ARRAY_BYTE]) {
		t.assertEqual(x, T.substParams(aT, [x]));
	}

	var T_T = TupleTypeCache.get([T, T]);
	var T_INT = TupleTypeCache.get([T, INT]);
	for (x in [INT, BOOL, VOID, ARRAY_BYTE]) {
		t.assertEqual(TupleTypeCache.get([x, x]), T_T.substParams(aT, [x]));
		t.assertEqual(TupleTypeCache.get([x, INT]), T_INT.substParams(aT, [x]));
	}
}

def test_subst2(t: TypeTester) {
	var T = TypeParamType.new(0), U = TypeParamType.new(1), aTU = [T, U];
	var Ft = ClosureTypeCache.get;
	var T__U = Ft(Signature.new([T], [U]));

	for (x in [INT, BOOL, VOID, ARRAY_BYTE]) {
		var T__x = Ft(Signature.new([T], [x]));
		t.assertEqual(T__x, T__U.substParams(aTU, [T, x]));
		t.assertEqual(T__x, T__x.substParams(aTU, [T, x]));

		for (y in [FLOAT, DOUBLE]) {
			var y__x = Ft(Signature.new([y], [x]));
			t.assertEqual(T__x, T__x.substParams(aTU, [T, y]));
			t.assertEqual(y__x, T__x.substParams(aTU, [y, y]));

			var x__y = Ft(Signature.new([x], [y]));
			t.assertEqual(x__y, T__U.substParams(aTU, [x, y]));
		}
	}
}

def test_common1(t: TypeTester) {
	var P = TypeParamType.new(0), Q = TypeParamType.new(0), R = TypeParamType.new(0);
	var A = ClassDecl.new([P], null), At = A.getCachedType;
	var B = ClassDecl.new([Q], At([Q])), Bt = B.getCachedType;
	var C = ClassDecl.new([R], At([R])), Ct = C.getCachedType;
	var X = ClassDecl.new([], null), Xt = X.getCachedType([]);

	for (x in [INT, VOID]) {
		var ax = [x];
		var ct = TypeSystem.commonSuperClass(At(ax), Bt(ax));
		t.assertEqual(At(ax), ct.0);
		t.assertEqual(At(ax), ct.1);
	}

	for (x in [BOOL, FLOAT]) {
		var ax = [x];
		var ct = TypeSystem.commonSuperClass(Ct(ax), Bt(ax));
		t.assertEqual(At(ax), ct.0);
		t.assertEqual(At(ax), ct.1);
	}

	for (x in [BOOL, FLOAT]) {
		for (y in [INT_INT, ARRAY_BYTE]) {
			var ax = [x], ay = [y];
			var ct = TypeSystem.commonSuperClass(Bt(ax), Ct(ay));
			t.assertEqual(At(ax), ct.0);
			t.assertEqual(At(ay), ct.1);
		}
	}

	for (x in [DOUBLE, VOID]) {
		var ax = [x];
		var ct = TypeSystem.commonSuperClass(Ct(ax), Xt);
		t.assertEqual(null, ct.0);
		t.assertEqual(null, ct.1);
		var at = TypeSystem.commonSuperClass(Xt, At(ax));
		t.assertEqual(null, at.0);
		t.assertEqual(null, at.1);
	}
}

def main(args: Array<string>) -> int {
	var list: List<GlobMatcher>;

	for (a in args) {
		if (String.equal("-fatal", a)) UnitTests.fatal = true;
		else list = List.new(GlobMatcher.new(a), list);
	}

	var t = UnitTests.run(list);
	return if (t.0 == t.1, 0, 1);
}
