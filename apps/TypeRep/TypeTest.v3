// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def T = UnitTests.registerT("type:", _, TypeTester.new, _);
def X = [
	T("prims", test_prims),
	T("promote", test_promote),
	T("assign", test_assign),
	T("int_array", test_int_array),
	T("float", test_float),
	T("null_array", test_null_array),
	T("tuple1", test_tuple1),
	T("tuple2", test_tuple2),
	T("class1", test_class1),
	T("class2", test_class2),
	()
];

class TypeTester(t: Tester) {
	def assertSubtype(expected: bool, src: Type, dst: Type) {
		if (expected != TypeSystem.isSubtype(src, dst)) t.fail("SubtypeError");
	}
	def assertPromotable(expected: bool, src: Type, dst: Type) {
		if (expected != TypeSystem.isPromotable(src, dst)) t.fail("PromotableError");
	}
	def assertAssignable(expected: bool, src: Type, dst: Type) {
		if (expected != TypeSystem.isAssignable(src, dst)) t.fail("AssignableError");
	}
	def assertUnrelated(a: Type, b: Type) {
		assertNotEqual(a, b);
		assertSubtype(false, a, b);
		assertSubtype(false, b, a);
		assertPromotable(false, a, b);
		assertPromotable(false, b, a);
		assertAssignable(false, a, b);
		assertAssignable(false, b, a);
	}
	def assertUnrelatedA(at: Array<Type>) {
		for (a in at) {
			for (b in at) {
				if (a == b) continue;
				assertUnrelated(a, b);
			}
		}
	}
	def assertUnrelated1(a: Type, at: Array<Type>) {
		for (b in at) {
			assertUnrelated(a, b);
		}
	}
	def assertEqual(a: Type, b: Type) {
		if (a != b) t.fail("EqualError");
	}
	def assertNotEqual(a: Type, b: Type) {
		if (a == b) t.fail("EqualError");
	}
}

def INT = IntTypeCache.get(true, 32);
def BYTE = IntTypeCache.get(false, 8);
def LONG = IntTypeCache.get(true, 64);
def BOOL = GlobalTypeCache.BOOL;
def VOID = GlobalTypeCache.VOID;

def ARRAY_INT = ArrayTypeCache.get(INT);
def ARRAY_BYTE = ArrayTypeCache.get(BYTE);
def ARRAY_LONG = ArrayTypeCache.get(LONG);
def ARRAY_BOOL = ArrayTypeCache.get(BOOL);
def ARRAY_VOID = ArrayTypeCache.get(VOID);

def FLOAT = FloatTypeCache.FLOAT;
def DOUBLE = FloatTypeCache.DOUBLE;

def ARRAY_FLOAT = ArrayTypeCache.get(FLOAT);
def ARRAY_DOUBLE = ArrayTypeCache.get(DOUBLE);

def NULL = GlobalTypeCache.NULL;
def INT_INT = TupleTypeCache.get([INT, INT]);
def INT_VOID = TupleTypeCache.get([INT, VOID]);
def BYTE_BYTE = TupleTypeCache.get([BYTE, BYTE]);
def FLOAT_INT = TupleTypeCache.get([FLOAT, INT]);
def FLOAT_DOUBLE = TupleTypeCache.get([FLOAT, DOUBLE]);

def test_prims(t: TypeTester) {
	t.assertSubtype(false, INT, BYTE);
	t.assertSubtype(false, BYTE, INT);
	t.assertSubtype(false, INT, LONG);
	t.assertSubtype(false, LONG, INT);
}

def test_promote(t: TypeTester) {
	t.assertPromotable(false, INT, BYTE);
	t.assertPromotable(false, LONG, BYTE);
	t.assertPromotable(false, LONG, INT);
	t.assertPromotable(true,  BYTE, INT);
	t.assertPromotable(true,  BYTE, LONG);
	t.assertPromotable(true,  INT, LONG);
}

def test_assign(t: TypeTester) {
	t.assertAssignable(false, INT, BYTE);
	t.assertAssignable(false, LONG, BYTE);
	t.assertAssignable(false, LONG, INT);
	t.assertAssignable(true,  BYTE, INT);
	t.assertAssignable(true,  BYTE, LONG);
	t.assertAssignable(true,  INT, LONG);
}

def test_int_array(t: TypeTester) {
	// Integer arrays
	t.assertUnrelatedA([INT, BOOL, VOID]);
	t.assertUnrelatedA([INT, VOID, BOOL, ARRAY_INT, ARRAY_BOOL, ARRAY_VOID]);
}

def test_float(t: TypeTester) {
	t.assertPromotable(true, FLOAT, DOUBLE);
	t.assertPromotable(false, DOUBLE, FLOAT);
	t.assertPromotable(true, BYTE, FLOAT);
	t.assertPromotable(true, BYTE, DOUBLE);

	t.assertUnrelatedA([INT, FLOAT, VOID, ARRAY_FLOAT, ARRAY_DOUBLE]);
}

def test_null_array(t: TypeTester) {
	// Null and arrays
	t.assertPromotable(true, NULL, ARRAY_FLOAT);
	t.assertPromotable(true, NULL, ARRAY_VOID);
	t.assertPromotable(false, ARRAY_FLOAT, NULL);
	t.assertPromotable(false, ARRAY_VOID, NULL);

	t.assertUnrelated1(NULL, [BYTE, INT, FLOAT, VOID]);
}

def test_tuple1(t: TypeTester) {
	t.assertPromotable(true, BYTE_BYTE, INT_INT);
	t.assertPromotable(false, INT_INT, BYTE_BYTE);
	t.assertUnrelated1(INT_INT, [INT, VOID, ARRAY_INT, FLOAT, NULL, INT_VOID]);
}

def out_t(t: Type) {
	System.puts(t.render(StringBuffer.new()).toString());
}

def test_tuple2(t: TypeTester) {
	t.assertEqual(VOID, TupleTypeCache.get([]));
	for (x in [VOID, INT, BOOL, FLOAT, DOUBLE, INT_INT]) {
		t.assertEqual(x, TupleTypeCache.get([x]));

		for (y in [VOID, INT, BOOL, FLOAT, INT_INT]) {
			var xy1 = TupleTypeCache.get([x, y]);
			var xy2 = TupleTypeCache.get([x, y]);
			t.assertEqual(xy1, xy2);
		}
	}
}

def test_class1(t: TypeTester) {
	var A = ClassDecl.new([], null), At = A.getCachedType([]);
	var B = ClassDecl.new([], At), Bt = B.getCachedType([]);
	var C = ClassDecl.new([], At), Ct = C.getCachedType([]);

	t.assertSubtype(true,  Bt, At);
	t.assertSubtype(false, At, Bt);
	t.assertSubtype(true,  Ct, At);
	t.assertSubtype(false, At, Ct);
	t.assertSubtype(false, Bt, Ct);
	t.assertSubtype(false, Ct, Bt);

	t.assertEqual(A.getCachedType([]), A.getCachedType([]));
	t.assertEqual(B.getCachedType([]), B.getCachedType([]));
	t.assertEqual(C.getCachedType([]), C.getCachedType([]));
}

def test_class2(t: TypeTester) {
	var P = TypeParamType.new(0), Q = TypeParamType.new(0);
	var A = ClassDecl.new([P], null), At = A.getCachedType, AtQ = At([Q]);
	var B = ClassDecl.new([Q], AtQ), Bt = B.getCachedType, BtQ = Bt([Q]);

	t.assertSubtype(true,  BtQ, AtQ);
	t.assertSubtype(false, AtQ, BtQ);

	for (x in [VOID, INT, BOOL, FLOAT, DOUBLE, AtQ, BtQ]) {
		t.assertEqual(At([x]), At([x]));
		t.assertEqual(Bt([x]), Bt([x]));
		t.assertUnrelated(At([x]), Bt([x]));
	}

}

def main(args: Array<string>) -> int {
	var list: List<GlobMatcher>;

	for (a in args) {
		list = List.new(GlobMatcher.new(a), list);
	}

	var t = UnitTests.run(list);
	return if (t.0 == t.1, 0, 1);
}
