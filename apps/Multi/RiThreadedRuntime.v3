// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// RiRuntime provides the platform-dependent runtime hooks called by the compiler
// to implement signal handling (and therefore exception handling), GC, and
// initialization of the runtime environment.
component RiRuntime {
	def SIGFPE  = 8;
	def SIGBUS  = 10;
	def SIGSEGV = 11;
	var gcInit: void -> void;
	var gcCollect: (int, Pointer, Pointer) -> Pointer = noCollect;
	var userSignalHandler: (int, Pointer, Pointer) -> bool;
	var stackRedZoneStart: Pointer;
	var stackRedZoneEnd: Pointer;
	var userCodeList: RiUserCode;

	// initialize runtime system from supplied arguments and return remaining args
	def init(c: int, a: Pointer, envp: Pointer) -> Array<string> {
		var argc = c, argp = a;
		// set up stack red zone to catch stack overflow
		var t = RiOs.initStackRedZone(CiRuntime.STACK_START, CiRuntime.STACK_END);
		stackRedZoneStart = t.0;
		stackRedZoneEnd = t.1;
		// install handler for SIGFPE, SIGBUS, and SIGSEGV
		RiOs.installHandler(SIGFPE);
		RiOs.installHandler(SIGBUS);
		RiOs.installHandler(SIGSEGV);

		if (gcInit != null) gcInit();
		if (argp == Pointer.NULL) return null;

		// convert argc, argp into an Array<string> for main, ignoring first arg
		argp = argp + Pointer.SIZE;
		argc--;
		var args = Array<string>.new(argc);
		for (i < argc) {
			args[i] = toString((argp + i * Pointer.SIZE).load<Pointer>());
		}
		return args;
	}
	// handle a signal generated by the program
	def signal(signum: int, siginfo: Pointer, ucontext: Pointer) {
		if (userSignalHandler != null && userSignalHandler(signum, siginfo, ucontext)) return;

		var ip = RiOs.getIp(ucontext), sp = RiOs.getSp(ucontext);
		var userCode = findUserCode(ip);
		if (userCode != null) {
			// call user signal handler first, if installed
			var handled = userCode.handleSignal(signum, siginfo, ucontext, ip, sp);
			if (handled) return;
		}
		match (signum) {
			SIGFPE => return fatalException("DivideByZeroException", null, ip, sp);
			SIGBUS, SIGSEGV => {
				if (ip >= CiRuntime.EX_START && ip < CiRuntime.EX_END) {
					// IP lies in exception region, use exception entry
					var exEntry = CiRuntime.EX_TABLE + (ip - CiRuntime.EX_START);
					var frameWords = NativeStackPrinter.printExEntry(exEntry, true);
					NativeStackPrinter.printStack(RiOs.callerFrame(ip, sp, frameWords));
					return RiOs.exit(255);
				} else {
					var addr = RiOs.getAccessAddress(siginfo, ucontext);
					if (inStackRedZone(addr)) return fatalException("StackOverflow", null, ip, sp);
					if (ip == Pointer.NULL) {
						// assume an indirect call to null, generate NCE
						ip = sp.load<Pointer>() + -1; // return address is on stack
						sp = sp + Pointer.SIZE; // skip return address
					}
					// should be a source entry at this IP
					return fatalException("NullCheckException", null, ip, sp);
				}
			}
			// XXX: SIGILL -> *bad*
			// XXX: SIGQUIT -> stacktrace + quit
			// XXX: SIGKILL -> stacktrace + quit
			// XXX: SIGPROF -> take profiling sample
		}
		System.err.puts("UnexpectedSignal: ").puti(signum).ln();
		NativeStackPrinter.printStack(ip, sp);
		RiOs.exit(255);
	}
	// Called from the generated allocation stub upon allocation failure.
	def gc(size: int, ip: Pointer, sp: Pointer) -> Pointer {
		return gcCollect(size, ip + -1, sp); // adjust caller IP for gc map search
	}
	private def noCollect(size: int, ip: Pointer, sp: Pointer) -> Pointer {
		System.error("HeapOverflow", "no garbage collector installed");
		return Pointer.NULL; // unreachable
	}
	// register new (machine) code with the runtime system
	def registerUserCode(code: RiUserCode) {
		code.next = userCodeList;
		userCodeList = code;
	}
	// un-register code from the runtime system
	def unregisterUserCode(code: RiUserCode) {
		var l = userCodeList, p: RiUserCode;
		while (l != null) {
			if (l == userCodeList) {
				if (p != null) p.next = l.next;
				else userCodeList = l.next;
				code.next = null;
				return;
			}
			p = l;
			l = l.next;
		}
	}
	// find the user code containing {ip}, if any
	def findUserCode(ip: Pointer) -> RiUserCode {
		for (l = userCodeList; l != null; l = l.next) {
			if (ip >= l.start && ip < l.end) return l;
		}
		return null;
	}
	// checks if the given pointer is in the stack red zone
	def inStackRedZone(p: Pointer) -> bool {
		return (p >= stackRedZoneStart && p < stackRedZoneEnd);
	}
	// convert a null-terminated string pointer to a byte array
	private def toString(p: Pointer) -> string {
		for (e = p; true; e = e + 1) {
			if (e.load<byte>() == '\x00') {
				var len = int.!(e - p), str = Array<byte>.new(len);
				for (i < len) str[i] = (p + i).load<byte>();
				return str;
			}
		}
		return null; // unreachable
	}
	def fatalException(ex: string, msg: string, ip: Pointer, sp: Pointer) {
		System.err.putc('!').puts(ex);
		if (msg != null) System.err.puts(": ").puts(msg).ln();
		else System.err.ln();
		NativeStackPrinter.printStack(ip, sp);
		RiOs.exit(255);
	}
	def registerThreadStart(pid: u32, thread: RiBaseThread) {
	}
	def unregisterThreadFinish(thread: RiBaseThread) {
	}
	def acquireStack(thread: RiBaseThread) -> Range<byte> {
		return FAKE_STACK;
	}
}
def FAKE_STACK = Array<byte>.new(1024000);

// Runtime tables are exposed by the compiler as values in a "CiRuntime" component.
// This component provides utilities to the rest of the runtime to traverse these
// tables and serves to separate them from encoding details.
component RiTables {
	def REF_SIZE	  = 4;	  // XXX: platform-dependent reference size
	def INT_SIZE	  = 4;
	def PAGE_SIZE	  = 4096; // XXX: page size from compiler
	def PAGE_SHIFT	  = '\x0c';  // 12
	def PAGE_MASK	  = 0xFFF;
	def EX_ENTRY_SIZE = 6;	  // XXX: ex entry size from compiler

	def findSource(ip: Pointer) -> Pointer {
		return exactMatch(searchTable(CiRuntime.SRC_POINTS_PAGES, CiRuntime.SRC_POINTS_TABLE, ip));
	}
	def findMethod(ip: Pointer) -> Pointer {
		var r = searchTable(CiRuntime.SRC_METHODS_PAGES, CiRuntime.SRC_METHODS_TABLE, ip);
		if (r.0 < CiRuntime.SRC_METHODS_TABLE) return Pointer.NULL;
		return r.0;
	}
	def exactMatch(p: Pointer, q: Pointer) -> Pointer {
		return if(p == q, p, Pointer.NULL);
	}
	// perform a binary search on a table, returning pointers (p, q) to adjacent entries
	// with p.ip <= ip <= q.ip || p == null && q == null
	// assumes 4-byte entries with lower #PAGE_SHIFT bits indicating the page offset
	def searchTable(pageTable: Pointer, table: Pointer, ip: Pointer) -> (Pointer, Pointer) {
		var none = (Pointer.NULL, Pointer.NULL);
		if (ip < CiRuntime.CODE_START) return none; // out of code range
		if (ip >= CiRuntime.CODE_END) return none; // out of code range

		var code_offset = ip - CiRuntime.CODE_START;
		var key_offset = code_offset & PAGE_MASK;
		var code_page = int.!(code_offset >>> PAGE_SHIFT);
		var start_p = loadPage(pageTable, code_page);
		var end_p = loadPage(pageTable, code_page + 1);
		// binary search for the entry
		while (start_p < end_p) {
			var diff = ((end_p - start_p) >> 1) & 0xFFFFFFFC;
			var mid_p = start_p + diff;
			var offset = mid_p.load<int>() & PAGE_MASK;
			if (offset < key_offset) {
				if (start_p == mid_p) return (start_p, end_p);
				else start_p = mid_p;
			} else if (offset == key_offset) {
				return (mid_p, mid_p);
			} else {
				end_p = mid_p;
			}
		}
		return (start_p + -4, end_p); // start_p == end_p
	}
	def loadPage(pageTable: Pointer, num: int) -> Pointer {
		if (Pointer.SIZE == 8) {
			return Pointer.NULL + (pageTable + num * 4).load<int>();
		} else {
			return (pageTable + num * Pointer.SIZE).load<Pointer>();
		}
	}
	def codePages() -> int {
		return int.!((CiRuntime.CODE_END - CiRuntime.CODE_START + (PAGE_SIZE - 1)) >>> PAGE_SHIFT);
	}
}
// Extension point for dynamic code. User applications can extend the runtime system
// by creating subclasses of this class and registering instances with the {RiRuntime}.
class RiUserCode(var start: Pointer, var end: Pointer) {
	var next: RiUserCode; // used internally in RiRuntime for list management

	// Called by the runtime when a fatal error occurs. Should write a description
	// of the frame (typically a single line) to the provided output function,
	// e.g. to print a helpful stack trace.
	def describeFrame(ip: Pointer, sp: Pointer, out: Range<byte> -> void) { }

	// Called when the runtime walks the stack. Should advance the instruction pointer
	// and stack pointer past this frame to the caller frame, returning the instruction
	// and stack pointers for the caller.
	def nextFrame(ip: Pointer, sp: Pointer) -> (Pointer, Pointer);

	// Called when the garbage collector finds a frame on the stack. Should notify
	// the garbage collector via {RiGc} of the location of any roots in the frame.
	def scanFrame(ip: Pointer, sp: Pointer) { }

	// Called when a signal occurs in this code. Should attempt to handle the signal,
	// e.g. by patching the platform-specific {ucontext}. If the signal could not be
	// handled, return {false}.
	def handleSignal(signum: int, siginfo: Pointer, ucontext: Pointer, ip: Pointer, sp: Pointer) -> bool { return false; }
}

enum RiThreadStatus {
	// Active states
	RUNNING,	// is currently running, though may be descheduled
	WAITING,	// blocked on resource or I/O
	PAUSED,		// has consumed alotted time resource or was explicitly paused
	// Terminated states
	FINISHED,	// has finished executing and produced a result
	CRASHED,	// failed with an exception
	FAILED,		// failed to spawn
	KILLED		// was explicitly killed
}

class RiBaseThread {
	private def index: u32;	// index into thread table
	def id: u64;
	private var status: RiThreadStatus;

	private def run(pid: u32);	// called internally to run user closure
	def join() -> RiThreadStatus;	// blocks until thread reaches a termination state
	def poll() -> RiThreadStatus {	// returns current status
		return status;
	}
	def kill();			// kills the thread if running
	def pause();			// pauses the thread if running
	def resume();			// resumes a thread if paused
}

class RiGcThread extends RiBaseThread {
	private def run(pid: u32);
}

class RiThread<R> extends RiBaseThread {
	def func: void -> R;
	def var result: R;

	private new(func) { }

	// First Virgil code run on new thread (via being passed to CiRuntime.spawn).
	private def run(pid: u32) {
		RiRuntime.registerThreadStart(pid, this);
		this.result = func();
		RiRuntime.unregisterThreadFinish(this); // recycles stack resource
	}
}

// Run {func} on all inputs in parallel, returning the results.
def ONE_BY_ONE = false;
def JOIN_ALL = false;
def doN<P, R>(inputs: Range<P>, func: P -> R) -> Array<R> {
	var threads = Array<RiThread<R>>.new(inputs.length);
	var results = Array<R>.new(inputs.length);
	for (i < threads.length) threads[i] = Threads.spawn(func, inputs[i]);

	if (ONE_BY_ONE) {
		for (i < threads.length) {
			var done = Threads.select(threads);
			for (i < threads.length) {
				if (threads[i] == done) {
					threads[i] = null;
					if (done.poll() == RiThreadStatus.FINISHED) results[i] = done.result;
				}
			}
		}
	}
	if (JOIN_ALL) {
		Threads.join(threads);
		for (i < threads.length) {
			var t = threads[i];
			if (t.poll() == RiThreadStatus.FINISHED) results[i] = t.result;
		}
	}
	return results;
}

def doWork(p: int) -> int {
	return p + 44;
}

component Threads {
	def spawn<P, R>(f: P -> R, p: P) -> RiThread<R> { // optional arguments: stack size, heap size, time alotment
		var thread = RiThread<R>.new(Functions.bind(f, p));
		spawn0(thread);
		return thread;
	}
	private def spawn0(thread: RiBaseThread) {
		var stack = RiRuntime.acquireStack(thread);
		var result = CiRuntime_spawn(thread.run, Pointer.atContents(stack) + stack.length);
		if (result != 0) thread.status = RiThreadStatus.FAILED; // failed to spawn, e.g. out of resources
	}
	def select<R>(some: Range<RiThread<R>>) -> RiThread<R> {
		// Implementation sketch 1:
		// - lock + wait on thread table, i.e. listen for updates
		// - scan thread table for changes
		// Implementation sketch 2:
		// - add listener for all threads
		return null; // TODO
	}
	def join<R>(some: Range<RiThread<R>>) {
		// TODO
	}
}

var spawnFun: (u32 -> void, Pointer) -> int;

def Regs: X86_64Regs;

def SYS_clone = 120;
def SYS_exit = 60;
def CLONE_VM = 0x00000100;
def CLONE_SIGHAND = 0x00000800;
def CLONE_PARENT = 0x00008000;
def CLONE_THREAD = 0x00010000;

def SYS_NUM = Regs.RAX;
def SYS_PARAM0 = Regs.RDI;
def SYS_PARAM1 = Regs.RSI;
def SYS_PARAM2 = Regs.RDX;
def SYS_PARAM3 = Regs.R10;
def SYS_PARAM4 = Regs.R8;
def SYS_PARAM5 = Regs.R9;
def SYS_RET0 = Regs.RAX;

def VIRGIL_PARAM0 = Regs.RDI;
def VIRGIL_PARAM1 = Regs.RSI;
def VIRGIL_PARAM2 = Regs.RDX;
def VIRGIL_PARAM3 = Regs.RCX;
def VIRGIL_RET0 = Regs.RAX;

def CiRuntime_spawn(func: u32 -> void, stack: Pointer) -> int {
	if (spawnFun == null) {
		def asm = X86_64Assemblers.create64(DataWriter.new());
		var in_caller = asm.newLabel();

		// VIRGIL_PARAM0 = null receiver, because this is a component method
		asm.pushq_r(VIRGIL_PARAM1);
		asm.pushq_r(VIRGIL_PARAM2);
		asm.pushq_r(VIRGIL_PARAM3);
		asm.movq_r_i(SYS_NUM, SYS_clone);
		asm.movq_r_i(SYS_PARAM0, CLONE_VM | CLONE_SIGHAND | CLONE_PARENT | CLONE_THREAD);
		asm.popq_r(SYS_PARAM2); // pop stack pointer
		asm.movq_r_i(SYS_PARAM2, 0);
		asm.movq_r_i(SYS_PARAM3, 0);
		asm.movq_r_i(SYS_PARAM4, 0);
		asm.movq_r_i(SYS_PARAM5, 0);
		asm.syscall();
		asm.q.cmp_r_i(SYS_RET0, 0);
		asm.jc_rel_near(X86_64Conds.NA, in_caller);
		// --- in new thread, call user function, passing PID ----------------------
		asm.popq_r(VIRGIL_PARAM0); // func.receiver
		asm.movq_r_r(VIRGIL_PARAM1, SYS_RET0);
		var r_tmp = Regs.R10;
		asm.popq_r(r_tmp); // func.codeptr
		asm.icall_r(r_tmp); // caller user function
		asm.movq_r_i(SYS_NUM, SYS_exit);
		asm.movq_r_i(SYS_PARAM0, 0);
		asm.syscall();
		// --- in calling thread, just return the result of the system call --------
		asm.bind(in_caller);
		asm.ret();
		var region = CiRuntime.forgeRange<byte>(CiRuntime.RUNTIME_CODE_START,
			int.!(CiRuntime.RUNTIME_CODE_END - CiRuntime.RUNTIME_CODE_START));
		for (i = 0; i < asm.w.pos; i++) {
			region[i] = asm.w.data[i];
		}
		spawnFun = CiRuntime.forgeClosure<void, ((u32 -> void), Pointer), int>(
			Pointer.atContents(region),
			());
			
	}
	return spawnFun(func, stack);
}

def main() {
	var t = Threads.spawn(System.puts, "Hello World!\n");
	while (t.poll() != RiThreadStatus.FINISHED) ;
}