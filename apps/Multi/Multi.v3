class Printer(str: string, out: string -> void) {
	def run() {
		for (i < 1000) {
			out(str);
			for (j < 1000000) ;
		}
	}
}

var print1 = Printer.new("#1 ", System.puts);
var print2 = Printer.new("#2 ", System.puts);
var print3 = Printer.new("#3 ", System.puts);

def SYS_clone = 120;
def CLONE_VM = 0x00000100;
def CLONE_SIGHAND = 0x00000800;
def CLONE_PARENT = 0x00008000;
def CLONE_THREAD = 0x00010000;

var func: void -> void;

def stack1 = Array<int>.new(1024); // TODO: dangerous, stack is in heap!
def stack2 = Array<int>.new(1024); // TODO: dangerous, stack is in heap!
var tid_buf = Array<int>.new(4);

def clone(f: void -> void, stack: Array<int>) {
	func = f;
	var t = Linux.syscall(SYS_clone,
		(CLONE_VM | CLONE_SIGHAND | CLONE_PARENT | CLONE_THREAD,
		Pointer.atEnd(stack),
		Pointer.atElement(tid_buf, 0),
		0x11223344,
		Pointer.atElement(tid_buf, 1)));
	if (t.0 < 0) System.error("ThreadError", "Linux.syscall(SYS_clone) failed.");
	if (t.0 == 0) {
		f = func;
		func = null;
		f();
		Linux.syscall(LinuxConst.SYS_exit, 0);
	} else {
		// TODO: can only spawn one thread at a time due to global func
		while (func != null);
	}
}
def main() {
	clone(print2.run, stack1);
	clone(print3.run, stack2);
	print1.run();
}

layout ThreadEntry {
	+0	id:		u32;
	+4	kind:		ThreadKind;
	+5	state:		ThreadState;
	+8	tlab_start:	u32;	// TODO: can't put Pointer here
	+16	tlab_end:	u32;	// TODO: can't put Pointer here
	+24	eip:		u32;	// TODO: can't put Pointer here
	+32	esp:		u32;	// TODO: can't put Pointer here
	=40;
}

enum ThreadState {
	FREE, STOPPED, RUN, BLOCKED, REQSCAN, DONE
}

enum ThreadKind {
	MAIN, GC, OTHER
}

component Threads {
	def MAX_THREADS = 1024;
	def THREAD_ALIGN = 0xF_FFFF;

	private def main_thread = Ref<ThreadEntry>.of(Array<byte>.new(ThreadEntry.size));
	private def table = Array<Ref<ThreadEntry>>.new(MAX_THREADS);

	new() {
		table[0] = main_thread;
	}

	def spawn(f: void -> void) -> Ref<ThreadEntry> {
		// TODO: mutex
		var null_ref: Ref<ThreadEntry>;
		for (i < table.length) {
			var r = table[i];
			if (r == null_ref) {
				r = alloc_thread();
				table[i] = r;
				r.state = ThreadState.STOPPED;
				// TODO: spawn
				return r;
			}
			if (r.state == ThreadState.FREE) {
				r.state = ThreadState.STOPPED;
				// TODO: spawn
				return r;
			}
		}
		return null_ref;
	}
	def alloc_thread() -> Ref<ThreadEntry>; // TODO

	def self_alloc_fail(size: u31) -> Pointer {
		var rip = CiRuntime.callerIp();
		var rsp = CiRuntime.callerSp();
		// TODO: self_scan, call GC, deal with in-progress GC
	}
	def self_maybe_block<P, R>(f: P -> R, p: P) -> R {
		var self = self_ref();
		self.eip = CiRuntime.callerIp();
		self.esp = CiRuntime.callerSp();
		// Pre-block: transition to a blocked state
		while (!(
			check_exit() ||
			transition(self, ThreadState.RUN, ThreadState.BLOCKED) ||
			transition(self, ThreadState.REQSCAN, ThreadState.BLOCKED))
		) { }
		// Execute blocking call
		var result = f(p);
		// Post-block: transition from blocked to running
		while (!(
			check_exit() ||
			transition(self, ThreadState.BLOCKED, ThreadState.RUN))
		) { }
		return result;
	}
	def self_safepoint() {
		var self = Threads.self_ref();
		match (self.state) {
			RUN, BLOCKED, STOPPED, DONE, FREE => ;
			REQSCAN => {
				self.eip = u32.view(CiRuntime.callerIp() - Pointer.NULL);
				self.esp = u32.view(CiRuntime.callerSp() - Pointer.NULL);
				transition(self, ThreadState.REQSCAN, ThreadState.BLOCKED);
				// TODO: call blocking kernel futex
			}
		}
	}
	private def transition(thread: Ref<ThreadEntry>, from: ThreadState, to: ThreadState) -> bool {
		var ptr = Pointer.atRef(thread) + ThreadEntry.state.offset;
		return ptr.cmpswp<ThreadState>(from, to);
	}
	private def check_exit() -> bool {
		return false; // TODO
	}
	def self_ref() -> Ref<ThreadEntry> {
		var rsp = CiRuntime.callerSp();
		var rsp_align = Pointer.NULL + ((rsp - Pointer.NULL) & ~THREAD_ALIGN);
		var range = CiRuntime.forgeRange<byte>(rsp_align, ThreadEntry.size);
		return Ref<ThreadEntry>.of(range);
	}
}

component RiRuntime2 {
	def alloc(size: u31) -> Pointer {
		var self = Threads.self_ref();
		var obj = self.tlab_start;
		var end = obj + size;
		if (end <= self.tlab_end) { //#likely
			self.tlab_start = end;
			return Pointer.NULL + int.view(obj);
		}
		return Threads.self_alloc_fail(size);
			
	}
}