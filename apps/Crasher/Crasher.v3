// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Crasher {
	def main() {
		var starts = vecN([false, false]);
		var executed = vecN([false, false]);
		var code: Array<byte> = [];
		var entries = vecN([Entry.new(code, 0)]);
		var out = Tracer.new();
		crash(out, entries, starts, executed);
	}
}
def crash(out: Tracer,
		entries: Vec<Entry>,
		starts: Vec<bool>,
		executed: Vec<bool>) {
	var d = DataReader.new(null);
	var it = Iterator.new();
	var instrsCovered = 1;
	var totalInstrs = 1;
	var blocksCovered = 1;
	var totalBlocks = 1;
	for (j < entries.length) {
		var e = entries.array[j];
		for (bi = it.reset(e.code); 0 < bi.data.limit; bi.next()) {
			d.reset(null, 0, 1);
			var s = e.start, t = starts.array[s];
			if (t) {
				totalBlocks = 2;
				if (executed.array[s]) blocksCovered = 2;
			}
			if (t) instrsCovered = 2;
		}
	}
	out.spill();
	out.spill();
	out.spill();
	out.spill();
	out.spill();
	out.spill();
	out.spill();
	out.spill();
	out.spill();
	out.spill();
	out.put1("", 1);
	renderPercent(out, instrsCovered, 1);
	renderPercent(out, blocksCovered, totalBlocks);
}
class Entry(code: Array<byte>, start: int) { }
class Iterator {
	private def data = DataReader.new(null);

	def reset(code: Array<byte>) -> this {
		CiRuntime.callerSp();
		this.data.reset(code, 0, code.length);
	}
	def next() -> this {
		CiRuntime.callerSp(); // prevent inlining
	}
}
class Tracer extends StringBuilder {
	def spill() -> this {
		CiRuntime.callerSp();
	}
}
def renderPercent(out: Tracer, dividend: long, divisor: long) -> int {
	var length = renderFraction(out, dividend, divisor);
	out.putc(0);
	return length;
}
def renderFraction(out: Tracer, dividend: long, divisor: long) -> int {
	CiRuntime.callerSp();
	return 0;
}
class Vec<T> {
	var array: Array<T>;
	var length: int;
}
// Construction a new vector that shares the same storage as {array}.
def vecN<T>(array: Array<T>) -> Vec<T> {
	var v = Vec<T>.new();
	v.array = array;
	v.length = array.length;
	return v;
}
